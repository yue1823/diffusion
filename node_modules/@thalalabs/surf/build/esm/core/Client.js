import { createViewPayload } from './createViewPayload.js';
import { createEntryPayload } from './createEntryPayload.js';
export function createSurfClient(aptosClient) {
    return new Client(aptosClient);
}
export class Client {
    constructor(client) {
        Object.defineProperty(this, "client", {
            enumerable: true,
            configurable: true,
            writable: true,
            value: void 0
        });
        this.client = client;
    }
    async view(args) {
        return await this.client.view(args);
    }
    async submitTransaction(args) {
        const transaction = await this.client.transaction.build.simple({
            sender: args.signer.accountAddress.toString(),
            data: args.payload,
        });
        const transactionRes = await this.client.transaction.signAndSubmitTransaction({
            signer: args.signer,
            transaction,
        });
        return await this.client.waitForTransaction({
            transactionHash: transactionRes.hash,
            options: args.options ?? {},
        });
    }
    async simulateTransaction(args) {
        const transaction = await this.client.transaction.build.simple({
            sender: args.sender,
            data: args.payload,
        });
        return (await this.client.transaction.simulate.simple({
            signerPublicKey: args.publicKey,
            transaction,
        }))[0];
    }
    async fetchABI(address, moduleName) {
        return (await this.client.getAccountModule({
            accountAddress: address,
            moduleName: moduleName,
        })).abi;
    }
    useABI(abi, address) {
        return {
            view: new Proxy({}, {
                get: (_, prop) => {
                    const functionName = prop.toString();
                    return (...args) => {
                        const payload = createViewPayload(abi, {
                            address: (address ?? abi.address),
                            function: functionName,
                            typeArguments: args[0].typeArguments,
                            functionArguments: args[0].functionArguments,
                        });
                        return this.view({
                            payload,
                            options: {
                                ledgerVersion: args[0].ledgerVersion,
                            },
                        });
                    };
                },
            }),
            entry: new Proxy({}, {
                get: (_, prop) => {
                    const functionName = prop.toString();
                    return (...args) => {
                        const payload = createEntryPayload(abi, {
                            address: (address ?? abi.address),
                            function: functionName,
                            typeArguments: args[0].typeArguments,
                            functionArguments: args[0].functionArguments,
                        });
                        const account = args[0].account;
                        return args[0].isSimulation
                            ? this.simulateTransaction({
                                publicKey: account.publicKey,
                                sender: account.accountAddress.toString(),
                                payload,
                            })
                            : this.submitTransaction({
                                signer: args[0].account,
                                payload,
                            });
                    };
                },
            }),
            resource: new Proxy({}, {
                get: (_, prop) => {
                    let structName = prop.toString();
                    return (...args) => {
                        if (args[0].typeArguments.length !== 0) {
                            structName += `<${args[0].typeArguments.join(',')}>`;
                        }
                        const account = args[0].account;
                        return this.client.getAccountResource({
                            accountAddress: account,
                            resourceType: `${address ?? abi.address}::${abi.name}::${structName}`,
                            options: {
                                ledgerVersion: args[0].ledgerVersion,
                            },
                        });
                    };
                },
            }),
        };
    }
}
//# sourceMappingURL=Client.js.map