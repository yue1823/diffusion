{"version":3,"sources":["../src/stablePoolMath.ts"],"sourcesContent":["export function calcOutGivenInStable(\n  amountIn: number,\n  indexIn: number,\n  indexOut: number,\n  balances: number[],\n  amp: number,\n  fee: number,\n): number {\n  amountIn = amountIn * (1 - fee);\n  const newX = balances[indexIn] + amountIn; // x is input\n  const newY = getY(balances, newX, amp, indexIn, indexOut);\n  return balances[indexOut] - newY;\n}\n\nexport function calcInGivenOutStable(\n  amountOut: number,\n  indexIn: number,\n  indexOut: number,\n  balances: number[],\n  amp: number,\n  fee: number,\n): number {\n  const newX = balances[indexOut] - amountOut; // x is output\n  const newY = getY(balances, newX, amp, indexOut, indexIn);\n  return (newY - balances[indexIn]) / (1 - fee);\n}\n\n// get relative price of coin j to i\n// formula: https://linear.app/thala-labs/issue/THA-434/calculate-swap-price-impact\nexport function getPriceStable(\n  i: number,\n  j: number,\n  balances: number[],\n  amp: number,\n): number {\n  const d = getD(balances, amp);\n  const n = balances.length;\n  let b = Math.pow(d, n + 1) / Math.pow(n, n);\n  balances.forEach((x: number, index: number) => {\n    if (index != i && index != j) {\n      b = b / x;\n    }\n  });\n  let naxx = n * amp * balances[i] * balances[i] * balances[j] * balances[j];\n  return (balances[i] * b + naxx) / (balances[j] * b + naxx);\n}\n\nexport function calcPriceImpactPercentageStable(\n  exactAmountIn: number,\n  exactAmountOut: number,\n  indexIn: number,\n  indexOut: number,\n  balances: number[],\n  amp: number,\n): number {\n  if (balances[indexOut] - exactAmountOut < 0.000001) {\n    // to avoid loss of accuracy, we just return 100%\n    return 100;\n  }\n  const oldPrice = getPriceStable(indexIn, indexOut, balances, amp);\n\n  // update new balance\n  balances[indexIn] = balances[indexIn] + exactAmountIn;\n  balances[indexOut] = balances[indexOut] - exactAmountOut;\n  const newPrice = getPriceStable(indexIn, indexOut, balances, amp);\n  return (Math.abs(newPrice - oldPrice) / oldPrice) * 100;\n}\n\n/*\nWhy is there a slippage loss?\nExample: an extreme case of stable pool D = sqrt(xy)\nBefore adding LP, the pool is 100 X + 100 Y, fair price of Y (relative to X) is 1\nAfter adding 300 X + 0 Y, the pool is 400 X + 100 Y, user's share of the pool is 50%\nBecause liquidity is added not evenly, the pool will be arbed to 200 X + 200 Y (fair price of Y to X should stay 1)\nWhen the user removes LP, the funds become 100 X + 100Y, therefore the users suffers a slippage loss of 33.3% (100/300)\n*/\nexport function getStableSwapSlippageLoss(\n  inputAmounts: number[],\n  poolBalances: number[],\n  amp: number,\n): number {\n  const d = getD(poolBalances, amp);\n  const relativePrices = Array(poolBalances.length)\n    .fill(0)\n    .map((_, i) =>\n      i == 0 ? 1 : getPriceStableWithKnownD(0, i, poolBalances, amp, d),\n    );\n  const prevWorth = inputAmounts.reduce(\n    (acc, cur, i) => acc + cur * relativePrices[i],\n    0,\n  );\n  const newBalances = poolBalances.map(\n    (balance, i) => balance + inputAmounts[i],\n  );\n  const newD = getD(newBalances, amp);\n  const newWorth =\n    (poolBalances.reduce((acc, cur, i) => acc + cur * relativePrices[i], 0) *\n      (newD - d)) /\n    d;\n  return (prevWorth - newWorth) / prevWorth;\n}\n\nexport function getLpTokenToIssueStable(\n  inputAmounts: number[],\n  poolBalances: number[],\n  amp: number,\n  lpSupply: number,\n): number {\n  const d = getD(poolBalances, amp);\n  const newPoolBalances = poolBalances.map(\n    (balance, i) => balance + inputAmounts[i],\n  );\n  const newD = getD(newPoolBalances, amp);\n  return (lpSupply * (newD - d)) / d;\n}\n\n// same as getPriceStable, but with known D (invariant)\nfunction getPriceStableWithKnownD(\n  i: number,\n  j: number,\n  balances: number[],\n  amp: number,\n  d: number,\n): number {\n  const n = balances.length;\n  let b = Math.pow(d, n + 1) / Math.pow(n, n);\n  balances.forEach((x: number, index: number) => {\n    if (index != i && index != j) {\n      b = b / x;\n    }\n  });\n  let naxx = n * amp * balances[i] * balances[i] * balances[j] * balances[j];\n  return (balances[i] * b + naxx) / (balances[j] * b + naxx);\n}\n\nconst EPSILON = 0.000001; // 1e-6, for detecting convergence in stableswap math\nconst MAX_LOOP_LIMIT = 100;\n\n// see `get_Y` in https://github.com/ThalaLabs/thala-modules/blob/main/thalaswap_math/sources/stable_math.move\nfunction getY(\n  xp: number[],\n  x: number,\n  a: number,\n  i: number,\n  j: number,\n): number {\n  const d = getD(xp, a);\n\n  const n = xp.length;\n  const ann = a * n;\n\n  let c = d;\n  let s = 0;\n\n  let k = 0;\n  while (k < n) {\n    if (k == j) {\n      k = k + 1;\n      continue;\n    }\n\n    let x_k = k == i ? x : xp[k];\n\n    s = s + x_k;\n    c = (c * d) / (x_k * n);\n\n    k = k + 1;\n  }\n\n  // in the above loop, there's only (n - 1) iterations\n  // therefore we add the last iteration that times (d / n), then divided by ann\n  c = (c * d) / (ann * n);\n  let b = s + d / ann;\n\n  let y = d;\n  k = 0;\n  while (k < MAX_LOOP_LIMIT) {\n    let prev_y = y;\n    y = (y * y + c) / (2 * y + b - d);\n    if (Math.abs(y - prev_y) < EPSILON) {\n      return y;\n    }\n\n    k = k + 1;\n  }\n\n  throw new Error(\n    `not converged in getY, xp: ${xp}, x: ${x}, a: ${a}, i: ${i}, j: ${j}`,\n  );\n}\n\n// see `compute_invarient` in https://github.com/ThalaLabs/thala-modules/blob/main/thalaswap_math/sources/stable_math.move\nfunction getD(xp: number[], a: number): number {\n  const n = xp.length;\n\n  // sum\n  const s = xp.reduce((partialSum, a) => partialSum + a, 0);\n\n  if (s == 0) {\n    return 0;\n  }\n\n  let prev_d: number;\n  let d = s;\n  const ann = a * n;\n\n  let i = 0;\n  while (i < MAX_LOOP_LIMIT) {\n    let dp = d;\n\n    let j = 0;\n    while (j < n) {\n      dp = (dp * d) / (xp[j] * n);\n      j = j + 1;\n    }\n\n    prev_d = d;\n    d = ((ann * s + n * dp) * d) / ((ann - 1) * d + (n + 1) * dp);\n    if (Math.abs(prev_d - d) < EPSILON) {\n      return d;\n    }\n\n    i = i + 1;\n  }\n\n  throw new Error(`not converged in getD, xp: ${xp}, a: ${a}`);\n}\n"],"mappings":"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","names":["a"]}