// src/stablePoolMath.ts
function calcOutGivenInStable(amountIn, indexIn, indexOut, balances, amp, fee) {
  amountIn = amountIn * (1 - fee);
  const newX = balances[indexIn] + amountIn;
  const newY = getY(balances, newX, amp, indexIn, indexOut);
  return balances[indexOut] - newY;
}
function calcInGivenOutStable(amountOut, indexIn, indexOut, balances, amp, fee) {
  const newX = balances[indexOut] - amountOut;
  const newY = getY(balances, newX, amp, indexOut, indexIn);
  return (newY - balances[indexIn]) / (1 - fee);
}
function getPriceStable(i, j, balances, amp) {
  const d = getD(balances, amp);
  const n = balances.length;
  let b = Math.pow(d, n + 1) / Math.pow(n, n);
  balances.forEach((x, index) => {
    if (index != i && index != j) {
      b = b / x;
    }
  });
  let naxx = n * amp * balances[i] * balances[i] * balances[j] * balances[j];
  return (balances[i] * b + naxx) / (balances[j] * b + naxx);
}
function calcPriceImpactPercentageStable(exactAmountIn, exactAmountOut, indexIn, indexOut, balances, amp) {
  if (balances[indexOut] - exactAmountOut < 1e-6) {
    return 100;
  }
  const oldPrice = getPriceStable(indexIn, indexOut, balances, amp);
  balances[indexIn] = balances[indexIn] + exactAmountIn;
  balances[indexOut] = balances[indexOut] - exactAmountOut;
  const newPrice = getPriceStable(indexIn, indexOut, balances, amp);
  return Math.abs(newPrice - oldPrice) / oldPrice * 100;
}
function getStableSwapSlippageLoss(inputAmounts, poolBalances, amp) {
  const d = getD(poolBalances, amp);
  const relativePrices = Array(poolBalances.length).fill(0).map(
    (_, i) => i == 0 ? 1 : getPriceStableWithKnownD(0, i, poolBalances, amp, d)
  );
  const prevWorth = inputAmounts.reduce(
    (acc, cur, i) => acc + cur * relativePrices[i],
    0
  );
  const newBalances = poolBalances.map(
    (balance, i) => balance + inputAmounts[i]
  );
  const newD = getD(newBalances, amp);
  const newWorth = poolBalances.reduce((acc, cur, i) => acc + cur * relativePrices[i], 0) * (newD - d) / d;
  return (prevWorth - newWorth) / prevWorth;
}
function getLpTokenToIssueStable(inputAmounts, poolBalances, amp, lpSupply) {
  const d = getD(poolBalances, amp);
  const newPoolBalances = poolBalances.map(
    (balance, i) => balance + inputAmounts[i]
  );
  const newD = getD(newPoolBalances, amp);
  return lpSupply * (newD - d) / d;
}
function getPriceStableWithKnownD(i, j, balances, amp, d) {
  const n = balances.length;
  let b = Math.pow(d, n + 1) / Math.pow(n, n);
  balances.forEach((x, index) => {
    if (index != i && index != j) {
      b = b / x;
    }
  });
  let naxx = n * amp * balances[i] * balances[i] * balances[j] * balances[j];
  return (balances[i] * b + naxx) / (balances[j] * b + naxx);
}
var EPSILON = 1e-6;
var MAX_LOOP_LIMIT = 100;
function getY(xp, x, a, i, j) {
  const d = getD(xp, a);
  const n = xp.length;
  const ann = a * n;
  let c = d;
  let s = 0;
  let k = 0;
  while (k < n) {
    if (k == j) {
      k = k + 1;
      continue;
    }
    let x_k = k == i ? x : xp[k];
    s = s + x_k;
    c = c * d / (x_k * n);
    k = k + 1;
  }
  c = c * d / (ann * n);
  let b = s + d / ann;
  let y = d;
  k = 0;
  while (k < MAX_LOOP_LIMIT) {
    let prev_y = y;
    y = (y * y + c) / (2 * y + b - d);
    if (Math.abs(y - prev_y) < EPSILON) {
      return y;
    }
    k = k + 1;
  }
  throw new Error(
    `not converged in getY, xp: ${xp}, x: ${x}, a: ${a}, i: ${i}, j: ${j}`
  );
}
function getD(xp, a) {
  const n = xp.length;
  const s = xp.reduce((partialSum, a2) => partialSum + a2, 0);
  if (s == 0) {
    return 0;
  }
  let prev_d;
  let d = s;
  const ann = a * n;
  let i = 0;
  while (i < MAX_LOOP_LIMIT) {
    let dp = d;
    let j = 0;
    while (j < n) {
      dp = dp * d / (xp[j] * n);
      j = j + 1;
    }
    prev_d = d;
    d = (ann * s + n * dp) * d / ((ann - 1) * d + (n + 1) * dp);
    if (Math.abs(prev_d - d) < EPSILON) {
      return d;
    }
    i = i + 1;
  }
  throw new Error(`not converged in getD, xp: ${xp}, a: ${a}`);
}
export {
  calcInGivenOutStable,
  calcOutGivenInStable,
  calcPriceImpactPercentageStable,
  getLpTokenToIssueStable,
  getPriceStable,
  getStableSwapSlippageLoss
};
//# sourceMappingURL=stablePoolMath.mjs.map