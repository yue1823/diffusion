"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  PoolDataClient: () => PoolDataClient,
  ThalaswapRouter: () => ThalaswapRouter
});
module.exports = __toCommonJS(src_exports);

// src/router.ts
var import_thalaswap_math = require("@thalalabs/thalaswap-math");
function calcOutGivenIn(amountIn, pool, fromIndex, toIndex) {
  const { poolType, balances, swapFee, weights, amp } = pool;
  if (poolType === "Stable") {
    return (0, import_thalaswap_math.calcOutGivenInStable)(
      amountIn,
      fromIndex,
      toIndex,
      balances,
      amp,
      swapFee
    );
  } else if (poolType === "Weighted") {
    const weightFrom = weights[fromIndex];
    const weightTo = weights[toIndex];
    return (0, import_thalaswap_math.calcOutGivenInWeighted)(
      balances[fromIndex],
      weightFrom,
      balances[toIndex],
      weightTo,
      amountIn,
      swapFee
    );
  } else {
    throw new Error("Invalid pool type");
  }
}
function calcInGivenOut(amountOut, pool, fromIndex, toIndex) {
  const { poolType, balances, swapFee, weights, amp } = pool;
  if (balances[toIndex] <= amountOut) {
    throw new Error("Insufficient balance");
  }
  if (poolType === "Stable") {
    return (0, import_thalaswap_math.calcInGivenOutStable)(
      amountOut,
      fromIndex,
      toIndex,
      balances,
      amp,
      swapFee
    );
  } else if (poolType === "Weighted") {
    return (0, import_thalaswap_math.calcInGivenOutWeighted)(
      balances[fromIndex],
      weights[fromIndex],
      balances[toIndex],
      weights[toIndex],
      amountOut,
      swapFee
    );
  } else {
    throw new Error("Invalid pool type");
  }
}
function calcPriceImpactPercentage(amountIn, amountOut, pool, fromIndex, toIndex) {
  const { poolType, balances, weights, amp } = pool;
  if (poolType === "Stable") {
    return (0, import_thalaswap_math.calcPriceImpactPercentageStable)(
      amountIn,
      amountOut,
      fromIndex,
      toIndex,
      balances,
      amp
    );
  } else if (poolType === "Weighted") {
    return (0, import_thalaswap_math.calcPriceImpactPercentageWeighted)(
      amountIn,
      amountOut,
      balances[fromIndex],
      balances[toIndex],
      weights[fromIndex],
      weights[toIndex]
    );
  } else {
    throw new Error("Invalid pool type");
  }
}
function findRouteGivenExactInput(graph, startToken, endToken, amountIn, maxHops, maxAllowedSwapPercentage) {
  const tokens = Object.keys(graph);
  const distances = {};
  const predecessors = {};
  const defaultDistance = -Infinity;
  for (const token of tokens) {
    distances[token] = {};
    predecessors[token] = {};
  }
  distances[startToken][0] = amountIn;
  for (let i = 0; i < maxHops; i++) {
    for (const [_, edges] of Object.entries(graph)) {
      for (const edge of edges) {
        const fromToken = edge.pool.coinAddresses[edge.fromIndex];
        const toToken = edge.pool.coinAddresses[edge.toIndex];
        if (fromToken === endToken || toToken === startToken)
          continue;
        if (distances[fromToken][i] === void 0)
          continue;
        if (distances[fromToken][i] / edge.pool.balances[edge.fromIndex] > maxAllowedSwapPercentage)
          continue;
        const newDistance = calcOutGivenIn(
          distances[fromToken][i],
          edge.pool,
          edge.fromIndex,
          edge.toIndex
        );
        const nextHop = i + 1;
        if (newDistance > (distances[toToken][nextHop] || defaultDistance)) {
          distances[toToken][nextHop] = newDistance;
          predecessors[toToken][nextHop] = {
            token: fromToken,
            pool: edge.pool
          };
        }
      }
    }
  }
  let maxDistance = -Infinity;
  let hops = 0;
  for (let i = 1; i <= maxHops; i++) {
    const distance = distances[endToken][i];
    if (distance && distance > maxDistance) {
      maxDistance = distance;
      hops = i;
    }
  }
  if (maxDistance === -Infinity) {
    console.error("No path found");
    return null;
  }
  const path = [];
  let currentToken = endToken;
  while (hops > 0) {
    const { token, pool } = predecessors[currentToken][hops];
    path.push({ from: token, to: currentToken, pool });
    currentToken = token;
    hops--;
  }
  path.reverse();
  let priceImpactPercentage = 0;
  let currentAmountIn = amountIn;
  for (const pathSegment of path) {
    const fromIndex = pathSegment.pool.coinAddresses.indexOf(pathSegment.from);
    const toIndex = pathSegment.pool.coinAddresses.indexOf(pathSegment.to);
    const amoutOutNoFees = calcOutGivenIn(
      currentAmountIn,
      __spreadProps(__spreadValues({}, pathSegment.pool), { swapFee: 0 }),
      fromIndex,
      toIndex
    );
    const currentPriceImpact = calcPriceImpactPercentage(
      currentAmountIn,
      amoutOutNoFees,
      pathSegment.pool,
      fromIndex,
      toIndex
    );
    if (currentPriceImpact > priceImpactPercentage) {
      priceImpactPercentage = currentPriceImpact;
    }
    currentAmountIn = amoutOutNoFees;
  }
  return {
    path,
    amountIn,
    amountOut: maxDistance,
    priceImpactPercentage,
    type: "exact_input"
  };
}
function findRouteGivenExactOutput(graph, startToken, endToken, amountOut, maxHops, maxAllowedSwapPercentage) {
  const tokens = Object.keys(graph);
  const distances = {};
  const predecessors = {};
  const defaultDistance = Infinity;
  for (const token of tokens) {
    distances[token] = {};
    predecessors[token] = {};
  }
  distances[endToken][0] = amountOut;
  for (let i = 0; i < maxHops; i++) {
    for (const [_, edges] of Object.entries(graph)) {
      for (const edge of edges) {
        const fromToken = edge.pool.coinAddresses[edge.fromIndex];
        const toToken = edge.pool.coinAddresses[edge.toIndex];
        if (fromToken === endToken || toToken === startToken)
          continue;
        if (distances[toToken][i] === void 0)
          continue;
        if (distances[toToken][i] / edge.pool.balances[edge.toIndex] > maxAllowedSwapPercentage)
          continue;
        try {
          const newDistance = calcInGivenOut(
            distances[toToken][i],
            edge.pool,
            edge.fromIndex,
            edge.toIndex
          );
          const nextHop = i + 1;
          if (newDistance < (distances[fromToken][nextHop] || defaultDistance)) {
            distances[fromToken][nextHop] = newDistance;
            predecessors[fromToken][nextHop] = {
              token: toToken,
              pool: edge.pool
            };
          }
        } catch (error) {
        }
      }
    }
  }
  let minDistance = Infinity;
  let hops = 0;
  for (let i = 1; i <= maxHops; i++) {
    const distance = distances[startToken][i];
    if (distance && distance < minDistance) {
      minDistance = distance;
      hops = i;
    }
  }
  if (minDistance === Infinity) {
    console.error("No path found");
    return null;
  }
  const path = [];
  let currentToken = startToken;
  while (hops > 0) {
    const { token, pool } = predecessors[currentToken][hops];
    path.push({ from: currentToken, to: token, pool });
    currentToken = token;
    hops--;
  }
  let priceImpactPercentage = 0;
  let currentAmountOut = amountOut;
  path.reverse();
  for (const pathSegment of path) {
    const fromIndex = pathSegment.pool.coinAddresses.indexOf(pathSegment.from);
    const toIndex = pathSegment.pool.coinAddresses.indexOf(pathSegment.to);
    const amoutInNoFees = calcInGivenOut(
      currentAmountOut,
      __spreadProps(__spreadValues({}, pathSegment.pool), { swapFee: 0 }),
      fromIndex,
      toIndex
    );
    const currentPriceImpact = calcPriceImpactPercentage(
      amoutInNoFees,
      currentAmountOut,
      pathSegment.pool,
      fromIndex,
      toIndex
    );
    if (currentPriceImpact > priceImpactPercentage) {
      priceImpactPercentage = currentPriceImpact;
    }
    currentAmountOut = amoutInNoFees;
  }
  return {
    path: path.reverse(),
    amountIn: minDistance,
    amountOut,
    priceImpactPercentage,
    type: "exact_output"
  };
}

// src/PoolDataClient.ts
var import_ts_sdk = require("@aptos-labs/ts-sdk");
var import_lodash = require("lodash");

// src/utils.ts
var import_bignumber = __toESM(require("bignumber.js"));
var BN_TEN = new import_bignumber.default(10);
function scaleDown(v, decimals) {
  return new import_bignumber.default(v).dividedBy(BN_TEN.exponentiatedBy(decimals)).toNumber();
}
function parsePoolMetadata(poolType, resourceAddress) {
  const NULL_PATTERN = new RegExp(`${resourceAddress}::base_pool::Null`);
  const [liquidityPoolType, poolTypeArgs] = parseLiquidityPoolType(
    poolType,
    resourceAddress
  );
  const nullIndex = poolTypeArgs.slice(0, 4).findIndex((e) => NULL_PATTERN.test(e));
  const numCoins = nullIndex === -1 ? 4 : nullIndex;
  const coinAddresses = poolTypeArgs.slice(0, numCoins);
  const weights = liquidityPoolType === "Weighted" ? poolTypeArgs.slice(4, 4 + numCoins).map((weight) => parseInt(weight.match(/.*::Weight_(\d+)/)[1])) : [];
  return {
    type: poolType,
    poolType: liquidityPoolType,
    numCoins,
    coinAddresses,
    weights
  };
}
function parseLiquidityPoolType(poolType, resourceAddress) {
  const WEIGHTED_POOL_PATTERN = new RegExp(
    `${resourceAddress}::weighted_pool::WeightedPool<(.*)>`
  );
  const STABLE_POOL_PATTERN = new RegExp(
    `${resourceAddress}::stable_pool::StablePool<(.*)>`
  );
  const matchWeightedPool = poolType.match(WEIGHTED_POOL_PATTERN);
  if (matchWeightedPool) {
    return ["Weighted", matchWeightedPool[1].split(",").map((e) => e.trim())];
  }
  const matchStablePool = poolType.match(STABLE_POOL_PATTERN);
  if (matchStablePool) {
    return ["Stable", matchStablePool[1].split(",").map((e) => e.trim())];
  }
  throw new Error(`Invalid poolType: ${poolType}`);
}
var ZERO = BigInt(0);
var ONE = BigInt(1);
var fp64ToFloat = (a) => {
  let mask = BigInt("0xffffffff000000000000000000000000");
  if ((a & mask) != ZERO) {
    throw new Error("too large");
  }
  mask = BigInt("0x10000000000000000");
  let base = 1;
  let result = 0;
  for (let i = 0; i < 32; ++i) {
    if ((a & mask) != ZERO) {
      result += base;
    }
    base *= 2;
    mask = mask << ONE;
  }
  mask = BigInt("0x8000000000000000");
  base = 0.5;
  for (let i = 0; i < 32; ++i) {
    if ((a & mask) != ZERO) {
      result += base;
    }
    base /= 2;
    mask = mask >> ONE;
  }
  return result;
};

// src/PoolDataClient.ts
var PoolDataClient = class {
  constructor(network, fullnode, resourceAddress) {
    this.poolData = null;
    this.lastUpdated = 0;
    this.expiry = 1e4;
    // 10 seconds
    this.retryLimit = 3;
    this.coins = [];
    this.resourceAddress = resourceAddress;
    this.client = new import_ts_sdk.Aptos(
      new import_ts_sdk.AptosConfig({
        network,
        fullnode
      })
    );
  }
  getPoolData() {
    return __async(this, null, function* () {
      const currentTime = Date.now();
      if (!this.poolData || currentTime - this.lastUpdated > this.expiry) {
        for (let i = 0; i < this.retryLimit; i++) {
          try {
            const resources = yield this.client.getAccountResources({
              accountAddress: this.resourceAddress
            });
            const poolResources = resources.filter(
              (r) => r.type.startsWith(
                `${this.resourceAddress}::weighted_pool::WeightedPool<`
              ) || r.type.startsWith(
                `${this.resourceAddress}::stable_pool::StablePool<`
              )
            );
            const allCoinAddress = (0, import_lodash.uniq)(
              poolResources.reduce((acc, resource) => {
                const metadata = parsePoolMetadata(
                  resource.type,
                  this.resourceAddress
                );
                metadata.coinAddresses.forEach((coin) => {
                  coin && acc.push(coin);
                });
                return acc;
              }, [])
            );
            yield Promise.all(
              allCoinAddress.map((address) => __async(this, null, function* () {
                if (this.coins.find((c) => c.address === address))
                  return;
                const coin = {
                  address,
                  decimals: (yield this.client.view({
                    payload: {
                      function: "0x1::coin::decimals",
                      functionArguments: [],
                      typeArguments: [
                        address
                      ]
                    }
                  }))[0]
                };
                this.coins.push(coin);
              }))
            );
            const pools = poolResources.reduce((acc, resource) => {
              try {
                const metadata = parsePoolMetadata(
                  resource.type,
                  this.resourceAddress
                );
                const [coin0, coin1, coin2, coin3] = metadata.coinAddresses.map(
                  (addr) => this.coins.find((c) => c.address === addr)
                );
                acc.push({
                  type: metadata.type,
                  weights: metadata.weights.map((w) => Number(w) / 100),
                  poolType: metadata.poolType,
                  amp: resource.data.amp_factor ? Number(resource.data.amp_factor) : void 0,
                  asset0: coin0,
                  asset1: coin1,
                  asset2: coin2,
                  asset3: coin3,
                  balance0: scaleDown(
                    resource.data.asset_0.value,
                    coin0.decimals
                  ),
                  balance1: scaleDown(
                    resource.data.asset_1.value,
                    coin1.decimals
                  ),
                  balance2: coin2 ? scaleDown(resource.data.asset_2.value, coin2.decimals) : void 0,
                  balance3: coin3 ? scaleDown(resource.data.asset_3.value, coin3.decimals) : void 0,
                  swapFee: fp64ToFloat(BigInt(resource.data.swap_fee_ratio.v))
                });
              } catch (e) {
                console.error("failed to add pool", resource.type, e);
              }
              return acc;
            }, []);
            this.poolData = {
              pools,
              coins: this.coins
            };
            this.lastUpdated = currentTime;
            return this.poolData;
          } catch (error) {
            console.error("Failed to get pool data:", error);
            if (i < this.retryLimit - 1) {
              console.log("Retrying...");
            } else {
              console.log("Failed after retrying.");
              throw error;
            }
          }
        }
      }
      return this.poolData;
    });
  }
};

// src/ThalaswapRouter.ts
var import_surf = require("@thalalabs/surf");

// src/abi/stable_pool_scripts.ts
var STABLE_POOL_SCRIPTS_ABI = {
  address: "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af",
  name: "stable_pool_scripts",
  friends: [],
  exposed_functions: [
    {
      name: "add_liquidity",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64", "u64", "u64"],
      return: []
    },
    {
      name: "remove_liquidity",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64", "u64", "u64", "u64"],
      return: []
    },
    {
      name: "swap_exact_in",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64"],
      return: []
    },
    {
      name: "swap_exact_out",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64"],
      return: []
    }
  ],
  structs: []
};

// src/abi/weighted_pool_scripts.ts
var WEIGHTED_POOL_SCRIPTS_ABI = {
  address: "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af",
  name: "weighted_pool_scripts",
  friends: [],
  exposed_functions: [
    {
      name: "add_liquidity",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: [
        "&signer",
        "u64",
        "u64",
        "u64",
        "u64",
        "u64",
        "u64",
        "u64",
        "u64"
      ],
      return: []
    },
    {
      name: "remove_liquidity",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64", "u64", "u64", "u64"],
      return: []
    },
    {
      name: "swap_exact_in",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64"],
      return: []
    },
    {
      name: "swap_exact_out",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64"],
      return: []
    }
  ],
  structs: []
};

// src/abi/multihop_router.ts
var MULTIHOP_ROUTER_ABI = {
  address: "0x60955b957956d79bc80b096d3e41bad525dd400d8ce957cdeb05719ed1e4fc26",
  name: "router",
  friends: [],
  exposed_functions: [
    {
      name: "swap_exact_in_2",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64"],
      return: []
    },
    {
      name: "swap_exact_in_3",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64"],
      return: []
    },
    {
      name: "swap_exact_out_2",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64"],
      return: []
    },
    {
      name: "swap_exact_out_3",
      visibility: "public",
      is_entry: true,
      is_view: false,
      generic_type_params: [
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        },
        {
          constraints: []
        }
      ],
      params: ["&signer", "u64", "u64"],
      return: []
    }
  ],
  structs: []
};

// src/ThalaswapRouter.ts
var encodeWeight = (weight, resourceAddress) => {
  return `${resourceAddress}::weighted_pool::Weight_${Math.floor(weight * 100).toString()}`;
};
var DEFAULT_MAX_ALLOWED_SWAP_PERCENTAGE = 0.5;
var encodePoolType = (pool, extendStableArgs, resourceAddress) => {
  const NULL_TYPE = `${resourceAddress}::base_pool::Null`;
  const NULL_4 = Array(4).fill(NULL_TYPE);
  if (pool.poolType === "Stable") {
    const typeArgs = NULL_4.map(
      (nullType, i) => i < pool.coinAddresses.length ? pool.coinAddresses[i] : nullType
    );
    return extendStableArgs ? typeArgs.concat(NULL_4) : typeArgs;
  } else {
    const typeArgsForCoins = NULL_4.map(
      (nullType, i) => i < pool.coinAddresses.length ? pool.coinAddresses[i] : nullType
    );
    const typeArgsForWeights = NULL_4.map(
      (nullType, i) => i < pool.weights.length ? encodeWeight(pool.weights[i], resourceAddress) : nullType
    );
    return typeArgsForCoins.concat(typeArgsForWeights);
  }
};
var calcMinReceivedValue = (expectedAmountOut, slippage) => expectedAmountOut * (1 - slippage / 100);
var calcMaxSoldValue = (expectedAmountIn, slippage) => expectedAmountIn * (1 + slippage / 100);
var scaleUp = (amount, decimals) => {
  return Math.floor(amount * Math.pow(10, decimals));
};
var ThalaswapRouter = class {
  constructor(network, fullnode, resourceAddress, multirouterAddress, options) {
    this.graph = null;
    this.coins = null;
    this.resourceAddress = resourceAddress;
    this.multirouterAddress = multirouterAddress;
    this.client = new PoolDataClient(network, fullnode, resourceAddress);
    this.options = options != null ? options : {};
  }
  setPoolDataClient(client) {
    this.client = client;
  }
  refreshData() {
    return __async(this, null, function* () {
      const poolData = yield this.client.getPoolData();
      const pools = poolData.pools;
      this.coins = poolData.coins;
      this.graph = yield this.buildGraph(pools);
    });
  }
  buildGraph(pools) {
    return __async(this, null, function* () {
      const tokens = /* @__PURE__ */ new Set();
      const graph = {};
      for (const pool of pools) {
        if (this.options.poolFilter && !this.options.poolFilter(pool)) {
          continue;
        }
        const assets = ["asset0", "asset1", "asset2", "asset3"].filter((a) => pool[a]).map((a) => pool[a]);
        const balances = ["balance0", "balance1", "balance2", "balance3"].filter((b, i) => assets[i]).map((b) => pool[b]);
        const weights = pool.poolType === "Weighted" ? pool.weights : void 0;
        const amp = pool.poolType === "Stable" ? pool.amp : void 0;
        const convertedPool = {
          coinAddresses: assets.map((a) => a.address),
          balances,
          poolType: pool.poolType,
          swapFee: pool.swapFee,
          weights,
          amp
        };
        for (let i = 0; i < assets.length; i++) {
          const token = assets[i].address;
          tokens.add(token);
          for (let j = 0; j < assets.length; j++) {
            if (i !== j) {
              if (!graph[token])
                graph[token] = [];
              graph[token].push({
                pool: convertedPool,
                fromIndex: i,
                toIndex: j
              });
            }
          }
        }
      }
      return graph;
    });
  }
  getRouteGivenExactInput(startToken, endToken, amountIn, maxHops = 3) {
    return __async(this, null, function* () {
      var _a;
      yield this.refreshData();
      if (!this.graph) {
        console.error("Failed to load pools");
        return null;
      }
      return findRouteGivenExactInput(
        this.graph,
        startToken,
        endToken,
        amountIn,
        maxHops,
        (_a = this.options.maxAllowedSwapPercentage) != null ? _a : DEFAULT_MAX_ALLOWED_SWAP_PERCENTAGE
      );
    });
  }
  getRouteGivenExactOutput(startToken, endToken, amountOut, maxHops = 3) {
    return __async(this, null, function* () {
      var _a;
      yield this.refreshData();
      if (!this.graph) {
        console.error("Failed to load pools");
        return null;
      }
      return findRouteGivenExactOutput(
        this.graph,
        startToken,
        endToken,
        amountOut,
        maxHops,
        (_a = this.options.maxAllowedSwapPercentage) != null ? _a : DEFAULT_MAX_ALLOWED_SWAP_PERCENTAGE
      );
    });
  }
  // balanceCoinIn is the user's balance of input coin. If it's specified, this function will check
  // (1) for exact-in type of swap, throw an error if the user doesn't have enough balance to perform the swap.
  // (2) for exact-out type of swap, the maximum input amount is limited by the user's balance.
  encodeRoute(route, slippagePercentage, balanceCoinIn) {
    if (route.path.length === 0 || route.path.length > 3) {
      throw new Error("Invalid route");
    }
    const tokenInDecimals = this.coins.find(
      (coin) => coin.address === route.path[0].from
    ).decimals;
    const tokenOutDecimals = this.coins.find(
      (coin) => coin.address === route.path[route.path.length - 1].to
    ).decimals;
    let amountInArg;
    let amountOutArg;
    if (route.type === "exact_input") {
      if (balanceCoinIn !== void 0 && balanceCoinIn < route.amountIn) {
        throw new Error("Insufficient balance");
      }
      amountInArg = scaleUp(route.amountIn, tokenInDecimals);
      amountOutArg = scaleUp(
        calcMinReceivedValue(route.amountOut, slippagePercentage),
        tokenOutDecimals
      );
    } else {
      const maxSoldValueAfterSlippage = calcMaxSoldValue(
        route.amountIn,
        slippagePercentage
      );
      amountInArg = scaleUp(
        balanceCoinIn !== void 0 ? Math.min(balanceCoinIn, maxSoldValueAfterSlippage) : maxSoldValueAfterSlippage,
        tokenInDecimals
      );
      amountOutArg = scaleUp(route.amountOut, tokenOutDecimals);
    }
    if (route.path.length == 1) {
      const path = route.path[0];
      const functionName = route.type === "exact_input" ? "swap_exact_in" : "swap_exact_out";
      const abi = path.pool.poolType === "Stable" ? STABLE_POOL_SCRIPTS_ABI : WEIGHTED_POOL_SCRIPTS_ABI;
      const typeArgs = encodePoolType(
        path.pool,
        false,
        this.resourceAddress
      ).concat([path.from, path.to]);
      return (0, import_surf.createEntryPayload)(abi, {
        function: functionName,
        typeArguments: typeArgs,
        functionArguments: [amountInArg, amountOutArg],
        address: this.resourceAddress
      });
    } else if (route.path.length == 2) {
      const path0 = route.path[0];
      const path1 = route.path[1];
      const typeArgs = encodePoolType(path0.pool, true, this.resourceAddress).concat(encodePoolType(path1.pool, true, this.resourceAddress)).concat([path0.from, path0.to, path1.to]);
      const functionName = route.type === "exact_input" ? "swap_exact_in_2" : "swap_exact_out_2";
      return (0, import_surf.createEntryPayload)(MULTIHOP_ROUTER_ABI, {
        function: functionName,
        typeArguments: typeArgs,
        functionArguments: [amountInArg, amountOutArg],
        address: this.multirouterAddress
      });
    } else {
      const path0 = route.path[0];
      const path1 = route.path[1];
      const path2 = route.path[2];
      const typeArgs = encodePoolType(path0.pool, true, this.resourceAddress).concat(encodePoolType(path1.pool, true, this.resourceAddress)).concat(encodePoolType(path2.pool, true, this.resourceAddress)).concat([path0.from, path0.to, path1.to, path2.to]);
      const functionName = route.type === "exact_input" ? "swap_exact_in_3" : "swap_exact_out_3";
      return (0, import_surf.createEntryPayload)(MULTIHOP_ROUTER_ABI, {
        function: functionName,
        typeArguments: typeArgs,
        functionArguments: [amountInArg, amountOutArg],
        address: this.multirouterAddress
      });
    }
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  PoolDataClient,
  ThalaswapRouter
});
