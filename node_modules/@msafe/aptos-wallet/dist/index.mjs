// src/JsonRPCServer.ts
import {
  JsonRpcError,
  format,
  parse
} from "json-rpc-protocol";

// src/coder.ts
import { Buffer } from "buffer";
function concat(list) {
  const total = list.reduce((size, a) => size + a.length, 0);
  const arr = new Uint8Array(total);
  let offset = 0;
  list.forEach((a) => {
    arr.set(a, offset);
    offset += a.length;
  });
  return arr;
}
var Decoder = class {
  constructor(data, byteOffset = data.byteOffset) {
    this.data = data;
    this.byteOffset = byteOffset;
  }
  read(byteLength) {
    const result = new Uint8Array(
      this.data.buffer,
      this.byteOffset,
      byteLength
    );
    this.byteOffset += byteLength;
    return result;
  }
  decodeBigInt() {
    return BigInt(this.decodeString());
  }
  decodeNumber() {
    return Number(this.decodeString());
  }
  decodeUint8Array() {
    const length = new Uint32Array(this.read(4).slice(0).buffer)[0];
    return this.read(length);
  }
  decodeBoolean() {
    return Boolean(this.read(1)[0]);
  }
  decodeString() {
    const de = this.decodeUint8Array();
    return Buffer.from(de).toString();
  }
  decodeArray() {
    const length = this.decode();
    return Array(length).fill(0).map(() => this.decode());
  }
  decodeObject() {
    const length = this.decode();
    const entries = Array(length).fill(0).map(() => [this.decode(), this.decode()]);
    return Object.fromEntries(entries);
  }
  decode() {
    const type = this.read(1)[0];
    switch (type) {
      case 2 /* BigInt */:
        return this.decodeBigInt();
      case 1 /* Number */:
        return this.decodeNumber();
      case 0 /* Boolean */:
        return this.decodeBoolean();
      case 3 /* String */:
        return this.decodeString();
      case 4 /* Uint8Array */:
        return this.decodeUint8Array();
      case 6 /* Array */:
        return this.decodeArray();
      case 5 /* Object */:
        return this.decodeObject();
      case 7 /* Undefined */:
        return void 0;
      case 8 /* Null */:
        return null;
    }
    throw `unkonw type: ${type}`;
  }
};
function encodeUint8Array(data) {
  const en = new Uint8Array(data.length + 5);
  en[0] = 4 /* Uint8Array */;
  Buffer.from(en.buffer, 1, 4).writeUInt32LE(data.length);
  en.set(data, 5);
  return en;
}
function encodeUndefined() {
  return Uint8Array.from([7 /* Undefined */]);
}
function encodeNull() {
  return Uint8Array.from([8 /* Null */]);
}
function encodeBigInt(data) {
  const en = encodeString(data.toString());
  en[0] = 2 /* BigInt */;
  return en;
}
function encodeNumber(data) {
  const en = encodeString(data.toString());
  en[0] = 1 /* Number */;
  return en;
}
function encodeBoolean(data) {
  return new Uint8Array([0 /* Boolean */, Number(data)]);
}
function encodeString(data) {
  const buf = new ArrayBuffer(data.length);
  Buffer.from(buf).write(data);
  const en = encodeUint8Array(new Uint8Array(buf));
  en[0] = 3 /* String */;
  return en;
}
function encodeObject(data) {
  const entries = Object.entries(data);
  const ens = entries.map(([key, value]) => {
    const keyBuf = encode(key);
    const valueBuf = encode(value);
    return concat([keyBuf, valueBuf]);
  });
  return concat([
    Uint8Array.from([5 /* Object */]),
    encode(entries.length),
    ...ens
  ]);
}
function encodeArray(data) {
  const ens = data.map((elem) => encode(elem));
  return concat([
    Uint8Array.from([6 /* Array */]),
    encode(ens.length),
    ...ens
  ]);
}
function encode(data) {
  if (data instanceof Uint8Array) {
    return encodeUint8Array(data);
  }
  if (data instanceof Array) {
    return encodeArray(data);
  }
  if (data instanceof Object) {
    return encodeObject(data);
  }
  if (data === null) {
    return encodeNull();
  }
  switch (typeof data) {
    case "string":
      return encodeString(data);
    case "number":
      return encodeNumber(data);
    case "bigint":
      return encodeBigInt(data);
    case "boolean":
      return encodeBoolean(data);
    case "undefined":
      return encodeUndefined();
  }
  throw `unsuport type: ${data}`;
}
function decode(data) {
  const decoder = new Decoder(data);
  return decoder.decode();
}
function encodeToStr(data) {
  return Buffer.from(encode(data).buffer).toString("hex");
}
function decodeFromStr(data) {
  const buffer = new ArrayBuffer(data.length / 2);
  Buffer.from(buffer).write(data, "hex");
  return decode(new Uint8Array(buffer));
}

// src/JsonRPCServer.ts
var JsonRPCServer = class {
  constructor(connector, methods) {
    this.connector = connector;
    this.methods = methods;
    this.connector.on("message", (data) => this.onRequest(data));
    this.connector.on("close", () => this.onClose());
  }
  onRequest(data) {
    const req = parse(data);
    if (req.type !== "request")
      return;
    const method = this.methods[req.method];
    if (method === void 0) {
      const resp = format.error(req.id, new JsonRpcError("method not exist"));
      this.connector.send(resp);
      return;
    }
    method(
      ...req.params.map(
        (param) => decodeFromStr(param)
      )
    ).then((response) => {
      const resp = format.response(req.id, encodeToStr(response));
      this.connector.send(resp);
    }).catch((err) => {
      const resp = format.error(req.id, new JsonRpcError(String(err)));
      this.connector.send(resp);
    });
  }
  notify(type, data) {
    const notification = format.notification(type, data.map(encodeToStr));
    this.connector.send(notification);
  }
  get version() {
    return this.connector.version;
  }
  onClose() {
  }
};

// src/utils.ts
function toLegacyAccount(account) {
  return {
    address: account.address,
    publicKey: convertPKsToMultiSigPK(
      account.publicKey,
      account.minKeysRequired
    )
  };
}
function convertPKsToMultiSigPK(pks, threshold) {
  let msPk = pks.map((pk) => pk.startsWith("0x") ? pk.substring(2) : pk).join("");
  msPk += threshold.toString(16).padStart(2, "0");
  return "0x" + msPk;
}

// src/version.ts
function cmp(a, b) {
  const parse3 = (version2) => version2.split(".").map(Number);
  const [majorA, minorA, batchA] = parse3(a);
  const [majorB, minorB, batchB] = parse3(b);
  if (majorA > majorB)
    return 1;
  if (majorA < majorB)
    return -1;
  if (minorA > minorB)
    return 1;
  if (minorA < minorB)
    return -1;
  if (batchA > batchB)
    return 1;
  if (batchA < batchB)
    return -1;
  return 0;
}
function isSessionIDVersion(version2) {
  return version2 !== void 0 && cmp(version2, "2.1.4" /* SESSION_ID */) >= 0;
}
function isAllowList(version2) {
  return version2 !== void 0 && cmp(version2, "2.0.5" /* ALLOWLIST */) >= 0;
}
function isMultiSigFormatVersion(version2) {
  return version2 !== void 0;
}
function isVersionedHandshakeVersion(version2) {
  return version2 !== void 0;
}

// src/WalletAPI.ts
var WalletEvent = /* @__PURE__ */ ((WalletEvent2) => {
  WalletEvent2["ChangeAccount"] = "ChangeAccountEvent";
  WalletEvent2["ChangeNetwork"] = "ChangeNetworkEvent";
  return WalletEvent2;
})(WalletEvent || {});
var WalletRPC = /* @__PURE__ */ ((WalletRPC2) => {
  WalletRPC2["connect"] = "connect";
  WalletRPC2["disconnect"] = "disconnect";
  WalletRPC2["isConnected"] = "isConnected";
  WalletRPC2["network"] = "network";
  WalletRPC2["account"] = "account";
  WalletRPC2["chainId"] = "chainId";
  WalletRPC2["signAndSubmit"] = "signAndSubmit";
  WalletRPC2["signTransaction"] = "signTransaction";
  WalletRPC2["signMessage"] = "signMessage";
  return WalletRPC2;
})(WalletRPC || {});
function adaptLegacyAccount(methods) {
  return {
    connect() {
      return methods.connect().then((account) => toLegacyAccount(account));
    },
    disconnect() {
      return methods.disconnect();
    },
    isConnected() {
      return methods.isConnected();
    },
    network() {
      return methods.network();
    },
    account() {
      return methods.account().then((account) => toLegacyAccount(account));
    },
    chainId() {
      return methods.chainId();
    },
    signAndSubmit(payload, option) {
      return methods.signAndSubmit(payload, option);
    },
    signTransaction(payload, option) {
      return methods.signTransaction(payload, option);
    },
    signMessage(message) {
      return methods.signMessage(message);
    }
  };
}

// src/MSafeServer.ts
var MSafeServer = class {
  constructor(connector, methods) {
    if (isMultiSigFormatVersion(connector.version.peer)) {
      this.server = new JsonRPCServer(connector, methods);
    } else {
      const legacyWalletAPI = adaptLegacyAccount(methods);
      this.server = new JsonRPCServer(connector, legacyWalletAPI);
    }
  }
  changeNetwork(network) {
    this.server.notify("ChangeNetworkEvent" /* ChangeNetwork */, [network]);
  }
  changeAccount(account) {
    const peerVersion = this.version.peer;
    if (isMultiSigFormatVersion(peerVersion)) {
      this.server.notify("ChangeAccountEvent" /* ChangeAccount */, [account]);
    } else {
      const legacyAccount = toLegacyAccount(account);
      this.server.notify("ChangeAccountEvent" /* ChangeAccount */, [legacyAccount]);
    }
  }
  get version() {
    return this.server.version;
  }
};

// package.json
var version = "6.1.0";

// src/HandshakeMessage.ts
var _HandshakeMessage = class {
  constructor(handshakeType, version2, sessionID) {
    this.handshakeType = handshakeType;
    if (version2 !== void 0)
      this.version = version2;
    if (sessionID !== void 0)
      this.sessionID = sessionID;
  }
  toString(messageVersion) {
    if (isSessionIDVersion(messageVersion)) {
      if (this.sessionID === void 0)
        throw Error("sessionID is undefined");
      return `${this.handshakeType}:${this.version}:${this.sessionID}`;
    }
    if (isVersionedHandshakeVersion(messageVersion))
      return `${this.handshakeType}:${this.version}`;
    return this.handshakeType;
  }
  isHandshakeMessage(handshakeType) {
    if (this.handshakeType !== handshakeType)
      return false;
    if (isSessionIDVersion(this.version) && this.sessionID === void 0)
      return false;
    return true;
  }
  static fromString(message) {
    const [handshakeType, version2, sessionID] = message.split(":");
    return new _HandshakeMessage(handshakeType, version2, Number(sessionID));
  }
};
var HandshakeMessage = _HandshakeMessage;
HandshakeMessage.HANDSHAKE_REQ = "HANDSHAKE_REQ";
HandshakeMessage.HANDSHAKE_ACK = "HANDSHAKE_ACK";
HandshakeMessage.HANDSHAKE_PORT_ACK = "HANDSHAKE_PORT_REQ";

// src/connector.ts
var _Connector = class {
  constructor(port, peerVersion, sessionID) {
    this.port = port;
    this.peerVersion = peerVersion;
    this.sessionID = sessionID;
    this.connected = true;
    this.port.onmessage = (event) => {
      this.onMessage && this.onMessage(event.data);
    };
    this.port.onmessageerror = () => {
      this.close();
    };
  }
  send(message) {
    this.port.postMessage(message);
  }
  on(type, handle) {
    switch (type) {
      case "close":
        this.onClose = handle;
        break;
      case "message":
        this.onMessage = handle;
        break;
      default:
        throw Error("invalid type");
    }
  }
  get version() {
    return {
      self: _Connector.version,
      peer: this.peerVersion
    };
  }
  close() {
    if (this.connected) {
      this.port.close();
      this.connected = false;
      this.onClose && this.onClose();
    }
  }
  static newSessionID() {
    return _Connector.sessionID++;
  }
  static async connect(targetWindow, origins) {
    return new Promise((resolve, rejected) => {
      const sessionID = _Connector.newSessionID();
      let cleaner = () => {
      };
      let timer = setTimeout(() => {
        cleaner();
        rejected(`Connect MSafe wallet timeout: ${sessionID}`);
      }, 1e3);
      const handle = (event) => {
        const port = event.ports[0];
        if (!origins.includes(event.origin))
          return;
        if (typeof event.data !== "string")
          return;
        const handshakeMessage2 = HandshakeMessage.fromString(event.data);
        if (!handshakeMessage2.isHandshakeMessage(
          HandshakeMessage.HANDSHAKE_PORT_ACK
        ))
          return;
        if (handshakeMessage2.sessionID !== sessionID)
          return;
        cleaner();
        resolve(new _Connector(port, handshakeMessage2.version, sessionID));
      };
      cleaner = () => {
        clearTimeout(timer);
        window.removeEventListener("message", handle);
      };
      window.addEventListener("message", handle);
      const handshakeMessage = new HandshakeMessage(
        HandshakeMessage.HANDSHAKE_REQ,
        _Connector.version,
        sessionID
      );
      targetWindow.postMessage(
        handshakeMessage.toString(handshakeMessage.version),
        "*"
      );
    });
  }
  static accepts(origin, handler) {
    origin = new URL(origin).origin;
    const handle = (event) => {
      if (event.origin !== origin)
        return;
      if (typeof event.data !== "string")
        return;
      const handshakeMessage = HandshakeMessage.fromString(event.data);
      if (!handshakeMessage.isHandshakeMessage(HandshakeMessage.HANDSHAKE_REQ))
        return;
      const peerVersion = handshakeMessage.version;
      const thisVersion = _Connector.version;
      if (isSessionIDVersion(peerVersion)) {
        const channelPair = new MessageChannel();
        const replyMessage = new HandshakeMessage(
          HandshakeMessage.HANDSHAKE_PORT_ACK,
          thisVersion,
          handshakeMessage.sessionID
        );
        event.source.postMessage(
          replyMessage.toString(peerVersion),
          event.origin,
          [channelPair.port2]
        );
        handler(
          new _Connector(
            channelPair.port1,
            peerVersion,
            handshakeMessage.sessionID
          )
        );
      } else if (isAllowList(peerVersion)) {
        const channelPair = new MessageChannel();
        const replyMessage = new HandshakeMessage(
          HandshakeMessage.HANDSHAKE_PORT_ACK,
          thisVersion
        );
        event.source.postMessage(
          replyMessage.toString(peerVersion),
          event.origin,
          [channelPair.port2]
        );
        handler(new _Connector(channelPair.port1, peerVersion, void 0));
      } else {
        const port = event.ports[0];
        const replyMessage = new HandshakeMessage(
          HandshakeMessage.HANDSHAKE_ACK,
          thisVersion
        );
        port.postMessage(replyMessage.toString(peerVersion));
        handler(new _Connector(event.ports[0], peerVersion, void 0));
      }
    };
    window.addEventListener("message", handle);
    return () => window.removeEventListener("message", handle);
  }
  static async accept(origin) {
    return new Promise((resolve) => {
      const cleaner = this.accepts(origin, (connector) => {
        resolve(connector);
        cleaner();
      });
    });
  }
};
var Connector = _Connector;
Connector.version = version;
Connector.sessionID = 0;

// src/JsonRPCClient.ts
import {
  format as format2,
  parse as parse2
} from "json-rpc-protocol";
var JsonRPCClient = class {
  constructor(connector, notifiers) {
    this.connector = connector;
    this.notifiers = notifiers;
    this.id = 0;
    this.executors = {};
    this.connector.on("message", (data) => this.onMessage(data));
    this.connector.on("close", () => this.onClose());
  }
  onMessage(data) {
    const message = parse2(data);
    switch (message.type) {
      case "notification":
        return this.onNotify(
          message.method,
          message.params.map(decodeFromStr)
        );
      case "response":
        const { resolve } = this.executors[Number(message.id)];
        delete this.executors[Number(message.id)];
        return resolve(decodeFromStr(message.result));
      case "error":
        const { reject } = this.executors[Number(message.id)];
        delete this.executors[Number(message.id)];
        return reject(message.error.message);
    }
  }
  async request(method, params = []) {
    return new Promise((resolve, reject) => {
      const reqId = this.id++;
      this.executors[reqId] = { resolve, reject };
      const req = format2.request(reqId, method, params.map(encodeToStr));
      this.connector.send(req);
    });
  }
  get version() {
    return this.connector.version;
  }
  onNotify(type, data) {
    this.notifiers[type](...data);
  }
  onClose() {
  }
};

// src/MSafeWallet.ts
var MSafeOrigins = {
  mainnet: "https://aptos.m-safe.io",
  testnet: "https://aptos-testnet.m-safe.io",
  partner: "https://aptos-preview.m-safe.io",
  legacy1: "https://app.m-safe.io",
  legacy2: "https://testnet.m-safe.io",
  legacy3: "https://partner.m-safe.io",
  local: "http://localhost:5173"
};
var DefaultMSafeEndpoints = Object.values(MSafeOrigins);
var MSafeWallet = class {
  constructor(connector) {
    this.events = {};
    const onEvent = (type, ...params) => {
      const cbk = this.events[type];
      cbk && cbk(params[0]);
    };
    const entries = ["ChangeAccountEvent" /* ChangeAccount */, "ChangeNetworkEvent" /* ChangeNetwork */].map(
      (event) => [event, (...params) => onEvent(event, ...params)]
    );
    const notifiers = Object.fromEntries(entries);
    this.client = new JsonRPCClient(connector, notifiers);
  }
  async connect() {
    return this.client.request("connect" /* connect */);
  }
  async isConnected() {
    return this.client.request("isConnected" /* isConnected */);
  }
  async disconnect() {
    return this.client.request("disconnect" /* disconnect */);
  }
  onChangeAccount(cbk) {
    this.events["ChangeAccountEvent" /* ChangeAccount */] = cbk;
  }
  onChangeNetwork(cbk) {
    this.events["ChangeNetworkEvent" /* ChangeNetwork */] = cbk;
  }
  async network() {
    return this.client.request("network" /* network */);
  }
  async account() {
    return this.client.request("account" /* account */);
  }
  async chainId() {
    return this.client.request("chainId" /* chainId */);
  }
  async signAndSubmit(payload, option) {
    return this.client.request("signAndSubmit" /* signAndSubmit */, [payload, option]);
  }
  async signTransaction(payload, option) {
    return this.client.request("signTransaction" /* signTransaction */, [payload, option]);
  }
  async signMessage(message) {
    return this.client.request("signMessage" /* signMessage */, [message]);
  }
  get version() {
    return this.client.version;
  }
  static inMSafeWallet() {
    return typeof window !== "undefined" && typeof document !== "undefined" && typeof parent !== "undefined" && typeof parent.window !== "undefined" && parent.window !== window;
  }
  static inMsafeWallet() {
    return MSafeWallet.inMSafeWallet();
  }
  static getAppUrl(msafe = "mainnet", dappUrl = `${window.location.href}`) {
    const msafeOrigin = MSafeWallet.getOrigin(msafe);
    return `${msafeOrigin}/store/0?url=${encodeURIComponent(dappUrl)}`;
  }
  static getOrigin(msafeNetwork = "mainnet") {
    const endpoint = MSafeOrigins[msafeNetwork.toLowerCase()] || msafeNetwork;
    return new URL(endpoint).origin;
  }
  static async new(allowlist = DefaultMSafeEndpoints) {
    const msafeOrigin = allowlist instanceof Array ? allowlist.map((m) => MSafeWallet.getOrigin(m)) : [MSafeWallet.getOrigin(allowlist)];
    const connector = await Connector.connect(
      window.parent,
      DefaultMSafeEndpoints.map((m) => MSafeWallet.getOrigin(m))
    );
    return new MSafeWallet(connector);
  }
};
var MsafeWallet = class extends MSafeWallet {
};
export {
  Connector,
  JsonRPCClient,
  JsonRPCServer,
  MSafeServer,
  MSafeWallet,
  MsafeWallet,
  WalletEvent,
  WalletRPC,
  adaptLegacyAccount,
  decode,
  decodeFromStr,
  encode,
  encodeToStr,
  toLegacyAccount
};
//# sourceMappingURL=index.mjs.map