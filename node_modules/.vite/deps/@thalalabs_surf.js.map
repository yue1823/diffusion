{
  "version": 3,
  "sources": ["../../@thalalabs/surf/src/ensureTypes.ts", "../../@thalalabs/surf/src/core/createViewPayload.ts", "../../@thalalabs/surf/src/core/createEntryPayload.ts", "../../@thalalabs/surf/src/core/Client.ts"],
  "sourcesContent": ["// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction assertType(val: any, types: string[] | string, message?: string) {\n  if (!types?.includes(typeof val)) {\n    throw new Error(\n      message ||\n        `Invalid arg: ${val} type should be ${\n          types instanceof Array ? types.join(' or ') : types\n        }`,\n    );\n  }\n}\n\nexport function ensureBoolean(val: boolean | string): boolean {\n  assertType(val, ['boolean', 'string']);\n  if (typeof val === 'boolean') {\n    return val;\n  }\n\n  if (val === 'true') {\n    return true;\n  }\n  if (val === 'false') {\n    return false;\n  }\n\n  throw new Error('Invalid boolean string.');\n}\n\nexport function ensureNumber(val: number | string): number {\n  assertType(val, ['number', 'string']);\n  if (typeof val === 'number') {\n    return val;\n  }\n\n  const res = Number.parseInt(val, 10);\n  if (Number.isNaN(res)) {\n    throw new Error('Invalid number string.');\n  }\n\n  return res;\n}\n\nexport function ensureBigInt(val: number | bigint | string): bigint {\n  assertType(val, ['number', 'bigint', 'string']);\n  return BigInt(val);\n}\n", "import {\n  ABIRoot,\n  ExtractReturnType,\n  ViewFunctionName,\n  ViewPayload,\n  ViewRequestPayload,\n} from '../types/index.js';\nimport { ensureNumber } from '../ensureTypes.js';\nimport {\n  MoveFunctionGenericTypeParam,\n  MoveStructId,\n  TypeTag,\n  ViewFunctionABI,\n  parseTypeTag,\n} from '@aptos-labs/ts-sdk';\nimport { ABIFunction } from '../types/abi.js';\n\n/**\n * Create a payload for calling a view function.\n *\n * @param abi The ABI JSON contains the view function. For type inference and encoding/decoding purpose.\n * @param payload.function The function name.\n * @param payload.arguments The input arguments for function.\n * @param payload.type_arguments The generic type arguments for function.\n * @returns The payload object to be used in `view` method.\n * @example\n * const payload = createViewPayload(COIN_ABI, {\n *   function: 'balance',\n *   functionArguments: ['0x1'],\n *   typeArguments: ['0x1::aptos_coin::AptosCoin'],\n * });\n * const [balance] = await client.view({ payload });\n */\nexport function createViewPayload<\n  T extends ABIRoot,\n  TFuncName extends ViewFunctionName<T>,\n>(\n  abi: T,\n  payload: ViewRequestPayload<T, TFuncName>,\n): ViewPayload<ExtractReturnType<T, TFuncName>> {\n  const fnAbi = abi.exposed_functions.filter(\n    (f) => f.name === payload.function,\n  )[0];\n  const type_arguments: string[] = payload.typeArguments;\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const val_arguments: any[] = payload.functionArguments;\n\n  // Validations\n  if (fnAbi === undefined)\n    throw new Error(`Function ${payload.function} not found in ABI`);\n  if (fnAbi.params.length !== val_arguments.length)\n    throw new Error(\n      `Function ${payload.function} expects ${fnAbi.params.length} arguments, but ${payload.functionArguments.length} were provided`,\n    );\n  if (fnAbi.generic_type_params.length !== type_arguments.length)\n    throw new Error(\n      `Function ${payload.function} expects ${fnAbi.generic_type_params.length} type arguments, but ${payload.functionArguments.length} were provided`,\n    );\n\n  // TODO: do serialization here\n  const args = fnAbi.params.map((type, i) => {\n    const arg = payload.functionArguments[i] as unknown;\n    if (['u8', 'u16', 'u32'].includes(type)) {\n      return ensureNumber(arg as number);\n    } else if (['u64', 'u128', 'u256'].includes(type)) {\n      if (!arg?.toString) {\n        throw new Error(`Expecting a bigint, but got ${arg}`);\n      }\n      return arg.toString();\n    } else if (type.includes('vector')) {\n      // eslint-disable-next-line @typescript-eslint/no-explicit-any\n      return encodeVector(type, arg as any[]);\n    } else {\n      // string or address\n      return arg;\n    }\n  });\n\n  return {\n    function: `${payload.address ?? abi.address}::${abi.name}::${\n      payload.function\n    }`,\n    functionArguments: args,\n    typeArguments: payload.typeArguments as Array<MoveStructId>,\n    abi: constructViewAbiObj(fnAbi),\n  };\n}\n\nfunction constructViewAbiObj(abi: ABIFunction): ViewFunctionABI {\n  // Non-view functions can't be used\n  if (!abi.is_view) {\n    throw new Error(`not an view function`);\n  }\n\n  // Type tag parameters for the function\n  const params: TypeTag[] = [];\n  for (let i = 0; i < abi.params.length; i += 1) {\n    params.push(parseTypeTag(abi.params[i]!, { allowGenerics: true }));\n  }\n\n  // The return types of the view function\n  const returnTypes: TypeTag[] = [];\n  for (let i = 0; i < abi.return.length; i += 1) {\n    returnTypes.push(parseTypeTag(abi.return[i]!, { allowGenerics: true }));\n  }\n\n  return {\n    typeParameters:\n      abi.generic_type_params as Array<MoveFunctionGenericTypeParam>,\n    parameters: params,\n    returnTypes,\n  };\n}\n\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction encodeVector(type: string, value: any) {\n  const regex = /vector<([^]+)>/;\n  const match = type.match(regex);\n  if (!match) {\n    // Should never happen\n    throw new Error(`Unsupported type: ${type}`);\n  }\n  const innerType = match[1];\n  if (!innerType) {\n    throw new Error(`Unsupported type: ${type}`);\n  }\n\n  if (innerType === 'u8') {\n    if (typeof value === 'string' || value instanceof Uint8Array) return value;\n    if (Array.isArray(value)) {\n      return value;\n    }\n\n    throw new Error(`Invalid u8 value: ${value}`);\n  } else if (['bool', 'u16', 'u32'].includes(innerType)) {\n    return value;\n  } else if (['u64', 'u128', 'u256'].includes(innerType)) {\n    return value.map((v: bigint) => v.toString());\n  } else {\n    // string or address\n    // TODO: encode for Vector of vector\n    return value;\n  }\n}\n", "import type {\n  ABIRoot,\n  EntryPayload,\n  EntryRequestPayload,\n} from '../types/index.js';\nimport { EntryFunctionName } from '../types/extractor/functionExtractor.js';\n\n/**\n * Create a payload for calling a entry function.\n *\n * @param abi The ABI JSON contains the entry function. For type inference and encoding/decoding purpose.\n * @param payload.function The function name.\n * @param payload.arguments The input arguments for function.\n * @param payload.type_arguments The generic type arguments for function.\n * @returns The payload object to be used in `simulateTransaction` or `submitTransaction` method.\n * @example\n * const payload = createEntryPayload(COIN_ABI, {\n *   function: 'transfer',\n *   functionArguments: ['0x1', 1],\n *   typeArguments: ['0x1::aptos_coin::AptosCoin'],\n * });\n *\n * const result = await client.submitTransaction({\n *   payload,\n *   signer: account,\n * });\n */\nexport function createEntryPayload<\n  T extends ABIRoot,\n  TFuncName extends EntryFunctionName<T>,\n>(abi: T, payload: EntryRequestPayload<T, TFuncName>): EntryPayload {\n  const fnAbi = abi.exposed_functions.filter(\n    (f) => f.name === payload.function,\n  )[0];\n\n  if (fnAbi === undefined)\n    throw new Error(`Function ${payload.function} not found in ABI`);\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const typeArguments: string[] = payload.typeArguments as any[];\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const valArguments: any[] = payload.functionArguments as any[];\n  const abiArgs =\n    fnAbi.params[0] === '&signer'\n      ? (fnAbi.params as string[]).slice(1)\n      : (fnAbi.params as string[]);\n\n  // Validations\n  if (fnAbi === undefined)\n    throw new Error(`Function ${payload.function} not found in ABI`);\n  if (abiArgs.length !== valArguments.length)\n    throw new Error(\n      `Function ${payload.function} expects ${fnAbi.params.length} arguments, but ${payload.functionArguments.length} were provided`,\n    );\n  if (fnAbi.generic_type_params.length !== typeArguments.length)\n    throw new Error(\n      `Function ${payload.function} expects ${fnAbi.generic_type_params.length} type arguments, but ${payload.typeArguments.length} were provided`,\n    );\n\n  return {\n    typeArguments: payload.typeArguments,\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    functionArguments: payload.functionArguments as any,\n    function: `${payload.address ?? abi.address}::${abi.name}::${payload.function}`,\n  };\n}\n", "import { createViewPayload } from './createViewPayload.js';\nimport { createEntryPayload } from './createEntryPayload.js';\nimport {\n  ABIEntryClient,\n  ABIViewClient,\n  ABIRoot,\n  EntryPayload,\n  ViewPayload,\n  DefaultABITable,\n  ABIResourceClient,\n} from '../types/index.js';\nimport { ABITable } from '../types/defaultABITable.js';\nimport {\n  Aptos,\n  LedgerVersionArg,\n  MoveValue,\n  Account,\n  CommittedTransactionResponse,\n  PublicKey,\n  AccountAddressInput,\n  UserTransactionResponse,\n  WaitForTransactionOptions,\n} from '@aptos-labs/ts-sdk';\n\n/**\n * Create a client to interact with Aptos smart contract.\n *\n * @param aptosClient The Aptos ts-sdk client.\n * @returns The Surf client object.\n * @example\n * const client = createSurfClient(new Aptos());\n */\nexport function createSurfClient<TABITable extends ABITable = DefaultABITable>(\n  aptosClient: Aptos,\n): Client<TABITable> {\n  return new Client<TABITable>(aptosClient);\n}\nexport class Client<TABITable extends ABITable> {\n  private client: Aptos;\n\n  constructor(client: Aptos) {\n    this.client = client;\n  }\n\n  /**\n   * Queries for a Move view function\n   *\n   * @param args.payload The payload object created by `createViewPayload`.\n   * @param options.ledgerVersion Specifies ledger version of transactions. By default latest version will be used.\n   * @returns an array of Move values\n   * @example\n   * const payload = createViewPayload(COIN_ABI, {\n   *   function: 'balance',\n   *   functionArguments: ['0x1'],\n   *   typeArguments: ['0x1::aptos_coin::AptosCoin'],\n   * });\n   * const [balance] = await client.view({ payload });\n   */\n  public async view<TReturn extends MoveValue[]>(args: {\n    payload: ViewPayload<TReturn>;\n    options?: LedgerVersionArg;\n  }): Promise<TReturn> {\n    return await this.client.view(args);\n  }\n\n  /**\n   * Submit a transaction.\n   *\n   * @param args.signer The signer account to sign the transaction\n   * @param args.payload The payload object created by `createEntryPayload`.\n   * @param args.options Option properties to pass for waitForTransaction() function\n   * @returns The transaction response.\n   * @example\n   * const payload = createEntryPayload(COIN_ABI, {\n   *   function: 'transfer',\n   *   functionArguments: ['0x1', 1],\n   *   typeArguments: ['0x1::aptos_coin::AptosCoin'],\n   * });\n   *\n   * const result = await client.submitTransaction({\n   *   payload,\n   *   signer: account,\n   * });\n   */\n  public async submitTransaction(args: {\n    signer: Account;\n    payload: EntryPayload;\n    options?: WaitForTransactionOptions;\n  }): Promise<CommittedTransactionResponse> {\n    const transaction = await this.client.transaction.build.simple({\n      sender: args.signer.accountAddress.toString(),\n      data: args.payload,\n    });\n\n    // Submit the transaction\n    const transactionRes =\n      await this.client.transaction.signAndSubmitTransaction({\n        signer: args.signer,\n        transaction,\n      });\n\n    // Wait for the transaction to finish\n    // throws an error if the tx fails or not confirmed after timeout\n    return await this.client.waitForTransaction({\n      transactionHash: transactionRes.hash,\n      options: args.options ?? {},\n    });\n  }\n\n  /**\n   * Simulate a transaction.\n   *\n   * @param args.publicKey The sender public key\n   * @param args.sender The sender address\n   * @param args.payload The payload object created by `createEntryPayload`.\n   * @returns The transaction response.\n   * @example\n   * const payload = createEntryPayload(COIN_ABI, {\n   *   function: 'transfer',\n   *   functionArguments: ['0x1', 1],\n   *   typeArguments: ['0x1::aptos_coin::AptosCoin'],\n   * });\n   *\n   * const result = await client.simulateTransaction({\n   *   payload,\n   *   sender: account.accountAddress,\n   *   publicKey: account.publicKey,\n   * });\n   */\n  public async simulateTransaction(args: {\n    publicKey: PublicKey;\n    sender: AccountAddressInput;\n    payload: EntryPayload;\n  }): Promise<UserTransactionResponse> {\n    const transaction = await this.client.transaction.build.simple({\n      sender: args.sender,\n      data: args.payload,\n    });\n\n    return (\n      await this.client.transaction.simulate.simple({\n        signerPublicKey: args.publicKey,\n        transaction,\n      })\n    )[0]!;\n  }\n\n  /**\n   * Builds ABI from a provided address and module name for given client. ABI name can be taken from abi.name\n   *\n   * @param address The module address\n   * @param moduleName The module name\n   * @returns The constructed ABI\n   * @example\n   * const abi = await client.fetchABI(address = '0x1', moduleName = 'AptosCoin');\n   */\n  public async fetchABI<T extends ABIRoot>(\n    address: string,\n    moduleName: string,\n  ): Promise<T> {\n    // Fetches ABI fom address and module name for given client\n    // throws if inexistent module name in address for given client\n    return (\n      await this.client.getAccountModule({\n        accountAddress: address,\n        moduleName: moduleName,\n      })\n    ).abi as unknown as T;\n  }\n\n  /**\n   * Create a client associated with a specific ABI.\n   *\n   * @param abi The ABI JSON.\n   * @param address The address of the module. If not provided, ABI address will be used.\n   * @returns A client can call view/entry functions or get account resource.\n   * @example\n   * const [balance] = await client.useABI(COIN_ABI).view.balance({\n   *    functionArguments: ['0x1'],\n   *    typeArguments: ['0x1::aptos_coin::AptosCoin'],\n   * });\n   */\n  public useABI<T extends ABIRoot>(abi: T, address?: string) {\n    return {\n      /**\n       * Queries for a Move view function\n       *\n       * @example\n       * const [balance] = await client.useABI(COIN_ABI).view.balance({\n       *     functionArguments: ['0x1'],\n       *     typeArguments: ['0x1::aptos_coin::AptosCoin'],\n       * });\n       */\n      view: new Proxy({} as ABIViewClient<T>, {\n        get: (_, prop) => {\n          const functionName = prop.toString();\n          return (...args) => {\n            const payload = createViewPayload(abi, {\n              address: (address ?? abi.address) as `0x${string}`,\n              function: functionName,\n              typeArguments: args[0].typeArguments,\n              functionArguments: args[0].functionArguments,\n            });\n            return this.view({\n              payload,\n              options: {\n                ledgerVersion: args[0].ledgerVersion,\n              },\n            });\n          };\n        },\n      }),\n\n      /**\n       * Call an entry function.\n       *\n       * @example\n       * const { hash } = await client.useABI(COIN_ABI).entry.transfer({\n       *     functionArguments: ['0x1', 1],\n       *     typeArguments: ['0x1::aptos_coin::AptosCoin'],\n       *     account,\n       * });\n       */\n      entry: new Proxy({} as ABIEntryClient<T>, {\n        get: (_, prop) => {\n          const functionName = prop.toString();\n          return (...args) => {\n            const payload = createEntryPayload(abi, {\n              address: (address ?? abi.address) as `0x${string}`,\n              function: functionName,\n              typeArguments: args[0].typeArguments,\n              functionArguments: args[0].functionArguments,\n            });\n\n            const account: Account = args[0].account;\n            return args[0].isSimulation\n              ? this.simulateTransaction({\n                  publicKey: account.publicKey,\n                  sender: account.accountAddress.toString(),\n                  payload,\n                })\n              : this.submitTransaction({\n                  signer: args[0].account,\n                  payload,\n                });\n          };\n        },\n      }),\n\n      /**\n       * Get account resource.\n       *\n       * @example\n       * const { data } = await client.useABI(COIN_ABI).resource.CoinStore({\n       *     typeArguments: ['0x1::aptos_coin::AptosCoin'],\n       *     account: '0x1',\n       * });\n       */\n      resource: new Proxy({} as ABIResourceClient<TABITable, T>, {\n        get: (_, prop) => {\n          let structName = prop.toString();\n          return (...args) => {\n            if (args[0].typeArguments.length !== 0) {\n              structName += `<${args[0].typeArguments.join(',')}>`;\n            }\n\n            const account: AccountAddressInput = args[0].account;\n            return this.client.getAccountResource({\n              accountAddress: account,\n              resourceType: `${address ?? abi.address}::${abi.name}::${structName}`,\n              options: {\n                ledgerVersion: args[0].ledgerVersion,\n              },\n            });\n          };\n        },\n      }),\n    };\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
