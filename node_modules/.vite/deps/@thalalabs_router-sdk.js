import {
  require_index_browser,
  require_lib
} from "./chunk-UXO2HZ2E.js";
import {
  require_poseidon_lite
} from "./chunk-HLYV2BFP.js";
import {
  require_eventemitter3
} from "./chunk-KEMPSE3P.js";
import {
  __commonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/@thalalabs/thalaswap-math/dist/index.js
var require_dist = __commonJS({
  "node_modules/@thalalabs/thalaswap-math/dist/index.js"(exports, module) {
    "use strict";
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var src_exports = {};
    __export(src_exports, {
      calcInGivenOutStable: () => calcInGivenOutStable,
      calcInGivenOutWeighted: () => calcInGivenOutWeighted,
      calcOutGivenInStable: () => calcOutGivenInStable,
      calcOutGivenInWeighted: () => calcOutGivenInWeighted,
      calcPriceImpactPercentageStable: () => calcPriceImpactPercentageStable,
      calcPriceImpactPercentageWeighted: () => calcPriceImpactPercentageWeighted,
      computeAssetAmountToReturn: () => computeAssetAmountToReturn,
      getLpTokenToIssueStable: () => getLpTokenToIssueStable,
      getPriceStable: () => getPriceStable,
      getStableSwapSlippageLoss: () => getStableSwapSlippageLoss
    });
    module.exports = __toCommonJS(src_exports);
    function calcOutGivenInStable(amountIn, indexIn, indexOut, balances, amp, fee) {
      amountIn = amountIn * (1 - fee);
      const newX = balances[indexIn] + amountIn;
      const newY = getY(balances, newX, amp, indexIn, indexOut);
      return balances[indexOut] - newY;
    }
    function calcInGivenOutStable(amountOut, indexIn, indexOut, balances, amp, fee) {
      const newX = balances[indexOut] - amountOut;
      const newY = getY(balances, newX, amp, indexOut, indexIn);
      return (newY - balances[indexIn]) / (1 - fee);
    }
    function getPriceStable(i, j, balances, amp) {
      const d = getD(balances, amp);
      const n = balances.length;
      let b = Math.pow(d, n + 1) / Math.pow(n, n);
      balances.forEach((x, index) => {
        if (index != i && index != j) {
          b = b / x;
        }
      });
      let naxx = n * amp * balances[i] * balances[i] * balances[j] * balances[j];
      return (balances[i] * b + naxx) / (balances[j] * b + naxx);
    }
    function calcPriceImpactPercentageStable(exactAmountIn, exactAmountOut, indexIn, indexOut, balances, amp) {
      if (balances[indexOut] - exactAmountOut < 1e-6) {
        return 100;
      }
      const oldPrice = getPriceStable(indexIn, indexOut, balances, amp);
      balances[indexIn] = balances[indexIn] + exactAmountIn;
      balances[indexOut] = balances[indexOut] - exactAmountOut;
      const newPrice = getPriceStable(indexIn, indexOut, balances, amp);
      return Math.abs(newPrice - oldPrice) / oldPrice * 100;
    }
    function getStableSwapSlippageLoss(inputAmounts, poolBalances, amp) {
      const d = getD(poolBalances, amp);
      const relativePrices = Array(poolBalances.length).fill(0).map(
        (_, i) => i == 0 ? 1 : getPriceStableWithKnownD(0, i, poolBalances, amp, d)
      );
      const prevWorth = inputAmounts.reduce(
        (acc, cur, i) => acc + cur * relativePrices[i],
        0
      );
      const newBalances = poolBalances.map(
        (balance, i) => balance + inputAmounts[i]
      );
      const newD = getD(newBalances, amp);
      const newWorth = poolBalances.reduce((acc, cur, i) => acc + cur * relativePrices[i], 0) * (newD - d) / d;
      return (prevWorth - newWorth) / prevWorth;
    }
    function getLpTokenToIssueStable(inputAmounts, poolBalances, amp, lpSupply) {
      const d = getD(poolBalances, amp);
      const newPoolBalances = poolBalances.map(
        (balance, i) => balance + inputAmounts[i]
      );
      const newD = getD(newPoolBalances, amp);
      return lpSupply * (newD - d) / d;
    }
    function getPriceStableWithKnownD(i, j, balances, amp, d) {
      const n = balances.length;
      let b = Math.pow(d, n + 1) / Math.pow(n, n);
      balances.forEach((x, index) => {
        if (index != i && index != j) {
          b = b / x;
        }
      });
      let naxx = n * amp * balances[i] * balances[i] * balances[j] * balances[j];
      return (balances[i] * b + naxx) / (balances[j] * b + naxx);
    }
    var EPSILON = 1e-6;
    var MAX_LOOP_LIMIT = 100;
    function getY(xp, x, a, i, j) {
      const d = getD(xp, a);
      const n = xp.length;
      const ann = a * n;
      let c = d;
      let s = 0;
      let k = 0;
      while (k < n) {
        if (k == j) {
          k = k + 1;
          continue;
        }
        let x_k = k == i ? x : xp[k];
        s = s + x_k;
        c = c * d / (x_k * n);
        k = k + 1;
      }
      c = c * d / (ann * n);
      let b = s + d / ann;
      let y = d;
      k = 0;
      while (k < MAX_LOOP_LIMIT) {
        let prev_y = y;
        y = (y * y + c) / (2 * y + b - d);
        if (Math.abs(y - prev_y) < EPSILON) {
          return y;
        }
        k = k + 1;
      }
      throw new Error(
        `not converged in getY, xp: ${xp}, x: ${x}, a: ${a}, i: ${i}, j: ${j}`
      );
    }
    function getD(xp, a) {
      const n = xp.length;
      const s = xp.reduce((partialSum, a2) => partialSum + a2, 0);
      if (s == 0) {
        return 0;
      }
      let prev_d;
      let d = s;
      const ann = a * n;
      let i = 0;
      while (i < MAX_LOOP_LIMIT) {
        let dp = d;
        let j = 0;
        while (j < n) {
          dp = dp * d / (xp[j] * n);
          j = j + 1;
        }
        prev_d = d;
        d = (ann * s + n * dp) * d / ((ann - 1) * d + (n + 1) * dp);
        if (Math.abs(prev_d - d) < EPSILON) {
          return d;
        }
        i = i + 1;
      }
      throw new Error(`not converged in getD, xp: ${xp}, a: ${a}`);
    }
    function calcOutGivenInWeighted(bI, wI, bO, wO, aI, sF) {
      const denom = bI + aI * (1 - sF);
      return bO * (1 - Math.pow(bI / denom, wI / wO));
    }
    function calcInGivenOutWeighted(bI, wI, bO, wO, aO, sF) {
      return bI * (Math.pow(bO / (bO - aO), wO / wI) - 1) / (1 - sF);
    }
    function calcPriceImpactPercentageWeighted(exactAmountIn, exactAmountOut, balanceIn, balanceOut, weightIn, weightOut) {
      if (balanceOut - exactAmountOut < 1e-6) {
        return 100;
      }
      const oldPrice = balanceIn / balanceOut * weightOut / weightIn;
      balanceIn = balanceIn + exactAmountIn;
      balanceOut = balanceOut - exactAmountOut;
      const newPrice = balanceIn / balanceOut * weightOut / weightIn;
      return Math.abs(newPrice - oldPrice) / oldPrice * 100;
    }
    function computeAssetAmountToReturn(balance, p_redeemed, p_supply) {
      return balance / p_supply * p_redeemed;
    }
  }
});

// node_modules/js-base64/base64.js
var require_base64 = __commonJS({
  "node_modules/js-base64/base64.js"(exports, module) {
    (function(global2, factory) {
      typeof exports === "object" && typeof module !== "undefined" ? module.exports = factory() : typeof define === "function" && define.amd ? define(factory) : (
        // cf. https://github.com/dankogai/js-base64/issues/119
        function() {
          var _Base64 = global2.Base64;
          var gBase64 = factory();
          gBase64.noConflict = function() {
            global2.Base64 = _Base64;
            return gBase64;
          };
          if (global2.Meteor) {
            Base64 = gBase64;
          }
          global2.Base64 = gBase64;
        }()
      );
    })(typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : exports, function() {
      "use strict";
      var version = "3.7.7";
      var VERSION = version;
      var _hasBuffer = typeof Buffer === "function";
      var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
      var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
      var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      var b64chs = Array.prototype.slice.call(b64ch);
      var b64tab = function(a) {
        var tab = {};
        a.forEach(function(c, i) {
          return tab[c] = i;
        });
        return tab;
      }(b64chs);
      var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
      var _fromCC = String.fromCharCode.bind(String);
      var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : function(it) {
        return new Uint8Array(Array.prototype.slice.call(it, 0));
      };
      var _mkUriSafe = function(src) {
        return src.replace(/=/g, "").replace(/[+\/]/g, function(m0) {
          return m0 == "+" ? "-" : "_";
        });
      };
      var _tidyB64 = function(s) {
        return s.replace(/[^A-Za-z0-9\+\/]/g, "");
      };
      var btoaPolyfill = function(bin) {
        var u32, c0, c1, c2, asc = "";
        var pad = bin.length % 3;
        for (var i = 0; i < bin.length; ) {
          if ((c0 = bin.charCodeAt(i++)) > 255 || (c1 = bin.charCodeAt(i++)) > 255 || (c2 = bin.charCodeAt(i++)) > 255)
            throw new TypeError("invalid character found");
          u32 = c0 << 16 | c1 << 8 | c2;
          asc += b64chs[u32 >> 18 & 63] + b64chs[u32 >> 12 & 63] + b64chs[u32 >> 6 & 63] + b64chs[u32 & 63];
        }
        return pad ? asc.slice(0, pad - 3) + "===".substring(pad) : asc;
      };
      var _btoa = typeof btoa === "function" ? function(bin) {
        return btoa(bin);
      } : _hasBuffer ? function(bin) {
        return Buffer.from(bin, "binary").toString("base64");
      } : btoaPolyfill;
      var _fromUint8Array = _hasBuffer ? function(u8a) {
        return Buffer.from(u8a).toString("base64");
      } : function(u8a) {
        var maxargs = 4096;
        var strs = [];
        for (var i = 0, l = u8a.length; i < l; i += maxargs) {
          strs.push(_fromCC.apply(null, u8a.subarray(i, i + maxargs)));
        }
        return _btoa(strs.join(""));
      };
      var fromUint8Array = function(u8a, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_fromUint8Array(u8a)) : _fromUint8Array(u8a);
      };
      var cb_utob = function(c) {
        if (c.length < 2) {
          var cc = c.charCodeAt(0);
          return cc < 128 ? c : cc < 2048 ? _fromCC(192 | cc >>> 6) + _fromCC(128 | cc & 63) : _fromCC(224 | cc >>> 12 & 15) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        } else {
          var cc = 65536 + (c.charCodeAt(0) - 55296) * 1024 + (c.charCodeAt(1) - 56320);
          return _fromCC(240 | cc >>> 18 & 7) + _fromCC(128 | cc >>> 12 & 63) + _fromCC(128 | cc >>> 6 & 63) + _fromCC(128 | cc & 63);
        }
      };
      var re_utob = /[\uD800-\uDBFF][\uDC00-\uDFFFF]|[^\x00-\x7F]/g;
      var utob = function(u) {
        return u.replace(re_utob, cb_utob);
      };
      var _encode = _hasBuffer ? function(s) {
        return Buffer.from(s, "utf8").toString("base64");
      } : _TE ? function(s) {
        return _fromUint8Array(_TE.encode(s));
      } : function(s) {
        return _btoa(utob(s));
      };
      var encode = function(src, urlsafe) {
        if (urlsafe === void 0) {
          urlsafe = false;
        }
        return urlsafe ? _mkUriSafe(_encode(src)) : _encode(src);
      };
      var encodeURI = function(src) {
        return encode(src, true);
      };
      var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
      var cb_btou = function(cccc) {
        switch (cccc.length) {
          case 4:
            var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
            return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
          case 3:
            return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
          default:
            return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
        }
      };
      var btou = function(b) {
        return b.replace(re_btou, cb_btou);
      };
      var atobPolyfill = function(asc) {
        asc = asc.replace(/\s+/g, "");
        if (!b64re.test(asc))
          throw new TypeError("malformed base64.");
        asc += "==".slice(2 - (asc.length & 3));
        var u24, bin = "", r1, r2;
        for (var i = 0; i < asc.length; ) {
          u24 = b64tab[asc.charAt(i++)] << 18 | b64tab[asc.charAt(i++)] << 12 | (r1 = b64tab[asc.charAt(i++)]) << 6 | (r2 = b64tab[asc.charAt(i++)]);
          bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r2 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
        }
        return bin;
      };
      var _atob = typeof atob === "function" ? function(asc) {
        return atob(_tidyB64(asc));
      } : _hasBuffer ? function(asc) {
        return Buffer.from(asc, "base64").toString("binary");
      } : atobPolyfill;
      var _toUint8Array = _hasBuffer ? function(a) {
        return _U8Afrom(Buffer.from(a, "base64"));
      } : function(a) {
        return _U8Afrom(_atob(a).split("").map(function(c) {
          return c.charCodeAt(0);
        }));
      };
      var toUint8Array = function(a) {
        return _toUint8Array(_unURI(a));
      };
      var _decode = _hasBuffer ? function(a) {
        return Buffer.from(a, "base64").toString("utf8");
      } : _TD ? function(a) {
        return _TD.decode(_toUint8Array(a));
      } : function(a) {
        return btou(_atob(a));
      };
      var _unURI = function(a) {
        return _tidyB64(a.replace(/[-_]/g, function(m0) {
          return m0 == "-" ? "+" : "/";
        }));
      };
      var decode = function(src) {
        return _decode(_unURI(src));
      };
      var isValid = function(src) {
        if (typeof src !== "string")
          return false;
        var s = src.replace(/\s+/g, "").replace(/={0,2}$/, "");
        return !/[^\s0-9a-zA-Z\+/]/.test(s) || !/[^\s0-9a-zA-Z\-_]/.test(s);
      };
      var _noEnum = function(v) {
        return {
          value: v,
          enumerable: false,
          writable: true,
          configurable: true
        };
      };
      var extendString = function() {
        var _add = function(name, body) {
          return Object.defineProperty(String.prototype, name, _noEnum(body));
        };
        _add("fromBase64", function() {
          return decode(this);
        });
        _add("toBase64", function(urlsafe) {
          return encode(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return encode(this, true);
        });
        _add("toBase64URL", function() {
          return encode(this, true);
        });
        _add("toUint8Array", function() {
          return toUint8Array(this);
        });
      };
      var extendUint8Array = function() {
        var _add = function(name, body) {
          return Object.defineProperty(Uint8Array.prototype, name, _noEnum(body));
        };
        _add("toBase64", function(urlsafe) {
          return fromUint8Array(this, urlsafe);
        });
        _add("toBase64URI", function() {
          return fromUint8Array(this, true);
        });
        _add("toBase64URL", function() {
          return fromUint8Array(this, true);
        });
      };
      var extendBuiltins = function() {
        extendString();
        extendUint8Array();
      };
      var gBase64 = {
        version,
        VERSION,
        atob: _atob,
        atobPolyfill,
        btoa: _btoa,
        btoaPolyfill,
        fromBase64: decode,
        toBase64: encode,
        encode,
        encodeURI,
        encodeURL: encodeURI,
        utob,
        btou,
        decode,
        isValid,
        fromUint8Array,
        toUint8Array,
        extendString,
        extendUint8Array,
        extendBuiltins
      };
      gBase64.Base64 = {};
      Object.keys(gBase64).forEach(function(k) {
        return gBase64.Base64[k] = gBase64[k];
      });
      return gBase64;
    });
  }
});

// node_modules/@aptos-labs/ts-sdk/dist/common/chunk-BHKSQXUZ.js
var require_chunk_BHKSQXUZ = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/dist/common/chunk-BHKSQXUZ.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var d = Object.defineProperty;
    var i = Object.getOwnPropertyDescriptor;
    var l = (o, e, t, r) => {
      for (var n = r > 1 ? void 0 : r ? i(e, t) : e, s = o.length - 1, c; s >= 0; s--) (c = o[s]) && (n = (r ? c(e, t, n) : c(n)) || n);
      return r && n && d(e, t, n), n;
    };
    var _jsbase64 = require_base64();
    async function m(o) {
      return new Promise((e) => {
        setTimeout(e, o);
      });
    }
    var p = () => Math.floor(Date.now() / 1e3);
    function f(o) {
      let e = new Date(o * 1e3);
      return e.setMinutes(0), e.setSeconds(0), e.setMilliseconds(0), Math.floor(e.getTime() / 1e3);
    }
    function b(o) {
      let e = o.replace(/-/g, "+").replace(/_/g, "/"), t = e + "==".substring(0, (3 - e.length % 3) % 3);
      return _jsbase64.decode.call(void 0, t);
    }
    exports.a = l;
    exports.b = m;
    exports.c = p;
    exports.d = f;
    exports.e = b;
  }
});

// node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = exports.isBytes = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`positive integer expected, not ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`boolean expected, not ${b}`);
    }
    exports.bool = bool;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    function bytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Uint8Array expected");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(h) {
      if (typeof h !== "function" || typeof h.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(h.outputLen);
      number(h.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.byteSwap32 = exports.byteSwapIfBE = exports.byteSwap = exports.isLE = exports.rotl = exports.rotr = exports.createView = exports.u32 = exports.u8 = exports.isBytes = void 0;
    var crypto_1 = require_crypto();
    var _assert_js_1 = require_assert();
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    exports.isBytes = isBytes;
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
    exports.rotl = rotl;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
    exports.byteSwap = byteSwap;
    exports.byteSwapIfBE = exports.isLE ? (n) => n : (n) => (0, exports.byteSwap)(n);
    function byteSwap32(arr) {
      for (let i = 0; i < arr.length; i++) {
        arr[i] = (0, exports.byteSwap)(arr[i]);
      }
    }
    exports.byteSwap32 = byteSwap32;
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      (0, _assert_js_1.bytes)(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      (0, _assert_js_1.bytes)(data);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        (0, _assert_js_1.bytes)(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/@noble/hashes/_md.js
var require_md = __commonJS({
  "node_modules/@noble/hashes/_md.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HashMD = exports.Maj = exports.Chi = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var Chi = (a, b, c) => a & b ^ ~a & c;
    exports.Chi = Chi;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    exports.Maj = Maj;
    var HashMD = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.HashMD = HashMD;
  }
});

// node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
    var _md_js_1 = require_md();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh, SHA512_Kl] = (() => _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _md_js_1.HashMD {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
    exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
  }
});

// node_modules/@noble/curves/abstract/utils.js
var require_utils2 = __commonJS({
  "node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.notImplemented = exports.bitMask = void 0;
    exports.isBytes = isBytes;
    exports.abytes = abytes;
    exports.abool = abool;
    exports.bytesToHex = bytesToHex;
    exports.numberToHexUnpadded = numberToHexUnpadded;
    exports.hexToNumber = hexToNumber;
    exports.hexToBytes = hexToBytes;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.bytesToNumberLE = bytesToNumberLE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.numberToBytesLE = numberToBytesLE;
    exports.numberToVarBytesBE = numberToVarBytesBE;
    exports.ensureBytes = ensureBytes;
    exports.concatBytes = concatBytes;
    exports.equalBytes = equalBytes;
    exports.utf8ToBytes = utf8ToBytes;
    exports.inRange = inRange;
    exports.aInRange = aInRange;
    exports.bitLen = bitLen;
    exports.bitGet = bitGet;
    exports.bitSet = bitSet;
    exports.createHmacDrbg = createHmacDrbg;
    exports.validateObject = validateObject;
    exports.memoized = memoized;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function abytes(item) {
      if (!isBytes(item))
        throw new Error("Uint8Array expected");
    }
    function abool(title, value) {
      if (typeof value !== "boolean")
        throw new Error(`${title} must be valid boolean, got "${value}".`);
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (isBytes(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    var isPosBig = (n) => typeof n === "bigint" && _0n <= n;
    function inRange(n, min, max) {
      return isPosBig(n) && isPosBig(min) && isPosBig(max) && min <= n && n < max;
    }
    function aInRange(title, n, min, max) {
      if (!inRange(n, min, max))
        throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n} ${n}`);
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
    var notImplemented = () => {
      throw new Error("not implemented");
    };
    exports.notImplemented = notImplemented;
    function memoized(fn) {
      const map = /* @__PURE__ */ new WeakMap();
      return (arg, ...args) => {
        const val = map.get(arg);
        if (val !== void 0)
          return val;
        const computed = fn(arg, ...args);
        map.set(arg, computed);
        return computed;
      };
    }
  }
});

// node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNegativeLE = void 0;
    exports.mod = mod;
    exports.pow = pow;
    exports.pow2 = pow2;
    exports.invert = invert;
    exports.tonelliShanks = tonelliShanks;
    exports.FpSqrt = FpSqrt;
    exports.validateField = validateField;
    exports.FpPow = FpPow;
    exports.FpInvertBatch = FpInvertBatch;
    exports.FpDiv = FpDiv;
    exports.FpLegendre = FpLegendre;
    exports.FpIsSquare = FpIsSquare;
    exports.nLength = nLength;
    exports.Field = Field;
    exports.FpSqrtOdd = FpSqrtOdd;
    exports.FpSqrtEven = FpSqrtEven;
    exports.hashToPrivateScalar = hashToPrivateScalar;
    exports.getFieldBytesLength = getFieldBytesLength;
    exports.getMinHashLength = getMinHashLength;
    exports.mapHashToField = mapHashToField;
    var utils_js_1 = require_utils2();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    function FpLegendre(order) {
      const legendreConst = (order - _1n) / _2n;
      return (f, x) => f.pow(x, legendreConst);
    }
    function FpIsSquare(f) {
      const legendre = FpLegendre(f.ORDER);
      return (x) => {
        const p = legendre(f, x);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wNAF = wNAF;
    exports.validateBasic = validateBasic;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils2();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var pointPrecomputes = /* @__PURE__ */ new WeakMap();
    var pointWindowSizes = /* @__PURE__ */ new WeakMap();
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const validateW = (W) => {
        if (!Number.isSafeInteger(W) || W <= 0 || W > bits)
          throw new Error(`Wrong window size=${W}, should be [1..${bits}]`);
      };
      const opts = (W) => {
        validateW(W);
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, n, transform) {
          const W = pointWindowSizes.get(P) || 1;
          let comp = pointPrecomputes.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1)
              pointPrecomputes.set(P, transform(comp));
          }
          return this.wNAF(W, comp, n);
        },
        // We calculate precomputes for elliptic curve point multiplication
        // using windowed method. This specifies window size and
        // stores precomputed values. Usually only base point would be precomputed.
        setWindowSize(P, W) {
          validateW(W);
          pointWindowSizes.set(P, W);
          pointPrecomputes.delete(P);
        }
      };
    }
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
  }
});

// node_modules/@noble/curves/abstract/edwards.js
var require_edwards = __commonJS({
  "node_modules/@noble/curves/abstract/edwards.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.twistedEdwards = twistedEdwards;
    var curve_js_1 = require_curve();
    var modular_js_1 = require_modular();
    var ut = require_utils2();
    var utils_js_1 = require_utils2();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _8n = BigInt(8);
    var VERIFY_DEFAULT = { zip215: true };
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(curve, {
        hash: "function",
        a: "bigint",
        d: "bigint",
        randomBytes: "function"
      }, {
        adjustScalarBytes: "function",
        domain: "function",
        uvRatio: "function",
        mapToCurve: "function"
      });
      return Object.freeze({ ...opts });
    }
    function twistedEdwards(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER, prehash, hash: cHash, randomBytes, nByteLength, h: cofactor } = CURVE;
      const MASK = _2n << BigInt(nByteLength * 8) - _1n;
      const modP = Fp.create;
      const uvRatio = CURVE.uvRatio || ((u, v) => {
        try {
          return { isValid: true, value: Fp.sqrt(u * Fp.inv(v)) };
        } catch (e) {
          return { isValid: false, value: _0n };
        }
      });
      const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
      const domain = CURVE.domain || ((data, ctx, phflag) => {
        (0, utils_js_1.abool)("phflag", phflag);
        if (ctx.length || phflag)
          throw new Error("Contexts/pre-hash are not supported");
        return data;
      });
      function aCoordinate(title, n) {
        ut.aInRange("coordinate " + title, n, _0n, MASK);
      }
      function assertPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ExtendedPoint expected");
      }
      const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {
        const { ex: x, ey: y, ez: z } = p;
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? _8n : Fp.inv(z);
        const ax = modP(x * iz);
        const ay = modP(y * iz);
        const zz = modP(z * iz);
        if (is0)
          return { x: _0n, y: _1n };
        if (zz !== _1n)
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      });
      const assertValidMemo = (0, utils_js_1.memoized)((p) => {
        const { a, d } = CURVE;
        if (p.is0())
          throw new Error("bad point: ZERO");
        const { ex: X, ey: Y, ez: Z, et: T } = p;
        const X2 = modP(X * X);
        const Y2 = modP(Y * Y);
        const Z2 = modP(Z * Z);
        const Z4 = modP(Z2 * Z2);
        const aX2 = modP(X2 * a);
        const left = modP(Z2 * modP(aX2 + Y2));
        const right = modP(Z4 + modP(d * modP(X2 * Y2)));
        if (left !== right)
          throw new Error("bad point: equation left != right (1)");
        const XY = modP(X * Y);
        const ZT = modP(Z * T);
        if (XY !== ZT)
          throw new Error("bad point: equation left != right (2)");
        return true;
      });
      class Point {
        constructor(ex, ey, ez, et) {
          this.ex = ex;
          this.ey = ey;
          this.ez = ez;
          this.et = et;
          aCoordinate("x", ex);
          aCoordinate("y", ey);
          aCoordinate("z", ez);
          aCoordinate("t", et);
          Object.freeze(this);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        static fromAffine(p) {
          if (p instanceof Point)
            throw new Error("extended point not allowed");
          const { x, y } = p || {};
          aCoordinate("x", x);
          aCoordinate("y", y);
          return new Point(x, y, _1n, modP(x * y));
        }
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.ez));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          wnaf.setWindowSize(this, windowSize);
        }
        // Not required for fromHex(), which always creates valid points.
        // Could be useful for fromAffine().
        assertValidity() {
          assertValidMemo(this);
        }
        // Compare one point to another.
        equals(other) {
          assertPoint(other);
          const { ex: X1, ey: Y1, ez: Z1 } = this;
          const { ex: X2, ey: Y2, ez: Z2 } = other;
          const X1Z2 = modP(X1 * Z2);
          const X2Z1 = modP(X2 * Z1);
          const Y1Z2 = modP(Y1 * Z2);
          const Y2Z1 = modP(Y2 * Z1);
          return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        negate() {
          return new Point(modP(-this.ex), this.ey, this.ez, modP(-this.et));
        }
        // Fast algo for doubling Extended Point.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
        // Cost: 4M + 4S + 1*a + 6add + 1*2.
        double() {
          const { a } = CURVE;
          const { ex: X1, ey: Y1, ez: Z1 } = this;
          const A = modP(X1 * X1);
          const B = modP(Y1 * Y1);
          const C = modP(_2n * modP(Z1 * Z1));
          const D = modP(a * A);
          const x1y1 = X1 + Y1;
          const E = modP(modP(x1y1 * x1y1) - A - B);
          const G2 = D + B;
          const F = G2 - C;
          const H = D - B;
          const X3 = modP(E * F);
          const Y3 = modP(G2 * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G2);
          return new Point(X3, Y3, Z3, T3);
        }
        // Fast algo for adding 2 Extended Points.
        // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
        // Cost: 9M + 1*a + 1*d + 7add.
        add(other) {
          assertPoint(other);
          const { a, d } = CURVE;
          const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
          const { ex: X2, ey: Y2, ez: Z2, et: T2 } = other;
          if (a === BigInt(-1)) {
            const A2 = modP((Y1 - X1) * (Y2 + X2));
            const B2 = modP((Y1 + X1) * (Y2 - X2));
            const F2 = modP(B2 - A2);
            if (F2 === _0n)
              return this.double();
            const C2 = modP(Z1 * _2n * T2);
            const D2 = modP(T1 * _2n * Z2);
            const E2 = D2 + C2;
            const G3 = B2 + A2;
            const H2 = D2 - C2;
            const X32 = modP(E2 * F2);
            const Y32 = modP(G3 * H2);
            const T32 = modP(E2 * H2);
            const Z32 = modP(F2 * G3);
            return new Point(X32, Y32, Z32, T32);
          }
          const A = modP(X1 * X2);
          const B = modP(Y1 * Y2);
          const C = modP(T1 * d * T2);
          const D = modP(Z1 * Z2);
          const E = modP((X1 + Y1) * (X2 + Y2) - A - B);
          const F = D - C;
          const G2 = D + C;
          const H = modP(B - a * A);
          const X3 = modP(E * F);
          const Y3 = modP(G2 * H);
          const T3 = modP(E * H);
          const Z3 = modP(F * G2);
          return new Point(X3, Y3, Z3, T3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        // Constant-time multiplication.
        multiply(scalar) {
          const n = scalar;
          ut.aInRange("scalar", n, _1n, CURVE_ORDER);
          const { p, f } = this.wNAF(n);
          return Point.normalizeZ([p, f])[0];
        }
        // Non-constant-time multiplication. Uses double-and-add algorithm.
        // It's faster, but should only be used when you don't care about
        // an exposed private key e.g. sig verification.
        // Does NOT allow scalars higher than CURVE.n.
        multiplyUnsafe(scalar) {
          const n = scalar;
          ut.aInRange("scalar", n, _0n, CURVE_ORDER);
          if (n === _0n)
            return I;
          if (this.equals(I) || n === _1n)
            return this;
          if (this.equals(G))
            return this.wNAF(n).p;
          return wnaf.unsafeLadder(this, n);
        }
        // Checks if point is of small order.
        // If you add something to small order point, you will have "dirty"
        // point with torsion component.
        // Multiplies point by cofactor and checks if the result is 0.
        isSmallOrder() {
          return this.multiplyUnsafe(cofactor).is0();
        }
        // Multiplies point by curve order and checks if the result is 0.
        // Returns `false` is the point is dirty.
        isTorsionFree() {
          return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
        }
        // Converts Extended point to default (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        toAffine(iz) {
          return toAffineMemo(this, iz);
        }
        clearCofactor() {
          const { h: cofactor2 } = CURVE;
          if (cofactor2 === _1n)
            return this;
          return this.multiplyUnsafe(cofactor2);
        }
        // Converts hash string or Uint8Array to Point.
        // Uses algo from RFC8032 5.1.3.
        static fromHex(hex, zip215 = false) {
          const { d, a } = CURVE;
          const len = Fp.BYTES;
          hex = (0, utils_js_1.ensureBytes)("pointHex", hex, len);
          (0, utils_js_1.abool)("zip215", zip215);
          const normed = hex.slice();
          const lastByte = hex[len - 1];
          normed[len - 1] = lastByte & ~128;
          const y = ut.bytesToNumberLE(normed);
          const max = zip215 ? MASK : Fp.ORDER;
          ut.aInRange("pointHex.y", y, _0n, max);
          const y2 = modP(y * y);
          const u = modP(y2 - _1n);
          const v = modP(d * y2 - a);
          let { isValid, value: x } = uvRatio(u, v);
          if (!isValid)
            throw new Error("Point.fromHex: invalid y coordinate");
          const isXOdd = (x & _1n) === _1n;
          const isLastByteOdd = (lastByte & 128) !== 0;
          if (!zip215 && x === _0n && isLastByteOdd)
            throw new Error("Point.fromHex: x=0 and x_0=1");
          if (isLastByteOdd !== isXOdd)
            x = modP(-x);
          return Point.fromAffine({ x, y });
        }
        static fromPrivateKey(privKey) {
          return getExtendedPublicKey(privKey).point;
        }
        toRawBytes() {
          const { x, y } = this.toAffine();
          const bytes = ut.numberToBytesLE(y, Fp.BYTES);
          bytes[bytes.length - 1] |= x & _1n ? 128 : 0;
          return bytes;
        }
        toHex() {
          return ut.bytesToHex(this.toRawBytes());
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, _1n, modP(CURVE.Gx * CURVE.Gy));
      Point.ZERO = new Point(_0n, _1n, _1n, _0n);
      const { BASE: G, ZERO: I } = Point;
      const wnaf = (0, curve_js_1.wNAF)(Point, nByteLength * 8);
      function modN(a) {
        return (0, modular_js_1.mod)(a, CURVE_ORDER);
      }
      function modN_LE(hash) {
        return modN(ut.bytesToNumberLE(hash));
      }
      function getExtendedPublicKey(key) {
        const len = nByteLength;
        key = (0, utils_js_1.ensureBytes)("private key", key, len);
        const hashed = (0, utils_js_1.ensureBytes)("hashed private key", cHash(key), 2 * len);
        const head = adjustScalarBytes(hashed.slice(0, len));
        const prefix = hashed.slice(len, 2 * len);
        const scalar = modN_LE(head);
        const point = G.multiply(scalar);
        const pointBytes = point.toRawBytes();
        return { head, prefix, scalar, point, pointBytes };
      }
      function getPublicKey(privKey) {
        return getExtendedPublicKey(privKey).pointBytes;
      }
      function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
        const msg = ut.concatBytes(...msgs);
        return modN_LE(cHash(domain(msg, (0, utils_js_1.ensureBytes)("context", context), !!prehash)));
      }
      function sign(msg, privKey, options = {}) {
        msg = (0, utils_js_1.ensureBytes)("message", msg);
        if (prehash)
          msg = prehash(msg);
        const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
        const r = hashDomainToScalar(options.context, prefix, msg);
        const R = G.multiply(r).toRawBytes();
        const k = hashDomainToScalar(options.context, R, pointBytes, msg);
        const s = modN(r + k * scalar);
        ut.aInRange("signature.s", s, _0n, CURVE_ORDER);
        const res = ut.concatBytes(R, ut.numberToBytesLE(s, Fp.BYTES));
        return (0, utils_js_1.ensureBytes)("result", res, nByteLength * 2);
      }
      const verifyOpts = VERIFY_DEFAULT;
      function verify(sig, msg, publicKey, options = verifyOpts) {
        const { context, zip215 } = options;
        const len = Fp.BYTES;
        sig = (0, utils_js_1.ensureBytes)("signature", sig, 2 * len);
        msg = (0, utils_js_1.ensureBytes)("message", msg);
        if (zip215 !== void 0)
          (0, utils_js_1.abool)("zip215", zip215);
        if (prehash)
          msg = prehash(msg);
        const s = ut.bytesToNumberLE(sig.slice(len, 2 * len));
        let A, R, SB;
        try {
          A = Point.fromHex(publicKey, zip215);
          R = Point.fromHex(sig.slice(0, len), zip215);
          SB = G.multiplyUnsafe(s);
        } catch (error) {
          return false;
        }
        if (!zip215 && A.isSmallOrder())
          return false;
        const k = hashDomainToScalar(context, R.toRawBytes(), A.toRawBytes(), msg);
        const RkA = R.add(A.multiplyUnsafe(k));
        return RkA.subtract(SB).clearCofactor().equals(Point.ZERO);
      }
      G._setWindowSize(8);
      const utils = {
        getExtendedPublicKey,
        // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
        randomPrivateKey: () => randomBytes(Fp.BYTES),
        /**
         * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
         * values. This slows down first getPublicKey() by milliseconds (see Speed section),
         * but allows to speed-up subsequent getPublicKey() calls up to 20x.
         * @param windowSize 2, 4, 8, 16
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      return {
        CURVE,
        getPublicKey,
        sign,
        verify,
        ExtendedPoint: Point,
        utils
      };
    }
  }
});

// node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expand_message_xmd = expand_message_xmd;
    exports.expand_message_xof = expand_message_xof;
    exports.hash_to_field = hash_to_field;
    exports.isogenyMap = isogenyMap;
    exports.createHasher = createHasher;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils2();
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      (0, utils_js_1.abytes)(msg);
      anum(count);
      const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("mapToCurve: expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
          const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
  }
});

// node_modules/@noble/curves/abstract/montgomery.js
var require_montgomery = __commonJS({
  "node_modules/@noble/curves/abstract/montgomery.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.montgomery = montgomery;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils2();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function validateOpts(curve) {
      (0, utils_js_1.validateObject)(curve, {
        a: "bigint"
      }, {
        montgomeryBits: "isSafeInteger",
        nByteLength: "isSafeInteger",
        adjustScalarBytes: "function",
        domain: "function",
        powPminus2: "function",
        Gu: "bigint"
      });
      return Object.freeze({ ...curve });
    }
    function montgomery(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { P } = CURVE;
      const modP = (n) => (0, modular_js_1.mod)(n, P);
      const montgomeryBits = CURVE.montgomeryBits;
      const montgomeryBytes = Math.ceil(montgomeryBits / 8);
      const fieldLen = CURVE.nByteLength;
      const adjustScalarBytes = CURVE.adjustScalarBytes || ((bytes) => bytes);
      const powPminus2 = CURVE.powPminus2 || ((x) => (0, modular_js_1.pow)(x, P - BigInt(2), P));
      function cswap(swap, x_2, x_3) {
        const dummy = modP(swap * (x_2 - x_3));
        x_2 = modP(x_2 - dummy);
        x_3 = modP(x_3 + dummy);
        return [x_2, x_3];
      }
      const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
      function montgomeryLadder(u, scalar) {
        (0, utils_js_1.aInRange)("u", u, _0n, P);
        (0, utils_js_1.aInRange)("scalar", scalar, _0n, P);
        const k = scalar;
        const x_1 = u;
        let x_2 = _1n;
        let z_2 = _0n;
        let x_3 = u;
        let z_3 = _1n;
        let swap = _0n;
        let sw;
        for (let t = BigInt(montgomeryBits - 1); t >= _0n; t--) {
          const k_t = k >> t & _1n;
          swap ^= k_t;
          sw = cswap(swap, x_2, x_3);
          x_2 = sw[0];
          x_3 = sw[1];
          sw = cswap(swap, z_2, z_3);
          z_2 = sw[0];
          z_3 = sw[1];
          swap = k_t;
          const A = x_2 + z_2;
          const AA = modP(A * A);
          const B = x_2 - z_2;
          const BB = modP(B * B);
          const E = AA - BB;
          const C = x_3 + z_3;
          const D = x_3 - z_3;
          const DA = modP(D * A);
          const CB = modP(C * B);
          const dacb = DA + CB;
          const da_cb = DA - CB;
          x_3 = modP(dacb * dacb);
          z_3 = modP(x_1 * modP(da_cb * da_cb));
          x_2 = modP(AA * BB);
          z_2 = modP(E * (AA + modP(a24 * E)));
        }
        sw = cswap(swap, x_2, x_3);
        x_2 = sw[0];
        x_3 = sw[1];
        sw = cswap(swap, z_2, z_3);
        z_2 = sw[0];
        z_3 = sw[1];
        const z2 = powPminus2(z_2);
        return modP(x_2 * z2);
      }
      function encodeUCoordinate(u) {
        return (0, utils_js_1.numberToBytesLE)(modP(u), montgomeryBytes);
      }
      function decodeUCoordinate(uEnc) {
        const u = (0, utils_js_1.ensureBytes)("u coordinate", uEnc, montgomeryBytes);
        if (fieldLen === 32)
          u[31] &= 127;
        return (0, utils_js_1.bytesToNumberLE)(u);
      }
      function decodeScalar(n) {
        const bytes = (0, utils_js_1.ensureBytes)("scalar", n);
        const len = bytes.length;
        if (len !== montgomeryBytes && len !== fieldLen)
          throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);
        return (0, utils_js_1.bytesToNumberLE)(adjustScalarBytes(bytes));
      }
      function scalarMult(scalar, u) {
        const pointU = decodeUCoordinate(u);
        const _scalar = decodeScalar(scalar);
        const pu = montgomeryLadder(pointU, _scalar);
        if (pu === _0n)
          throw new Error("Invalid private or public key received");
        return encodeUCoordinate(pu);
      }
      const GuBytes = encodeUCoordinate(CURVE.Gu);
      function scalarMultBase(scalar) {
        return scalarMult(scalar, GuBytes);
      }
      return {
        scalarMult,
        scalarMultBase,
        getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
        getPublicKey: (privateKey) => scalarMultBase(privateKey),
        utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
        GuBytes
      };
    }
  }
});

// node_modules/@noble/curves/ed25519.js
var require_ed25519 = __commonJS({
  "node_modules/@noble/curves/ed25519.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hash_to_ristretto255 = exports.hashToRistretto255 = exports.RistrettoPoint = exports.encodeToCurve = exports.hashToCurve = exports.edwardsToMontgomery = exports.x25519 = exports.ed25519ph = exports.ed25519ctx = exports.ed25519 = exports.ED25519_TORSION_SUBGROUP = void 0;
    exports.edwardsToMontgomeryPub = edwardsToMontgomeryPub;
    exports.edwardsToMontgomeryPriv = edwardsToMontgomeryPriv;
    var sha512_1 = require_sha512();
    var utils_1 = require_utils();
    var edwards_js_1 = require_edwards();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var modular_js_1 = require_modular();
    var montgomery_js_1 = require_montgomery();
    var utils_js_1 = require_utils2();
    var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
    var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    function ed25519_pow_2_252_3(x) {
      const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
      const P = ED25519_P;
      const x2 = x * x % P;
      const b2 = x2 * x % P;
      const b4 = (0, modular_js_1.pow2)(b2, _2n, P) * b2 % P;
      const b5 = (0, modular_js_1.pow2)(b4, _1n, P) * x % P;
      const b10 = (0, modular_js_1.pow2)(b5, _5n, P) * b5 % P;
      const b20 = (0, modular_js_1.pow2)(b10, _10n, P) * b10 % P;
      const b40 = (0, modular_js_1.pow2)(b20, _20n, P) * b20 % P;
      const b80 = (0, modular_js_1.pow2)(b40, _40n, P) * b40 % P;
      const b160 = (0, modular_js_1.pow2)(b80, _80n, P) * b80 % P;
      const b240 = (0, modular_js_1.pow2)(b160, _80n, P) * b80 % P;
      const b250 = (0, modular_js_1.pow2)(b240, _10n, P) * b10 % P;
      const pow_p_5_8 = (0, modular_js_1.pow2)(b250, _2n, P) * x % P;
      return { pow_p_5_8, b2 };
    }
    function adjustScalarBytes(bytes) {
      bytes[0] &= 248;
      bytes[31] &= 127;
      bytes[31] |= 64;
      return bytes;
    }
    function uvRatio(u, v) {
      const P = ED25519_P;
      const v3 = (0, modular_js_1.mod)(v * v * v, P);
      const v7 = (0, modular_js_1.mod)(v3 * v3 * v, P);
      const pow = ed25519_pow_2_252_3(u * v7).pow_p_5_8;
      let x = (0, modular_js_1.mod)(u * v3 * pow, P);
      const vx2 = (0, modular_js_1.mod)(v * x * x, P);
      const root1 = x;
      const root2 = (0, modular_js_1.mod)(x * ED25519_SQRT_M1, P);
      const useRoot1 = vx2 === u;
      const useRoot2 = vx2 === (0, modular_js_1.mod)(-u, P);
      const noRoot = vx2 === (0, modular_js_1.mod)(-u * ED25519_SQRT_M1, P);
      if (useRoot1)
        x = root1;
      if (useRoot2 || noRoot)
        x = root2;
      if ((0, modular_js_1.isNegativeLE)(x, P))
        x = (0, modular_js_1.mod)(-x, P);
      return { isValid: useRoot1 || useRoot2, value: x };
    }
    exports.ED25519_TORSION_SUBGROUP = [
      "0100000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac037a",
      "0000000000000000000000000000000000000000000000000000000000000080",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc05",
      "ecffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7f",
      "26e8958fc2b227b045c3f489f2ef98f0d5dfac05d3c63339b13802886d53fc85",
      "0000000000000000000000000000000000000000000000000000000000000000",
      "c7176a703d4dd84fba3c0b760d10670f2a2053fa2c39ccc64ec7fd7792ac03fa"
    ];
    var Fp = (() => (0, modular_js_1.Field)(ED25519_P, void 0, true))();
    var ed25519Defaults = (() => ({
      // Param: a
      a: BigInt(-1),
      // Fp.create(-1) is proper; our way still works and is faster
      // d is equal to -121665/121666 over finite field.
      // Negative number is P - number, and division is invert(number, P)
      d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
      // Finite field p over which we'll do calculations; 2n**255n - 19n
      Fp,
      // Subgroup order: how many points curve has
      // 2n**252n + 27742317777372353535851937790883648493n;
      n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
      // Cofactor
      h: _8n,
      // Base point (x, y) aka generator point
      Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
      Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
      hash: sha512_1.sha512,
      randomBytes: utils_1.randomBytes,
      adjustScalarBytes,
      // dom2
      // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
      // Constant-time, u/v
      uvRatio
    }))();
    exports.ed25519 = (() => (0, edwards_js_1.twistedEdwards)(ed25519Defaults))();
    function ed25519_domain(data, ctx, phflag) {
      if (ctx.length > 255)
        throw new Error("Context is too big");
      return (0, utils_1.concatBytes)((0, utils_1.utf8ToBytes)("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
    }
    exports.ed25519ctx = (() => (0, edwards_js_1.twistedEdwards)({
      ...ed25519Defaults,
      domain: ed25519_domain
    }))();
    exports.ed25519ph = (() => (0, edwards_js_1.twistedEdwards)(Object.assign({}, ed25519Defaults, {
      domain: ed25519_domain,
      prehash: sha512_1.sha512
    })))();
    exports.x25519 = (() => (0, montgomery_js_1.montgomery)({
      P: ED25519_P,
      a: BigInt(486662),
      montgomeryBits: 255,
      // n is 253 bits
      nByteLength: 32,
      Gu: BigInt(9),
      powPminus2: (x) => {
        const P = ED25519_P;
        const { pow_p_5_8, b2 } = ed25519_pow_2_252_3(x);
        return (0, modular_js_1.mod)((0, modular_js_1.pow2)(pow_p_5_8, _3n, P) * b2, P);
      },
      adjustScalarBytes,
      randomBytes: utils_1.randomBytes
    }))();
    function edwardsToMontgomeryPub(edwardsPub) {
      const { y } = exports.ed25519.ExtendedPoint.fromHex(edwardsPub);
      const _1n2 = BigInt(1);
      return Fp.toBytes(Fp.create((_1n2 + y) * Fp.inv(_1n2 - y)));
    }
    exports.edwardsToMontgomery = edwardsToMontgomeryPub;
    function edwardsToMontgomeryPriv(edwardsPriv) {
      const hashed = ed25519Defaults.hash(edwardsPriv.subarray(0, 32));
      return ed25519Defaults.adjustScalarBytes(hashed).subarray(0, 32);
    }
    var ELL2_C1 = (() => (Fp.ORDER + _3n) / _8n)();
    var ELL2_C2 = (() => Fp.pow(_2n, ELL2_C1))();
    var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
    function map_to_curve_elligator2_curve25519(u) {
      const ELL2_C4 = (Fp.ORDER - _5n) / _8n;
      const ELL2_J = BigInt(486662);
      let tv1 = Fp.sqr(u);
      tv1 = Fp.mul(tv1, _2n);
      let xd = Fp.add(tv1, Fp.ONE);
      let x1n = Fp.neg(ELL2_J);
      let tv2 = Fp.sqr(xd);
      let gxd = Fp.mul(tv2, xd);
      let gx1 = Fp.mul(tv1, ELL2_J);
      gx1 = Fp.mul(gx1, x1n);
      gx1 = Fp.add(gx1, tv2);
      gx1 = Fp.mul(gx1, x1n);
      let tv3 = Fp.sqr(gxd);
      tv2 = Fp.sqr(tv3);
      tv3 = Fp.mul(tv3, gxd);
      tv3 = Fp.mul(tv3, gx1);
      tv2 = Fp.mul(tv2, tv3);
      let y11 = Fp.pow(tv2, ELL2_C4);
      y11 = Fp.mul(y11, tv3);
      let y12 = Fp.mul(y11, ELL2_C3);
      tv2 = Fp.sqr(y11);
      tv2 = Fp.mul(tv2, gxd);
      let e1 = Fp.eql(tv2, gx1);
      let y1 = Fp.cmov(y12, y11, e1);
      let x2n = Fp.mul(x1n, tv1);
      let y21 = Fp.mul(y11, u);
      y21 = Fp.mul(y21, ELL2_C2);
      let y22 = Fp.mul(y21, ELL2_C3);
      let gx2 = Fp.mul(gx1, tv1);
      tv2 = Fp.sqr(y21);
      tv2 = Fp.mul(tv2, gxd);
      let e2 = Fp.eql(tv2, gx2);
      let y2 = Fp.cmov(y22, y21, e2);
      tv2 = Fp.sqr(y1);
      tv2 = Fp.mul(tv2, gxd);
      let e3 = Fp.eql(tv2, gx1);
      let xn = Fp.cmov(x2n, x1n, e3);
      let y = Fp.cmov(y2, y1, e3);
      let e4 = Fp.isOdd(y);
      y = Fp.cmov(y, Fp.neg(y), e3 !== e4);
      return { xMn: xn, xMd: xd, yMn: y, yMd: _1n };
    }
    var ELL2_C1_EDWARDS = (() => (0, modular_js_1.FpSqrtEven)(Fp, Fp.neg(BigInt(486664))))();
    function map_to_curve_elligator2_edwards25519(u) {
      const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u);
      let xn = Fp.mul(xMn, yMd);
      xn = Fp.mul(xn, ELL2_C1_EDWARDS);
      let xd = Fp.mul(xMd, yMn);
      let yn = Fp.sub(xMn, xMd);
      let yd = Fp.add(xMn, xMd);
      let tv1 = Fp.mul(xd, yd);
      let e = Fp.eql(tv1, Fp.ZERO);
      xn = Fp.cmov(xn, Fp.ZERO, e);
      xd = Fp.cmov(xd, Fp.ONE, e);
      yn = Fp.cmov(yn, Fp.ONE, e);
      yd = Fp.cmov(yd, Fp.ONE, e);
      const inv = Fp.invertBatch([xd, yd]);
      return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn, inv[1]) };
    }
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
      DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
      encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha512_1.sha512
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
    function assertRstPoint(other) {
      if (!(other instanceof RistPoint))
        throw new Error("RistrettoPoint expected");
    }
    var SQRT_M1 = ED25519_SQRT_M1;
    var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
    var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
    var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
    var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
    var invertSqrt = (number) => uvRatio(_1n, number);
    var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    var bytes255ToNumberLE = (bytes) => exports.ed25519.CURVE.Fp.create((0, utils_js_1.bytesToNumberLE)(bytes) & MAX_255B);
    function calcElligatorRistrettoMap(r0) {
      const { d } = exports.ed25519.CURVE;
      const P = exports.ed25519.CURVE.Fp.ORDER;
      const mod = exports.ed25519.CURVE.Fp.create;
      const r = mod(SQRT_M1 * r0 * r0);
      const Ns = mod((r + _1n) * ONE_MINUS_D_SQ);
      let c = BigInt(-1);
      const D = mod((c - d * r) * mod(r + d));
      let { isValid: Ns_D_is_sq, value: s } = uvRatio(Ns, D);
      let s_ = mod(s * r0);
      if (!(0, modular_js_1.isNegativeLE)(s_, P))
        s_ = mod(-s_);
      if (!Ns_D_is_sq)
        s = s_;
      if (!Ns_D_is_sq)
        c = r;
      const Nt = mod(c * (r - _1n) * D_MINUS_ONE_SQ - D);
      const s2 = s * s;
      const W0 = mod((s + s) * D);
      const W1 = mod(Nt * SQRT_AD_MINUS_ONE);
      const W2 = mod(_1n - s2);
      const W3 = mod(_1n + s2);
      return new exports.ed25519.ExtendedPoint(mod(W0 * W3), mod(W2 * W1), mod(W1 * W3), mod(W0 * W2));
    }
    var RistPoint = class _RistPoint {
      // Private property to discourage combining ExtendedPoint + RistrettoPoint
      // Always use Ristretto encoding/decoding instead.
      constructor(ep) {
        this.ep = ep;
      }
      static fromAffine(ap) {
        return new _RistPoint(exports.ed25519.ExtendedPoint.fromAffine(ap));
      }
      /**
       * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
       * The hash-to-group operation applies Elligator twice and adds the results.
       * **Note:** this is one-way map, there is no conversion from point to hash.
       * https://ristretto.group/formulas/elligator.html
       * @param hex 64-byte output of a hash function
       */
      static hashToCurve(hex) {
        hex = (0, utils_js_1.ensureBytes)("ristrettoHash", hex, 64);
        const r1 = bytes255ToNumberLE(hex.slice(0, 32));
        const R1 = calcElligatorRistrettoMap(r1);
        const r2 = bytes255ToNumberLE(hex.slice(32, 64));
        const R2 = calcElligatorRistrettoMap(r2);
        return new _RistPoint(R1.add(R2));
      }
      /**
       * Converts ristretto-encoded string to ristretto point.
       * https://ristretto.group/formulas/decoding.html
       * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
       */
      static fromHex(hex) {
        hex = (0, utils_js_1.ensureBytes)("ristrettoHex", hex, 32);
        const { a, d } = exports.ed25519.CURVE;
        const P = exports.ed25519.CURVE.Fp.ORDER;
        const mod = exports.ed25519.CURVE.Fp.create;
        const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
        const s = bytes255ToNumberLE(hex);
        if (!(0, utils_js_1.equalBytes)((0, utils_js_1.numberToBytesLE)(s, 32), hex) || (0, modular_js_1.isNegativeLE)(s, P))
          throw new Error(emsg);
        const s2 = mod(s * s);
        const u1 = mod(_1n + a * s2);
        const u2 = mod(_1n - a * s2);
        const u1_2 = mod(u1 * u1);
        const u2_2 = mod(u2 * u2);
        const v = mod(a * d * u1_2 - u2_2);
        const { isValid, value: I } = invertSqrt(mod(v * u2_2));
        const Dx = mod(I * u2);
        const Dy = mod(I * Dx * v);
        let x = mod((s + s) * Dx);
        if ((0, modular_js_1.isNegativeLE)(x, P))
          x = mod(-x);
        const y = mod(u1 * Dy);
        const t = mod(x * y);
        if (!isValid || (0, modular_js_1.isNegativeLE)(t, P) || y === _0n)
          throw new Error(emsg);
        return new _RistPoint(new exports.ed25519.ExtendedPoint(x, y, _1n, t));
      }
      /**
       * Encodes ristretto point to Uint8Array.
       * https://ristretto.group/formulas/encoding.html
       */
      toRawBytes() {
        let { ex: x, ey: y, ez: z, et: t } = this.ep;
        const P = exports.ed25519.CURVE.Fp.ORDER;
        const mod = exports.ed25519.CURVE.Fp.create;
        const u1 = mod(mod(z + y) * mod(z - y));
        const u2 = mod(x * y);
        const u2sq = mod(u2 * u2);
        const { value: invsqrt } = invertSqrt(mod(u1 * u2sq));
        const D1 = mod(invsqrt * u1);
        const D2 = mod(invsqrt * u2);
        const zInv = mod(D1 * D2 * t);
        let D;
        if ((0, modular_js_1.isNegativeLE)(t * zInv, P)) {
          let _x = mod(y * SQRT_M1);
          let _y = mod(x * SQRT_M1);
          x = _x;
          y = _y;
          D = mod(D1 * INVSQRT_A_MINUS_D);
        } else {
          D = D2;
        }
        if ((0, modular_js_1.isNegativeLE)(x * zInv, P))
          y = mod(-y);
        let s = mod((z - y) * D);
        if ((0, modular_js_1.isNegativeLE)(s, P))
          s = mod(-s);
        return (0, utils_js_1.numberToBytesLE)(s, 32);
      }
      toHex() {
        return (0, utils_js_1.bytesToHex)(this.toRawBytes());
      }
      toString() {
        return this.toHex();
      }
      // Compare one point to another.
      equals(other) {
        assertRstPoint(other);
        const { ex: X1, ey: Y1 } = this.ep;
        const { ex: X2, ey: Y2 } = other.ep;
        const mod = exports.ed25519.CURVE.Fp.create;
        const one = mod(X1 * Y2) === mod(Y1 * X2);
        const two = mod(Y1 * Y2) === mod(X1 * X2);
        return one || two;
      }
      add(other) {
        assertRstPoint(other);
        return new _RistPoint(this.ep.add(other.ep));
      }
      subtract(other) {
        assertRstPoint(other);
        return new _RistPoint(this.ep.subtract(other.ep));
      }
      multiply(scalar) {
        return new _RistPoint(this.ep.multiply(scalar));
      }
      multiplyUnsafe(scalar) {
        return new _RistPoint(this.ep.multiplyUnsafe(scalar));
      }
      double() {
        return new _RistPoint(this.ep.double());
      }
      negate() {
        return new _RistPoint(this.ep.negate());
      }
    };
    exports.RistrettoPoint = (() => {
      if (!RistPoint.BASE)
        RistPoint.BASE = new RistPoint(exports.ed25519.ExtendedPoint.BASE);
      if (!RistPoint.ZERO)
        RistPoint.ZERO = new RistPoint(exports.ed25519.ExtendedPoint.ZERO);
      return RistPoint;
    })();
    var hashToRistretto255 = (msg, options) => {
      const d = options.DST;
      const DST = typeof d === "string" ? (0, utils_1.utf8ToBytes)(d) : d;
      const uniform_bytes = (0, hash_to_curve_js_1.expand_message_xmd)(msg, DST, 64, sha512_1.sha512);
      const P = RistPoint.hashToCurve(uniform_bytes);
      return P;
    };
    exports.hashToRistretto255 = hashToRistretto255;
    exports.hash_to_ristretto255 = exports.hashToRistretto255;
  }
});

// node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var SHA3_PI = [];
    var SHA3_ROTL = [];
    var _SHA3_IOTA = [];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        keccakP(this.state32, this.rounds);
        if (!utils_js_1.isLE)
          (0, utils_js_1.byteSwap32)(this.state32);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2Async = exports.pbkdf2 = void 0;
    var _assert_js_1 = require_assert();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils();
    function pbkdf2Init(hash, _password, _salt, _opts) {
      (0, _assert_js_1.hash)(hash);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      (0, _assert_js_1.number)(c);
      (0, _assert_js_1.number)(dkLen);
      (0, _assert_js_1.number)(asyncTick);
      if (c < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u.fill(0);
      return DK;
    }
    function pbkdf2(hash, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2 = pbkdf2;
    async function pbkdf2Async(hash, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2Async = pbkdf2Async;
  }
});

// node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils();
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var SHA256_IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 32, 8, false);
        this.A = SHA256_IV[0] | 0;
        this.B = SHA256_IV[1] | 0;
        this.C = SHA256_IV[2] | 0;
        this.D = SHA256_IV[3] | 0;
        this.E = SHA256_IV[4] | 0;
        this.F = SHA256_IV[5] | 0;
        this.G = SHA256_IV[6] | 0;
        this.H = SHA256_IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + (0, _md_js_1.Chi)(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + (0, _md_js_1.Maj)(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/@scure/bip39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
    var _assert_1 = require_assert();
    var pbkdf2_1 = require_pbkdf2();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist) => wordlist[0] === "";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
      return str.normalize("NFKD");
    }
    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function assertEntropy(entropy) {
      (0, _assert_1.bytes)(entropy, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist, strength = 128) {
      (0, _assert_1.number)(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
    }
    exports.generateMnemonic = generateMnemonic;
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist) {
      if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string")
        throw new Error("Wordlist: expected array of 2048 strings");
      wordlist.forEach((i) => {
        if (typeof i !== "string")
          throw new Error(`Wordlist: non-string element: ${i}`);
      });
      return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize(mnemonic);
      const entropy = getCoder(wordlist).decode(words);
      assertEntropy(entropy);
      return entropy;
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      assertEntropy(entropy);
      const words = getCoder(wordlist).encode(entropy);
      return words.join(isJapanese(wordlist) ? "" : " ");
    }
    exports.entropyToMnemonic = entropyToMnemonic;
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    exports.validateMnemonic = validateMnemonic;
    var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
    function mnemonicToSeed(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeed = mnemonicToSeed;
    function mnemonicToSeedSync(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeedSync = mnemonicToSeedSync;
  }
});

// node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DER = void 0;
    exports.weierstrassPoints = weierstrassPoints;
    exports.weierstrass = weierstrass;
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    var curve_js_1 = require_curve();
    var mod = require_modular();
    var ut = require_utils2();
    var utils_js_1 = require_utils2();
    function validateSigVerOpts(opts) {
      if (opts.lowS !== void 0)
        (0, utils_js_1.abool)("lowS", opts.lowS);
      if (opts.prehash !== void 0)
        (0, utils_js_1.abool)("prehash", opts.prehash);
    }
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        ut.abytes(data);
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return ut.inRange(num, _1n, CURVE.n);
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, N);
        ut.aInRange("private key", num, _1n, N);
        return num;
      }
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      const toAffineMemo = (0, utils_js_1.memoized)((p, iz) => {
        const { px: x, py: y, pz: z } = p;
        if (Fp.eql(z, Fp.ONE))
          return { x, y };
        const is0 = p.is0();
        if (iz == null)
          iz = is0 ? Fp.ONE : Fp.inv(z);
        const ax = Fp.mul(x, iz);
        const ay = Fp.mul(y, iz);
        const zz = Fp.mul(z, iz);
        if (is0)
          return { x: Fp.ZERO, y: Fp.ZERO };
        if (!Fp.eql(zz, Fp.ONE))
          throw new Error("invZ was invalid");
        return { x: ax, y: ay };
      });
      const assertValidMemo = (0, utils_js_1.memoized)((p) => {
        if (p.is0()) {
          if (CURVE.allowInfinityPoint && !Fp.is0(p.py))
            return;
          throw new Error("bad point: ZERO");
        }
        const { x, y } = p.toAffine();
        if (!Fp.isValid(x) || !Fp.isValid(y))
          throw new Error("bad point: x or y not FE");
        const left = Fp.sqr(y);
        const right = weierstrassEquation(x);
        if (!Fp.eql(left, right))
          throw new Error("bad point: equation left != right");
        if (!p.isTorsionFree())
          throw new Error("bad point: not in prime-order subgroup");
        return true;
      });
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
          Object.freeze(this);
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          wnaf.setWindowSize(this, windowSize);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          assertValidMemo(this);
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, n, Point.normalizeZ);
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(sc) {
          ut.aInRange("scalar", sc, _0n, CURVE.n);
          const I = Point.ZERO;
          if (sc === _0n)
            return I;
          if (sc === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, sc);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(sc);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          const { endo, n: N } = CURVE;
          ut.aInRange("scalar", scalar, _1n, N);
          let point, fake;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(scalar);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(scalar);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
          return toAffineMemo(this, iz);
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          (0, utils_js_1.abool)("isCompressed", isCompressed);
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          (0, utils_js_1.abool)("isCompressed", isCompressed);
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          (0, utils_js_1.abool)("isCompressed", isCompressed);
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!ut.inRange(x, _1n, Fp.ORDER))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y;
            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("Point is not on curve" + suffix);
            }
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          ut.aInRange("r", this.r, _1n, CURVE_ORDER);
          ut.aInRange("s", this.s, _1n, CURVE_ORDER);
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        ut.aInRange(`num < 2^${CURVE.nBitLength}`, num, _0n, ORDER_MASK);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        validateSigVerOpts(opts);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        validateSigVerOpts(opts);
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || ut.isBytes(sg)) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = (_a = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
  }
});

// node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHash = getHash;
    exports.createCurve = createCurve;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
  }
});

// node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils();
    var _shortw_utils_js_1 = require_shortw_utils();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils2();
    var weierstrass_js_1 = require_weierstrass();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      (0, utils_js_1.aInRange)("x", x, _1n, secp256k1P);
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    var num = utils_js_1.bytesToNumberBE;
    function challenge(...args) {
      return modN(num(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ num(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN(num(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x(num(pub));
        const r = num(sig.subarray(0, 32));
        if (!(0, utils_js_1.inRange)(r, _1n, secp256k1P))
          return false;
        const s = num(sig.subarray(32, 64));
        if (!(0, utils_js_1.inRange)(s, _1n, secp256k1N))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/@noble/hashes/ripemd160.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = void 0;
    var _md_js_1 = require_md();
    var utils_js_1 = require_utils();
    var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    var Id = new Uint8Array(new Array(16).fill(0).map((_, i) => i));
    var Pi = Id.map((i) => (9 * i + 5) % 16);
    var idxL = [Id];
    var idxR = [Pi];
    for (let i = 0; i < 4; i++)
      for (let j of [idxL, idxR])
        j.push(j[i].map((k) => Rho[k]));
    var shifts = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i) => new Uint8Array(i));
    var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
    var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
    var Kl = new Uint32Array([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr = new Uint32Array([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    function f(group, x, y, z) {
      if (group === 0)
        return x ^ y ^ z;
      else if (group === 1)
        return x & y | ~x & z;
      else if (group === 2)
        return (x | ~y) ^ z;
      else if (group === 3)
        return x & z | y & ~z;
      else
        return x ^ (y | ~z);
    }
    var R_BUF = new Uint32Array(16);
    var RIPEMD160 = class extends _md_js_1.HashMD {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          R_BUF[i] = view.getUint32(offset, true);
        let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl[group], hbr = Kr[group];
          const rl = idxL[group], rr = idxR[group];
          const sl = shiftsL[group], sr = shiftsR[group];
          for (let i = 0; i < 16; i++) {
            const tl = (0, utils_js_1.rotl)(al + f(group, bl, cl, dl) + R_BUF[rl[i]] + hbl, sl[i]) + el | 0;
            al = el, el = dl, dl = (0, utils_js_1.rotl)(cl, 10) | 0, cl = bl, bl = tl;
          }
          for (let i = 0; i < 16; i++) {
            const tr = (0, utils_js_1.rotl)(ar + f(rGroup, br, cr, dr) + R_BUF[rr[i]] + hbr, sr[i]) + er | 0;
            ar = er, er = dr, dr = (0, utils_js_1.rotl)(cr, 10) | 0, cr = br, br = tr;
          }
        }
        this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
      }
      roundClean() {
        R_BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD160;
    exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD160());
  }
});

// node_modules/@scure/bip32/node_modules/@noble/curves/abstract/utils.js
var require_utils3 = __commonJS({
  "node_modules/@scure/bip32/node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.bitMask = void 0;
    exports.isBytes = isBytes;
    exports.abytes = abytes;
    exports.bytesToHex = bytesToHex;
    exports.numberToHexUnpadded = numberToHexUnpadded;
    exports.hexToNumber = hexToNumber;
    exports.hexToBytes = hexToBytes;
    exports.bytesToNumberBE = bytesToNumberBE;
    exports.bytesToNumberLE = bytesToNumberLE;
    exports.numberToBytesBE = numberToBytesBE;
    exports.numberToBytesLE = numberToBytesLE;
    exports.numberToVarBytesBE = numberToVarBytesBE;
    exports.ensureBytes = ensureBytes;
    exports.concatBytes = concatBytes;
    exports.equalBytes = equalBytes;
    exports.utf8ToBytes = utf8ToBytes;
    exports.bitLen = bitLen;
    exports.bitGet = bitGet;
    exports.bitSet = bitSet;
    exports.createHmacDrbg = createHmacDrbg;
    exports.validateObject = validateObject;
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function abytes(item) {
      if (!isBytes(item))
        throw new Error("Uint8Array expected");
    }
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      abytes(bytes);
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    function numberToHexUnpadded(num) {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    }
    function hexToNumber(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      return BigInt(hex === "" ? "0" : `0x${hex}`);
    }
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    function bytesToNumberBE(bytes) {
      return hexToNumber(bytesToHex(bytes));
    }
    function bytesToNumberLE(bytes) {
      abytes(bytes);
      return hexToNumber(bytesToHex(Uint8Array.from(bytes).reverse()));
    }
    function numberToBytesBE(n, len) {
      return hexToBytes(n.toString(16).padStart(len * 2, "0"));
    }
    function numberToBytesLE(n, len) {
      return numberToBytesBE(n, len).reverse();
    }
    function numberToVarBytesBE(n) {
      return hexToBytes(numberToHexUnpadded(n));
    }
    function ensureBytes(title, hex, expectedLength) {
      let res;
      if (typeof hex === "string") {
        try {
          res = hexToBytes(hex);
        } catch (e) {
          throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
        }
      } else if (isBytes(hex)) {
        res = Uint8Array.from(hex);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        abytes(a);
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    function equalBytes(a, b) {
      if (a.length !== b.length)
        return false;
      let diff = 0;
      for (let i = 0; i < a.length; i++)
        diff |= a[i] ^ b[i];
      return diff === 0;
    }
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    function bitLen(n) {
      let len;
      for (len = 0; n > _0n; n >>= _1n, len += 1)
        ;
      return len;
    }
    function bitGet(n, pos) {
      return n >> BigInt(pos) & _1n;
    }
    function bitSet(n, pos, value) {
      return n | (value ? _1n : _0n) << BigInt(pos);
    }
    var bitMask = (n) => (_2n << BigInt(n - 1)) - _1n;
    exports.bitMask = bitMask;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v = u8n(hashLen);
      let k = u8n(hashLen);
      let i = 0;
      const reset = () => {
        v.fill(1);
        k.fill(0);
        i = 0;
      };
      const h = (...b) => hmacFn(k, v, ...b);
      const reseed = (seed = u8n()) => {
        k = h(u8fr([0]), seed);
        v = h();
        if (seed.length === 0)
          return;
        k = h(u8fr([1]), seed);
        v = h();
      };
      const gen = () => {
        if (i++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v = h();
          const sl = v.slice();
          out.push(sl);
          len += v.length;
        }
        return concatBytes(...out);
      };
      const genUntil = (seed, pred) => {
        reset();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset();
        return res;
      };
      return genUntil;
    }
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || isBytes(val),
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators, optValidators = {}) {
      const checkField = (fieldName, type, isOptional) => {
        const checkVal = validatorFns[type];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
        }
      };
      for (const [fieldName, type] of Object.entries(validators))
        checkField(fieldName, type, false);
      for (const [fieldName, type] of Object.entries(optValidators))
        checkField(fieldName, type, true);
      return object;
    }
  }
});

// node_modules/@scure/bip32/node_modules/@noble/curves/abstract/modular.js
var require_modular2 = __commonJS({
  "node_modules/@scure/bip32/node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isNegativeLE = void 0;
    exports.mod = mod;
    exports.pow = pow;
    exports.pow2 = pow2;
    exports.invert = invert;
    exports.tonelliShanks = tonelliShanks;
    exports.FpSqrt = FpSqrt;
    exports.validateField = validateField;
    exports.FpPow = FpPow;
    exports.FpInvertBatch = FpInvertBatch;
    exports.FpDiv = FpDiv;
    exports.FpIsSquare = FpIsSquare;
    exports.nLength = nLength;
    exports.Field = Field;
    exports.FpSqrtOdd = FpSqrtOdd;
    exports.FpSqrtEven = FpSqrtEven;
    exports.hashToPrivateScalar = hashToPrivateScalar;
    exports.getFieldBytesLength = getFieldBytesLength;
    exports.getMinHashLength = getMinHashLength;
    exports.mapHashToField = mapHashToField;
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod(a, b) {
      const result = a % b;
      return result >= _0n ? result : b + result;
    }
    function pow(num, power, modulo) {
      if (modulo <= _0n || power < _0n)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n)
        return _0n;
      let res = _1n;
      while (power > _0n) {
        if (power & _1n)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n;
      }
      return res;
    }
    function pow2(x, power, modulo) {
      let res = x;
      while (power-- > _0n) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    function invert(number, modulo) {
      if (number === _0n || modulo <= _0n) {
        throw new Error(`invert: expected positive integers, got n=${number} mod=${modulo}`);
      }
      let a = mod(number, modulo);
      let b = modulo;
      let x = _0n, y = _1n, u = _1n, v = _0n;
      while (a !== _0n) {
        const q = b / a;
        const r = b % a;
        const m = x - u * q;
        const n = y - v * q;
        b = a, a = r, x = u, y = v, u = m, v = n;
      }
      const gcd = b;
      if (gcd !== _1n)
        throw new Error("invert: does not exist");
      return mod(x, modulo);
    }
    function tonelliShanks(P) {
      const legendreC = (P - _1n) / _2n;
      let Q, S, Z;
      for (Q = P - _1n, S = 0; Q % _2n === _0n; Q /= _2n, S++)
        ;
      for (Z = _2n; Z < P && pow(Z, legendreC, P) !== P - _1n; Z++)
        ;
      if (S === 1) {
        const p1div4 = (P + _1n) / _4n;
        return function tonelliFast(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      const Q1div2 = (Q + _1n) / _2n;
      return function tonelliSlow(Fp, n) {
        if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
          throw new Error("Cannot find square root");
        let r = S;
        let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
        let x = Fp.pow(n, Q1div2);
        let b = Fp.pow(n, Q);
        while (!Fp.eql(b, Fp.ONE)) {
          if (Fp.eql(b, Fp.ZERO))
            return Fp.ZERO;
          let m = 1;
          for (let t2 = Fp.sqr(b); m < r; m++) {
            if (Fp.eql(t2, Fp.ONE))
              break;
            t2 = Fp.sqr(t2);
          }
          const ge = Fp.pow(g, _1n << BigInt(r - m - 1));
          g = Fp.sqr(ge);
          x = Fp.mul(x, ge);
          b = Fp.mul(b, g);
          r = m;
        }
        return x;
      };
    }
    function FpSqrt(P) {
      if (P % _4n === _3n) {
        const p1div4 = (P + _1n) / _4n;
        return function sqrt3mod4(Fp, n) {
          const root = Fp.pow(n, p1div4);
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp, n) {
          const n2 = Fp.mul(n, _2n);
          const v = Fp.pow(n2, c1);
          const nv = Fp.mul(n, v);
          const i = Fp.mul(Fp.mul(nv, _2n), v);
          const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
          if (!Fp.eql(Fp.sqr(root), n))
            throw new Error("Cannot find square root");
          return root;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    var isNegativeLE = (num, modulo) => (mod(num, modulo) & _1n) === _1n;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    function FpPow(f, num, power) {
      if (power < _0n)
        throw new Error("Expected power > 0");
      if (power === _0n)
        return f.ONE;
      if (power === _1n)
        return num;
      let p = f.ONE;
      let d = num;
      while (power > _0n) {
        if (power & _1n)
          p = f.mul(p, d);
        d = f.sqr(d);
        power >>= _1n;
      }
      return p;
    }
    function FpInvertBatch(f, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = acc;
        return f.mul(acc, num);
      }, f.ONE);
      const inverted = f.inv(lastMultiplied);
      nums.reduceRight((acc, num, i) => {
        if (f.is0(num))
          return acc;
        tmp[i] = f.mul(acc, tmp[i]);
        return f.mul(acc, num);
      }, inverted);
      return tmp;
    }
    function FpDiv(f, lhs, rhs) {
      return f.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f.ORDER) : f.inv(rhs));
    }
    function FpIsSquare(f) {
      const legendreConst = (f.ORDER - _1n) / _2n;
      return (x) => {
        const p = f.pow(x, legendreConst);
        return f.eql(p, f.ZERO) || f.eql(p, f.ONE);
      };
    }
    function nLength(n, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    function Field(ORDER, bitLen, isLE = false, redef = {}) {
      if (ORDER <= _0n)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n,
        ONE: _1n,
        create: (num) => mod(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n <= num && num < ORDER;
        },
        is0: (num) => num === _0n,
        isOdd: (num) => (num & _1n) === _1n,
        neg: (num) => mod(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod(num * num, ORDER),
        add: (lhs, rhs) => mod(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
        pow: (num, power) => FpPow(f, num, power),
        div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
        invertBatch: (lst) => FpInvertBatch(f, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a, b, c) => c ? b : a,
        toBytes: (num) => isLE ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f);
    }
    function FpSqrtOdd(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? root : Fp.neg(root);
    }
    function FpSqrtEven(Fp, elm) {
      if (!Fp.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root = Fp.sqrt(elm);
      return Fp.isOdd(root) ? Fp.neg(root) : root;
    }
    function hashToPrivateScalar(hash, groupOrder, isLE = false) {
      hash = (0, utils_js_1.ensureBytes)("privateHash", hash);
      const hashLen = hash.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberLE)(hash) : (0, utils_js_1.bytesToNumberBE)(hash);
      return mod(num, groupOrder - _1n) + _1n;
    }
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    function getMinHashLength(fieldOrder) {
      const length = getFieldBytesLength(fieldOrder);
      return length + Math.ceil(length / 2);
    }
    function mapHashToField(key, fieldOrder, isLE = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod(num, fieldOrder - _1n) + _1n;
      return isLE ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
  }
});

// node_modules/@scure/bip32/node_modules/@noble/curves/abstract/curve.js
var require_curve2 = __commonJS({
  "node_modules/@scure/bip32/node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wNAF = wNAF;
    exports.validateBasic = validateBasic;
    var modular_js_1 = require_modular2();
    var utils_js_1 = require_utils3();
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    function wNAF(c, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W) => {
        const windows = Math.ceil(bits / W) + 1;
        const windowSize = 2 ** (W - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n) {
          let p = c.ZERO;
          let d = elm;
          while (n > _0n) {
            if (n & _1n)
              p = p.add(d);
            d = d.double();
            n >>= _1n;
          }
          return p;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W) {
          const { windows, windowSize } = opts(W);
          const points = [];
          let p = elm;
          let base = p;
          for (let window2 = 0; window2 < windows; window2++) {
            base = p;
            points.push(base);
            for (let i = 1; i < windowSize; i++) {
              base = base.add(p);
              points.push(base);
            }
            p = base.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W, precomputes, n) {
          const { windows, windowSize } = opts(W);
          let p = c.ZERO;
          let f = c.BASE;
          const mask = BigInt(2 ** W - 1);
          const maxNumber = 2 ** W;
          const shiftBy = BigInt(W);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n & mask);
            n >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n += _1n;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f = f.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p = p.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p, f };
        },
        wNAFCached(P, precomputesMap, n, transform) {
          const W = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W);
            if (W !== 1) {
              precomputesMap.set(P, transform(comp));
            }
          }
          return this.wNAF(W, comp, n);
        }
      };
    }
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
  }
});

// node_modules/@scure/bip32/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass2 = __commonJS({
  "node_modules/@scure/bip32/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DER = void 0;
    exports.weierstrassPoints = weierstrassPoints;
    exports.weierstrass = weierstrass;
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU;
    var curve_js_1 = require_curve2();
    var mod = require_modular2();
    var ut = require_utils3();
    var utils_js_1 = require_utils3();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp, a } = opts;
      if (endo) {
        if (!Fp.eql(a, Fp.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m = "") {
          super(m);
        }
      },
      _parseInt(data) {
        const { Err: E } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex) {
        const { Err: E } = exports.DER;
        const data = typeof hex === "string" ? h2b(hex) : hex;
        ut.abytes(data);
        let l = data.length;
        if (l < 2 || data[0] != 48)
          throw new E("Invalid signature tag");
        if (data[1] !== l - 2)
          throw new E("Invalid signature: incorrect length");
        const { d: r, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E("Invalid signature: left bytes after parsing");
        return { r, s };
      },
      hexFromSig(sig) {
        const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
        const h = (num) => {
          const hex = num.toString(16);
          return hex.length & 1 ? `0${hex}` : hex;
        };
        const s = slice(h(sig.s));
        const r = slice(h(sig.r));
        const shl = s.length / 2;
        const rhl = r.length / 2;
        const sl = h(shl);
        const rl = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
      }
    };
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _3n = BigInt(3);
    var _4n = BigInt(4);
    function weierstrassPoints(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp } = CURVE;
      const toBytes = CURVE.toBytes || ((_c, point, _isCompressed) => {
        const a = point.toAffine();
        return ut.concatBytes(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
      });
      const fromBytes = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      });
      function weierstrassEquation(x) {
        const { a, b } = CURVE;
        const x2 = Fp.sqr(x);
        const x3 = Fp.mul(x2, x);
        return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
      }
      if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (ut.isBytes(key))
            key = ut.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod.mod(num, n);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point))
          throw new Error("ProjectivePoint expected");
      }
      class Point {
        constructor(px, py, pz) {
          this.px = px;
          this.py = py;
          this.pz = pz;
          if (px == null || !Fp.isValid(px))
            throw new Error("x required");
          if (py == null || !Fp.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p) {
          const { x, y } = p || {};
          if (!p || !Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("invalid affine point");
          if (p instanceof Point)
            throw new Error("projective point not allowed");
          const is0 = (i) => Fp.eql(i, Fp.ZERO);
          if (is0(x) && is0(y))
            return Point.ZERO;
          return new Point(x, y, Fp.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp.invertBatch(points.map((p) => p.pz));
          return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex) {
          const P = Point.fromAffine(fromBytes((0, utils_js_1.ensureBytes)("pointHex", hex)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x, y } = this.toAffine();
          if (!Fp.isValid(x) || !Fp.isValid(y))
            throw new Error("bad point: x or y not FE");
          const left = Fp.sqr(y);
          const right = weierstrassEquation(x);
          if (!Fp.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y } = this.toAffine();
          if (Fp.isOdd)
            return !Fp.isOdd(y);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
          const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point(this.px, Fp.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a, b } = CURVE;
          const b3 = Fp.mul(b, _3n);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          let t0 = Fp.mul(X1, X1);
          let t1 = Fp.mul(Y1, Y1);
          let t2 = Fp.mul(Z1, Z1);
          let t3 = Fp.mul(X1, Y1);
          t3 = Fp.add(t3, t3);
          Z3 = Fp.mul(X1, Z1);
          Z3 = Fp.add(Z3, Z3);
          X3 = Fp.mul(a, Z3);
          Y3 = Fp.mul(b3, t2);
          Y3 = Fp.add(X3, Y3);
          X3 = Fp.sub(t1, Y3);
          Y3 = Fp.add(t1, Y3);
          Y3 = Fp.mul(X3, Y3);
          X3 = Fp.mul(t3, X3);
          Z3 = Fp.mul(b3, Z3);
          t2 = Fp.mul(a, t2);
          t3 = Fp.sub(t0, t2);
          t3 = Fp.mul(a, t3);
          t3 = Fp.add(t3, Z3);
          Z3 = Fp.add(t0, t0);
          t0 = Fp.add(Z3, t0);
          t0 = Fp.add(t0, t2);
          t0 = Fp.mul(t0, t3);
          Y3 = Fp.add(Y3, t0);
          t2 = Fp.mul(Y1, Z1);
          t2 = Fp.add(t2, t2);
          t0 = Fp.mul(t2, t3);
          X3 = Fp.sub(X3, t0);
          Z3 = Fp.mul(t2, t1);
          Z3 = Fp.add(Z3, Z3);
          Z3 = Fp.add(Z3, Z3);
          return new Point(X3, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X2, py: Y2, pz: Z2 } = other;
          let X3 = Fp.ZERO, Y3 = Fp.ZERO, Z3 = Fp.ZERO;
          const a = CURVE.a;
          const b3 = Fp.mul(CURVE.b, _3n);
          let t0 = Fp.mul(X1, X2);
          let t1 = Fp.mul(Y1, Y2);
          let t2 = Fp.mul(Z1, Z2);
          let t3 = Fp.add(X1, Y1);
          let t4 = Fp.add(X2, Y2);
          t3 = Fp.mul(t3, t4);
          t4 = Fp.add(t0, t1);
          t3 = Fp.sub(t3, t4);
          t4 = Fp.add(X1, Z1);
          let t5 = Fp.add(X2, Z2);
          t4 = Fp.mul(t4, t5);
          t5 = Fp.add(t0, t2);
          t4 = Fp.sub(t4, t5);
          t5 = Fp.add(Y1, Z1);
          X3 = Fp.add(Y2, Z2);
          t5 = Fp.mul(t5, X3);
          X3 = Fp.add(t1, t2);
          t5 = Fp.sub(t5, X3);
          Z3 = Fp.mul(a, t4);
          X3 = Fp.mul(b3, t2);
          Z3 = Fp.add(X3, Z3);
          X3 = Fp.sub(t1, Z3);
          Z3 = Fp.add(t1, Z3);
          Y3 = Fp.mul(X3, Z3);
          t1 = Fp.add(t0, t0);
          t1 = Fp.add(t1, t0);
          t2 = Fp.mul(a, t2);
          t4 = Fp.mul(b3, t4);
          t1 = Fp.add(t1, t2);
          t2 = Fp.sub(t0, t2);
          t2 = Fp.mul(a, t2);
          t4 = Fp.add(t4, t2);
          t0 = Fp.mul(t1, t4);
          Y3 = Fp.add(Y3, t0);
          t0 = Fp.mul(t5, t4);
          X3 = Fp.mul(t3, X3);
          X3 = Fp.sub(X3, t0);
          t0 = Fp.mul(t3, t1);
          Z3 = Fp.mul(t5, Z3);
          Z3 = Fp.add(Z3, t0);
          return new Point(X3, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point.ZERO);
        }
        wNAF(n) {
          return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
            const toInv = Fp.invertBatch(comp.map((p) => p.pz));
            return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n) {
          const I = Point.ZERO;
          if (n === _0n)
            return I;
          assertGE(n);
          if (n === _1n)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n);
          let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
          let k1p = I;
          let k2p = I;
          let d = this;
          while (k1 > _0n || k2 > _0n) {
            if (k1 & _1n)
              k1p = k1p.add(d);
            if (k2 & _1n)
              k2p = k2p.add(d);
            d = d.double();
            k1 >>= _1n;
            k2 >>= _1n;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k2);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p, f } = this.wNAF(n);
            point = p;
            fake = f;
          }
          return Point.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q, a, b) {
          const G = Point.BASE;
          const mul = (P, a2) => a2 === _0n || a2 === _1n || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
          const sum = mul(this, a).add(mul(Q, b));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x, py: y, pz: z } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp.ONE : Fp.inv(z);
          const ax = Fp.mul(x, iz);
          const ay = Fp.mul(y, iz);
          const zz = Fp.mul(z, iz);
          if (is0)
            return { x: Fp.ZERO, y: Fp.ZERO };
          if (!Fp.eql(zz, Fp.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n)
            return this;
          if (clearCofactor)
            return clearCofactor(Point, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes(Point, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
      Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp.BYTES + 1;
      const uncompressedLen = 2 * Fp.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n < num && num < Fp.ORDER;
      }
      function modN(a) {
        return mod.mod(a, CURVE_ORDER);
      }
      function invN(a) {
        return mod.invert(a, CURVE_ORDER);
      }
      const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
        ...CURVE,
        toBytes(_c, point, isCompressed) {
          const a = point.toAffine();
          const x = Fp.toBytes(a.x);
          const cat = ut.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
          } else {
            return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x = ut.bytesToNumberBE(tail);
            if (!isValidFieldElement(x))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x);
            let y;
            try {
              y = Fp.sqrt(y2);
            } catch (sqrtError) {
              const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
              throw new Error("Point is not on curve" + suffix);
            }
            const isYOdd = (y & _1n) === _1n;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y = Fp.neg(y);
            return { x, y };
          } else if (len === uncompressedLen && head === 4) {
            const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
            const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
            return { x, y };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut.bytesToHex(ut.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number) {
        const HALF = CURVE_ORDER >> _1n;
        return number > HALF;
      }
      function normalizeS(s) {
        return isBiggerThanHalfOrder(s) ? modN(-s) : s;
      }
      const slcNum = (b, from, to) => ut.bytesToNumberBE(b.slice(from, to));
      class Signature {
        constructor(r, s, recovery) {
          this.r = r;
          this.s = s;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex) {
          const l = CURVE.nByteLength;
          hex = (0, utils_js_1.ensureBytes)("compactSignature", hex, l * 2);
          return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex) {
          const { r, s } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex));
          return new Signature(r, s);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r, s, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
          if (radj >= Fp.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R = Point.fromHex(prefix + numToNByteStr(radj));
          const ir = invN(radj);
          const u1 = modN(-h * ir);
          const u2 = modN(s * ir);
          const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
          if (!Q)
            throw new Error("point at infinify");
          Q.assertValidity();
          return Q;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length = mod.getMinHashLength(CURVE.n);
          return mod.mapHashToField(CURVE.randomBytes(length), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey(privateKey, isCompressed = true) {
        return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = ut.isBytes(item);
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b = Point.fromHex(publicB);
        return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k) => k in opts))
          throw new Error("sign() legacy options not supported");
        const { hash, randomBytes } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d), int2octets(h1int)];
        if (ent != null && ent !== false) {
          const e = ent === true ? randomBytes(Fp.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e));
        }
        const seed = ut.concatBytes(...seedArgs);
        const m = h1int;
        function k2sig(kBytes) {
          const k = bits2int(kBytes);
          if (!isWithinCurveOrder(k))
            return;
          const ik = invN(k);
          const q = Point.BASE.multiply(k).toAffine();
          const r = modN(q.x);
          if (r === _0n)
            return;
          const s = modN(ik * modN(m + r * d));
          if (s === _0n)
            return;
          let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n);
          let normS = s;
          if (lowS && isBiggerThanHalfOrder(s)) {
            normS = normalizeS(s);
            recovery ^= 1;
          }
          return new Signature(r, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C = CURVE;
        const drbg = ut.createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
        return drbg(seed, k2sig);
      }
      Point.BASE._setWindowSize(8);
      function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || ut.isBytes(sg)) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r2, s: s2 } = sg;
            _sig = new Signature(r2, s2);
          } else {
            throw new Error("PARSE");
          }
          P = Point.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r, s } = _sig;
        const h = bits2int_modN(msgHash);
        const is = invN(s);
        const u1 = modN(h * is);
        const u2 = modN(r * is);
        const R = (_a = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)) == null ? void 0 : _a.toAffine();
        if (!R)
          return false;
        const v = modN(R.x);
        return v === r;
      }
      return {
        CURVE,
        getPublicKey,
        getSharedSecret,
        sign,
        verify,
        ProjectivePoint: Point,
        Signature,
        utils
      };
    }
    function SWUFpSqrtRatio(Fp, Z) {
      const q = Fp.ORDER;
      let l = _0n;
      for (let o = q - _1n; o % _2n === _0n; o /= _2n)
        l += _1n;
      const c1 = l;
      const _2n_pow_c1_1 = _2n << c1 - _1n - _1n;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n;
      const c2 = (q - _1n) / _2n_pow_c1;
      const c3 = (c2 - _1n) / _2n;
      const c4 = _2n_pow_c1 - _1n;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp.pow(Z, c2);
      const c7 = Fp.pow(Z, (c2 + _1n) / _2n);
      let sqrtRatio = (u, v) => {
        let tv1 = c6;
        let tv2 = Fp.pow(v, c4);
        let tv3 = Fp.sqr(tv2);
        tv3 = Fp.mul(tv3, v);
        let tv5 = Fp.mul(u, tv3);
        tv5 = Fp.pow(tv5, c3);
        tv5 = Fp.mul(tv5, tv2);
        tv2 = Fp.mul(tv5, v);
        tv3 = Fp.mul(tv5, u);
        let tv4 = Fp.mul(tv3, tv2);
        tv5 = Fp.pow(tv4, c5);
        let isQR = Fp.eql(tv5, Fp.ONE);
        tv2 = Fp.mul(tv3, c7);
        tv5 = Fp.mul(tv4, tv1);
        tv3 = Fp.cmov(tv2, tv3, isQR);
        tv4 = Fp.cmov(tv5, tv4, isQR);
        for (let i = c1; i > _1n; i--) {
          let tv52 = i - _2n;
          tv52 = _2n << tv52 - _1n;
          let tvv5 = Fp.pow(tv4, tv52);
          const e1 = Fp.eql(tvv5, Fp.ONE);
          tv2 = Fp.mul(tv3, tv1);
          tv1 = Fp.mul(tv1, tv1);
          tvv5 = Fp.mul(tv4, tv1);
          tv3 = Fp.cmov(tv2, tv3, e1);
          tv4 = Fp.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp.ORDER % _4n === _3n) {
        const c12 = (Fp.ORDER - _3n) / _4n;
        const c22 = Fp.sqrt(Fp.neg(Z));
        sqrtRatio = (u, v) => {
          let tv1 = Fp.sqr(v);
          const tv2 = Fp.mul(u, v);
          tv1 = Fp.mul(tv1, tv2);
          let y1 = Fp.pow(tv1, c12);
          y1 = Fp.mul(y1, tv2);
          const y2 = Fp.mul(y1, c22);
          const tv3 = Fp.mul(Fp.sqr(y1), v);
          const isQR = Fp.eql(tv3, u);
          let y = Fp.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y };
        };
      }
      return sqrtRatio;
    }
    function mapToCurveSimpleSWU(Fp, opts) {
      mod.validateField(Fp);
      if (!Fp.isValid(opts.A) || !Fp.isValid(opts.B) || !Fp.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp, opts.Z);
      if (!Fp.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x, y;
        tv1 = Fp.sqr(u);
        tv1 = Fp.mul(tv1, opts.Z);
        tv2 = Fp.sqr(tv1);
        tv2 = Fp.add(tv2, tv1);
        tv3 = Fp.add(tv2, Fp.ONE);
        tv3 = Fp.mul(tv3, opts.B);
        tv4 = Fp.cmov(opts.Z, Fp.neg(tv2), !Fp.eql(tv2, Fp.ZERO));
        tv4 = Fp.mul(tv4, opts.A);
        tv2 = Fp.sqr(tv3);
        tv6 = Fp.sqr(tv4);
        tv5 = Fp.mul(tv6, opts.A);
        tv2 = Fp.add(tv2, tv5);
        tv2 = Fp.mul(tv2, tv3);
        tv6 = Fp.mul(tv6, tv4);
        tv5 = Fp.mul(tv6, opts.B);
        tv2 = Fp.add(tv2, tv5);
        x = Fp.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y = Fp.mul(tv1, u);
        y = Fp.mul(y, value);
        x = Fp.cmov(x, tv3, isValid);
        y = Fp.cmov(y, value, isValid);
        const e1 = Fp.isOdd(u) === Fp.isOdd(y);
        y = Fp.cmov(Fp.neg(y), y, e1);
        x = Fp.div(x, tv4);
        return { x, y };
      };
    }
  }
});

// node_modules/@scure/bip32/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils2 = __commonJS({
  "node_modules/@scure/bip32/node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getHash = getHash;
    exports.createCurve = createCurve;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils();
    var weierstrass_js_1 = require_weierstrass2();
    function getHash(hash) {
      return {
        hash,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    function createCurve(curveDef, defHash) {
      const create = (hash) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash) });
      return Object.freeze({ ...create(defHash), create });
    }
  }
});

// node_modules/@scure/bip32/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve2 = __commonJS({
  "node_modules/@scure/bip32/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.expand_message_xmd = expand_message_xmd;
    exports.expand_message_xof = expand_message_xof;
    exports.hash_to_field = hash_to_field;
    exports.isogenyMap = isogenyMap;
    exports.createHasher = createHasher;
    var modular_js_1 = require_modular2();
    var utils_js_1 = require_utils3();
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length) {
      if (value < 0 || value >= 1 << 8 * length) {
        throw new Error(`bad I2OSP call: value=${value} length=${length}`);
      }
      const res = Array.from({ length }).fill(0);
      for (let i = length - 1; i >= 0; i--) {
        res[i] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a, b) {
      const arr = new Uint8Array(a.length);
      for (let i = 0; i < a.length; i++) {
        arr[i] = a[i] ^ b[i];
      }
      return arr;
    }
    function anum(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255)
        DST = H((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b = new Array(ell);
      const b_0 = H((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b[0] = H((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i = 1; i <= ell; i++) {
        const args = [strxor(b_0, b[i - 1]), i2osp(i + 1, 1), DST_prime];
        b[i] = H((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    function expand_message_xof(msg, DST, lenInBytes, k, H) {
      (0, utils_js_1.abytes)(msg);
      (0, utils_js_1.abytes)(DST);
      anum(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k / 8);
        DST = H.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p, k, m, hash, expand, DST: _DST } = options;
      (0, utils_js_1.abytes)(msg);
      anum(count);
      const DST = typeof _DST === "string" ? (0, utils_js_1.utf8ToBytes)(_DST) : _DST;
      const log2p = p.toString(2).length;
      const L = Math.ceil((log2p + k) / 8);
      const len_in_bytes = count * m * L;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k, hash);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u = new Array(count);
      for (let i = 0; i < count; i++) {
        const e = new Array(m);
        for (let j = 0; j < m; j++) {
          const elm_offset = L * (j + i * m);
          const tv = prb.subarray(elm_offset, elm_offset + L);
          e[j] = (0, modular_js_1.mod)(os2ip(tv), p);
        }
        u[i] = e;
      }
      return u;
    }
    function isogenyMap(field, map) {
      const COEFF = map.map((i) => Array.from(i).reverse());
      return (x, y) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i) => field.add(field.mul(acc, x), i)));
        x = field.div(xNum, xDen);
        y = field.mul(y, field.div(yNum, yDen));
        return { x, y };
      };
    }
    function createHasher(Point, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point.fromAffine(mapToCurve(u[0]));
          const u1 = Point.fromAffine(mapToCurve(u[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point.fromAffine(mapToCurve(u[0])).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Same as encodeToCurve, but without hash
        mapToCurve(scalars) {
          if (!Array.isArray(scalars))
            throw new Error("mapToCurve: expected array of bigints");
          for (const i of scalars)
            if (typeof i !== "bigint")
              throw new Error(`mapToCurve: expected array of bigints, got ${i} in array`);
          const P = Point.fromAffine(mapToCurve(scalars)).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
  }
});

// node_modules/@scure/bip32/node_modules/@noble/curves/secp256k1.js
var require_secp256k12 = __commonJS({
  "node_modules/@scure/bip32/node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils();
    var _shortw_utils_js_1 = require_shortw_utils2();
    var hash_to_curve_js_1 = require_hash_to_curve2();
    var modular_js_1 = require_modular2();
    var utils_js_1 = require_utils3();
    var weierstrass_js_1 = require_weierstrass2();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var divNearest = (a, b) => (a + b / _2n) / b;
    function sqrtMod(y) {
      const P = secp256k1P;
      const _3n = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b2 = y * y * y % P;
      const b3 = b2 * b2 * y % P;
      const b6 = (0, modular_js_1.pow2)(b3, _3n, P) * b3 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n, P) * b3 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n, P) * b2 % P;
      const b22 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b22, _22n, P) * b22 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n, P) * b3 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b22 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b2 % P;
      const root = (0, modular_js_1.pow2)(t2, _2n, P);
      if (!Fp.eql(Fp.sqr(root), y))
        throw new Error("Cannot find square root");
      return root;
    }
    var Fp = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      // equation params: a, b
      b: BigInt(7),
      // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
      Fp,
      // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
      n: secp256k1N,
      // Curve order, total count of valid points in the field
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      // Cofactor
      lowS: true,
      // Allow only low-S signatures by default in sign() and verify()
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k) => {
          const n = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b2 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b2 * k, n);
          const c2 = divNearest(-b1 * k, n);
          let k1 = (0, modular_js_1.mod)(k - c1 * a1 - c2 * a2, n);
          let k2 = (0, modular_js_1.mod)(-c1 * b1 - c2 * b2, n);
          const k1neg = k1 > POW_2_128;
          const k2neg = k2 > POW_2_128;
          if (k1neg)
            k1 = n - k1;
          if (k2neg)
            k2 = n - k2;
          if (k1 > POW_2_128 || k2 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k);
          }
          return { k1neg, k1, k2neg, k2 };
        }
      }
    }, sha256_1.sha256);
    var _0n = BigInt(0);
    var fe = (x) => typeof x === "bigint" && _0n < x && x < secp256k1P;
    var ge = (x) => typeof x === "bigint" && _0n < x && x < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n) => (0, utils_js_1.numberToBytesBE)(n, 32);
    var modP = (x) => (0, modular_js_1.mod)(x, secp256k1P);
    var modN = (x) => (0, modular_js_1.mod)(x, secp256k1N);
    var Point = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q, a, b) => Point.BASE.multiplyAndAddUnsafe(Q, a, b);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p = Point.fromPrivateKey(d_);
      const scalar = p.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p) };
    }
    function lift_x(x) {
      if (!fe(x))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x * x);
      const c = modP(xx * x + BigInt(7));
      let y = sqrtMod(c);
      if (y % _2n !== _0n)
        y = modP(-y);
      const p = new Point(x, y, _1n);
      p.assertValidity();
      return p;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px, scalar: d } = schnorrGetExtPubKey(privateKey);
      const a = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t = numTo32b(d ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a)));
      const rand = taggedHash("BIP0340/nonce", t, px, m);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k } = schnorrGetExtPubKey(k_);
      const e = challenge(rx, px, m);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k + e * d)), 32);
      if (!schnorrVerify(sig, m, px))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe(r))
          return false;
        const s = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge(s))
          return false;
        const e = challenge(numTo32b(r), pointToBytes(P), m);
        const R = GmulAdd(P, s, modN(-e));
        if (!R || !R.hasEvenY() || R.toAffine().x !== r)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i) => i.map((j) => BigInt(j)))))();
    var mapSWU = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp.create(BigInt("-11"))
    }))();
    var htf = (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x, y } = mapSWU(Fp.create(scalars[0]));
      return isoMap(x, y);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf.hashToCurve)();
    exports.encodeToCurve = (() => htf.encodeToCurve)();
  }
});

// node_modules/@scure/bip32/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@scure/bip32/lib/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.HDKey = exports.HARDENED_OFFSET = void 0;
    var hmac_1 = require_hmac();
    var ripemd160_1 = require_ripemd160();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var _assert_1 = require_assert();
    var utils_1 = require_utils();
    var secp256k1_1 = require_secp256k12();
    var modular_1 = require_modular2();
    var base_1 = require_lib();
    var Point = secp256k1_1.secp256k1.ProjectivePoint;
    var base58check = (0, base_1.createBase58check)(sha256_1.sha256);
    function bytesToNumber(bytes) {
      return BigInt(`0x${(0, utils_1.bytesToHex)(bytes)}`);
    }
    function numberToBytes(num) {
      return (0, utils_1.hexToBytes)(num.toString(16).padStart(64, "0"));
    }
    var MASTER_SECRET = (0, utils_1.utf8ToBytes)("Bitcoin seed");
    var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
    exports.HARDENED_OFFSET = 2147483648;
    var hash160 = (data) => (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(data));
    var fromU32 = (data) => (0, utils_1.createView)(data).getUint32(0, false);
    var toU32 = (n) => {
      if (!Number.isSafeInteger(n) || n < 0 || n > 2 ** 32 - 1) {
        throw new Error(`Invalid number=${n}. Should be from 0 to 2 ** 32 - 1`);
      }
      const buf = new Uint8Array(4);
      (0, utils_1.createView)(buf).setUint32(0, n, false);
      return buf;
    };
    var HDKey = class _HDKey {
      get fingerprint() {
        if (!this.pubHash) {
          throw new Error("No publicKey set!");
        }
        return fromU32(this.pubHash);
      }
      get identifier() {
        return this.pubHash;
      }
      get pubKeyHash() {
        return this.pubHash;
      }
      get privateKey() {
        return this.privKeyBytes || null;
      }
      get publicKey() {
        return this.pubKey || null;
      }
      get privateExtendedKey() {
        const priv = this.privateKey;
        if (!priv) {
          throw new Error("No private key");
        }
        return base58check.encode(this.serialize(this.versions.private, (0, utils_1.concatBytes)(new Uint8Array([0]), priv)));
      }
      get publicExtendedKey() {
        if (!this.pubKey) {
          throw new Error("No public key");
        }
        return base58check.encode(this.serialize(this.versions.public, this.pubKey));
      }
      static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
        (0, _assert_1.bytes)(seed);
        if (8 * seed.length < 128 || 8 * seed.length > 512) {
          throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
        }
        const I = (0, hmac_1.hmac)(sha512_1.sha512, MASTER_SECRET, seed);
        return new _HDKey({
          versions,
          chainCode: I.slice(32),
          privateKey: I.slice(0, 32)
        });
      }
      static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
        const keyBuffer = base58check.decode(base58key);
        const keyView = (0, utils_1.createView)(keyBuffer);
        const version = keyView.getUint32(0, false);
        const opt = {
          versions,
          depth: keyBuffer[4],
          parentFingerprint: keyView.getUint32(5, false),
          index: keyView.getUint32(9, false),
          chainCode: keyBuffer.slice(13, 45)
        };
        const key = keyBuffer.slice(45);
        const isPriv = key[0] === 0;
        if (version !== versions[isPriv ? "private" : "public"]) {
          throw new Error("Version mismatch");
        }
        if (isPriv) {
          return new _HDKey({ ...opt, privateKey: key.slice(1) });
        } else {
          return new _HDKey({ ...opt, publicKey: key });
        }
      }
      static fromJSON(json) {
        return _HDKey.fromExtendedKey(json.xpriv);
      }
      constructor(opt) {
        this.depth = 0;
        this.index = 0;
        this.chainCode = null;
        this.parentFingerprint = 0;
        if (!opt || typeof opt !== "object") {
          throw new Error("HDKey.constructor must not be called directly");
        }
        this.versions = opt.versions || BITCOIN_VERSIONS;
        this.depth = opt.depth || 0;
        this.chainCode = opt.chainCode || null;
        this.index = opt.index || 0;
        this.parentFingerprint = opt.parentFingerprint || 0;
        if (!this.depth) {
          if (this.parentFingerprint || this.index) {
            throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
          }
        }
        if (opt.publicKey && opt.privateKey) {
          throw new Error("HDKey: publicKey and privateKey at same time.");
        }
        if (opt.privateKey) {
          if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
            throw new Error("Invalid private key");
          }
          this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
          this.privKeyBytes = numberToBytes(this.privKey);
          this.pubKey = secp256k1_1.secp256k1.getPublicKey(opt.privateKey, true);
        } else if (opt.publicKey) {
          this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
        } else {
          throw new Error("HDKey: no public or private key provided");
        }
        this.pubHash = hash160(this.pubKey);
      }
      derive(path) {
        if (!/^[mM]'?/.test(path)) {
          throw new Error('Path must start with "m" or "M"');
        }
        if (/^[mM]'?$/.test(path)) {
          return this;
        }
        const parts = path.replace(/^[mM]'?\//, "").split("/");
        let child = this;
        for (const c of parts) {
          const m = /^(\d+)('?)$/.exec(c);
          const m1 = m && m[1];
          if (!m || m.length !== 3 || typeof m1 !== "string") {
            throw new Error(`Invalid child index: ${c}`);
          }
          let idx = +m1;
          if (!Number.isSafeInteger(idx) || idx >= exports.HARDENED_OFFSET) {
            throw new Error("Invalid index");
          }
          if (m[2] === "'") {
            idx += exports.HARDENED_OFFSET;
          }
          child = child.deriveChild(idx);
        }
        return child;
      }
      deriveChild(index) {
        if (!this.pubKey || !this.chainCode) {
          throw new Error("No publicKey or chainCode set");
        }
        let data = toU32(index);
        if (index >= exports.HARDENED_OFFSET) {
          const priv = this.privateKey;
          if (!priv) {
            throw new Error("Could not derive hardened child key");
          }
          data = (0, utils_1.concatBytes)(new Uint8Array([0]), priv, data);
        } else {
          data = (0, utils_1.concatBytes)(this.pubKey, data);
        }
        const I = (0, hmac_1.hmac)(sha512_1.sha512, this.chainCode, data);
        const childTweak = bytesToNumber(I.slice(0, 32));
        const chainCode = I.slice(32);
        if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(childTweak)) {
          throw new Error("Tweak bigger than curve order");
        }
        const opt = {
          versions: this.versions,
          chainCode,
          depth: this.depth + 1,
          parentFingerprint: this.fingerprint,
          index
        };
        try {
          if (this.privateKey) {
            const added = (0, modular_1.mod)(this.privKey + childTweak, secp256k1_1.secp256k1.CURVE.n);
            if (!secp256k1_1.secp256k1.utils.isValidPrivateKey(added)) {
              throw new Error("The tweak was out of range or the resulted private key is invalid");
            }
            opt.privateKey = added;
          } else {
            const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
            if (added.equals(Point.ZERO)) {
              throw new Error("The tweak was equal to negative P, which made the result key invalid");
            }
            opt.publicKey = added.toRawBytes(true);
          }
          return new _HDKey(opt);
        } catch (err) {
          return this.deriveChild(index + 1);
        }
      }
      sign(hash) {
        if (!this.privateKey) {
          throw new Error("No privateKey set!");
        }
        (0, _assert_1.bytes)(hash, 32);
        return secp256k1_1.secp256k1.sign(hash, this.privKey).toCompactRawBytes();
      }
      verify(hash, signature) {
        (0, _assert_1.bytes)(hash, 32);
        (0, _assert_1.bytes)(signature, 64);
        if (!this.publicKey) {
          throw new Error("No publicKey set!");
        }
        let sig;
        try {
          sig = secp256k1_1.secp256k1.Signature.fromCompact(signature);
        } catch (error) {
          return false;
        }
        return secp256k1_1.secp256k1.verify(sig, hash, this.publicKey);
      }
      wipePrivateData() {
        this.privKey = void 0;
        if (this.privKeyBytes) {
          this.privKeyBytes.fill(0);
          this.privKeyBytes = void 0;
        }
        return this;
      }
      toJSON() {
        return {
          xpriv: this.privateExtendedKey,
          xpub: this.publicExtendedKey
        };
      }
      serialize(version, key) {
        if (!this.chainCode) {
          throw new Error("No chainCode set");
        }
        (0, _assert_1.bytes)(key, 33);
        return (0, utils_1.concatBytes)(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
      }
    };
    exports.HDKey = HDKey;
  }
});

// node_modules/jwt-decode/build/cjs/index.js
var require_cjs = __commonJS({
  "node_modules/jwt-decode/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.jwtDecode = exports.InvalidTokenError = void 0;
    var InvalidTokenError = class extends Error {
    };
    exports.InvalidTokenError = InvalidTokenError;
    InvalidTokenError.prototype.name = "InvalidTokenError";
    function b64DecodeUnicode(str) {
      return decodeURIComponent(atob(str).replace(/(.)/g, (m, p) => {
        let code = p.charCodeAt(0).toString(16).toUpperCase();
        if (code.length < 2) {
          code = "0" + code;
        }
        return "%" + code;
      }));
    }
    function base64UrlDecode(str) {
      let output = str.replace(/-/g, "+").replace(/_/g, "/");
      switch (output.length % 4) {
        case 0:
          break;
        case 2:
          output += "==";
          break;
        case 3:
          output += "=";
          break;
        default:
          throw new Error("base64 string is not of the correct length");
      }
      try {
        return b64DecodeUnicode(output);
      } catch (err) {
        return atob(output);
      }
    }
    function jwtDecode(token, options) {
      if (typeof token !== "string") {
        throw new InvalidTokenError("Invalid token specified: must be a string");
      }
      options || (options = {});
      const pos = options.header === true ? 0 : 1;
      const part = token.split(".")[pos];
      if (typeof part !== "string") {
        throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
      }
      let decoded;
      try {
        decoded = base64UrlDecode(part);
      } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e.message})`);
      }
      try {
        return JSON.parse(decoded);
      } catch (e) {
        throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e.message})`);
      }
    }
    exports.jwtDecode = jwtDecode;
  }
});

// node_modules/@aptos-labs/ts-sdk/dist/common/index.js
var require_common = __commonJS({
  "node_modules/@aptos-labs/ts-sdk/dist/common/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};
        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              newObj[key] = obj[key];
            }
          }
        }
        newObj.default = obj;
        return newObj;
      }
    }
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : { default: obj };
    }
    function _nullishCoalesce(lhs, rhsFn) {
      if (lhs != null) {
        return lhs;
      } else {
        return rhsFn();
      }
    }
    function _optionalChain(ops) {
      let lastAccessLHS = void 0;
      let value = ops[0];
      let i = 1;
      while (i < ops.length) {
        const op = ops[i];
        const fn2 = ops[i + 1];
        i += 2;
        if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
          return void 0;
        }
        if (op === "access" || op === "optionalAccess") {
          lastAccessLHS = value;
          value = fn2(value);
        } else if (op === "call" || op === "optionalCall") {
          value = fn2((...args) => value.call(lastAccessLHS, ...args));
          lastAccessLHS = void 0;
        }
      }
      return value;
    }
    function _optionalChainDelete(ops) {
      const result = _optionalChain(ops);
      return result == null ? true : result;
    }
    var _chunkBHKSQXUZjs = require_chunk_BHKSQXUZ();
    var xn = 255;
    var Pn = 65535;
    var xe = 4294967295;
    var Ye = 18446744073709551615n;
    var $t = 340282366920938463463374607431768211455n;
    var vn = 115792089237316195423570985008687907853269984665640564039457584007913129639935n;
    var oe = class {
      constructor(e) {
        this.buffer = new ArrayBuffer(e.length), new Uint8Array(this.buffer).set(e, 0), this.offset = 0;
      }
      read(e) {
        if (this.offset + e > this.buffer.byteLength) throw new Error("Reached to the end of buffer");
        let t = this.buffer.slice(this.offset, this.offset + e);
        return this.offset += e, t;
      }
      deserializeStr() {
        let e = this.deserializeBytes();
        return new TextDecoder().decode(e);
      }
      deserializeOptionStr() {
        return this.deserializeBool() ? this.deserializeStr() : void 0;
      }
      deserializeOption(e) {
        return this.deserializeBool() ? this.deserialize(e) : void 0;
      }
      deserializeBytes() {
        let e = this.deserializeUleb128AsU32();
        return new Uint8Array(this.read(e));
      }
      deserializeFixedBytes(e) {
        return new Uint8Array(this.read(e));
      }
      deserializeBool() {
        let e = new Uint8Array(this.read(1))[0];
        if (e !== 1 && e !== 0) throw new Error("Invalid boolean value");
        return e === 1;
      }
      deserializeU8() {
        return new DataView(this.read(1)).getUint8(0);
      }
      deserializeU16() {
        return new DataView(this.read(2)).getUint16(0, true);
      }
      deserializeU32() {
        return new DataView(this.read(4)).getUint32(0, true);
      }
      deserializeU64() {
        let e = this.deserializeU32(), t = this.deserializeU32();
        return BigInt(BigInt(t) << BigInt(32) | BigInt(e));
      }
      deserializeU128() {
        let e = this.deserializeU64(), t = this.deserializeU64();
        return BigInt(t << BigInt(64) | e);
      }
      deserializeU256() {
        let e = this.deserializeU128(), t = this.deserializeU128();
        return BigInt(t << BigInt(128) | e);
      }
      deserializeUleb128AsU32() {
        let e = BigInt(0), t = 0;
        for (; e < xe; ) {
          let r = this.deserializeU8();
          if (e |= BigInt(r & 127) << BigInt(t), !(r & 128)) break;
          t += 7;
        }
        if (e > xe) throw new Error("Overflow while parsing uleb128-encoded uint32 value");
        return Number(e);
      }
      deserialize(e) {
        return e.deserialize(this);
      }
      deserializeVector(e) {
        let t = this.deserializeUleb128AsU32(), r = new Array();
        for (let o = 0; o < t; o += 1) r.push(this.deserialize(e));
        return r;
      }
    };
    var _utils = require_utils();
    var Y = class extends Error {
      constructor(e, t) {
        super(e), this.invalidReason = t;
      }
    };
    var ia = ((r) => (r.TOO_SHORT = "too_short", r.INVALID_LENGTH = "invalid_length", r.INVALID_HEX_CHARS = "invalid_hex_chars", r))(ia || {});
    var l = exports.Hex = class n {
      constructor(e) {
        this.data = e;
      }
      toUint8Array() {
        return this.data;
      }
      toStringWithoutPrefix() {
        return _utils.bytesToHex.call(void 0, this.data);
      }
      toString() {
        return `0x${this.toStringWithoutPrefix()}`;
      }
      static fromHexString(e) {
        let t = e;
        if (t.startsWith("0x") && (t = t.slice(2)), t.length === 0) throw new Y("Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.", "too_short");
        if (t.length % 2 !== 0) throw new Y("Hex string must be an even number of hex characters.", "invalid_length");
        try {
          return new n(_utils.hexToBytes.call(void 0, t));
        } catch (r) {
          throw new Y(`Hex string contains invalid hex characters: ${_optionalChain([r, "optionalAccess", (_2) => _2.message])}`, "invalid_hex_chars");
        }
      }
      static fromHexInput(e) {
        return e instanceof Uint8Array ? new n(e) : n.fromHexString(e);
      }
      static isValid(e) {
        try {
          return n.fromHexString(e), { valid: true };
        } catch (t) {
          return { valid: false, invalidReason: _optionalChain([t, "optionalAccess", (_3) => _3.invalidReason]), invalidReasonMessage: _optionalChain([t, "optionalAccess", (_4) => _4.message]) };
        }
      }
      equals(e) {
        return this.data.length !== e.data.length ? false : this.data.every((t, r) => t === e.data[r]);
      }
    };
    var d = class {
      bcsToBytes() {
        let e = new Z();
        return this.serialize(e), e.toUint8Array();
      }
      bcsToHex() {
        let e = this.bcsToBytes();
        return l.fromHexInput(e);
      }
    };
    var Z = exports.Serializer = class {
      constructor(e = 64) {
        if (e <= 0) throw new Error("Length needs to be greater than 0");
        this.buffer = new ArrayBuffer(e), this.offset = 0;
      }
      ensureBufferWillHandleSize(e) {
        for (; this.buffer.byteLength < this.offset + e; ) {
          let t = new ArrayBuffer(this.buffer.byteLength * 2);
          new Uint8Array(t).set(new Uint8Array(this.buffer)), this.buffer = t;
        }
      }
      appendToBuffer(e) {
        this.ensureBufferWillHandleSize(e.length), new Uint8Array(this.buffer, this.offset).set(e), this.offset += e.length;
      }
      serializeWithFunction(e, t, r) {
        this.ensureBufferWillHandleSize(t);
        let o = new DataView(this.buffer, this.offset);
        e.apply(o, [0, r, true]), this.offset += t;
      }
      serializeStr(e) {
        let t = new TextEncoder();
        this.serializeBytes(t.encode(e));
      }
      serializeBytes(e) {
        this.serializeU32AsUleb128(e.length), this.appendToBuffer(e);
      }
      serializeFixedBytes(e) {
        this.appendToBuffer(e);
      }
      serializeBool(e) {
        fr(e);
        let t = e ? 1 : 0;
        this.appendToBuffer(new Uint8Array([t]));
      }
      serializeU8(e) {
        this.appendToBuffer(new Uint8Array([e]));
      }
      serializeU16(e) {
        this.serializeWithFunction(DataView.prototype.setUint16, 2, e);
      }
      serializeU32(e) {
        this.serializeWithFunction(DataView.prototype.setUint32, 4, e);
      }
      serializeU64(e) {
        let t = BigInt(e) & BigInt(xe), r = BigInt(e) >> BigInt(32);
        this.serializeU32(Number(t)), this.serializeU32(Number(r));
      }
      serializeU128(e) {
        let t = BigInt(e) & Ye, r = BigInt(e) >> BigInt(64);
        this.serializeU64(t), this.serializeU64(r);
      }
      serializeU256(e) {
        let t = BigInt(e) & $t, r = BigInt(e) >> BigInt(128);
        this.serializeU128(t), this.serializeU128(r);
      }
      serializeU32AsUleb128(e) {
        let t = e, r = [];
        for (; t >>> 7; ) r.push(t & 127 | 128), t >>>= 7;
        r.push(t), this.appendToBuffer(new Uint8Array(r));
      }
      toUint8Array() {
        return new Uint8Array(this.buffer).slice(0, this.offset);
      }
      serialize(e) {
        e.serialize(this);
      }
      serializeVector(e) {
        this.serializeU32AsUleb128(e.length), e.forEach((t) => {
          t.serialize(this);
        });
      }
      serializeOption(e) {
        let t = e !== void 0;
        this.serializeBool(t), t && e.serialize(this);
      }
      serializeOptionStr(e) {
        e === void 0 ? this.serializeU32AsUleb128(0) : (this.serializeU32AsUleb128(1), this.serializeStr(e));
      }
    };
    _chunkBHKSQXUZjs.a.call(void 0, [Ze(0, xn)], Z.prototype, "serializeU8", 1), _chunkBHKSQXUZjs.a.call(void 0, [Ze(0, Pn)], Z.prototype, "serializeU16", 1), _chunkBHKSQXUZjs.a.call(void 0, [Ze(0, xe)], Z.prototype, "serializeU32", 1), _chunkBHKSQXUZjs.a.call(void 0, [Ze(BigInt(0), Ye)], Z.prototype, "serializeU64", 1), _chunkBHKSQXUZjs.a.call(void 0, [Ze(BigInt(0), $t)], Z.prototype, "serializeU128", 1), _chunkBHKSQXUZjs.a.call(void 0, [Ze(BigInt(0), vn)], Z.prototype, "serializeU256", 1), _chunkBHKSQXUZjs.a.call(void 0, [Ze(0, xe)], Z.prototype, "serializeU32AsUleb128", 1);
    function fr(n) {
      if (typeof n != "boolean") throw new Error(`${n} is not a boolean value`);
    }
    var sa = (n, e, t) => `${n} is out of range: [${e}, ${t}]`;
    function Be(n, e, t) {
      let r = BigInt(n);
      if (r > BigInt(t) || r < BigInt(e)) throw new Error(sa(n, e, t));
    }
    function Ze(n, e) {
      return (t, r, o) => {
        let i = o.value;
        return o.value = function(a) {
          return Be(a, n, e), i.apply(this, [a]);
        }, o;
      };
    }
    var Je = class n extends d {
      constructor(e) {
        super(), this.value = l.fromHexInput(e).toUint8Array();
      }
      serialize(e) {
        e.serializeFixedBytes(this.value);
      }
      serializeForEntryFunction(e) {
        e.serialize(this);
      }
      serializeForScriptFunction(e) {
        e.serialize(this);
      }
      static deserialize(e, t) {
        let r = e.deserializeFixedBytes(t);
        return new n(r);
      }
    };
    var Cn = class n extends d {
      constructor(e) {
        super(), this.value = new Je(e);
      }
      serialize(e) {
        e.serialize(this.value);
      }
      serializeForEntryFunction(e) {
        e.serializeU32AsUleb128(this.value.value.length), e.serialize(this);
      }
      static deserialize(e, t) {
        let r = Je.deserialize(e, t);
        return new n(r.value);
      }
    };
    var En = ((o) => (o.JSON = "application/json", o.BCS = "application/x-bcs", o.BCS_SIGNED_TRANSACTION = "application/x.aptos.signed_transaction+bcs", o.BCS_VIEW_FUNCTION = "application/x.aptos.view_function+bcs", o))(En || {});
    var fo = exports.TypeTagVariants = ((g) => (g[g.Bool = 0] = "Bool", g[g.U8 = 1] = "U8", g[g.U64 = 2] = "U64", g[g.U128 = 3] = "U128", g[g.Address = 4] = "Address", g[g.Signer = 5] = "Signer", g[g.Vector = 6] = "Vector", g[g.Struct = 7] = "Struct", g[g.U16 = 8] = "U16", g[g.U32 = 9] = "U32", g[g.U256 = 10] = "U256", g[g.Reference = 254] = "Reference", g[g.Generic = 255] = "Generic", g))(fo || {});
    var Lt = exports.ScriptTransactionArgumentVariants = ((p) => (p[p.U8 = 0] = "U8", p[p.U64 = 1] = "U64", p[p.U128 = 2] = "U128", p[p.Address = 3] = "Address", p[p.U8Vector = 4] = "U8Vector", p[p.Bool = 5] = "Bool", p[p.U16 = 6] = "U16", p[p.U32 = 7] = "U32", p[p.U256 = 8] = "U256", p))(Lt || {});
    var Ao = exports.TransactionPayloadVariants = ((r) => (r[r.Script = 0] = "Script", r[r.EntryFunction = 2] = "EntryFunction", r[r.Multisig = 3] = "Multisig", r))(Ao || {});
    var ho = exports.TransactionVariants = ((t) => (t[t.MultiAgentTransaction = 0] = "MultiAgentTransaction", t[t.FeePayerTransaction = 1] = "FeePayerTransaction", t))(ho || {});
    var To = exports.TransactionAuthenticatorVariant = ((i) => (i[i.Ed25519 = 0] = "Ed25519", i[i.MultiEd25519 = 1] = "MultiEd25519", i[i.MultiAgent = 2] = "MultiAgent", i[i.FeePayer = 3] = "FeePayer", i[i.SingleSender = 4] = "SingleSender", i))(To || {});
    var bo = exports.AccountAuthenticatorVariant = ((o) => (o[o.Ed25519 = 0] = "Ed25519", o[o.MultiEd25519 = 1] = "MultiEd25519", o[o.SingleKey = 2] = "SingleKey", o[o.MultiKey = 3] = "MultiKey", o))(bo || {});
    var Ar = exports.AnyPublicKeyVariant = ((r) => (r[r.Ed25519 = 0] = "Ed25519", r[r.Secp256k1 = 1] = "Secp256k1", r[r.Keyless = 3] = "Keyless", r))(Ar || {});
    var wo = exports.AnySignatureVariant = ((r) => (r[r.Ed25519 = 0] = "Ed25519", r[r.Secp256k1 = 1] = "Secp256k1", r[r.Keyless = 3] = "Keyless", r))(wo || {});
    var hr = exports.EphemeralPublicKeyVariant = ((e) => (e[e.Ed25519 = 0] = "Ed25519", e))(hr || {});
    var So = exports.EphemeralSignatureVariant = ((e) => (e[e.Ed25519 = 0] = "Ed25519", e))(So || {});
    var Tr = exports.EphemeralCertificateVariant = ((e) => (e[e.ZkProof = 0] = "ZkProof", e))(Tr || {});
    var br = exports.ZkpVariant = ((e) => (e[e.Groth16 = 0] = "Groth16", e))(br || {});
    var wr = exports.TransactionResponseType = ((a) => (a.Pending = "pending_transaction", a.User = "user_transaction", a.Genesis = "genesis_transaction", a.BlockMetadata = "block_metadata_transaction", a.StateCheckpoint = "state_checkpoint_transaction", a.Validator = "validator_transaction", a.BlockEpilogue = "block_epilogue_transaction", a))(wr || {});
    function Su(n) {
      return n.type === "pending_transaction";
    }
    function _u(n) {
      return n.type === "user_transaction";
    }
    function xu(n) {
      return n.type === "genesis_transaction";
    }
    function Pu(n) {
      return n.type === "block_metadata_transaction";
    }
    function vu(n) {
      return n.type === "state_checkpoint_transaction";
    }
    function Cu(n) {
      return n.type === "validator_transaction";
    }
    function Eu(n) {
      return n.type === "block_epilogue_transaction";
    }
    function Iu(n) {
      return "signature" in n && n.signature === "ed25519_signature";
    }
    function Uu(n) {
      return "signature" in n && n.signature === "secp256k1_ecdsa_signature";
    }
    function Ru(n) {
      return n.type === "multi_agent_signature";
    }
    function zu(n) {
      return n.type === "fee_payer_signature";
    }
    function ku(n) {
      return n.type === "multi_ed25519_signature";
    }
    var aa = ((r) => (r.PRIVATE = "private", r.PUBLIC = "public", r.FRIEND = "friend", r))(aa || {});
    var _o = exports.MoveAbility = ((o) => (o.STORE = "store", o.DROP = "drop", o.KEY = "key", o.COPY = "copy", o))(_o || {});
    var ca = exports.RoleType = ((t) => (t.VALIDATOR = "validator", t.FULL_NODE = "full_node", t))(ca || {});
    var Ae = exports.SigningScheme = ((o) => (o[o.Ed25519 = 0] = "Ed25519", o[o.MultiEd25519 = 1] = "MultiEd25519", o[o.SingleKey = 2] = "SingleKey", o[o.MultiKey = 3] = "MultiKey", o))(Ae || {});
    var Sr = exports.SigningSchemeInput = ((t) => (t[t.Ed25519 = 0] = "Ed25519", t[t.Secp256k1Ecdsa = 2] = "Secp256k1Ecdsa", t))(Sr || {});
    var xo = exports.DeriveScheme = ((i) => (i[i.DeriveAuid = 251] = "DeriveAuid", i[i.DeriveObjectAddressFromObject = 252] = "DeriveObjectAddressFromObject", i[i.DeriveObjectAddressFromGuid = 253] = "DeriveObjectAddressFromGuid", i[i.DeriveObjectAddressFromSeed = 254] = "DeriveObjectAddressFromSeed", i[i.DeriveResourceAccountAddress = 255] = "DeriveResourceAccountAddress", i))(xo || {});
    var I = class n extends d {
      constructor(e) {
        super(), fr(e), this.value = e;
      }
      serialize(e) {
        e.serializeBool(this.value);
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        e.serializeU32AsUleb128(5), e.serialize(this);
      }
      static deserialize(e) {
        return new n(e.deserializeBool());
      }
    };
    var F = exports.U8 = class n extends d {
      constructor(e) {
        super(), Be(e, 0, xn), this.value = e;
      }
      serialize(e) {
        e.serializeU8(this.value);
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        e.serializeU32AsUleb128(0), e.serialize(this);
      }
      static deserialize(e) {
        return new n(e.deserializeU8());
      }
    };
    var de = exports.U16 = class n extends d {
      constructor(e) {
        super(), Be(e, 0, Pn), this.value = e;
      }
      serialize(e) {
        e.serializeU16(this.value);
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        e.serializeU32AsUleb128(6), e.serialize(this);
      }
      static deserialize(e) {
        return new n(e.deserializeU16());
      }
    };
    var le = exports.U32 = class n extends d {
      constructor(e) {
        super(), Be(e, 0, xe), this.value = e;
      }
      serialize(e) {
        e.serializeU32(this.value);
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        e.serializeU32AsUleb128(7), e.serialize(this);
      }
      static deserialize(e) {
        return new n(e.deserializeU32());
      }
    };
    var O = exports.U64 = class n extends d {
      constructor(e) {
        super(), Be(e, BigInt(0), Ye), this.value = BigInt(e);
      }
      serialize(e) {
        e.serializeU64(this.value);
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        e.serializeU32AsUleb128(1), e.serialize(this);
      }
      static deserialize(e) {
        return new n(e.deserializeU64());
      }
    };
    var ge = exports.U128 = class n extends d {
      constructor(e) {
        super(), Be(e, BigInt(0), $t), this.value = BigInt(e);
      }
      serialize(e) {
        e.serializeU128(this.value);
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        e.serializeU32AsUleb128(2), e.serialize(this);
      }
      static deserialize(e) {
        return new n(e.deserializeU128());
      }
    };
    var me = exports.U256 = class n extends d {
      constructor(e) {
        super(), Be(e, BigInt(0), vn), this.value = BigInt(e);
      }
      serialize(e) {
        e.serializeU256(this.value);
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        e.serializeU32AsUleb128(8), e.serialize(this);
      }
      static deserialize(e) {
        return new n(e.deserializeU256());
      }
    };
    var T = class n extends d {
      constructor(e) {
        super(), this.values = e;
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        if (!(this.values[0] instanceof F) && this.values[0] !== void 0) throw new Error("Script function arguments only accept u8 vectors");
        e.serializeU32AsUleb128(4), e.serialize(this);
      }
      static U8(e) {
        let t;
        if (Array.isArray(e) && e.length === 0) t = [];
        else if (Array.isArray(e) && typeof e[0] == "number") t = e;
        else if (typeof e == "string") {
          let r = l.fromHexInput(e);
          t = Array.from(r.toUint8Array());
        } else if (e instanceof Uint8Array) t = Array.from(e);
        else throw new Error("Invalid input type, must be an number[], Uint8Array, or hex string");
        return new n(t.map((r) => new F(r)));
      }
      static U16(e) {
        return new n(e.map((t) => new de(t)));
      }
      static U32(e) {
        return new n(e.map((t) => new le(t)));
      }
      static U64(e) {
        return new n(e.map((t) => new O(t)));
      }
      static U128(e) {
        return new n(e.map((t) => new ge(t)));
      }
      static U256(e) {
        return new n(e.map((t) => new me(t)));
      }
      static Bool(e) {
        return new n(e.map((t) => new I(t)));
      }
      static MoveString(e) {
        return new n(e.map((t) => new b(t)));
      }
      serialize(e) {
        e.serializeVector(this.values);
      }
      static deserialize(e, t) {
        let r = e.deserializeUleb128AsU32(), o = new Array();
        for (let i = 0; i < r; i += 1) o.push(t.deserialize(e));
        return new n(o);
      }
    };
    var b = exports.MoveString = class n extends d {
      constructor(e) {
        super(), this.value = e;
      }
      serialize(e) {
        e.serializeStr(this.value);
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        let t = this.bcsToBytes().slice(1);
        T.U8(t).serializeForScriptFunction(e);
      }
      static deserialize(e) {
        return new n(e.deserializeStr());
      }
    };
    var M = exports.MoveOption = class n extends d {
      constructor(e) {
        super(), typeof e < "u" && e !== null ? this.vec = new T([e]) : this.vec = new T([]), [this.value] = this.vec.values;
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      unwrap() {
        if (this.isSome()) return this.vec.values[0];
        throw new Error("Called unwrap on a MoveOption with no value");
      }
      isSome() {
        return this.vec.values.length === 1;
      }
      serialize(e) {
        this.vec.serialize(e);
      }
      static U8(e) {
        return new n(e != null ? new F(e) : void 0);
      }
      static U16(e) {
        return new n(e != null ? new de(e) : void 0);
      }
      static U32(e) {
        return new n(e != null ? new le(e) : void 0);
      }
      static U64(e) {
        return new n(e != null ? new O(e) : void 0);
      }
      static U128(e) {
        return new n(e != null ? new ge(e) : void 0);
      }
      static U256(e) {
        return new n(e != null ? new me(e) : void 0);
      }
      static Bool(e) {
        return new n(e != null ? new I(e) : void 0);
      }
      static MoveString(e) {
        return new n(e != null ? new b(e) : void 0);
      }
      static deserialize(e, t) {
        let r = T.deserialize(e, t);
        return new n(r.values[0]);
      }
    };
    var _ed25519 = require_ed25519();
    var _sha3 = require_sha3();
    var pa = ((a) => (a.INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes", a.INVALID_HEX_CHARS = "invalid_hex_chars", a.TOO_SHORT = "too_short", a.TOO_LONG = "too_long", a.LEADING_ZERO_X_REQUIRED = "leading_zero_x_required", a.LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special", a.INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES", a))(pa || {});
    var _ = class _2 extends d {
      constructor(e) {
        if (super(), e.length !== _2.LENGTH) throw new Y("AccountAddress data should be exactly 32 bytes long", "incorrect_number_of_bytes");
        this.data = e;
      }
      isSpecial() {
        return this.data.slice(0, this.data.length - 1).every((e) => e === 0) && this.data[this.data.length - 1] < 16;
      }
      toString() {
        return `0x${this.toStringWithoutPrefix()}`;
      }
      toStringWithoutPrefix() {
        let e = _utils.bytesToHex.call(void 0, this.data);
        return this.isSpecial() && (e = e[e.length - 1]), e;
      }
      toStringLong() {
        return `0x${this.toStringLongWithoutPrefix()}`;
      }
      toStringLongWithoutPrefix() {
        return _utils.bytesToHex.call(void 0, this.data);
      }
      toUint8Array() {
        return this.data;
      }
      serialize(e) {
        e.serializeFixedBytes(this.data);
      }
      serializeForEntryFunction(e) {
        let t = this.bcsToBytes();
        e.serializeBytes(t);
      }
      serializeForScriptFunction(e) {
        e.serializeU32AsUleb128(3), e.serialize(this);
      }
      static deserialize(e) {
        let t = e.deserializeFixedBytes(_2.LENGTH);
        return new _2(t);
      }
      static fromStringStrict(e) {
        if (!e.startsWith("0x")) throw new Y("Hex string must start with a leading 0x.", "leading_zero_x_required");
        let t = _2.fromString(e);
        if (e.length !== _2.LONG_STRING_LENGTH + 2) if (t.isSpecial()) {
          if (e.length !== 3) throw new Y(`The given hex string ${e} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, "INVALID_PADDING_ZEROES");
        } else throw new Y(`The given hex string ${e} is not a special address, it must be represented as 0x + 64 chars.`, "long_form_required_unless_special");
        return t;
      }
      static fromString(e) {
        let t = e;
        if (e.startsWith("0x") && (t = e.slice(2)), t.length === 0) throw new Y("Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.", "too_short");
        if (t.length > 64) throw new Y("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.", "too_long");
        let r;
        try {
          r = _utils.hexToBytes.call(void 0, t.padStart(64, "0"));
        } catch (o) {
          throw new Y(`Hex characters are invalid: ${_optionalChain([o, "optionalAccess", (_5) => _5.message])}`, "invalid_hex_chars");
        }
        return new _2(r);
      }
      static from(e) {
        return typeof e == "string" ? _2.fromString(e) : e instanceof Uint8Array ? new _2(e) : e;
      }
      static fromStrict(e) {
        return typeof e == "string" ? _2.fromStringStrict(e) : e instanceof Uint8Array ? new _2(e) : e;
      }
      static isValid(e) {
        try {
          return e.strict ? _2.fromStrict(e.input) : _2.from(e.input), { valid: true };
        } catch (t) {
          return { valid: false, invalidReason: _optionalChain([t, "optionalAccess", (_6) => _6.invalidReason]), invalidReasonMessage: _optionalChain([t, "optionalAccess", (_7) => _7.message]) };
        }
      }
      equals(e) {
        return this.data.length !== e.data.length ? false : this.data.every((t, r) => t === e.data[r]);
      }
    };
    _.LENGTH = 32, _.LONG_STRING_LENGTH = 64, _.ZERO = _.from("0x0"), _.ONE = _.from("0x1"), _.TWO = _.from("0x2"), _.THREE = _.from("0x3"), _.FOUR = _.from("0x4"), _.A = _.from("0xA");
    var u = _;
    var Ge = class Ge2 extends d {
      constructor(e) {
        super();
        let { data: t } = e, r = l.fromHexInput(t);
        if (r.toUint8Array().length !== Ge2.LENGTH) throw new Error(`Authentication Key length should be ${Ge2.LENGTH}`);
        this.data = r;
      }
      serialize(e) {
        e.serializeFixedBytes(this.data.toUint8Array());
      }
      static deserialize(e) {
        let t = e.deserializeFixedBytes(Ge2.LENGTH);
        return new Ge2({ data: t });
      }
      toString() {
        return this.data.toString();
      }
      toUint8Array() {
        return this.data.toUint8Array();
      }
      static fromSchemeAndBytes(e) {
        let { scheme: t, input: r } = e, o = l.fromHexInput(r).toUint8Array(), i = new Uint8Array([...o, t]), s = _sha3.sha3_256.create();
        s.update(i);
        let a = s.digest();
        return new Ge2({ data: a });
      }
      static fromPublicKeyAndScheme(e) {
        let { publicKey: t } = e;
        return t.authKey();
      }
      static fromPublicKey(e) {
        let { publicKey: t } = e;
        return t.authKey();
      }
      derivedAddress() {
        return new u(this.data.toUint8Array());
      }
    };
    Ge.LENGTH = 32;
    var q = Ge;
    var _hmac = require_hmac();
    var _sha512 = require_sha512();
    var _bip39 = require_bip39();
    var vo = _interopRequireWildcard(_bip39);
    var ma = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/;
    var ya = exports.APTOS_BIP44_REGEX = /^m\/44'\/637'\/[0-9]+'\/[0-9]+\/[0-9]+$/;
    var fa = exports.KeyType = ((e) => (e.ED25519 = "ed25519 seed", e))(fa || {});
    var Co = exports.HARDENED_OFFSET = 2147483648;
    function Eo(n) {
      return ya.test(n);
    }
    function Io(n) {
      return ma.test(n);
    }
    var _r = (n, e) => {
      let t = _hmac.hmac.create(_sha512.sha512, n).update(e).digest();
      return { key: t.slice(0, 32), chainCode: t.slice(32) };
    };
    var Uo = exports.CKDPriv = ({ key: n, chainCode: e }, t) => {
      let r = new ArrayBuffer(4);
      new DataView(r).setUint32(0, t);
      let o = new Uint8Array(r), i = new Uint8Array([0]), s = new Uint8Array([...i, ...n, ...o]);
      return _r(e, s);
    };
    var Aa = (n) => n.replace("'", "");
    var Ro = exports.splitPath = (n) => n.split("/").slice(1).map(Aa);
    var In = exports.mnemonicToSeed = (n) => {
      let e = n.trim().split(/\s+/).map((t) => t.toLowerCase()).join(" ");
      return vo.mnemonicToSeedSync(e);
    };
    var et = class extends d {
      toString() {
        let e = this.toUint8Array();
        return l.fromHexInput(e).toString();
      }
    };
    var ie = exports.AccountPublicKey = class extends et {
    };
    var B = class extends d {
      toString() {
        let e = this.toUint8Array();
        return l.fromHexInput(e).toString();
      }
    };
    var mt = (n) => typeof n == "string" ? l.isValid(n).valid ? n : Buffer.from(n, "utf8") : n;
    var xr = [237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16];
    function ha(n) {
      let e = n.toUint8Array().slice(32);
      for (let t = xr.length - 1; t >= 0; t -= 1) {
        if (e[t] < xr[t]) return true;
        if (e[t] > xr[t]) return false;
      }
      return false;
    }
    var Ke = class Ke2 extends ie {
      constructor(e) {
        super();
        let t = l.fromHexInput(e);
        if (t.toUint8Array().length !== Ke2.LENGTH) throw new Error(`PublicKey length should be ${Ke2.LENGTH}`);
        this.key = t;
      }
      verifySignature(e) {
        let { message: t, signature: r } = e;
        if (!ha(r)) return false;
        let o = mt(t), i = l.fromHexInput(o).toUint8Array(), s = r.toUint8Array(), a = this.key.toUint8Array();
        return _ed25519.ed25519.verify(s, i, a);
      }
      authKey() {
        return q.fromSchemeAndBytes({ scheme: 0, input: this.toUint8Array() });
      }
      toUint8Array() {
        return this.key.toUint8Array();
      }
      serialize(e) {
        e.serializeBytes(this.key.toUint8Array());
      }
      static deserialize(e) {
        let t = e.deserializeBytes();
        return new Ke2(t);
      }
      static isPublicKey(e) {
        return e instanceof Ke2;
      }
      static isInstance(e) {
        return "key" in e && _optionalChain([e, "access", (_8) => _8.key, "optionalAccess", (_9) => _9.data, "optionalAccess", (_10) => _10.length]) === Ke2.LENGTH;
      }
    };
    Ke.LENGTH = 32;
    var x = Ke;
    var se = class se2 extends d {
      constructor(e) {
        super();
        let t = l.fromHexInput(e);
        if (t.toUint8Array().length !== se2.LENGTH) throw new Error(`PrivateKey length should be ${se2.LENGTH}`);
        this.signingKey = t;
      }
      static generate() {
        let e = _ed25519.ed25519.utils.randomPrivateKey();
        return new se2(e);
      }
      static fromDerivationPath(e, t) {
        if (!Io(e)) throw new Error(`Invalid derivation path ${e}`);
        return se2.fromDerivationPathInner(e, In(t));
      }
      static fromDerivationPathInner(e, t, r = Co) {
        let { key: o, chainCode: i } = _r(se2.SLIP_0010_SEED, t), s = Ro(e).map((c) => parseInt(c, 10)), { key: a } = s.reduce((c, p) => Uo(c, p + r), { key: o, chainCode: i });
        return new se2(a);
      }
      publicKey() {
        let e = _ed25519.ed25519.getPublicKey(this.signingKey.toUint8Array());
        return new x(e);
      }
      sign(e) {
        let t = mt(e), r = l.fromHexInput(t).toUint8Array(), o = _ed25519.ed25519.sign(r, this.signingKey.toUint8Array());
        return new v(o);
      }
      toUint8Array() {
        return this.signingKey.toUint8Array();
      }
      toString() {
        return this.signingKey.toString();
      }
      serialize(e) {
        e.serializeBytes(this.toUint8Array());
      }
      static deserialize(e) {
        let t = e.deserializeBytes();
        return new se2(t);
      }
      static isPrivateKey(e) {
        return e instanceof se2;
      }
    };
    se.LENGTH = 32, se.SLIP_0010_SEED = "ed25519 seed";
    var L = se;
    var yt = class yt2 extends B {
      constructor(e) {
        super();
        let t = l.fromHexInput(e);
        if (t.toUint8Array().length !== yt2.LENGTH) throw new Error(`Signature length should be ${yt2.LENGTH}`);
        this.data = t;
      }
      toUint8Array() {
        return this.data.toUint8Array();
      }
      serialize(e) {
        e.serializeBytes(this.data.toUint8Array());
      }
      static deserialize(e) {
        let t = e.deserializeBytes();
        return new yt2(t);
      }
    };
    yt.LENGTH = 64;
    var v = yt;
    var ae = class ae2 extends ie {
      constructor(e) {
        super();
        let { publicKeys: t, threshold: r } = e;
        if (t.length > ae2.MAX_KEYS || t.length < ae2.MIN_KEYS) throw new Error(`Must have between ${ae2.MIN_KEYS} and ${ae2.MAX_KEYS} public keys, inclusive`);
        if (r < ae2.MIN_THRESHOLD || r > t.length) throw new Error(`Threshold must be between ${ae2.MIN_THRESHOLD} and ${t.length}, inclusive`);
        this.publicKeys = t, this.threshold = r;
      }
      verifySignature(e) {
        let { message: t, signature: r } = e;
        if (!(r instanceof tt)) return false;
        let o = [];
        for (let i = 0; i < 4; i += 1) for (let s = 0; s < 8; s += 1) if ((r.bitmap[i] & 1 << 7 - s) !== 0) {
          let c = i * 8 + s;
          o.push(c);
        }
        if (o.length !== r.signatures.length) throw new Error("Bitmap and signatures length mismatch");
        if (o.length < this.threshold) throw new Error("Not enough signatures");
        for (let i = 0; i < o.length; i += 1) if (!this.publicKeys[o[i]].verifySignature({ message: t, signature: r.signatures[i] })) return false;
        return true;
      }
      authKey() {
        return q.fromSchemeAndBytes({ scheme: 1, input: this.toUint8Array() });
      }
      toUint8Array() {
        let e = new Uint8Array(this.publicKeys.length * x.LENGTH + 1);
        return this.publicKeys.forEach((t, r) => {
          e.set(t.toUint8Array(), r * x.LENGTH);
        }), e[this.publicKeys.length * x.LENGTH] = this.threshold, e;
      }
      serialize(e) {
        e.serializeBytes(this.toUint8Array());
      }
      static deserialize(e) {
        let t = e.deserializeBytes(), r = t[t.length - 1], o = [];
        for (let i = 0; i < t.length - 1; i += x.LENGTH) {
          let s = i;
          o.push(new x(t.subarray(s, s + x.LENGTH)));
        }
        return new ae2({ publicKeys: o, threshold: r });
      }
    };
    ae.MAX_KEYS = 32, ae.MIN_KEYS = 2, ae.MIN_THRESHOLD = 1;
    var ft = ae;
    var J = class J2 extends B {
      constructor(e) {
        super();
        let { signatures: t, bitmap: r } = e;
        if (t.length > J2.MAX_SIGNATURES_SUPPORTED) throw new Error(`The number of signatures cannot be greater than ${J2.MAX_SIGNATURES_SUPPORTED}`);
        if (this.signatures = t, !(r instanceof Uint8Array)) this.bitmap = J2.createBitmap({ bits: r });
        else {
          if (r.length !== J2.BITMAP_LEN) throw new Error(`"bitmap" length should be ${J2.BITMAP_LEN}`);
          this.bitmap = r;
        }
      }
      toUint8Array() {
        let e = new Uint8Array(this.signatures.length * v.LENGTH + J2.BITMAP_LEN);
        return this.signatures.forEach((t, r) => {
          e.set(t.toUint8Array(), r * v.LENGTH);
        }), e.set(this.bitmap, this.signatures.length * v.LENGTH), e;
      }
      serialize(e) {
        e.serializeBytes(this.toUint8Array());
      }
      static deserialize(e) {
        let t = e.deserializeBytes(), r = t.subarray(t.length - 4), o = [];
        for (let i = 0; i < t.length - r.length; i += v.LENGTH) {
          let s = i;
          o.push(new v(t.subarray(s, s + v.LENGTH)));
        }
        return new J2({ signatures: o, bitmap: r });
      }
      static createBitmap(e) {
        let { bits: t } = e, r = 128, o = new Uint8Array([0, 0, 0, 0]), i = /* @__PURE__ */ new Set();
        return t.forEach((s, a) => {
          if (s >= J2.MAX_SIGNATURES_SUPPORTED) throw new Error(`Cannot have a signature larger than ${J2.MAX_SIGNATURES_SUPPORTED - 1}.`);
          if (i.has(s)) throw new Error("Duplicate bits detected.");
          if (a > 0 && s <= t[a - 1]) throw new Error("The bits need to be sorted in ascending order.");
          i.add(s);
          let c = Math.floor(s / 8), p = o[c];
          p |= r >> s % 8, o[c] = p;
        }), o;
      }
    };
    J.MAX_SIGNATURES_SUPPORTED = 32, J.BITMAP_LEN = 4;
    var tt = J;
    var _secp256k1 = require_secp256k1();
    var _bip32 = require_lib2();
    var Ne = class Ne2 extends et {
      constructor(e) {
        super();
        let t = l.fromHexInput(e);
        if (t.toUint8Array().length !== Ne2.LENGTH) throw new Error(`PublicKey length should be ${Ne2.LENGTH}`);
        this.key = t;
      }
      verifySignature(e) {
        let { message: t, signature: r } = e, o = mt(t), i = l.fromHexInput(o).toUint8Array(), s = _sha3.sha3_256.call(void 0, i), a = r.toUint8Array();
        return _secp256k1.secp256k1.verify(a, s, this.key.toUint8Array(), { lowS: true });
      }
      toUint8Array() {
        return this.key.toUint8Array();
      }
      serialize(e) {
        e.serializeBytes(this.key.toUint8Array());
      }
      static deserialize(e) {
        let t = e.deserializeBytes();
        return new Ne2(t);
      }
      static isPublicKey(e) {
        return e instanceof Ne2;
      }
      static isInstance(e) {
        return "key" in e && _optionalChain([e, "access", (_11) => _11.key, "optionalAccess", (_12) => _12.data, "optionalAccess", (_13) => _13.length]) === Ne2.LENGTH;
      }
    };
    Ne.LENGTH = 65;
    var Pe = Ne;
    var he = class he2 extends d {
      constructor(e) {
        super();
        let t = l.fromHexInput(e);
        if (t.toUint8Array().length !== he2.LENGTH) throw new Error(`PrivateKey length should be ${he2.LENGTH}`);
        this.key = t;
      }
      static generate() {
        let e = _secp256k1.secp256k1.utils.randomPrivateKey();
        return new he2(e);
      }
      static fromDerivationPath(e, t) {
        if (!Eo(e)) throw new Error(`Invalid derivation path ${e}`);
        return he2.fromDerivationPathInner(e, In(t));
      }
      static fromDerivationPathInner(e, t) {
        let { privateKey: r } = _bip32.HDKey.fromMasterSeed(t).derive(e);
        if (r === null) throw new Error("Invalid key");
        return new he2(r);
      }
      sign(e) {
        let t = mt(e), r = l.fromHexInput(t), o = _sha3.sha3_256.call(void 0, r.toUint8Array()), i = _secp256k1.secp256k1.sign(o, this.key.toUint8Array(), { lowS: true });
        return new ht(i.toCompactRawBytes());
      }
      publicKey() {
        let e = _secp256k1.secp256k1.getPublicKey(this.key.toUint8Array(), false);
        return new Pe(e);
      }
      toUint8Array() {
        return this.key.toUint8Array();
      }
      toString() {
        return this.key.toString();
      }
      serialize(e) {
        e.serializeBytes(this.toUint8Array());
      }
      static deserialize(e) {
        let t = e.deserializeBytes();
        return new he2(t);
      }
      static isPrivateKey(e) {
        return e instanceof he2;
      }
    };
    he.LENGTH = 32;
    var nt = he;
    var At = class At2 extends B {
      constructor(e) {
        super();
        let t = l.fromHexInput(e);
        if (t.toUint8Array().length !== At2.LENGTH) throw new Error(`Signature length should be ${At2.LENGTH}, received ${t.toUint8Array().length}`);
        this.data = t;
      }
      toUint8Array() {
        return this.data.toUint8Array();
      }
      serialize(e) {
        e.serializeBytes(this.data.toUint8Array());
      }
      static deserialize(e) {
        let t = e.deserializeBytes();
        return new At2(t);
      }
    };
    At.LENGTH = 64;
    var ht = At;
    var _jwtdecode = require_cjs();
    var rt = class n extends et {
      constructor(e) {
        super();
        let t = e.constructor.name;
        switch (t) {
          case x.name:
            this.publicKey = e, this.variant = 0;
            break;
          default:
            throw new Error(`Unsupported key for EphemeralPublicKey - ${t}`);
        }
      }
      toUint8Array() {
        return this.bcsToBytes();
      }
      verifySignature(e) {
        let { message: t, signature: r } = e;
        return this.publicKey.verifySignature({ message: t, signature: r.signature });
      }
      serialize(e) {
        if (this.publicKey instanceof x) e.serializeU32AsUleb128(0), this.publicKey.serialize(e);
        else throw new Error("Unknown public key type");
      }
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32();
        switch (t) {
          case 0:
            return new n(x.deserialize(e));
          default:
            throw new Error(`Unknown variant index for EphemeralPublicKey: ${t}`);
        }
      }
      static isPublicKey(e) {
        return e instanceof n;
      }
    };
    var Te = exports.EphemeralSignature = class n extends B {
      constructor(e) {
        super();
        let t = e.constructor.name;
        switch (t) {
          case v.name:
            this.signature = e;
            break;
          default:
            throw new Error(`Unsupported signature for EphemeralSignature - ${t}`);
        }
      }
      toUint8Array() {
        return this.bcsToBytes();
      }
      static fromHex(e) {
        let t = l.fromHexInput(e), r = new oe(t.toUint8Array());
        return n.deserialize(r);
      }
      serialize(e) {
        if (this.signature instanceof v) e.serializeU32AsUleb128(0), this.signature.serialize(e);
        else throw new Error("Unknown signature type");
      }
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32();
        switch (t) {
          case 0:
            return new n(v.deserialize(e));
          default:
            throw new Error(`Unknown variant index for EphemeralSignature: ${t}`);
        }
      }
    };
    var _poseidonlite = require_poseidon_lite();
    var Pr = [_poseidonlite.poseidon1, _poseidonlite.poseidon2, _poseidonlite.poseidon3, _poseidonlite.poseidon4, _poseidonlite.poseidon5, _poseidonlite.poseidon6, _poseidonlite.poseidon7, _poseidonlite.poseidon8, _poseidonlite.poseidon9, _poseidonlite.poseidon10, _poseidonlite.poseidon11, _poseidonlite.poseidon12, _poseidonlite.poseidon13, _poseidonlite.poseidon14, _poseidonlite.poseidon15, _poseidonlite.poseidon16];
    var Do = 31;
    var Ga = 16;
    var ko = (Ga - 1) * Do;
    function zn(n, e) {
      let r = new TextEncoder().encode(n);
      return Ka(r, e);
    }
    function Ka(n, e) {
      if (n.length > e) throw new Error(`Inputted bytes of length ${n} is longer than ${e}`);
      let t = vr(n, e);
      return Qt(t);
    }
    function Na(n, e) {
      if (n.length > e) throw new Error(`Input bytes of length ${n} is longer than ${e}`);
      let t = Ma(n, e);
      return Oa(t);
    }
    function vr(n, e) {
      if (n.length > e) throw new Error(`Input bytes of length ${n} is longer than ${e}`);
      return Na(n, e).concat([BigInt(n.length)]);
    }
    function Oa(n) {
      if (n.length > ko) throw new Error(`Can't pack more than ${ko}.  Was given ${n.length} bytes`);
      return Fa(n, Do).map((e) => Ht(e));
    }
    function Fa(n, e) {
      let t = [];
      for (let r = 0; r < n.length; r += e) t.push(n.subarray(r, r + e));
      return t;
    }
    function Ht(n) {
      let e = BigInt(0);
      for (let t = n.length - 1; t >= 0; t -= 1) e = e << BigInt(8) | BigInt(n[t]);
      return e;
    }
    function Bo(n, e) {
      let t = new Uint8Array(e);
      for (let r = 0; r < e; r += 1) t[r] = Number(n & BigInt(255)), n >>= BigInt(8);
      return t;
    }
    function Ma(n, e) {
      if (e < n.length) throw new Error("Padded size must be greater than or equal to the input array size.");
      let t = new Uint8Array(e);
      t.set(n);
      for (let r = n.length; r < e; r += 1) t[r] = 0;
      return t;
    }
    function Qt(n) {
      if (n.length > Pr.length) throw new Error(`Unable to hash input of length ${n.length}.  Max input length is ${Pr.length}`);
      return Pr[n.length - 1](n);
    }
    var kn = class extends d {
      toString() {
        let e = this.bcsToBytes();
        return l.fromHexInput(e).toString();
      }
    };
    var Tt = ((i) => (i.FULLNODE = "Fullnode", i.INDEXER = "Indexer", i.FAUCET = "Faucet", i.PEPPER = "Pepper", i.PROVER = "Prover", i))(Tt || {});
    var Go = exports.DEFAULT_MAX_GAS_AMOUNT = 2e5;
    var Ko = exports.DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;
    var Dn = exports.DEFAULT_TXN_TIMEOUT_SEC = 20;
    var ot = exports.APTOS_COIN = "0x1::aptos_coin::AptosCoin";
    var No = exports.RAW_TRANSACTION_SALT = "APTOS::RawTransaction";
    var Cr = exports.RAW_TRANSACTION_WITH_DATA_SALT = "APTOS::RawTransactionWithData";
    var ve = exports.ProcessorType = ((c) => (c.ACCOUNT_TRANSACTION_PROCESSOR = "account_transactions_processor", c.DEFAULT = "default_processor", c.EVENTS_PROCESSOR = "events_processor", c.FUNGIBLE_ASSET_PROCESSOR = "fungible_asset_processor", c.STAKE_PROCESSOR = "stake_processor", c.TOKEN_V2_PROCESSOR = "token_v2_processor", c.USER_TRANSACTION_PROCESSOR = "user_transaction_processor", c.OBJECT_PROCESSOR = "objects_processor", c))(ve || {});
    var ye = class extends Error {
      constructor({ apiType: e, aptosRequest: t, aptosResponse: r }) {
        super(qa({ apiType: e, aptosRequest: t, aptosResponse: r })), this.name = "AptosApiError", this.url = r.url, this.status = r.status, this.statusText = r.statusText, this.data = r.data, this.request = t;
      }
    };
    function qa({ apiType: n, aptosRequest: e, aptosResponse: t }) {
      let r = _optionalChain([t, "access", (_14) => _14.headers, "optionalAccess", (_15) => _15.traceparent, "optionalAccess", (_16) => _16.split, "call", (_17) => _17("-"), "access", (_18) => _18[1]]), o = r ? `(trace_id:${r}) ` : "", i = `Request to [${n}]: ${e.method} ${_nullishCoalesce(t.url, () => e.url)} ${o}failed with`;
      return n === "Indexer" && _optionalChain([t, "access", (_19) => _19.data, "optionalAccess", (_20) => _20.errors, "optionalAccess", (_21) => _21[0], "optionalAccess", (_22) => _22.message]) != null ? `${i}: ${t.data.errors[0].message}` : _optionalChain([t, "access", (_23) => _23.data, "optionalAccess", (_24) => _24.message]) != null && _optionalChain([t, "access", (_25) => _25.data, "optionalAccess", (_26) => _26.error_code]) != null ? `${i}: ${JSON.stringify(t.data)}` : `${i} status: ${t.statusText}(code:${t.status}) and response body: ${Va(t.data)}`;
    }
    var Er = 400;
    function Va(n) {
      let e = JSON.stringify(n);
      return e.length <= Er ? e : `truncated(original_size:${e.length}): ${e.slice(0, Er / 2)}...${e.slice(-Er / 2)}`;
    }
    var Oo = "1.26.0";
    var Fo = { mainnet: "https://api.mainnet.aptoslabs.com/v1/graphql", testnet: "https://api.testnet.aptoslabs.com/v1/graphql", devnet: "https://api.devnet.aptoslabs.com/v1/graphql", local: "http://127.0.0.1:8090/v1/graphql" };
    var Mo = exports.NetworkToNodeAPI = { mainnet: "https://api.mainnet.aptoslabs.com/v1", testnet: "https://api.testnet.aptoslabs.com/v1", devnet: "https://api.devnet.aptoslabs.com/v1", local: "http://127.0.0.1:8080/v1" };
    var qo = exports.NetworkToFaucetAPI = { mainnet: "https://faucet.mainnet.aptoslabs.com", testnet: "https://faucet.testnet.aptoslabs.com", devnet: "https://faucet.devnet.aptoslabs.com", local: "http://127.0.0.1:8081" };
    var Ir = exports.NetworkToPepperAPI = { mainnet: "https://api.mainnet.aptoslabs.com/keyless/pepper/v0", testnet: "https://api.testnet.aptoslabs.com/keyless/pepper/v0", devnet: "https://api.devnet.aptoslabs.com/keyless/pepper/v0", local: "https://api.devnet.aptoslabs.com/keyless/pepper/v0" };
    var Ur = exports.NetworkToProverAPI = { mainnet: "https://api.mainnet.aptoslabs.com/keyless/prover/v0", testnet: "https://api.testnet.aptoslabs.com/keyless/prover/v0", devnet: "https://api.devnet.aptoslabs.com/keyless/prover/v0", local: "https://api.devnet.aptoslabs.com/keyless/prover/v0" };
    var Rr = exports.Network = ((i) => (i.MAINNET = "mainnet", i.TESTNET = "testnet", i.DEVNET = "devnet", i.LOCAL = "local", i.CUSTOM = "custom", i))(Rr || {});
    var zr = exports.NetworkToChainId = { mainnet: 1, testnet: 2, local: 4 };
    var Id = exports.NetworkToNetworkName = { mainnet: "mainnet", testnet: "testnet", devnet: "devnet", local: "local", custom: "custom" };
    function Vo(n, e) {
      let t = e.bcsToBytes(), r = new oe(t);
      return n.deserialize(r);
    }
    async function $a(n, e) {
      let { url: t, method: r, body: o, contentType: i, params: s, overrides: a, originMethod: c } = n, p = { ..._optionalChain([a, "optionalAccess", (_27) => _27.HEADERS]), "x-aptos-client": `aptos-typescript-sdk/${Oo}`, "content-type": _nullishCoalesce(i, () => "application/json"), "x-aptos-typescript-sdk-origin-method": c };
      return _optionalChain([a, "optionalAccess", (_28) => _28.AUTH_TOKEN]) && (p.Authorization = `Bearer ${_optionalChain([a, "optionalAccess", (_29) => _29.AUTH_TOKEN])}`), _optionalChain([a, "optionalAccess", (_30) => _30.API_KEY]) && (p.Authorization = `Bearer ${_optionalChain([a, "optionalAccess", (_31) => _31.API_KEY])}`), e.provider({ url: t, method: r, body: o, params: s, headers: p, overrides: a });
    }
    async function Bn(n, e, t) {
      let { url: r, path: o } = n, i = o ? `${r}/${o}` : r, s = await $a({ ...n, url: i }, e.client), a = { status: s.status, statusText: s.statusText, data: s.data, headers: s.headers, config: s.config, request: s.request, url: i };
      if (a.status === 401) throw new ye({ apiType: t, aptosRequest: n, aptosResponse: a });
      if (t === "Indexer") {
        let c = a.data;
        if (c.errors) throw new ye({ apiType: t, aptosRequest: n, aptosResponse: a });
        a.data = c.data;
      } else if ((t === "Pepper" || t === "Prover") && a.status >= 400) throw new ye({ apiType: t, aptosRequest: n, aptosResponse: a });
      if (a.status >= 200 && a.status < 300) return a;
      throw new ye({ apiType: t, aptosRequest: n, aptosResponse: a });
    }
    async function kr(n) {
      let { aptosConfig: e, overrides: t, params: r, contentType: o, acceptType: i, path: s, originMethod: a, type: c } = n, p = e.getRequestUrl(c);
      return Bn({ url: p, method: "GET", originMethod: a, path: s, contentType: o, acceptType: i, params: r, overrides: { ...e.clientConfig, ...t } }, e, n.type);
    }
    async function V(n) {
      let { aptosConfig: e } = n;
      return kr({ ...n, type: "Fullnode", overrides: { ...e.clientConfig, ...e.fullnodeConfig, ...n.overrides, HEADERS: { ..._optionalChain([e, "access", (_32) => _32.clientConfig, "optionalAccess", (_33) => _33.HEADERS]), ..._optionalChain([e, "access", (_34) => _34.fullnodeConfig, "optionalAccess", (_35) => _35.HEADERS]) } } });
    }
    async function Yd(n) {
      return kr({ ...n, type: "Pepper" });
    }
    async function bt(n) {
      let e = [], t, r = n.params;
      do {
        let o = await kr({ type: "Fullnode", aptosConfig: n.aptosConfig, originMethod: n.originMethod, path: n.path, params: r, overrides: n.overrides });
        t = o.headers["x-aptos-cursor"], delete o.headers, e.push(...o.data), r.start = t;
      } while (t != null);
      return e;
    }
    async function Wt(n) {
      let { type: e, originMethod: t, path: r, body: o, acceptType: i, contentType: s, params: a, aptosConfig: c, overrides: p } = n, y = c.getRequestUrl(e);
      return Bn({ url: y, method: "POST", originMethod: t, path: r, body: o, contentType: s, acceptType: i, params: a, overrides: p }, c, n.type);
    }
    async function Oe(n) {
      let { aptosConfig: e } = n;
      return Wt({ ...n, type: "Fullnode", overrides: { ...e.clientConfig, ...e.fullnodeConfig, ...n.overrides, HEADERS: { ..._optionalChain([e, "access", (_36) => _36.clientConfig, "optionalAccess", (_37) => _37.HEADERS]), ..._optionalChain([e, "access", (_38) => _38.fullnodeConfig, "optionalAccess", (_39) => _39.HEADERS]) } } });
    }
    async function $o(n) {
      let { aptosConfig: e } = n;
      return Wt({ ...n, type: "Indexer", overrides: { ...e.clientConfig, ...e.indexerConfig, ...n.overrides, HEADERS: { ..._optionalChain([e, "access", (_40) => _40.clientConfig, "optionalAccess", (_41) => _41.HEADERS]), ..._optionalChain([e, "access", (_42) => _42.indexerConfig, "optionalAccess", (_43) => _43.HEADERS]) } } });
    }
    async function Lo(n) {
      let { aptosConfig: e } = n, t = { ...e, clientConfig: { ...e.clientConfig } };
      return _optionalChainDelete([t, "optionalAccess", (_44) => _44.clientConfig, "optionalAccess", (_45) => delete _45.API_KEY]), Wt({ ...n, type: "Faucet", overrides: { ...t.clientConfig, ...t.faucetConfig, ...n.overrides, HEADERS: { ..._optionalChain([t, "access", (_46) => _46.clientConfig, "optionalAccess", (_47) => _47.HEADERS]), ..._optionalChain([t, "access", (_48) => _48.faucetConfig, "optionalAccess", (_49) => _49.HEADERS]) } } });
    }
    async function Ho(n) {
      return Wt({ ...n, type: "Pepper" });
    }
    async function Qo(n) {
      return Wt({ ...n, type: "Prover" });
    }
    var Dr = /* @__PURE__ */ new Map();
    function Fe(n, e, t) {
      return async (...r) => {
        if (Dr.has(e)) {
          let { value: i, timestamp: s } = Dr.get(e);
          if (t === void 0 || Date.now() - s <= t) return i;
        }
        let o = await n(...r);
        return Dr.set(e, { value: o, timestamp: Date.now() }), o;
      };
    }
    var Cl = 1e7;
    var Ha = exports.MAX_AUD_VAL_BYTES = 120;
    var Qa = exports.MAX_UID_KEY_BYTES = 30;
    var Wa = exports.MAX_UID_VAL_BYTES = 330;
    var El = exports.MAX_ISS_VAL_BYTES = 120;
    var Il = exports.MAX_EXTRA_FIELD_BYTES = 350;
    var Ul = exports.MAX_JWT_HEADER_B64_BYTES = 300;
    var Rl = exports.MAX_COMMITED_EPK_BYTES = 93;
    var be = class be2 extends ie {
      constructor(e, t) {
        super();
        let r = l.fromHexInput(t).toUint8Array();
        if (r.length !== be2.ID_COMMITMENT_LENGTH) throw new Error(`Id Commitment length in bytes should be ${be2.ID_COMMITMENT_LENGTH}`);
        this.iss = e, this.idCommitment = r;
      }
      authKey() {
        let e = new Z();
        return e.serializeU32AsUleb128(3), e.serializeFixedBytes(this.bcsToBytes()), q.fromSchemeAndBytes({ scheme: 2, input: e.toUint8Array() });
      }
      toUint8Array() {
        return this.bcsToBytes();
      }
      toString() {
        return l.fromHexInput(this.toUint8Array()).toString();
      }
      verifySignature(e) {
        throw new Error("Not yet implemented");
      }
      serialize(e) {
        e.serializeStr(this.iss), e.serializeBytes(this.idCommitment);
      }
      static deserialize(e) {
        let t = e.deserializeStr(), r = e.deserializeBytes();
        return new be2(t, r);
      }
      static load(e) {
        let t = e.deserializeStr(), r = e.deserializeBytes();
        return new be2(t, r);
      }
      static isPublicKey(e) {
        return e instanceof be2;
      }
      static create(e) {
        return Wo(e), new be2(e.iss, Wo(e));
      }
      static fromJwtAndPepper(e) {
        let { jwt: t, pepper: r, uidKey: o = "sub" } = e, i = _jwtdecode.jwtDecode.call(void 0, t), s = i.iss;
        if (typeof i.aud != "string") throw new Error("aud was not found or an array of values");
        let a = i.aud, c = i[o];
        return be2.create({ iss: s, uidKey: o, uidVal: c, aud: a, pepper: r });
      }
      static isInstance(e) {
        return "iss" in e && typeof e.iss == "string" && "idCommitment" in e && e.idCommitment instanceof Uint8Array;
      }
    };
    be.ID_COMMITMENT_LENGTH = 32;
    var ee = be;
    function Wo(n) {
      let { uidKey: e, uidVal: t, aud: r, pepper: o } = n, i = [Ht(l.fromHexInput(o).toUint8Array()), zn(r, Ha), zn(t, Wa), zn(e, Qa)];
      return Bo(Qt(i), ee.ID_COMMITMENT_LENGTH);
    }
    var Ee = class n extends B {
      constructor(e) {
        super();
        let { jwtHeader: t, ephemeralCertificate: r, expiryDateSecs: o, ephemeralPublicKey: i, ephemeralSignature: s } = e;
        this.jwtHeader = t, this.ephemeralCertificate = r, this.expiryDateSecs = o, this.ephemeralPublicKey = i, this.ephemeralSignature = s;
      }
      toUint8Array() {
        return this.bcsToBytes();
      }
      serialize(e) {
        this.ephemeralCertificate.serialize(e), e.serializeStr(this.jwtHeader), e.serializeU64(this.expiryDateSecs), this.ephemeralPublicKey.serialize(e), this.ephemeralSignature.serialize(e);
      }
      static deserialize(e) {
        let t = wt.deserialize(e), r = e.deserializeStr(), o = e.deserializeU64(), i = rt.deserialize(e), s = Te.deserialize(e);
        return new n({ jwtHeader: r, expiryDateSecs: Number(o), ephemeralCertificate: t, ephemeralPublicKey: i, ephemeralSignature: s });
      }
      static getSimulationSignature() {
        return new n({ jwtHeader: "{}", ephemeralCertificate: new wt(new Ie({ proof: new _t(new St({ a: new Uint8Array(32), b: new Uint8Array(64), c: new Uint8Array(32) }), 0), expHorizonSecs: 0 }), 0), expiryDateSecs: 0, ephemeralPublicKey: new rt(new x(new Uint8Array(32))), ephemeralSignature: new Te(new v(new Uint8Array(64))) });
      }
      static isSignature(e) {
        return e instanceof n;
      }
    };
    var wt = exports.EphemeralCertificate = class n extends B {
      constructor(e, t) {
        super(), this.signature = e, this.variant = t;
      }
      toUint8Array() {
        return this.signature.toUint8Array();
      }
      serialize(e) {
        e.serializeU32AsUleb128(this.variant), this.signature.serialize(e);
      }
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32();
        switch (t) {
          case 0:
            return new n(Ie.deserialize(e), t);
          default:
            throw new Error(`Unknown variant index for EphemeralCertificate: ${t}`);
        }
      }
    };
    var Ce = class n extends d {
      constructor(e) {
        if (super(), this.data = l.fromHexInput(e).toUint8Array(), this.data.length !== 32) throw new Error("Input needs to be 32 bytes");
      }
      serialize(e) {
        e.serializeFixedBytes(this.data);
      }
      static deserialize(e) {
        let t = e.deserializeFixedBytes(32);
        return new n(t);
      }
    };
    var it = class n extends d {
      constructor(e) {
        if (super(), this.data = l.fromHexInput(e).toUint8Array(), this.data.length !== 64) throw new Error("Input needs to be 64 bytes");
      }
      serialize(e) {
        e.serializeFixedBytes(this.data);
      }
      static deserialize(e) {
        let t = e.deserializeFixedBytes(64);
        return new n(t);
      }
    };
    var St = exports.Groth16Zkp = class n extends kn {
      constructor(e) {
        super();
        let { a: t, b: r, c: o } = e;
        this.a = new Ce(t), this.b = new it(r), this.c = new Ce(o);
      }
      serialize(e) {
        this.a.serialize(e), this.b.serialize(e), this.c.serialize(e);
      }
      static deserialize(e) {
        let t = Ce.deserialize(e).bcsToBytes(), r = it.deserialize(e).bcsToBytes(), o = Ce.deserialize(e).bcsToBytes();
        return new n({ a: t, b: r, c: o });
      }
    };
    var _t = exports.ZkProof = class n extends d {
      constructor(e, t) {
        super(), this.proof = e, this.variant = t;
      }
      serialize(e) {
        e.serializeU32AsUleb128(this.variant), this.proof.serialize(e);
      }
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32();
        switch (t) {
          case 0:
            return new n(St.deserialize(e), t);
          default:
            throw new Error(`Unknown variant index for ZkProof: ${t}`);
        }
      }
    };
    var Ie = exports.ZeroKnowledgeSig = class n extends B {
      constructor(e) {
        super();
        let { proof: t, expHorizonSecs: r, trainingWheelsSignature: o, extraField: i, overrideAudVal: s } = e;
        this.proof = t, this.expHorizonSecs = r, this.trainingWheelsSignature = o, this.extraField = i, this.overrideAudVal = s;
      }
      toUint8Array() {
        return this.bcsToBytes();
      }
      static fromBytes(e) {
        return n.deserialize(new oe(e));
      }
      serialize(e) {
        this.proof.serialize(e), e.serializeU64(this.expHorizonSecs), e.serializeOptionStr(this.extraField), e.serializeOptionStr(this.overrideAudVal), e.serializeOption(this.trainingWheelsSignature);
      }
      static deserialize(e) {
        let t = _t.deserialize(e), r = Number(e.deserializeU64()), o = e.deserializeOptionStr(), i = e.deserializeOptionStr(), s = e.deserializeOption(Te);
        return new n({ proof: t, expHorizonSecs: r, trainingWheelsSignature: s, extraField: o, overrideAudVal: i });
      }
    };
    var Br = exports.KeylessConfiguration = class n {
      constructor(e, t) {
        this.verficationKey = e, this.maxExpHorizonSecs = t;
      }
      static create(e, t) {
        return new n(new Gr({ alphaG1: e.alpha_g1, betaG2: e.beta_g2, deltaG2: e.delta_g2, gammaAbcG1: e.gamma_abc_g1, gammaG2: e.gamma_g2 }), t);
      }
    };
    var Gr = class n {
      constructor(e) {
        let { alphaG1: t, betaG2: r, deltaG2: o, gammaAbcG1: i, gammaG2: s } = e;
        this.alphaG1 = new Ce(t), this.betaG2 = new it(r), this.deltaG2 = new it(o), this.gammaAbcG1 = [new Ce(i[0]), new Ce(i[1])], this.gammaG2 = new it(s);
      }
      static fromGroth16VerificationKeyResponse(e) {
        return new n({ alphaG1: e.alpha_g1, betaG2: e.beta_g2, deltaG2: e.delta_g2, gammaAbcG1: e.gamma_abc_g1, gammaG2: e.gamma_g2 });
      }
    };
    async function jo(n) {
      let { aptosConfig: e } = n;
      return Fe(async () => {
        let t = await ja(n), r = await Xa(n);
        return Br.create(r, Number(t.max_exp_horizon_secs));
      }, `keyless-configuration-${e.network}`, 1e3 * 60 * 5)();
    }
    async function ja(n) {
      let { aptosConfig: e, options: t } = n, r = "0x1::keyless_account::Configuration", { data: o } = await V({ aptosConfig: e, originMethod: "getKeylessConfigurationResource", path: `accounts/${u.from("0x1").toString()}/resource/${r}`, params: { ledger_version: _optionalChain([t, "optionalAccess", (_50) => _50.ledgerVersion]) } });
      return o.data;
    }
    async function Xa(n) {
      let { aptosConfig: e, options: t } = n, r = "0x1::keyless_account::Groth16VerificationKey", { data: o } = await V({ aptosConfig: e, originMethod: "getGroth16VerificationKeyResource", path: `accounts/${u.from("0x1").toString()}/resource/${r}`, params: { ledger_version: _optionalChain([t, "optionalAccess", (_51) => _51.ledgerVersion]) } });
      return o.data;
    }
    var D = class n extends ie {
      constructor(e) {
        if (super(), this.publicKey = e, e instanceof x) this.variant = 0;
        else if (e instanceof Pe) this.variant = 1;
        else if (e instanceof ee) this.variant = 3;
        else throw new Error("Unsupported public key type");
      }
      verifySignature(e) {
        let { message: t, signature: r } = e;
        return G.isInstance(r) ? this.publicKey.verifySignature({ message: t, signature: r.signature }) : false;
      }
      authKey() {
        return q.fromSchemeAndBytes({ scheme: 2, input: this.toUint8Array() });
      }
      toUint8Array() {
        return this.bcsToBytes();
      }
      serialize(e) {
        e.serializeU32AsUleb128(this.variant), this.publicKey.serialize(e);
      }
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32(), r;
        switch (t) {
          case 0:
            r = x.deserialize(e);
            break;
          case 1:
            r = Pe.deserialize(e);
            break;
          case 3:
            r = ee.deserialize(e);
            break;
          default:
            throw new Error(`Unknown variant index for AnyPublicKey: ${t}`);
        }
        return new n(r);
      }
      static isPublicKey(e) {
        return e instanceof n;
      }
      isEd25519() {
        return this.publicKey instanceof x;
      }
      isSecp256k1PublicKey() {
        return this.publicKey instanceof Pe;
      }
      static isInstance(e) {
        return "publicKey" in e && "variant" in e;
      }
    };
    var G = exports.AnySignature = class n extends B {
      constructor(e) {
        if (super(), this.signature = e, e instanceof v) this.variant = 0;
        else if (e instanceof ht) this.variant = 1;
        else if (e instanceof Ee) this.variant = 3;
        else throw new Error("Unsupported signature type");
      }
      toUint8Array() {
        return console.warn("[Aptos SDK] Calls to AnySignature.toUint8Array() will soon return the underlying signature bytes. Use AnySignature.bcsToBytes() instead."), this.bcsToBytes();
      }
      serialize(e) {
        e.serializeU32AsUleb128(this.variant), this.signature.serialize(e);
      }
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32(), r;
        switch (t) {
          case 0:
            r = v.deserialize(e);
            break;
          case 1:
            r = ht.deserialize(e);
            break;
          case 3:
            r = Ee.deserialize(e);
            break;
          default:
            throw new Error(`Unknown variant index for AnySignature: ${t}`);
        }
        return new n(r);
      }
      static isInstance(e) {
        return "signature" in e && typeof e.signature == "object" && e.signature !== null && "toUint8Array" in e.signature;
      }
    };
    function Ya(n) {
      let e = n;
      return e -= e >> 1 & 1431655765, e = (e & 858993459) + (e >> 2 & 858993459), (e + (e >> 4) & 252645135) * 16843009 >> 24;
    }
    var xt = class n extends ie {
      constructor(e) {
        super();
        let { publicKeys: t, signaturesRequired: r } = e;
        if (r < 1) throw new Error("The number of required signatures needs to be greater than 0");
        if (t.length < r) throw new Error(`Provided ${t.length} public keys is smaller than the ${r} required signatures`);
        this.publicKeys = t.map((o) => o instanceof D ? o : new D(o)), this.signaturesRequired = r;
      }
      verifySignature(e) {
        throw new Error("not implemented");
      }
      authKey() {
        return q.fromSchemeAndBytes({ scheme: 3, input: this.toUint8Array() });
      }
      toUint8Array() {
        return this.bcsToBytes();
      }
      serialize(e) {
        e.serializeVector(this.publicKeys), e.serializeU8(this.signaturesRequired);
      }
      static deserialize(e) {
        let t = e.deserializeVector(D), r = e.deserializeU8();
        return new n({ publicKeys: t, signaturesRequired: r });
      }
      createBitmap(e) {
        let { bits: t } = e, r = 128, o = new Uint8Array([0, 0, 0, 0]), i = /* @__PURE__ */ new Set();
        return t.forEach((s, a) => {
          if (a + 1 > this.publicKeys.length) throw new Error(`Signature index ${a + 1} is out of public keys range, ${this.publicKeys.length}.`);
          if (i.has(s)) throw new Error(`Duplicate bit ${s} detected.`);
          i.add(s);
          let c = Math.floor(s / 8), p = o[c];
          p |= r >> s % 8, o[c] = p;
        }), o;
      }
      getIndex(e) {
        let t = e instanceof D ? e : new D(e), r = this.publicKeys.findIndex((o) => o.toString() === t.toString());
        if (r !== -1) return r;
        throw new Error("Public key not found in MultiKey");
      }
    };
    var te = class te2 extends B {
      constructor(e) {
        super();
        let { signatures: t, bitmap: r } = e;
        if (t.length > te2.MAX_SIGNATURES_SUPPORTED) throw new Error(`The number of signatures cannot be greater than ${te2.MAX_SIGNATURES_SUPPORTED}`);
        if (this.signatures = t.map((i) => i instanceof G ? i : new G(i)), !(r instanceof Uint8Array)) this.bitmap = te2.createBitmap({ bits: r });
        else {
          if (r.length !== te2.BITMAP_LEN) throw new Error(`"bitmap" length should be ${te2.BITMAP_LEN}`);
          this.bitmap = r;
        }
        let o = this.bitmap.reduce((i, s) => i + Ya(s), 0);
        if (o !== this.signatures.length) throw new Error(`Expecting ${o} signatures from the bitmap, but got ${this.signatures.length}`);
      }
      static createBitmap(e) {
        let { bits: t } = e, r = 128, o = new Uint8Array([0, 0, 0, 0]), i = /* @__PURE__ */ new Set();
        return t.forEach((s) => {
          if (s >= te2.MAX_SIGNATURES_SUPPORTED) throw new Error(`Cannot have a signature larger than ${te2.MAX_SIGNATURES_SUPPORTED - 1}.`);
          if (i.has(s)) throw new Error("Duplicate bits detected.");
          i.add(s);
          let a = Math.floor(s / 8), c = o[a];
          c |= r >> s % 8, o[a] = c;
        }), o;
      }
      toUint8Array() {
        return this.bcsToBytes();
      }
      serialize(e) {
        e.serializeVector(this.signatures), e.serializeBytes(this.bitmap);
      }
      static deserialize(e) {
        let t = e.deserializeVector(G), r = e.deserializeBytes();
        return new te2({ signatures: t, bitmap: r });
      }
    };
    te.BITMAP_LEN = 4, te.MAX_SIGNATURES_SUPPORTED = te.BITMAP_LEN * 8;
    var st = te;
    var H = class extends d {
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32();
        switch (t) {
          case 0:
            return fe.load(e);
          case 1:
            return Gn.load(e);
          case 2:
            return Q.load(e);
          case 3:
            return at.load(e);
          default:
            throw new Error(`Unknown variant index for AccountAuthenticator: ${t}`);
        }
      }
      isEd25519() {
        return this instanceof fe;
      }
      isMultiEd25519() {
        return this instanceof Gn;
      }
      isSingleKey() {
        return this instanceof Q;
      }
      isMultiKey() {
        return this instanceof at;
      }
    };
    var fe = exports.AccountAuthenticatorEd25519 = class n extends H {
      constructor(e, t) {
        super(), this.public_key = e, this.signature = t;
      }
      serialize(e) {
        e.serializeU32AsUleb128(0), this.public_key.serialize(e), this.signature.serialize(e);
      }
      static load(e) {
        let t = x.deserialize(e), r = v.deserialize(e);
        return new n(t, r);
      }
    };
    var Gn = exports.AccountAuthenticatorMultiEd25519 = class n extends H {
      constructor(e, t) {
        super(), this.public_key = e, this.signature = t;
      }
      serialize(e) {
        e.serializeU32AsUleb128(1), this.public_key.serialize(e), this.signature.serialize(e);
      }
      static load(e) {
        let t = ft.deserialize(e), r = tt.deserialize(e);
        return new n(t, r);
      }
    };
    var Q = exports.AccountAuthenticatorSingleKey = class n extends H {
      constructor(e, t) {
        super(), this.public_key = e, this.signature = t;
      }
      serialize(e) {
        e.serializeU32AsUleb128(2), this.public_key.serialize(e), this.signature.serialize(e);
      }
      static load(e) {
        let t = D.deserialize(e), r = G.deserialize(e);
        return new n(t, r);
      }
    };
    var at = exports.AccountAuthenticatorMultiKey = class n extends H {
      constructor(e, t) {
        super(), this.public_keys = e, this.signatures = t;
      }
      serialize(e) {
        e.serializeU32AsUleb128(3), this.public_keys.serialize(e), this.signatures.serialize(e);
      }
      static load(e) {
        let t = xt.deserialize(e), r = st.deserialize(e);
        return new n(t, r);
      }
    };
    var Pt = class n extends d {
      constructor(e) {
        super(), this.chainId = e;
      }
      serialize(e) {
        e.serializeU8(this.chainId);
      }
      static deserialize(e) {
        let t = e.deserializeU8();
        return new n(t);
      }
    };
    var R = class n extends d {
      constructor(e) {
        super(), this.identifier = e;
      }
      serialize(e) {
        e.serializeStr(this.identifier);
      }
      static deserialize(e) {
        let t = e.deserializeStr();
        return new n(t);
      }
    };
    var Kr = (n, e) => {
      let t = n.bcsToBytes(), r = typeof e == "string" ? Buffer.from(e, "utf8") : e, o = new Uint8Array([...t, ...r, 254]);
      return new u(_sha3.sha3_256.call(void 0, o));
    };
    var Cg = exports.createResourceAddress = (n, e) => {
      let t = n.bcsToBytes(), r = typeof e == "string" ? Buffer.from(e, "utf8") : e, o = new Uint8Array([...t, ...r, 255]);
      return new u(_sha3.sha3_256.call(void 0, o));
    };
    var Eg = exports.createTokenAddress = (n, e, t) => {
      let r = `${e}::${t}`;
      return Kr(n, r);
    };
    var jt = class n extends d {
      constructor(e, t) {
        super(), this.address = e, this.name = t;
      }
      static fromStr(e) {
        let t = e.split("::");
        if (t.length !== 2) throw new Error("Invalid module id.");
        return new n(u.fromString(t[0]), new R(t[1]));
      }
      serialize(e) {
        this.address.serialize(e), this.name.serialize(e);
      }
      static deserialize(e) {
        let t = u.deserialize(e), r = R.deserialize(e);
        return new n(t, r);
      }
    };
    var z = class extends d {
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32();
        switch (t) {
          case 0:
            return K.load(e);
          case 1:
            return ce.load(e);
          case 2:
            return $.load(e);
          case 3:
            return Ve.load(e);
          case 4:
            return W.load(e);
          case 5:
            return vt.load(e);
          case 6:
            return C.load(e);
          case 7:
            return m.load(e);
          case 8:
            return Me.load(e);
          case 9:
            return qe.load(e);
          case 10:
            return $e.load(e);
          case 255:
            return k.load(e);
          default:
            throw new Error(`Unknown variant index for TypeTag: ${t}`);
        }
      }
      isBool() {
        return this instanceof K;
      }
      isAddress() {
        return this instanceof W;
      }
      isGeneric() {
        return this instanceof k;
      }
      isSigner() {
        return this instanceof vt;
      }
      isVector() {
        return this instanceof C;
      }
      isStruct() {
        return this instanceof m;
      }
      isU8() {
        return this instanceof ce;
      }
      isU16() {
        return this instanceof Me;
      }
      isU32() {
        return this instanceof qe;
      }
      isU64() {
        return this instanceof $;
      }
      isU128() {
        return this instanceof Ve;
      }
      isU256() {
        return this instanceof $e;
      }
    };
    var K = exports.TypeTagBool = class n extends z {
      toString() {
        return "bool";
      }
      serialize(e) {
        e.serializeU32AsUleb128(0);
      }
      static load(e) {
        return new n();
      }
    };
    var ce = exports.TypeTagU8 = class n extends z {
      toString() {
        return "u8";
      }
      serialize(e) {
        e.serializeU32AsUleb128(1);
      }
      static load(e) {
        return new n();
      }
    };
    var Me = exports.TypeTagU16 = class n extends z {
      toString() {
        return "u16";
      }
      serialize(e) {
        e.serializeU32AsUleb128(8);
      }
      static load(e) {
        return new n();
      }
    };
    var qe = exports.TypeTagU32 = class n extends z {
      toString() {
        return "u32";
      }
      serialize(e) {
        e.serializeU32AsUleb128(9);
      }
      static load(e) {
        return new n();
      }
    };
    var $ = exports.TypeTagU64 = class n extends z {
      toString() {
        return "u64";
      }
      serialize(e) {
        e.serializeU32AsUleb128(2);
      }
      static load(e) {
        return new n();
      }
    };
    var Ve = exports.TypeTagU128 = class n extends z {
      toString() {
        return "u128";
      }
      serialize(e) {
        e.serializeU32AsUleb128(3);
      }
      static load(e) {
        return new n();
      }
    };
    var $e = exports.TypeTagU256 = class n extends z {
      toString() {
        return "u256";
      }
      serialize(e) {
        e.serializeU32AsUleb128(10);
      }
      static load(e) {
        return new n();
      }
    };
    var W = exports.TypeTagAddress = class n extends z {
      toString() {
        return "address";
      }
      serialize(e) {
        e.serializeU32AsUleb128(4);
      }
      static load(e) {
        return new n();
      }
    };
    var vt = exports.TypeTagSigner = class n extends z {
      toString() {
        return "signer";
      }
      serialize(e) {
        e.serializeU32AsUleb128(5);
      }
      static load(e) {
        return new n();
      }
    };
    var Kn = exports.TypeTagReference = class n extends z {
      constructor(t) {
        super();
        this.value = t;
      }
      toString() {
        return `&${this.value.toString()}`;
      }
      serialize(t) {
        t.serializeU32AsUleb128(254);
      }
      static load(t) {
        let r = z.deserialize(t);
        return new n(r);
      }
    };
    var k = exports.TypeTagGeneric = class n extends z {
      constructor(t) {
        super();
        this.value = t;
        if (t < 0) throw new Error("Generic type parameter index cannot be negative");
      }
      toString() {
        return `T${this.value}`;
      }
      serialize(t) {
        t.serializeU32AsUleb128(255), t.serializeU32(this.value);
      }
      static load(t) {
        let r = t.deserializeU32();
        return new n(r);
      }
    };
    var C = exports.TypeTagVector = class n extends z {
      constructor(t) {
        super();
        this.value = t;
      }
      toString() {
        return `vector<${this.value.toString()}>`;
      }
      static u8() {
        return new n(new ce());
      }
      serialize(t) {
        t.serializeU32AsUleb128(6), this.value.serialize(t);
      }
      static load(t) {
        let r = z.deserialize(t);
        return new n(r);
      }
    };
    var m = exports.TypeTagStruct = class n extends z {
      constructor(t) {
        super();
        this.value = t;
      }
      toString() {
        let t = "";
        return this.value.typeArgs.length > 0 && (t = `<${this.value.typeArgs.map((r) => r.toString()).join(", ")}>`), `${this.value.address.toString()}::${this.value.moduleName.identifier}::${this.value.name.identifier}${t}`;
      }
      serialize(t) {
        t.serializeU32AsUleb128(7), this.value.serialize(t);
      }
      static load(t) {
        let r = Ue.deserialize(t);
        return new n(r);
      }
      isTypeTag(t, r, o) {
        return this.value.moduleName.identifier === r && this.value.name.identifier === o && this.value.address.equals(t);
      }
      isString() {
        return this.isTypeTag(u.ONE, "string", "String");
      }
      isOption() {
        return this.isTypeTag(u.ONE, "option", "Option");
      }
      isObject() {
        return this.isTypeTag(u.ONE, "object", "Object");
      }
    };
    var Ue = exports.StructTag = class n extends d {
      constructor(e, t, r, o) {
        super(), this.address = e, this.moduleName = t, this.name = r, this.typeArgs = o;
      }
      serialize(e) {
        e.serialize(this.address), e.serialize(this.moduleName), e.serialize(this.name), e.serializeVector(this.typeArgs);
      }
      static deserialize(e) {
        let t = u.deserialize(e), r = R.deserialize(e), o = R.deserialize(e), i = e.deserializeVector(z);
        return new n(t, r, o, i);
      }
    };
    function Yg() {
      return new Ue(u.ONE, new R("aptos_coin"), new R("AptosCoin"), []);
    }
    function P() {
      return new Ue(u.ONE, new R("string"), new R("String"), []);
    }
    function Zg(n) {
      return new Ue(u.ONE, new R("option"), new R("Option"), [n]);
    }
    function ne(n) {
      return new Ue(u.ONE, new R("object"), new R("Object"), [n]);
    }
    function Za(n) {
      let e = n.deserializeUleb128AsU32();
      switch (e) {
        case 0:
          return F.deserialize(n);
        case 1:
          return O.deserialize(n);
        case 2:
          return ge.deserialize(n);
        case 3:
          return u.deserialize(n);
        case 4:
          return T.deserialize(n, F);
        case 5:
          return I.deserialize(n);
        case 6:
          return de.deserialize(n);
        case 7:
          return le.deserialize(n);
        case 8:
          return me.deserialize(n);
        default:
          throw new Error(`Unknown variant index for ScriptTransactionArgument: ${e}`);
      }
    }
    var ct = class extends d {
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32();
        switch (t) {
          case 0:
            return Xt.load(e);
          case 2:
            return Yt.load(e);
          case 3:
            return Zt.load(e);
          default:
            throw new Error(`Unknown variant index for TransactionPayload: ${t}`);
        }
      }
    };
    var Xt = exports.TransactionPayloadScript = class n extends ct {
      constructor(e) {
        super(), this.script = e;
      }
      serialize(e) {
        e.serializeU32AsUleb128(0), this.script.serialize(e);
      }
      static load(e) {
        let t = Jt.deserialize(e);
        return new n(t);
      }
    };
    var Yt = exports.TransactionPayloadEntryFunction = class n extends ct {
      constructor(e) {
        super(), this.entryFunction = e;
      }
      serialize(e) {
        e.serializeU32AsUleb128(2), this.entryFunction.serialize(e);
      }
      static load(e) {
        let t = ut.deserialize(e);
        return new n(t);
      }
    };
    var Zt = exports.TransactionPayloadMultiSig = class n extends ct {
      constructor(e) {
        super(), this.multiSig = e;
      }
      serialize(e) {
        e.serializeU32AsUleb128(3), this.multiSig.serialize(e);
      }
      static load(e) {
        let t = en.deserialize(e);
        return new n(t);
      }
    };
    var ut = exports.EntryFunction = class n {
      constructor(e, t, r, o) {
        this.module_name = e, this.function_name = t, this.type_args = r, this.args = o;
      }
      static build(e, t, r, o) {
        return new n(jt.fromStr(e), new R(t), r, o);
      }
      serialize(e) {
        this.module_name.serialize(e), this.function_name.serialize(e), e.serializeVector(this.type_args), e.serializeU32AsUleb128(this.args.length), this.args.forEach((t) => {
          t.serializeForEntryFunction(e);
        });
      }
      static deserialize(e) {
        let t = jt.deserialize(e), r = R.deserialize(e), o = e.deserializeVector(z), i = e.deserializeUleb128AsU32(), s = new Array();
        for (let a = 0; a < i; a += 1) {
          let c = e.deserializeUleb128AsU32(), p = Cn.deserialize(e, c);
          s.push(p);
        }
        return new n(t, r, o, s);
      }
    };
    var Jt = exports.Script = class n {
      constructor(e, t, r) {
        this.bytecode = e, this.type_args = t, this.args = r;
      }
      serialize(e) {
        e.serializeBytes(this.bytecode), e.serializeVector(this.type_args), e.serializeU32AsUleb128(this.args.length), this.args.forEach((t) => {
          t.serializeForScriptFunction(e);
        });
      }
      static deserialize(e) {
        let t = e.deserializeBytes(), r = e.deserializeVector(z), o = e.deserializeUleb128AsU32(), i = new Array();
        for (let s = 0; s < o; s += 1) {
          let a = Za(e);
          i.push(a);
        }
        return new n(t, r, i);
      }
    };
    var en = exports.MultiSig = class n {
      constructor(e, t) {
        this.multisig_address = e, this.transaction_payload = t;
      }
      serialize(e) {
        this.multisig_address.serialize(e), this.transaction_payload === void 0 ? e.serializeBool(false) : (e.serializeBool(true), this.transaction_payload.serialize(e));
      }
      static deserialize(e) {
        let t = u.deserialize(e), r = e.deserializeBool(), o;
        return r && (o = tn.deserialize(e)), new n(t, o);
      }
    };
    var tn = exports.MultiSigTransactionPayload = class n extends d {
      constructor(e) {
        super(), this.transaction_payload = e;
      }
      serialize(e) {
        e.serializeU32AsUleb128(0), this.transaction_payload.serialize(e);
      }
      static deserialize(e) {
        return e.deserializeUleb128AsU32(), new n(ut.deserialize(e));
      }
    };
    var ue = class n extends d {
      constructor(e, t, r, o, i, s, a) {
        super(), this.sender = e, this.sequence_number = t, this.payload = r, this.max_gas_amount = o, this.gas_unit_price = i, this.expiration_timestamp_secs = s, this.chain_id = a;
      }
      serialize(e) {
        this.sender.serialize(e), e.serializeU64(this.sequence_number), this.payload.serialize(e), e.serializeU64(this.max_gas_amount), e.serializeU64(this.gas_unit_price), e.serializeU64(this.expiration_timestamp_secs), this.chain_id.serialize(e);
      }
      static deserialize(e) {
        let t = u.deserialize(e), r = e.deserializeU64(), o = ct.deserialize(e), i = e.deserializeU64(), s = e.deserializeU64(), a = e.deserializeU64(), c = Pt.deserialize(e);
        return new n(t, r, o, i, s, a, c);
      }
    };
    var Nn = exports.RawTransactionWithData = class extends d {
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32();
        switch (t) {
          case 0:
            return pt.load(e);
          case 1:
            return dt.load(e);
          default:
            throw new Error(`Unknown variant index for RawTransactionWithData: ${t}`);
        }
      }
    };
    var pt = exports.MultiAgentRawTransaction = class n extends Nn {
      constructor(e, t) {
        super(), this.raw_txn = e, this.secondary_signer_addresses = t;
      }
      serialize(e) {
        e.serializeU32AsUleb128(0), this.raw_txn.serialize(e), e.serializeVector(this.secondary_signer_addresses);
      }
      static load(e) {
        let t = ue.deserialize(e), r = e.deserializeVector(u);
        return new n(t, r);
      }
    };
    var dt = exports.FeePayerRawTransaction = class n extends Nn {
      constructor(e, t, r) {
        super(), this.raw_txn = e, this.secondary_signer_addresses = t, this.fee_payer_address = r;
      }
      serialize(e) {
        e.serializeU32AsUleb128(1), this.raw_txn.serialize(e), e.serializeVector(this.secondary_signer_addresses), this.fee_payer_address.serialize(e);
      }
      static load(e) {
        let t = ue.deserialize(e), r = e.deserializeVector(u), o = u.deserialize(e);
        return new n(t, r, o);
      }
    };
    var On = class extends d {
      constructor(t) {
        super();
        this.accountAddress = u.ONE;
        this.moduleName = new b("account");
        this.structName = new b("RotationProofChallenge");
        this.sequenceNumber = new O(t.sequenceNumber), this.originator = t.originator, this.currentAuthKey = t.currentAuthKey, this.newPublicKey = T.U8(t.newPublicKey.toUint8Array());
      }
      serialize(t) {
        t.serialize(this.accountAddress), t.serialize(this.moduleName), t.serialize(this.structName), t.serialize(this.sequenceNumber), t.serialize(this.originator), t.serialize(this.currentAuthKey), t.serialize(this.newPublicKey);
      }
    };
    var Re = class extends d {
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32();
        switch (t) {
          case 0:
            return Ct.load(e);
          case 1:
            return Nr.load(e);
          case 2:
            return Et.load(e);
          case 3:
            return It.load(e);
          case 4:
            return Ut.load(e);
          default:
            throw new Error(`Unknown variant index for TransactionAuthenticator: ${t}`);
        }
      }
    };
    var Ct = exports.TransactionAuthenticatorEd25519 = class n extends Re {
      constructor(e, t) {
        super(), this.public_key = e, this.signature = t;
      }
      serialize(e) {
        e.serializeU32AsUleb128(0), this.public_key.serialize(e), this.signature.serialize(e);
      }
      static load(e) {
        let t = x.deserialize(e), r = v.deserialize(e);
        return new n(t, r);
      }
    };
    var Nr = exports.TransactionAuthenticatorMultiEd25519 = class n extends Re {
      constructor(e, t) {
        super(), this.public_key = e, this.signature = t;
      }
      serialize(e) {
        e.serializeU32AsUleb128(1), this.public_key.serialize(e), this.signature.serialize(e);
      }
      static load(e) {
        let t = ft.deserialize(e), r = tt.deserialize(e);
        return new n(t, r);
      }
    };
    var Et = exports.TransactionAuthenticatorMultiAgent = class n extends Re {
      constructor(e, t, r) {
        super(), this.sender = e, this.secondary_signer_addresses = t, this.secondary_signers = r;
      }
      serialize(e) {
        e.serializeU32AsUleb128(2), this.sender.serialize(e), e.serializeVector(this.secondary_signer_addresses), e.serializeVector(this.secondary_signers);
      }
      static load(e) {
        let t = H.deserialize(e), r = e.deserializeVector(u), o = e.deserializeVector(H);
        return new n(t, r, o);
      }
    };
    var It = exports.TransactionAuthenticatorFeePayer = class n extends Re {
      constructor(e, t, r, o) {
        super(), this.sender = e, this.secondary_signer_addresses = t, this.secondary_signers = r, this.fee_payer = o;
      }
      serialize(e) {
        e.serializeU32AsUleb128(3), this.sender.serialize(e), e.serializeVector(this.secondary_signer_addresses), e.serializeVector(this.secondary_signers), this.fee_payer.address.serialize(e), this.fee_payer.authenticator.serialize(e);
      }
      static load(e) {
        let t = H.deserialize(e), r = e.deserializeVector(u), o = e.deserializeVector(H), i = u.deserialize(e), s = H.deserialize(e), a = { address: i, authenticator: s };
        return new n(t, r, o, a);
      }
    };
    var Ut = exports.TransactionAuthenticatorSingleSender = class n extends Re {
      constructor(e) {
        super(), this.sender = e;
      }
      serialize(e) {
        e.serializeU32AsUleb128(4), this.sender.serialize(e);
      }
      static load(e) {
        let t = H.deserialize(e);
        return new n(t);
      }
    };
    var lt = class n extends d {
      constructor(e, t) {
        super(), this.raw_txn = e, this.authenticator = t;
      }
      serialize(e) {
        this.raw_txn.serialize(e), this.authenticator.serialize(e);
      }
      static deserialize(e) {
        let t = ue.deserialize(e), r = Re.deserialize(e);
        return new n(t, r);
      }
    };
    var Fn = class n extends d {
      constructor(e, t) {
        super(), this.rawTransaction = e, this.feePayerAddress = t;
      }
      serialize(e) {
        this.rawTransaction.serialize(e), this.feePayerAddress === void 0 ? e.serializeBool(false) : (e.serializeBool(true), this.feePayerAddress.serialize(e));
      }
      static deserialize(e) {
        let t = ue.deserialize(e), r = e.deserializeBool(), o;
        return r && (o = u.deserialize(e)), new n(t, o);
      }
    };
    var Mn = class n extends d {
      constructor(e, t, r) {
        super(), this.rawTransaction = e, this.feePayerAddress = r, this.secondarySignerAddresses = t;
      }
      serialize(e) {
        this.rawTransaction.serialize(e), e.serializeVector(this.secondarySignerAddresses), this.feePayerAddress === void 0 ? e.serializeBool(false) : (e.serializeBool(true), this.feePayerAddress.serialize(e));
      }
      static deserialize(e) {
        let t = ue.deserialize(e), r = e.deserializeVector(u), o = e.deserializeBool(), i;
        return o && (i = u.deserialize(e)), new n(t, r, i);
      }
    };
    function Or(n) {
      return n.feePayerAddress ? new dt(n.rawTransaction, _nullishCoalesce(n.secondarySignerAddresses, () => []), n.feePayerAddress) : n.secondarySignerAddresses ? new pt(n.rawTransaction, n.secondarySignerAddresses) : n.rawTransaction;
    }
    function Rt(n, e) {
      let t = _sha3.sha3_256.create();
      if (!e.startsWith("APTOS::")) throw new Error(`Domain separator needs to start with 'APTOS::'.  Provided - ${e}`);
      t.update(e);
      let r = t.digest(), o = n, i = new Uint8Array(r.length + o.length);
      return i.set(r), i.set(o, r.length), i;
    }
    function uy(n) {
      return Rt(n.bcsToBytes(), `APTOS::${n.constructor.name}`);
    }
    function zt(n) {
      let e = Or(n);
      return n.feePayerAddress ? Rt(e.bcsToBytes(), Cr) : n.secondarySignerAddresses ? Rt(e.bcsToBytes(), Cr) : Rt(e.bcsToBytes(), No);
    }
    var kt = class n {
      constructor(e) {
        this.signingScheme = 0;
        let { privateKey: t, address: r } = e;
        this.privateKey = t, this.publicKey = t.publicKey(), this.accountAddress = r ? u.from(r) : this.publicKey.authKey().derivedAddress();
      }
      static generate() {
        let e = L.generate();
        return new n({ privateKey: e });
      }
      static fromDerivationPath(e) {
        let { path: t, mnemonic: r } = e, o = L.fromDerivationPath(t, r);
        return new n({ privateKey: o });
      }
      verifySignature(e) {
        return this.publicKey.verifySignature(e);
      }
      signWithAuthenticator(e) {
        return new fe(this.publicKey, this.privateKey.sign(e));
      }
      signTransactionWithAuthenticator(e) {
        return new fe(this.publicKey, this.signTransaction(e));
      }
      sign(e) {
        return this.privateKey.sign(e);
      }
      signTransaction(e) {
        return this.sign(zt(e));
      }
    };
    var Dt = class n {
      constructor(e) {
        this.signingScheme = 2;
        let { privateKey: t, address: r } = e;
        this.privateKey = t, this.publicKey = new D(t.publicKey()), this.accountAddress = r ? u.from(r) : this.publicKey.authKey().derivedAddress();
      }
      static generate(e = {}) {
        let { scheme: t = 0 } = e, r;
        switch (t) {
          case 0:
            r = L.generate();
            break;
          case 2:
            r = nt.generate();
            break;
          default:
            throw new Error(`Unsupported signature scheme ${t}`);
        }
        return new n({ privateKey: r });
      }
      static fromDerivationPath(e) {
        let { scheme: t = 0, path: r, mnemonic: o } = e, i;
        switch (t) {
          case 0:
            i = L.fromDerivationPath(r, o);
            break;
          case 2:
            i = nt.fromDerivationPath(r, o);
            break;
          default:
            throw new Error(`Unsupported signature scheme ${t}`);
        }
        return new n({ privateKey: i });
      }
      verifySignature(e) {
        return this.publicKey.verifySignature(e);
      }
      signWithAuthenticator(e) {
        return new Q(this.publicKey, this.sign(e));
      }
      signTransactionWithAuthenticator(e) {
        return new Q(this.publicKey, this.signTransaction(e));
      }
      sign(e) {
        return new G(this.privateKey.sign(e));
      }
      signTransaction(e) {
        return this.sign(zt(e));
      }
    };
    var Le = class {
      static generate(e = {}) {
        let { scheme: t = 0, legacy: r = true } = e;
        return t === 0 && r ? kt.generate() : Dt.generate({ scheme: t });
      }
      static fromPrivateKey(e) {
        let { privateKey: t, address: r, legacy: o = true } = e;
        return t instanceof L && o ? new kt({ privateKey: t, address: r }) : new Dt({ privateKey: t, address: r });
      }
      static fromPrivateKeyAndAddress(e) {
        return this.fromPrivateKey(e);
      }
      static fromDerivationPath(e) {
        let { scheme: t = 0, mnemonic: r, path: o, legacy: i = true } = e;
        return t === 0 && i ? kt.fromDerivationPath({ mnemonic: r, path: o }) : Dt.fromDerivationPath({ scheme: t, mnemonic: r, path: o });
      }
      static authKey(e) {
        let { publicKey: t } = e;
        return t.authKey();
      }
      verifySignature(e) {
        return this.publicKey.verifySignature(e);
      }
    };
    var tc = 1209600;
    var Bt = class Bt2 extends d {
      constructor(e) {
        super();
        let { privateKey: t, expiryDateSecs: r, blinder: o } = e;
        this.privateKey = t, this.publicKey = new rt(t.publicKey()), this.expiryDateSecs = r || _chunkBHKSQXUZjs.d.call(void 0, _chunkBHKSQXUZjs.c.call(void 0) + tc), this.blinder = o !== void 0 ? l.fromHexInput(o).toUint8Array() : nc();
        let i = vr(this.publicKey.bcsToBytes(), 93);
        i.push(BigInt(this.expiryDateSecs)), i.push(Ht(this.blinder));
        let s = Qt(i);
        this.nonce = s.toString();
      }
      getPublicKey() {
        return this.publicKey;
      }
      isExpired() {
        return Math.floor(Date.now() / 1e3) > this.expiryDateSecs;
      }
      serialize(e) {
        e.serializeU32AsUleb128(this.publicKey.variant), e.serializeBytes(this.privateKey.toUint8Array()), e.serializeU64(this.expiryDateSecs), e.serializeFixedBytes(this.blinder);
      }
      static deserialize(e) {
        let t = e.deserializeUleb128AsU32(), r;
        switch (t) {
          case 0:
            r = L.deserialize(e);
            break;
          default:
            throw new Error(`Unknown variant index for EphemeralPublicKey: ${t}`);
        }
        let o = e.deserializeU64(), i = e.deserializeFixedBytes(31);
        return new Bt2({ privateKey: r, expiryDateSecs: Number(o), blinder: i });
      }
      static fromBytes(e) {
        return Bt2.deserialize(new oe(e));
      }
      static generate(e) {
        let t;
        switch (_optionalChain([e, "optionalAccess", (_52) => _52.scheme])) {
          case 0:
          default:
            t = L.generate();
        }
        return new Bt2({ privateKey: t, expiryDateSecs: _optionalChain([e, "optionalAccess", (_53) => _53.expiryDateSecs]) });
      }
      sign(e) {
        if (this.isExpired()) throw new Error("EphemeralKeyPair has expired");
        return new Te(this.privateKey.sign(e));
      }
    };
    Bt.BLINDER_LENGTH = 31;
    var nn = Bt;
    function nc() {
      return _utils.randomBytes.call(void 0, nn.BLINDER_LENGTH);
    }
    var _eventemitter3 = require_eventemitter3();
    var _eventemitter32 = _interopRequireDefault(_eventemitter3);
    var He = class He2 extends d {
      constructor(e) {
        super();
        let { address: t, ephemeralKeyPair: r, uidKey: o, uidVal: i, aud: s, pepper: a, proof: c, proofFetchCallback: p, jwt: y } = e;
        if (this.ephemeralKeyPair = r, this.publicKey = ee.create(e), this.accountAddress = t ? u.from(t) : this.publicKey.authKey().derivedAddress(), this.uidKey = o, this.uidVal = i, this.aud = s, this.jwt = y, this.emitter = new _eventemitter32.default(), this.proofOrPromise = c, c instanceof Ie) this.proof = c;
        else {
          if (p === void 0) throw new Error("Must provide callback for async proof fetch");
          this.emitter.on("proofFetchFinish", async (S) => {
            await p(S), this.emitter.removeAllListeners();
          }), this.init(c);
        }
        this.signingScheme = 2;
        let w = l.fromHexInput(a).toUint8Array();
        if (w.length !== He2.PEPPER_LENGTH) throw new Error(`Pepper length in bytes should be ${He2.PEPPER_LENGTH}`);
        this.pepper = w;
      }
      async init(e) {
        try {
          this.proof = await e, this.emitter.emit("proofFetchFinish", { status: "Success" });
        } catch (t) {
          t instanceof Error ? this.emitter.emit("proofFetchFinish", { status: "Failed", error: t.toString() }) : this.emitter.emit("proofFetchFinish", { status: "Failed", error: "Unknown" });
        }
      }
      serialize(e) {
        if (e.serializeStr(this.jwt), e.serializeStr(this.uidKey), e.serializeFixedBytes(this.pepper), this.ephemeralKeyPair.serialize(e), this.proof === void 0) throw new Error("Connot serialize - proof undefined");
        this.proof.serialize(e);
      }
      static deserialize(e) {
        let t = e.deserializeStr(), r = e.deserializeStr(), o = e.deserializeFixedBytes(31), i = nn.deserialize(e), s = Ie.deserialize(e);
        return He2.create({ proof: s, pepper: o, uidKey: r, jwt: t, ephemeralKeyPair: i });
      }
      isExpired() {
        return this.ephemeralKeyPair.isExpired();
      }
      signWithAuthenticator(e) {
        let t = new G(this.sign(e)), r = new D(this.publicKey);
        return new Q(r, t);
      }
      signTransactionWithAuthenticator(e) {
        let t = new G(this.signTransaction(e)), r = new D(this.publicKey);
        return new Q(r, t);
      }
      async waitForProofFetch() {
        this.proofOrPromise instanceof Promise && await this.proofOrPromise;
      }
      sign(e) {
        let { expiryDateSecs: t } = this.ephemeralKeyPair;
        if (this.isExpired()) throw new Error("EphemeralKeyPair is expired");
        if (this.proof === void 0) throw new Error("Proof not defined");
        let r = this.ephemeralKeyPair.getPublicKey(), o = this.ephemeralKeyPair.sign(e);
        return new Ee({ jwtHeader: _chunkBHKSQXUZjs.e.call(void 0, this.jwt.split(".")[0]), ephemeralCertificate: new wt(this.proof, 0), expiryDateSecs: t, ephemeralPublicKey: r, ephemeralSignature: o });
      }
      signTransaction(e) {
        if (this.proof === void 0) throw new Error("Proof not found");
        let t = Or(e), o = new Fr(t, this.proof.proof).hash();
        return this.sign(o);
      }
      verifySignature(e) {
        let { message: t, signature: r } = e;
        return !(this.isExpired() || !this.ephemeralKeyPair.getPublicKey().verifySignature({ message: t, signature: r.ephemeralSignature }));
      }
      static fromBytes(e) {
        return He2.deserialize(new oe(e));
      }
      static create(e) {
        let { address: t, proof: r, jwt: o, ephemeralKeyPair: i, pepper: s, uidKey: a = "sub", proofFetchCallback: c } = e, p = _jwtdecode.jwtDecode.call(void 0, o), y = p.iss;
        if (typeof p.aud != "string") throw new Error("aud was not found or an array of values");
        let w = p.aud, S = p[a];
        return new He2({ address: t, proof: r, ephemeralKeyPair: i, iss: y, uidKey: a, uidVal: S, aud: w, pepper: s, jwt: o, proofFetchCallback: c });
      }
    };
    He.PEPPER_LENGTH = 31;
    var we = He;
    var Fr = class extends d {
      constructor(t, r) {
        super();
        this.domainSeparator = "APTOS::TransactionAndProof";
        this.transaction = t, this.proof = r;
      }
      serialize(t) {
        t.serializeFixedBytes(this.transaction.bcsToBytes()), t.serializeOption(this.proof);
      }
      hash() {
        return Rt(this.bcsToBytes(), this.domainSeparator);
      }
    };
    var qn = class n {
      constructor(e) {
        let { multiKey: t, signers: r } = e;
        this.publicKey = t, this.signingScheme = 3, this.accountAddress = this.publicKey.authKey().derivedAddress();
        let o = [];
        for (let s of r) o.push(this.publicKey.getIndex(s.publicKey));
        let i = r.map((s, a) => [s, o[a]]);
        i.sort((s, a) => s[1] - a[1]), this.signers = i.map((s) => s[0]), this.signerIndicies = i.map((s) => s[1]), this.signaturesBitmap = this.publicKey.createBitmap({ bits: o });
      }
      static fromPublicKeysAndSigners(e) {
        let { publicKeys: t, signaturesRequired: r, signers: o } = e, i = new xt({ publicKeys: t, signaturesRequired: r });
        return new n({ multiKey: i, signers: o });
      }
      static isMultiKeySigner(e) {
        return e instanceof n;
      }
      signWithAuthenticator(e) {
        return new at(this.publicKey, this.sign(e));
      }
      signTransactionWithAuthenticator(e) {
        return new at(this.publicKey, this.signTransaction(e));
      }
      async waitForProofFetch() {
        let t = this.signers.filter((r) => r instanceof we).map(async (r) => r.waitForProofFetch());
        await Promise.all(t);
      }
      sign(e) {
        let t = [];
        for (let r of this.signers) t.push(r.sign(e));
        return new st({ signatures: t, bitmap: this.signaturesBitmap });
      }
      signTransaction(e) {
        let t = [];
        for (let r of this.signers) t.push(r.signTransaction(e));
        return new st({ signatures: t, bitmap: this.signaturesBitmap });
      }
      verifySignature(e) {
        let { message: t, signature: r } = e;
        if (!this.signerIndicies.every((i, s) => s === 0 || i >= this.signerIndicies[s - 1])) return false;
        for (let i = 0; i < r.signatures.length; i += 1) {
          let s = r.signatures[i];
          if (!this.publicKey.publicKeys[this.signerIndicies[i]].verifySignature({ message: t, signature: s })) return false;
        }
        return true;
      }
    };
    var ic = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
    var sc = `
    fragment AnsTokenFragment on current_aptos_names {
  domain
  expiration_timestamp
  registered_address
  subdomain
  token_standard
  is_primary
  owner_address
  subdomain_expiration_policy
  domain_expiration_timestamp
}
    `;
    var Vn = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
    var Yo = `
    query getAccountCoinsCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
    var Zo = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
    var Jo = `
    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
    var ei = `
    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${Vn}`;
    var Ef = `
    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${Vn}`;
    var ti = `
    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${Vn}`;
    var ni = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
    var ri = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
    var oi = `
    query getChainTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
    var ii = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {
  current_collections_v2(where: $where_condition) {
    uri
    total_minted_v2
    token_standard
    table_handle_v1
    mutable_uri
    mutable_description
    max_supply
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    cdn_asset_uris {
      cdn_image_uri
      asset_uri
      animation_optimizer_retry_count
      cdn_animation_uri
      cdn_json_uri
      image_optimizer_retry_count
      json_parser_retry_count
      raw_animation_uri
      raw_image_uri
    }
  }
}
    `;
    var si = `
    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
  }
}
    `;
    var ai = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
    var ci = `
    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {
  events(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    account_address
    creation_number
    data
    event_index
    sequence_number
    transaction_block_height
    transaction_version
    type
    indexed_type
  }
}
    `;
    var ui = `
    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_activities(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    block_height
    entry_function_id_str
    event_index
    gas_fee_payer_address
    is_frozen
    is_gas_fee
    is_transaction_success
    owner_address
    storage_id
    storage_refund_amount
    token_standard
    transaction_timestamp
    transaction_version
    type
  }
}
    `;
    var pi = `
    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {
    icon_uri
    project_uri
    supply_aggregator_table_handle_v1
    supply_aggregator_table_key_v1
    creator_address
    asset_type
    decimals
    last_transaction_timestamp
    last_transaction_version
    name
    symbol
    token_standard
    supply_v2
    maximum_v2
  }
}
    `;
    var Gt = `
    query getNames($offset: Int, $limit: Int, $where_condition: current_aptos_names_bool_exp, $order_by: [current_aptos_names_order_by!]) {
  current_aptos_names(
    limit: $limit
    where: $where_condition
    order_by: $order_by
    offset: $offset
  ) {
    ...AnsTokenFragment
  }
}
    ${sc}`;
    var Mr = `
    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp, $order_by: [num_active_delegator_per_pool_order_by!]) {
  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {
    num_active_delegator
    pool_address
  }
}
    `;
    var $n = `
    query getObjectData($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
    var qr = `
    query getProcessorStatus($where_condition: processor_status_bool_exp) {
  processor_status(where: $where_condition) {
    last_success_version
    processor
    last_updated
  }
}
    `;
    var di = `
    query getTableItemsData($where_condition: table_items_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_items_order_by!]) {
  table_items(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    decoded_key
    decoded_value
    key
    table_handle
    transaction_version
    write_set_change_index
  }
}
    `;
    var li = `
    query getTableItemsMetadata($where_condition: table_metadatas_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_metadatas_order_by!]) {
  table_metadatas(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    handle
    key_type
    value_type
  }
}
    `;
    var gi = `
    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${ic}`;
    var Vr = `
    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${Vn}`;
    var mi = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
    async function Ln(n) {
      let { aptosConfig: e } = n, { data: t } = await V({ aptosConfig: e, originMethod: "getLedgerInfo", path: "" });
      return t;
    }
    async function yi(n) {
      let { aptosConfig: e, limit: t } = n;
      return (await f({ aptosConfig: e, query: { query: oi, variables: { limit: t } }, originMethod: "getChainTopUserTransactions" })).user_transactions;
    }
    async function f(n) {
      let { aptosConfig: e, query: t, originMethod: r } = n, { data: o } = await $o({ aptosConfig: e, originMethod: _nullishCoalesce(r, () => "queryIndexer"), path: "", body: t, overrides: { WITH_CREDENTIALS: false } });
      return o;
    }
    async function ac(n) {
      let { aptosConfig: e } = n;
      return (await f({ aptosConfig: e, query: { query: qr }, originMethod: "getProcessorStatuses" })).processor_status;
    }
    async function Hn(n) {
      let e = await ac({ aptosConfig: n.aptosConfig });
      return BigInt(e[0].last_success_version);
    }
    async function Qn(n) {
      let { aptosConfig: e, processorType: t } = n;
      return (await f({ aptosConfig: e, query: { query: qr, variables: { where_condition: { processor: { _eq: t } } } }, originMethod: "getProcessorStatus" })).processor_status[0];
    }
    async function Wn(n) {
      let { aptosConfig: e, handle: t, data: r, options: o } = n;
      return (await Oe({ aptosConfig: e, originMethod: "getTableItem", path: `tables/${t}/item`, params: { ledger_version: _optionalChain([o, "optionalAccess", (_54) => _54.ledgerVersion]) }, body: r })).data;
    }
    async function fi(n) {
      let { aptosConfig: e, options: t } = n, r = { query: di, variables: { where_condition: _optionalChain([t, "optionalAccess", (_55) => _55.where]), offset: _optionalChain([t, "optionalAccess", (_56) => _56.offset]), limit: _optionalChain([t, "optionalAccess", (_57) => _57.limit]), order_by: _optionalChain([t, "optionalAccess", (_58) => _58.orderBy]) } };
      return (await f({ aptosConfig: e, query: r, originMethod: "getTableItemsData" })).table_items;
    }
    async function Ai(n) {
      let { aptosConfig: e, options: t } = n, r = { query: li, variables: { where_condition: _optionalChain([t, "optionalAccess", (_59) => _59.where]), offset: _optionalChain([t, "optionalAccess", (_60) => _60.offset]), limit: _optionalChain([t, "optionalAccess", (_61) => _61.limit]), order_by: _optionalChain([t, "optionalAccess", (_62) => _62.orderBy]) } };
      return (await f({ aptosConfig: e, query: r, originMethod: "getTableItemsMetadata" })).table_metadatas;
    }
    async function Se(n) {
      let { aptosConfig: e, accountAddress: t } = n, { data: r } = await V({ aptosConfig: e, originMethod: "getInfo", path: `accounts/${u.from(t).toString()}` });
      return r;
    }
    async function bi(n) {
      let { aptosConfig: e, accountAddress: t, options: r } = n;
      return bt({ aptosConfig: e, originMethod: "getModules", path: `accounts/${u.from(t).toString()}/modules`, params: { ledger_version: _optionalChain([r, "optionalAccess", (_63) => _63.ledgerVersion]), start: _optionalChain([r, "optionalAccess", (_64) => _64.offset]), limit: _nullishCoalesce(_optionalChain([r, "optionalAccess", (_65) => _65.limit]), () => 1e3) } });
    }
    async function jn(n) {
      return _optionalChain([n, "access", (_66) => _66.options, "optionalAccess", (_67) => _67.ledgerVersion]) !== void 0 ? hi(n) : Fe(async () => hi(n), `module-${n.accountAddress}-${n.moduleName}`, 1e3 * 60 * 5)();
    }
    async function hi(n) {
      let { aptosConfig: e, accountAddress: t, moduleName: r, options: o } = n, { data: i } = await V({ aptosConfig: e, originMethod: "getModule", path: `accounts/${u.from(t).toString()}/module/${r}`, params: { ledger_version: _optionalChain([o, "optionalAccess", (_68) => _68.ledgerVersion]) } });
      return i;
    }
    async function wi(n) {
      let { aptosConfig: e, accountAddress: t, options: r } = n;
      return bt({ aptosConfig: e, originMethod: "getTransactions", path: `accounts/${u.from(t).toString()}/transactions`, params: { start: _optionalChain([r, "optionalAccess", (_69) => _69.offset]), limit: _optionalChain([r, "optionalAccess", (_70) => _70.limit]) } });
    }
    async function Si(n) {
      let { aptosConfig: e, accountAddress: t, options: r } = n;
      return bt({ aptosConfig: e, originMethod: "getResources", path: `accounts/${u.from(t).toString()}/resources`, params: { ledger_version: _optionalChain([r, "optionalAccess", (_71) => _71.ledgerVersion]), start: _optionalChain([r, "optionalAccess", (_72) => _72.offset]), limit: _nullishCoalesce(_optionalChain([r, "optionalAccess", (_73) => _73.limit]), () => 999) } });
    }
    async function $r(n) {
      let { aptosConfig: e, accountAddress: t, resourceType: r, options: o } = n, { data: i } = await V({ aptosConfig: e, originMethod: "getResource", path: `accounts/${u.from(t).toString()}/resource/${r}`, params: { ledger_version: _optionalChain([o, "optionalAccess", (_74) => _74.ledgerVersion]) } });
      return i.data;
    }
    async function rn(n) {
      let { aptosConfig: e, authenticationKey: t, options: r } = n, o = await $r({ aptosConfig: e, accountAddress: "0x1", resourceType: "0x1::account::OriginatingAddress", options: r }), { address_map: { handle: i } } = o, s = u.from(t);
      try {
        let a = await Wn({ aptosConfig: e, handle: i, data: { key: s.toString(), key_type: "address", value_type: "address" }, options: r });
        return u.from(a);
      } catch (a) {
        if (a instanceof ye && a.data.error_code === "table_item_not_found") return s;
        throw a;
      }
    }
    async function _i(n) {
      let { aptosConfig: e, accountAddress: t } = n, o = { owner_address: { _eq: u.from(t).toStringLong() }, amount: { _gt: 0 } }, s = await f({ aptosConfig: e, query: { query: ni, variables: { where_condition: o } }, originMethod: "getAccountTokensCount" });
      return s.current_token_ownerships_v2_aggregate.aggregate ? s.current_token_ownerships_v2_aggregate.aggregate.count : 0;
    }
    async function xi(n) {
      let { aptosConfig: e, accountAddress: t, options: r } = n, i = { owner_address: { _eq: u.from(t).toStringLong() }, amount: { _gt: 0 } };
      _optionalChain([r, "optionalAccess", (_75) => _75.tokenStandard]) && (i.token_standard = { _eq: _optionalChain([r, "optionalAccess", (_76) => _76.tokenStandard]) });
      let s = { query: ei, variables: { where_condition: i, offset: _optionalChain([r, "optionalAccess", (_77) => _77.offset]), limit: _optionalChain([r, "optionalAccess", (_78) => _78.limit]), order_by: _optionalChain([r, "optionalAccess", (_79) => _79.orderBy]) } };
      return (await f({ aptosConfig: e, query: s, originMethod: "getAccountOwnedTokens" })).current_token_ownerships_v2;
    }
    async function Pi(n) {
      let { aptosConfig: e, accountAddress: t, collectionAddress: r, options: o } = n, i = u.from(t).toStringLong(), s = u.from(r).toStringLong(), a = { owner_address: { _eq: i }, current_token_data: { collection_id: { _eq: s } }, amount: { _gt: 0 } };
      _optionalChain([o, "optionalAccess", (_80) => _80.tokenStandard]) && (a.token_standard = { _eq: _optionalChain([o, "optionalAccess", (_81) => _81.tokenStandard]) });
      let c = { query: ti, variables: { where_condition: a, offset: _optionalChain([o, "optionalAccess", (_82) => _82.offset]), limit: _optionalChain([o, "optionalAccess", (_83) => _83.limit]), order_by: _optionalChain([o, "optionalAccess", (_84) => _84.orderBy]) } };
      return (await f({ aptosConfig: e, query: c, originMethod: "getAccountOwnedTokensFromCollectionAddress" })).current_token_ownerships_v2;
    }
    async function vi(n) {
      let { aptosConfig: e, accountAddress: t, options: r } = n, i = { owner_address: { _eq: u.from(t).toStringLong() } };
      _optionalChain([r, "optionalAccess", (_85) => _85.tokenStandard]) && (i.current_collection = { token_standard: { _eq: _optionalChain([r, "optionalAccess", (_86) => _86.tokenStandard]) } });
      let s = { query: Jo, variables: { where_condition: i, offset: _optionalChain([r, "optionalAccess", (_87) => _87.offset]), limit: _optionalChain([r, "optionalAccess", (_88) => _88.limit]), order_by: _optionalChain([r, "optionalAccess", (_89) => _89.orderBy]) } };
      return (await f({ aptosConfig: e, query: s, originMethod: "getAccountCollectionsWithOwnedTokens" })).current_collection_ownership_v2_view;
    }
    async function Ci(n) {
      let { aptosConfig: e, accountAddress: t } = n, r = u.from(t).toStringLong(), i = await f({ aptosConfig: e, query: { query: ri, variables: { address: r } }, originMethod: "getAccountTransactionsCount" });
      return i.account_transactions_aggregate.aggregate ? i.account_transactions_aggregate.aggregate.count : 0;
    }
    async function Ei(n) {
      let { aptosConfig: e, accountAddress: t, coinType: r, faMetadataAddress: o } = n, i, s;
      if (r !== void 0 && o !== void 0) s = u.from(o).toStringLong();
      else if (r !== void 0 && o === void 0) i = r, n.coinType === ot ? s = u.A.toStringLong() : s = Kr(u.A, r).toStringLong();
      else if (r === void 0 && o !== void 0) {
        let y = u.from(o);
        s = y.toStringLong(), y === u.A && (i = ot);
      } else throw new Error("Either coinType, fungibleAssetAddress, or both must be provided");
      let a = u.from(t).toStringLong(), c = { asset_type: { _eq: s } };
      r !== void 0 && (c = { asset_type: { _in: [i, s] } });
      let p = await Lr({ aptosConfig: e, accountAddress: a, options: { where: c } });
      return p[0] ? p[0].amount : 0;
    }
    async function Lr(n) {
      let { aptosConfig: e, accountAddress: t, options: r } = n, o = u.from(t).toStringLong(), i = { ..._optionalChain([r, "optionalAccess", (_90) => _90.where]), owner_address: { _eq: o } }, s = { query: Zo, variables: { where_condition: i, offset: _optionalChain([r, "optionalAccess", (_91) => _91.offset]), limit: _optionalChain([r, "optionalAccess", (_92) => _92.limit]), order_by: _optionalChain([r, "optionalAccess", (_93) => _93.orderBy]) } };
      return (await f({ aptosConfig: e, query: s, originMethod: "getAccountCoinsData" })).current_fungible_asset_balances;
    }
    async function Ii(n) {
      let { aptosConfig: e, accountAddress: t } = n, r = u.from(t).toStringLong(), i = await f({ aptosConfig: e, query: { query: Yo, variables: { address: r } }, originMethod: "getAccountCoinsCount" });
      if (!i.current_fungible_asset_balances_aggregate.aggregate) throw Error("Failed to get the count of account coins");
      return i.current_fungible_asset_balances_aggregate.aggregate.count;
    }
    async function Ui(n) {
      let { aptosConfig: e, accountAddress: t, options: r } = n, i = { owner_address: { _eq: u.from(t).toStringLong() } }, s = { query: $n, variables: { where_condition: i, offset: _optionalChain([r, "optionalAccess", (_94) => _94.offset]), limit: _optionalChain([r, "optionalAccess", (_95) => _95.limit]), order_by: _optionalChain([r, "optionalAccess", (_96) => _96.orderBy]) } };
      return (await f({ aptosConfig: e, query: s, originMethod: "getAccountOwnedObjects" })).current_objects;
    }
    async function Ri(n) {
      let { aptosConfig: e, privateKey: t } = n, r = new D(t.publicKey());
      if (t instanceof nt) {
        let i = q.fromPublicKey({ publicKey: r }).derivedAddress();
        return Le.fromPrivateKey({ privateKey: t, address: i });
      }
      if (t instanceof L) {
        let o = q.fromPublicKey({ publicKey: r });
        if (await Ti({ authKey: o, aptosConfig: e })) {
          let c = o.derivedAddress();
          return Le.fromPrivateKey({ privateKey: t, address: c, legacy: false });
        }
        let s = q.fromPublicKey({ publicKey: r.publicKey });
        if (await Ti({ authKey: s, aptosConfig: e })) {
          let c = s.derivedAddress();
          return Le.fromPrivateKey({ privateKey: t, address: c, legacy: true });
        }
      }
      throw new Error(`Can't derive account from private key ${t}`);
    }
    async function Ti(n) {
      let { aptosConfig: e, authKey: t } = n, r = await rn({ aptosConfig: e, authenticationKey: t.derivedAddress() });
      try {
        return await Se({ aptosConfig: e, accountAddress: r }), true;
      } catch (o) {
        if (o.status === 404) return false;
        throw new Error(`Error while looking for an account info ${r.toString()}`);
      }
    }
    async function Qr(n) {
      let { aptosConfig: e, options: t } = n;
      return bt({ aptosConfig: e, originMethod: "getTransactions", path: "transactions", params: { start: _optionalChain([t, "optionalAccess", (_97) => _97.offset]), limit: _optionalChain([t, "optionalAccess", (_98) => _98.limit]) } });
    }
    async function Yn(n) {
      let { aptosConfig: e } = n;
      return Fe(async () => {
        let { data: t } = await V({ aptosConfig: e, originMethod: "getGasPriceEstimation", path: "estimate_gas_price" });
        return t;
      }, `gas-price-${e.network}`, 1e3 * 60 * 5)();
    }
    async function zi(n) {
      let { aptosConfig: e, ledgerVersion: t } = n, { data: r } = await V({ aptosConfig: e, originMethod: "getTransactionByVersion", path: `transactions/by_version/${t}` });
      return r;
    }
    async function on(n) {
      let { aptosConfig: e, transactionHash: t } = n, { data: r } = await V({ aptosConfig: e, path: `transactions/by_hash/${t}`, originMethod: "getTransactionByHash" });
      return r;
    }
    async function ki(n) {
      let { aptosConfig: e, transactionHash: t } = n;
      try {
        return (await on({ aptosConfig: e, transactionHash: t })).type === "pending_transaction";
      } catch (r) {
        if (_optionalChain([r, "optionalAccess", (_99) => _99.status]) === 404) return true;
        throw r;
      }
    }
    async function cc(n) {
      let { aptosConfig: e, transactionHash: t } = n, { data: r } = await V({ aptosConfig: e, path: `transactions/wait_by_hash/${t}`, originMethod: "longWaitForTransaction" });
      return r;
    }
    async function Kt(n) {
      let { aptosConfig: e, transactionHash: t, options: r } = n, o = _nullishCoalesce(_optionalChain([r, "optionalAccess", (_100) => _100.timeoutSecs]), () => 20), i = _nullishCoalesce(_optionalChain([r, "optionalAccess", (_101) => _101.checkSuccess]), () => true), s = true, a = 0, c, p, y = 200, w = 1.5;
      function S(g) {
        if (!(g instanceof ye) || (p = g, g.status !== 404 && g.status >= 400 && g.status < 500)) throw g;
      }
      try {
        c = await on({ aptosConfig: e, transactionHash: t }), s = c.type === "pending_transaction";
      } catch (g) {
        S(g);
      }
      if (s) {
        let g = Date.now();
        try {
          c = await cc({ aptosConfig: e, transactionHash: t }), s = c.type === "pending_transaction";
        } catch (E) {
          S(E);
        }
        a = (Date.now() - g) / 1e3;
      }
      for (; s && !(a >= o); ) {
        try {
          if (c = await on({ aptosConfig: e, transactionHash: t }), s = c.type === "pending_transaction", !s) break;
        } catch (g) {
          S(g);
        }
        await _chunkBHKSQXUZjs.b.call(void 0, y), a += y / 1e3, y *= w;
      }
      if (c === void 0) throw p || new Xn(`Fetching transaction ${t} failed and timed out after ${o} seconds`, c);
      if (c.type === "pending_transaction") throw new Xn(`Transaction ${t} timed out in pending state after ${o} seconds`, c);
      if (!i) return c;
      if (!c.success) throw new Hr(`Transaction ${t} failed with an error: ${c.vm_status}`, c);
      return c;
    }
    async function Zn(n) {
      let { aptosConfig: e, processorType: t } = n, r = BigInt(n.minimumLedgerVersion), o = 3e3, i = (/* @__PURE__ */ new Date()).getTime(), s = BigInt(-1);
      for (; s < r; ) {
        if ((/* @__PURE__ */ new Date()).getTime() - i > o) throw new Error("waitForLastSuccessIndexerVersionSync timeout");
        if (t === void 0 ? s = await Hn({ aptosConfig: e }) : s = (await Qn({ aptosConfig: e, processorType: t })).last_success_version, s >= r) break;
        await _chunkBHKSQXUZjs.b.call(void 0, 200);
      }
    }
    var Xn = class extends Error {
      constructor(e, t) {
        super(e), this.lastSubmittedTransaction = t;
      }
    };
    var Hr = class extends Error {
      constructor(e, t) {
        super(e), this.transaction = t;
      }
    };
    async function Di(n) {
      let { aptosConfig: e, ledgerVersion: t, options: r } = n, { data: o } = await V({ aptosConfig: e, originMethod: "getBlockByVersion", path: `blocks/by_version/${t}`, params: { with_transactions: _optionalChain([r, "optionalAccess", (_102) => _102.withTransactions]) } });
      return Gi({ block: o, ...n });
    }
    async function Bi(n) {
      let { aptosConfig: e, blockHeight: t, options: r } = n, { data: o } = await V({ aptosConfig: e, originMethod: "getBlockByHeight", path: `blocks/by_height/${t}`, params: { with_transactions: _optionalChain([r, "optionalAccess", (_103) => _103.withTransactions]) } });
      return Gi({ block: o, ...n });
    }
    async function Gi(n) {
      let { aptosConfig: e, block: t, options: r } = n;
      if (_optionalChain([r, "optionalAccess", (_104) => _104.withTransactions])) {
        t.transactions = _nullishCoalesce(t.transactions, () => []);
        let o = t.transactions[t.transactions.length - 1], i = BigInt(t.first_version), s = BigInt(t.last_version), a = _optionalChain([o, "optionalAccess", (_105) => _105.version]), c;
        if (a === void 0 ? c = i - 1n : c = BigInt(a), c === s) return t;
        let p = [], y = 100n;
        for (let S = c + 1n; S < s; S += BigInt(100)) p.push(Qr({ aptosConfig: e, options: { offset: S, limit: Math.min(Number(y), Number(s - S + 1n)) } }));
        let w = await Promise.all(p);
        for (let S of w) t.transactions.push(...S);
      }
      return t;
    }
    async function A(n) {
      n.minimumLedgerVersion !== void 0 && await Zn({ aptosConfig: n.config, minimumLedgerVersion: n.minimumLedgerVersion, processorType: n.processorType });
    }
    var sn = class {
      constructor(e) {
        this.config = e;
      }
      async getAccountInfo(e) {
        return Se({ aptosConfig: this.config, ...e });
      }
      async getAccountModules(e) {
        return bi({ aptosConfig: this.config, ...e });
      }
      async getAccountModule(e) {
        return jn({ aptosConfig: this.config, ...e });
      }
      async getAccountTransactions(e) {
        return wi({ aptosConfig: this.config, ...e });
      }
      async getAccountResources(e) {
        return Si({ aptosConfig: this.config, ...e });
      }
      async getAccountResource(e) {
        return $r({ aptosConfig: this.config, ...e });
      }
      async lookupOriginalAccountAddress(e) {
        return rn({ aptosConfig: this.config, ...e });
      }
      async getAccountTokensCount(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "account_transactions_processor" }), _i({ aptosConfig: this.config, ...e });
      }
      async getAccountOwnedTokens(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), xi({ aptosConfig: this.config, ...e });
      }
      async getAccountOwnedTokensFromCollectionAddress(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), Pi({ aptosConfig: this.config, ...e });
      }
      async getAccountCollectionsWithOwnedTokens(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), vi({ aptosConfig: this.config, ...e });
      }
      async getAccountTransactionsCount(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "account_transactions_processor" }), Ci({ aptosConfig: this.config, ...e });
      }
      async getAccountCoinsData(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "fungible_asset_processor" }), Lr({ aptosConfig: this.config, ...e });
      }
      async getAccountCoinsCount(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "fungible_asset_processor" }), Ii({ aptosConfig: this.config, ...e });
      }
      async getAccountAPTAmount(e) {
        return this.getAccountCoinAmount({ coinType: ot, ...e });
      }
      async getAccountCoinAmount(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "fungible_asset_processor" }), Ei({ aptosConfig: this.config, ...e });
      }
      async getAccountOwnedObjects(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "default_processor" }), Ui({ aptosConfig: this.config, ...e });
      }
      async deriveAccountFromPrivateKey(e) {
        return Ri({ aptosConfig: this.config, ...e });
      }
    };
    var _aptosclient = require_index_browser();
    var _aptosclient2 = _interopRequireDefault(_aptosclient);
    var Jn = class {
      constructor(e) {
        this.network = _nullishCoalesce(_optionalChain([e, "optionalAccess", (_106) => _106.network]), () => "devnet"), this.fullnode = _optionalChain([e, "optionalAccess", (_107) => _107.fullnode]), this.faucet = _optionalChain([e, "optionalAccess", (_108) => _108.faucet]), this.pepper = _optionalChain([e, "optionalAccess", (_109) => _109.pepper]), this.prover = _optionalChain([e, "optionalAccess", (_110) => _110.prover]), this.indexer = _optionalChain([e, "optionalAccess", (_111) => _111.indexer]), this.client = _nullishCoalesce(_optionalChain([e, "optionalAccess", (_112) => _112.client]), () => ({ provider: _aptosclient2.default })), this.clientConfig = _nullishCoalesce(_optionalChain([e, "optionalAccess", (_113) => _113.clientConfig]), () => ({})), this.fullnodeConfig = _nullishCoalesce(_optionalChain([e, "optionalAccess", (_114) => _114.fullnodeConfig]), () => ({})), this.indexerConfig = _nullishCoalesce(_optionalChain([e, "optionalAccess", (_115) => _115.indexerConfig]), () => ({})), this.faucetConfig = _nullishCoalesce(_optionalChain([e, "optionalAccess", (_116) => _116.faucetConfig]), () => ({}));
      }
      getRequestUrl(e) {
        switch (e) {
          case "Fullnode":
            if (this.fullnode !== void 0) return this.fullnode;
            if (this.network === "custom") throw new Error("Please provide a custom full node url");
            return Mo[this.network];
          case "Faucet":
            if (this.faucet !== void 0) return this.faucet;
            if (this.network === "custom") throw new Error("Please provide a custom faucet url");
            return qo[this.network];
          case "Indexer":
            if (this.indexer !== void 0) return this.indexer;
            if (this.network === "custom") throw new Error("Please provide a custom indexer url");
            return Fo[this.network];
          case "Pepper":
            if (this.pepper !== void 0) return this.pepper;
            if (this.network === "custom") throw new Error("Please provide a custom pepper service url");
            return Ir[this.network];
          case "Prover":
            if (this.prover !== void 0) return this.prover;
            if (this.network === "custom") throw new Error("Please provide a custom prover service url");
            return Ur[this.network];
          default:
            throw Error(`apiType ${e} is not supported`);
        }
      }
      isPepperServiceRequest(e) {
        return Ir[this.network] === e;
      }
      isProverServiceRequest(e) {
        return Ur[this.network] === e;
      }
    };
    function Ki(n) {
      return !!n.match(/^[_a-zA-Z0-9]+$/);
    }
    function Ni(n) {
      return !!n.match(/\s/);
    }
    function pc(n) {
      return !!n.match(/^T[0-9]+$/);
    }
    function dc(n) {
      return !!n.match(/^&.+$/);
    }
    function lc(n) {
      switch (n) {
        case "signer":
        case "address":
        case "bool":
        case "u8":
        case "u16":
        case "u32":
        case "u64":
        case "u128":
        case "u256":
          return true;
        default:
          return false;
      }
    }
    function gc(n, e) {
      let t = e;
      for (; t < n.length; t += 1) {
        let r = n[t];
        if (!Ni(r)) break;
      }
      return t;
    }
    var mc = ((E) => (E.InvalidTypeTag = "unknown type", E.UnexpectedGenericType = "unexpected generic type", E.UnexpectedTypeArgumentClose = "unexpected '>'", E.UnexpectedWhitespaceCharacter = "unexpected whitespace character", E.UnexpectedComma = "unexpected ','", E.TypeArgumentCountMismatch = "type argument count doesn't match expected amount", E.MissingTypeArgumentClose = "no matching '>' for '<'", E.MissingTypeArgument = "no type argument before ','", E.UnexpectedPrimitiveTypeArguments = "primitive types not expected to have type arguments", E.UnexpectedVectorTypeArgumentCount = "vector type expected to have exactly one type argument", E.UnexpectedStructFormat = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name", E.InvalidModuleNameCharacter = "module name must only contain alphanumeric or '_' characters", E.InvalidStructNameCharacter = "struct name must only contain alphanumeric or '_' characters", E.InvalidAddress = "struct address must be valid", E))(mc || {});
    var N = exports.TypeTagParserError = class extends Error {
      constructor(e, t) {
        super(`Failed to parse typeTag '${e}', ${t}`);
      }
    };
    function ze(n, e) {
      let t = _nullishCoalesce(_optionalChain([e, "optionalAccess", (_117) => _117.allowGenerics]), () => false), r = [], o = [], i = [], s = 0, a = "", c = 1;
      for (; s < n.length; ) {
        let p = n[s];
        if (p === "<") r.push({ savedExpectedTypes: c, savedStr: a, savedTypes: i }), a = "", i = [], c = 1;
        else if (p === ">") {
          if (a !== "") {
            let E = an(a, o, t);
            i.push(E);
          }
          let y = r.pop();
          if (y === void 0) throw new N(n, "unexpected '>'");
          if (c !== i.length) throw new N(n, "type argument count doesn't match expected amount");
          let { savedStr: w, savedTypes: S, savedExpectedTypes: g } = y;
          o = i, i = S, a = w, c = g;
        } else if (p === ",") {
          if (r.length === 0) throw new N(n, "unexpected ','");
          if (a.length === 0) throw new N(n, "no type argument before ','");
          let y = an(a, o, t);
          o = [], i.push(y), a = "", c += 1;
        } else if (Ni(p)) {
          let y = false;
          if (a.length !== 0) {
            let S = an(a, o, t);
            o = [], i.push(S), a = "", y = true;
          }
          s = gc(n, s);
          let w = n[s];
          if (s < n.length && y && w !== "," && w !== ">") throw new N(n, "unexpected whitespace character");
          continue;
        } else a += p;
        s += 1;
      }
      if (r.length > 0) throw new N(n, "no matching '>' for '<'");
      switch (i.length) {
        case 0:
          return an(a, o, t);
        case 1:
          if (a === "") return i[0];
          throw new N(n, "unexpected ','");
        default:
          throw new N(n, "unexpected whitespace character");
      }
    }
    function an(n, e, t) {
      let r = n.trim(), o = r.toLowerCase();
      if (lc(o) && e.length > 0) throw new N(n, "primitive types not expected to have type arguments");
      switch (r.toLowerCase()) {
        case "signer":
          return new vt();
        case "bool":
          return new K();
        case "address":
          return new W();
        case "u8":
          return new ce();
        case "u16":
          return new Me();
        case "u32":
          return new qe();
        case "u64":
          return new $();
        case "u128":
          return new Ve();
        case "u256":
          return new $e();
        case "vector":
          if (e.length !== 1) throw new N(n, "vector type expected to have exactly one type argument");
          return new C(e[0]);
        default:
          if (dc(r)) {
            let a = r.substring(1);
            return new Kn(an(a, e, t));
          }
          if (pc(r)) {
            if (t) return new k(Number(r.split("T")[1]));
            throw new N(n, "unexpected generic type");
          }
          if (!r.match(/:/)) throw new N(n, "unknown type");
          let i = r.split("::");
          if (i.length !== 3) throw new N(n, "unexpected struct format, must be of the form 0xaddress::module_name::struct_name");
          let s;
          try {
            s = u.fromString(i[0]);
          } catch (e2) {
            throw new N(n, "struct address must be valid");
          }
          if (!Ki(i[1])) throw new N(n, "module name must only contain alphanumeric or '_' characters");
          if (!Ki(i[2])) throw new N(n, "struct name must only contain alphanumeric or '_' characters");
          return new m(new Ue(s, new R(i[1]), new R(i[2]), e));
      }
    }
    function Oi(n) {
      return typeof n == "boolean";
    }
    function Qe(n) {
      return typeof n == "string";
    }
    function yc(n) {
      return typeof n == "number";
    }
    function er(n) {
      if (yc(n)) return n;
      if (Qe(n) && n !== "") return Number.parseInt(n, 10);
    }
    function tr(n) {
      return typeof n == "number" || typeof n == "bigint" || typeof n == "string";
    }
    function Fi(n) {
      return n == null;
    }
    function Mi(n) {
      return Wr(n) || Xr(n) || Yr(n) || Zr(n) || Jr(n) || eo(n) || to(n) || nr(n) || jr(n) || fc(n) || n instanceof T || n instanceof M;
    }
    function Wr(n) {
      return n instanceof I;
    }
    function nr(n) {
      return n instanceof u;
    }
    function jr(n) {
      return n instanceof b;
    }
    function fc(n) {
      return n instanceof Je;
    }
    function Xr(n) {
      return n instanceof F;
    }
    function Yr(n) {
      return n instanceof de;
    }
    function Zr(n) {
      return n instanceof le;
    }
    function Jr(n) {
      return n instanceof O;
    }
    function eo(n) {
      return n instanceof ge;
    }
    function to(n) {
      return n instanceof me;
    }
    function qi(n) {
      return "bytecode" in n;
    }
    function U(n, e) {
      throw new Error(`Type mismatch for argument ${e}, expected '${n}'`);
    }
    function Vi(n) {
      let e = n.params.findIndex((t) => t !== "signer" && t !== "&signer");
      return e < 0 ? n.params.length : e;
    }
    function cn(n) {
      let e = n.split("::");
      if (e.length !== 3) throw new Error(`Invalid function ${n}`);
      let t = e[0], r = e[1], o = e[2];
      return { moduleAddress: t, moduleName: r, functionName: o };
    }
    var Ac = new TextEncoder();
    function rr(n) {
      return _nullishCoalesce(_optionalChain([n, "optionalAccess", (_118) => _118.map, "call", (_119) => _119((e) => Qe(e) ? ze(e) : e)]), () => []);
    }
    async function $i(n, e, t, r) {
      let o = await jn({ aptosConfig: r, accountAddress: n, moduleName: e });
      if (o.abi) return o.abi.exposed_functions.find((i) => i.name === t);
    }
    async function Li(n, e, t, r) {
      let o = await $i(n, e, t, r);
      if (!o) throw new Error(`Could not find entry function ABI for '${n}::${e}::${t}'`);
      if (!o.is_entry) throw new Error(`'${n}::${e}::${t}' is not an entry function`);
      let i = Vi(o), s = [];
      for (let a = i; a < o.params.length; a += 1) s.push(ze(o.params[a], { allowGenerics: true }));
      return { signers: i, typeParameters: o.generic_type_params, parameters: s };
    }
    async function Hi(n, e, t, r) {
      let o = await $i(n, e, t, r);
      if (!o) throw new Error(`Could not find view function ABI for '${n}::${e}::${t}'`);
      if (!o.is_view) throw new Error(`'${n}::${e}::${t}' is not an view function`);
      let i = [];
      for (let a = 0; a < o.params.length; a += 1) i.push(ze(o.params[a], { allowGenerics: true }));
      let s = [];
      for (let a = 0; a < o.return.length; a += 1) s.push(ze(o.return[a], { allowGenerics: true }));
      return { typeParameters: o.generic_type_params, parameters: i, returnTypes: s };
    }
    function ro(n, e, t, r, o) {
      if (r >= e.parameters.length) throw new Error(`Too many arguments for '${n}', expected ${e.parameters.length}`);
      let i = e.parameters[r];
      return Nt(t, i, r, o);
    }
    function Nt(n, e, t, r) {
      return Mi(n) ? (no(e, n, t), n) : hc(n, e, t, r);
    }
    function hc(n, e, t, r) {
      if (e.isBool()) {
        if (Oi(n)) return new I(n);
        if (Qe(n)) {
          if (n === "true") return new I(true);
          if (n === "false") return new I(false);
        }
        U("boolean", t);
      }
      if (e.isAddress()) {
        if (Qe(n)) return u.fromString(n);
        U("string | AccountAddress", t);
      }
      if (e.isU8()) {
        let o = er(n);
        if (o !== void 0) return new F(o);
        U("number | string", t);
      }
      if (e.isU16()) {
        let o = er(n);
        if (o !== void 0) return new de(o);
        U("number | string", t);
      }
      if (e.isU32()) {
        let o = er(n);
        if (o !== void 0) return new le(o);
        U("number | string", t);
      }
      if (e.isU64()) {
        if (tr(n)) return new O(BigInt(n));
        U("bigint | number | string", t);
      }
      if (e.isU128()) {
        if (tr(n)) return new ge(BigInt(n));
        U("bigint | number | string", t);
      }
      if (e.isU256()) {
        if (tr(n)) return new me(BigInt(n));
        U("bigint | number | string", t);
      }
      if (e.isGeneric()) {
        let o = e.value;
        if (o < 0 || o >= r.length) throw new Error(`Generic argument ${e.toString()} is invalid for argument ${t}`);
        return Nt(n, r[o], t, r);
      }
      if (e.isVector()) {
        if (e.value.isU8()) {
          if (Qe(n)) return T.U8(Ac.encode(n));
          if (n instanceof Uint8Array) return T.U8(n);
          if (n instanceof ArrayBuffer) return T.U8(new Uint8Array(n));
        }
        if (Array.isArray(n)) return new T(n.map((o) => Nt(o, e.value, t, r)));
        throw new Error(`Type mismatch for argument ${t}, type '${e.toString()}'`);
      }
      if (e.isStruct()) {
        if (e.isString()) {
          if (Qe(n)) return new b(n);
          U("string", t);
        }
        if (e.isObject()) {
          if (Qe(n)) return u.fromString(n);
          U("string | AccountAddress", t);
        }
        if (e.isOption()) {
          if (Fi(n)) {
            let o = e.value.typeArgs[0];
            return o instanceof K ? new M(null) : o instanceof W ? new M(null) : o instanceof ce ? new M(null) : o instanceof Me ? new M(null) : o instanceof qe ? new M(null) : o instanceof $ ? new M(null) : o instanceof Ve ? new M(null) : o instanceof $e ? new M(null) : new M(null);
          }
          return new M(Nt(n, e.value.typeArgs[0], t, r));
        }
        throw new Error(`Unsupported struct input type for argument ${t}, type '${e.toString()}'`);
      }
      throw new Error(`Type mismatch for argument ${t}, type '${e.toString()}'`);
    }
    function no(n, e, t) {
      if (n.isBool()) {
        if (Wr(e)) return;
        U("Bool", t);
      }
      if (n.isAddress()) {
        if (nr(e)) return;
        U("AccountAddress", t);
      }
      if (n.isU8()) {
        if (Xr(e)) return;
        U("U8", t);
      }
      if (n.isU16()) {
        if (Yr(e)) return;
        U("U16", t);
      }
      if (n.isU32()) {
        if (Zr(e)) return;
        U("U32", t);
      }
      if (n.isU64()) {
        if (Jr(e)) return;
        U("U64", t);
      }
      if (n.isU128()) {
        if (eo(e)) return;
        U("U128", t);
      }
      if (n.isU256()) {
        if (to(e)) return;
        U("U256", t);
      }
      if (n.isVector()) {
        if (e instanceof T) {
          e.values.length > 0 && no(n.value, e.values[0], t);
          return;
        }
        U("MoveVector", t);
      }
      if (n instanceof m) {
        if (n.isString()) {
          if (jr(e)) return;
          U("MoveString", t);
        }
        if (n.isObject()) {
          if (nr(e)) return;
          U("AccountAddress", t);
        }
        if (n.isOption()) {
          if (e instanceof M) {
            e.value !== void 0 && no(n.value.typeArgs[0], e.value, t);
            return;
          }
          U("MoveOption", t);
        }
      }
      throw new Error(`Type mismatch for argument ${t}, expected '${n.toString()}'`);
    }
    async function ir(n) {
      if (qi(n)) return Sc(n);
      let { moduleAddress: e, moduleName: t, functionName: r } = cn(n.function), o = await Xi({ key: "entry-function", moduleAddress: e, moduleName: t, functionName: r, aptosConfig: n.aptosConfig, abi: n.abi, fetch: Li });
      return bc({ ...n, abi: o });
    }
    function bc(n) {
      let e = n.abi, { moduleAddress: t, moduleName: r, functionName: o } = cn(n.function), i = rr(n.typeArguments);
      if (i.length !== e.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${e.typeParameters.length}, received ${i.length}`);
      let s = n.functionArguments.map((c, p) => ro(n.function, e, c, p, i));
      if (s.length !== e.parameters.length) throw new Error(`Too few arguments for '${t}::${r}::${o}', expected ${e.parameters.length} but got ${s.length}`);
      let a = ut.build(`${t}::${r}`, o, i, s);
      if ("multisigAddress" in n) {
        let c = u.from(n.multisigAddress);
        return new Zt(new en(c, new tn(a)));
      }
      return new Yt(a);
    }
    async function Qi(n) {
      let { moduleAddress: e, moduleName: t, functionName: r } = cn(n.function), o = await Xi({ key: "view-function", moduleAddress: e, moduleName: t, functionName: r, aptosConfig: n.aptosConfig, abi: n.abi, fetch: Hi });
      return wc({ abi: o, ...n });
    }
    function wc(n) {
      let e = n.abi, { moduleAddress: t, moduleName: r, functionName: o } = cn(n.function), i = rr(n.typeArguments);
      if (i.length !== e.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${e.typeParameters.length}, received ${i.length}`);
      let s = _nullishCoalesce(_optionalChain([n, "optionalAccess", (_120) => _120.functionArguments, "optionalAccess", (_121) => _121.map, "call", (_122) => _122((a, c) => ro(n.function, e, a, c, i))]), () => []);
      if (s.length !== e.parameters.length) throw new Error(`Too few arguments for '${t}::${r}::${o}', expected ${e.parameters.length} but got ${s.length}`);
      return ut.build(`${t}::${r}`, o, i, s);
    }
    function Sc(n) {
      return new Xt(new Jt(l.fromHexInput(n.bytecode).toUint8Array(), rr(n.typeArguments), n.functionArguments));
    }
    async function _c(n) {
      let { aptosConfig: e, sender: t, payload: r, options: o, feePayerAddress: i } = n, s = async () => zr[e.network] ? { chainId: zr[e.network] } : { chainId: (await Ln({ aptosConfig: e })).chain_id }, a = async () => _optionalChain([o, "optionalAccess", (_123) => _123.gasUnitPrice]) ? { gasEstimate: o.gasUnitPrice } : { gasEstimate: (await Yn({ aptosConfig: e })).gas_estimate }, c = async () => {
        let gt = async () => _optionalChain([o, "optionalAccess", (_124) => _124.accountSequenceNumber]) !== void 0 ? o.accountSequenceNumber : (await Se({ aptosConfig: e, accountAddress: t })).sequence_number;
        if (i && u.from(i).equals(u.ZERO)) try {
          return await gt();
        } catch (e3) {
          return 0;
        }
        else return gt();
      }, [{ chainId: p }, { gasEstimate: y }, w] = await Promise.all([s(), a(), c()]), { maxGasAmount: S, gasUnitPrice: g, expireTimestamp: E } = { maxGasAmount: _optionalChain([o, "optionalAccess", (_125) => _125.maxGasAmount]) ? BigInt(o.maxGasAmount) : BigInt(2e5), gasUnitPrice: _nullishCoalesce(_optionalChain([o, "optionalAccess", (_126) => _126.gasUnitPrice]), () => BigInt(y)), expireTimestamp: _nullishCoalesce(_optionalChain([o, "optionalAccess", (_127) => _127.expireTimestamp]), () => BigInt(Math.floor(Date.now() / 1e3) + 20)) };
      return new ue(u.from(t), BigInt(w), r, BigInt(S), BigInt(g), BigInt(E), new Pt(p));
    }
    async function oo(n) {
      let { aptosConfig: e, sender: t, payload: r, options: o, feePayerAddress: i } = n, s = await _c({ aptosConfig: e, sender: t, payload: r, options: o, feePayerAddress: i });
      if ("secondarySignerAddresses" in n) {
        let a = _nullishCoalesce(_optionalChain([n, "access", (_128) => _128.secondarySignerAddresses, "optionalAccess", (_129) => _129.map, "call", (_130) => _130((c) => u.from(c))]), () => []);
        return new Mn(s, a, n.feePayerAddress ? u.from(n.feePayerAddress) : void 0);
      }
      return new Fn(s, n.feePayerAddress ? u.from(n.feePayerAddress) : void 0);
    }
    function Wi(n) {
      let { signerPublicKey: e, transaction: t, secondarySignersPublicKeys: r, feePayerPublicKey: o } = n, i = or(e);
      if (t.feePayerAddress) {
        let a = new dt(t.rawTransaction, _nullishCoalesce(t.secondarySignerAddresses, () => []), t.feePayerAddress), c = [];
        r && (c = r.map((w) => or(w)));
        let p = or(o), y = new It(i, _nullishCoalesce(t.secondarySignerAddresses, () => []), c, { address: t.feePayerAddress, authenticator: p });
        return new lt(a.raw_txn, y).bcsToBytes();
      }
      if (t.secondarySignerAddresses) {
        let a = new pt(t.rawTransaction, t.secondarySignerAddresses), c = [];
        c = r.map((y) => or(y));
        let p = new Et(i, t.secondarySignerAddresses, c);
        return new lt(a.raw_txn, p).bcsToBytes();
      }
      let s;
      if (i instanceof fe) s = new Ct(i.public_key, i.signature);
      else if (i instanceof Q) s = new Ut(i);
      else throw new Error("Invalid public key");
      return new lt(t.rawTransaction, s).bcsToBytes();
    }
    function or(n) {
      let e = new v(new Uint8Array(64));
      if (x.isInstance(n)) return new fe(n, e);
      if (D.isInstance(n)) return ee.isInstance(n.publicKey) ? new Q(n, new G(Ee.getSimulationSignature())) : new Q(n, new G(e));
      if (ee.isInstance(n) || Pe.isInstance(n)) return console.warn("Expected AccountPublicKey, but got PublicKey. Please wrap your public key with AnyPublicKey."), new Q(new D(n), new G(e));
      throw new Error("Unsupported public key");
    }
    function io(n) {
      let { transaction: e, feePayerAuthenticator: t, additionalSignersAuthenticators: r } = n, o = Vo(H, n.senderAuthenticator), i;
      if (e.feePayerAddress) {
        if (!t) throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
        i = new It(o, _nullishCoalesce(e.secondarySignerAddresses, () => []), _nullishCoalesce(r, () => []), { address: e.feePayerAddress, authenticator: t });
      } else if (e.secondarySignerAddresses) {
        if (!r) throw new Error("Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction");
        i = new Et(o, e.secondarySignerAddresses, r);
      } else o instanceof fe ? i = new Ct(o.public_key, o.signature) : i = new Ut(o);
      return new lt(e.rawTransaction, i).bcsToBytes();
    }
    function ji(n) {
      let e = _sha3.sha3_256.create();
      for (let t of n) e.update(t);
      return e.digest();
    }
    var xc = ji(["APTOS::Transaction"]);
    function nh(n) {
      let e = io(n);
      return new l(ji([xc, new Uint8Array([0]), e])).toString();
    }
    async function Xi({ key: n, moduleAddress: e, moduleName: t, functionName: r, aptosConfig: o, abi: i, fetch: s }) {
      return i !== void 0 ? i : Fe(async () => s(e, t, r, o), `${n}-${o.network}-${e}-${t}-${r}`, 1e3 * 60 * 5)();
    }
    async function h(n) {
      let e = await Pc(n);
      return vc(n, e);
    }
    async function Pc(n) {
      let { aptosConfig: e, data: t } = n, r, o;
      return "bytecode" in t ? o = await ir(t) : "multisigAddress" in t ? (r = { aptosConfig: e, multisigAddress: t.multisigAddress, function: t.function, functionArguments: t.functionArguments, typeArguments: t.typeArguments, abi: t.abi }, o = await ir(r)) : (r = { aptosConfig: e, function: t.function, functionArguments: t.functionArguments, typeArguments: t.typeArguments, abi: t.abi }, o = await ir(r)), o;
    }
    async function vc(n, e) {
      let { aptosConfig: t, sender: r, options: o } = n, i;
      if (Cc(n) && (i = u.ZERO.toString()), Ec(n)) {
        let { secondarySignerAddresses: s } = n;
        return oo({ aptosConfig: t, sender: r, payload: e, options: o, secondarySignerAddresses: s, feePayerAddress: i });
      }
      return oo({ aptosConfig: t, sender: r, payload: e, options: o, feePayerAddress: i });
    }
    function Cc(n) {
      return n.withFeePayer === true;
    }
    function Ec(n) {
      return "secondarySignerAddresses" in n;
    }
    function Yi(n) {
      let { transaction: e } = n;
      return zt(e);
    }
    function sr(n) {
      let { signer: e, transaction: t } = n;
      return e.signTransactionWithAuthenticator(t);
    }
    async function so(n) {
      let { aptosConfig: e, transaction: t, signerPublicKey: r, secondarySignersPublicKeys: o, feePayerPublicKey: i, options: s } = n, a = Wi({ transaction: t, signerPublicKey: r, secondarySignersPublicKeys: o, feePayerPublicKey: i, options: s }), { data: c } = await Oe({ aptosConfig: e, body: a, path: "transactions/simulate", params: { estimate_gas_unit_price: _nullishCoalesce(_optionalChain([n, "access", (_131) => _131.options, "optionalAccess", (_132) => _132.estimateGasUnitPrice]), () => false), estimate_max_gas_amount: _nullishCoalesce(_optionalChain([n, "access", (_133) => _133.options, "optionalAccess", (_134) => _134.estimateMaxGasAmount]), () => false), estimate_prioritized_gas_unit_price: _nullishCoalesce(_optionalChain([n, "access", (_135) => _135.options, "optionalAccess", (_136) => _136.estimatePrioritizedGasUnitPrice]), () => false) }, originMethod: "simulateTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
      return c;
    }
    async function ar(n) {
      let { aptosConfig: e } = n, t = io({ ...n }), { data: r } = await Oe({ aptosConfig: e, body: t, path: "transactions", originMethod: "submitTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
      return r;
    }
    async function un(n) {
      let { aptosConfig: e, signer: t, transaction: r } = n;
      (t instanceof we || t instanceof qn) && await t.waitForProofFetch();
      let o = sr({ signer: t, transaction: r });
      return ar({ aptosConfig: e, transaction: r, senderAuthenticator: o });
    }
    var Ic = { typeParameters: [], parameters: [C.u8(), new C(C.u8())] };
    async function Zi(n) {
      let { aptosConfig: e, account: t, metadataBytes: r, moduleBytecode: o, options: i } = n, s = o.map((a) => T.U8(a));
      return h({ aptosConfig: e, sender: u.from(t), data: { function: "0x1::code::publish_package_txn", functionArguments: [T.U8(r), new T(s)], abi: Ic }, options: i });
    }
    var Uc = { typeParameters: [], parameters: [new ce(), C.u8(), new ce(), C.u8(), C.u8(), C.u8()] };
    async function Ji(n) {
      let { aptosConfig: e, fromAccount: t, toNewPrivateKey: r } = n, o = await Se({ aptosConfig: e, accountAddress: t.accountAddress }), i = Le.fromPrivateKey({ privateKey: r, legacy: true }), a = new On({ sequenceNumber: BigInt(o.sequence_number), originator: t.accountAddress, currentAuthKey: u.from(o.authentication_key), newPublicKey: i.publicKey }).bcsToBytes(), c = t.sign(a), p = i.sign(a), y = await h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x1::account::rotate_authentication_key", functionArguments: [new F(t.signingScheme), T.U8(t.publicKey.toUint8Array()), new F(i.signingScheme), T.U8(i.publicKey.toUint8Array()), T.U8(c.toUint8Array()), T.U8(p.toUint8Array())], abi: Uc } });
      return un({ aptosConfig: e, signer: t, transaction: y });
    }
    var Rc = { typeParameters: [{ constraints: [] }], parameters: [new W(), new $()] };
    async function es(n) {
      let { aptosConfig: e, sender: t, recipient: r, amount: o, coinType: i, options: s } = n;
      return h({ aptosConfig: e, sender: t, data: { function: "0x1::aptos_account::transfer_coins", typeArguments: [_nullishCoalesce(i, () => ot)], functionArguments: [r, o], abi: Rc }, options: s });
    }
    var pn = class {
      constructor(e) {
        this.config = e;
      }
      async transferCoinTransaction(e) {
        return es({ aptosConfig: this.config, ...e });
      }
    };
    var We = { BOOLEAN: "bool", U8: "u8", U16: "u16", U32: "u32", U64: "u64", U128: "u128", U256: "u256", ADDRESS: "address", STRING: "0x1::string::String", ARRAY: "vector<u8>" };
    var pe = "0x4::token::Token";
    async function ts(n) {
      let { aptosConfig: e, digitalAssetAddress: t } = n, r = { token_data_id: { _eq: u.from(t).toStringLong() } };
      return (await f({ aptosConfig: e, query: { query: mi, variables: { where_condition: r } }, originMethod: "getDigitalAssetData" })).current_token_datas_v2[0];
    }
    async function ns(n) {
      let { aptosConfig: e, digitalAssetAddress: t } = n, r = { token_data_id: { _eq: u.from(t).toStringLong() }, amount: { _gt: 0 } };
      return (await f({ aptosConfig: e, query: { query: Vr, variables: { where_condition: r } }, originMethod: "getCurrentDigitalAssetOwnership" })).current_token_ownerships_v2[0];
    }
    async function rs(n) {
      let { aptosConfig: e, ownerAddress: t, options: r } = n, o = { owner_address: { _eq: u.from(t).toStringLong() }, amount: { _gt: 0 } }, i = { query: Vr, variables: { where_condition: o, offset: _optionalChain([r, "optionalAccess", (_137) => _137.offset]), limit: _optionalChain([r, "optionalAccess", (_138) => _138.limit]), order_by: _optionalChain([r, "optionalAccess", (_139) => _139.orderBy]) } };
      return (await f({ aptosConfig: e, query: i, originMethod: "getOwnedDigitalAssets" })).current_token_ownerships_v2;
    }
    async function os(n) {
      let { aptosConfig: e, digitalAssetAddress: t, options: r } = n, o = { token_data_id: { _eq: u.from(t).toStringLong() } }, i = { query: gi, variables: { where_condition: o, offset: _optionalChain([r, "optionalAccess", (_140) => _140.offset]), limit: _optionalChain([r, "optionalAccess", (_141) => _141.limit]), order_by: _optionalChain([r, "optionalAccess", (_142) => _142.orderBy]) } };
      return (await f({ aptosConfig: e, query: i, originMethod: "getDigitalAssetActivity" })).token_activities_v2;
    }
    var zc = { typeParameters: [], parameters: [new m(P()), new $(), new m(P()), new m(P()), new K(), new K(), new K(), new K(), new K(), new K(), new K(), new K(), new K(), new $(), new $()] };
    async function is(n) {
      let { aptosConfig: e, options: t, creator: r } = n;
      return h({ aptosConfig: e, sender: r.accountAddress, data: { function: "0x4::aptos_token::create_collection", functionArguments: [new b(n.description), new O(_nullishCoalesce(n.maxSupply, () => Ye)), new b(n.name), new b(n.uri), new I(_nullishCoalesce(n.mutableDescription, () => true)), new I(_nullishCoalesce(n.mutableRoyalty, () => true)), new I(_nullishCoalesce(n.mutableURI, () => true)), new I(_nullishCoalesce(n.mutableTokenDescription, () => true)), new I(_nullishCoalesce(n.mutableTokenName, () => true)), new I(_nullishCoalesce(n.mutableTokenProperties, () => true)), new I(_nullishCoalesce(n.mutableTokenURI, () => true)), new I(_nullishCoalesce(n.tokensBurnableByCreator, () => true)), new I(_nullishCoalesce(n.tokensFreezableByCreator, () => true)), new O(_nullishCoalesce(n.royaltyNumerator, () => 0)), new O(_nullishCoalesce(n.royaltyDenominator, () => 1))], abi: zc }, options: t });
    }
    async function Ot(n) {
      let { aptosConfig: e, options: t } = n, r = _optionalChain([t, "optionalAccess", (_143) => _143.where]);
      _optionalChain([t, "optionalAccess", (_144) => _144.tokenStandard]) && (r.token_standard = { _eq: _nullishCoalesce(_optionalChain([t, "optionalAccess", (_145) => _145.tokenStandard]), () => "v2") });
      let o = { query: ii, variables: { where_condition: r, offset: _optionalChain([t, "optionalAccess", (_146) => _146.offset]), limit: _optionalChain([t, "optionalAccess", (_147) => _147.limit]) } };
      return (await f({ aptosConfig: e, query: o, originMethod: "getCollectionData" })).current_collections_v2[0];
    }
    async function ss(n) {
      let { aptosConfig: e, creatorAddress: t, collectionName: r, options: o } = n, i = u.from(t), s = { collection_name: { _eq: r }, creator_address: { _eq: i.toStringLong() } };
      return _optionalChain([o, "optionalAccess", (_148) => _148.tokenStandard]) && (s.token_standard = { _eq: _nullishCoalesce(_optionalChain([o, "optionalAccess", (_149) => _149.tokenStandard]), () => "v2") }), Ot({ aptosConfig: e, options: { ...o, where: s } });
    }
    async function as(n) {
      let { aptosConfig: e, creatorAddress: t, options: r } = n, i = { creator_address: { _eq: u.from(t).toStringLong() } };
      return _optionalChain([r, "optionalAccess", (_150) => _150.tokenStandard]) && (i.token_standard = { _eq: _nullishCoalesce(_optionalChain([r, "optionalAccess", (_151) => _151.tokenStandard]), () => "v2") }), Ot({ aptosConfig: e, options: { ...r, where: i } });
    }
    async function cs(n) {
      let { aptosConfig: e, collectionId: t, options: r } = n, i = { collection_id: { _eq: u.from(t).toStringLong() } };
      return _optionalChain([r, "optionalAccess", (_152) => _152.tokenStandard]) && (i.token_standard = { _eq: _nullishCoalesce(_optionalChain([r, "optionalAccess", (_153) => _153.tokenStandard]), () => "v2") }), Ot({ aptosConfig: e, options: { ...r, where: i } });
    }
    async function us(n) {
      let { creatorAddress: e, collectionName: t, options: r, aptosConfig: o } = n, i = u.from(e), s = { collection_name: { _eq: t }, creator_address: { _eq: i.toStringLong() } };
      return _optionalChain([r, "optionalAccess", (_154) => _154.tokenStandard]) && (s.token_standard = { _eq: _nullishCoalesce(_optionalChain([r, "optionalAccess", (_155) => _155.tokenStandard]), () => "v2") }), (await Ot({ aptosConfig: o, options: { where: s } })).collection_id;
    }
    var kc = { typeParameters: [], parameters: [new m(P()), new m(P()), new m(P()), new m(P()), new C(new m(P())), new C(new m(P())), new C(C.u8())] };
    async function ps(n) {
      let { aptosConfig: e, options: t, creator: r, collection: o, description: i, name: s, uri: a, propertyKeys: c, propertyTypes: p, propertyValues: y } = n, w = _optionalChain([p, "optionalAccess", (_156) => _156.map, "call", (_157) => _157((S) => We[S])]);
      return h({ aptosConfig: e, sender: r.accountAddress, data: { function: "0x4::aptos_token::mint", functionArguments: [new b(o), new b(i), new b(s), new b(a), T.MoveString(_nullishCoalesce(c, () => [])), T.MoveString(_nullishCoalesce(w, () => [])), xs(_nullishCoalesce(y, () => []), _nullishCoalesce(w, () => []))], abi: kc }, options: t });
    }
    var Dc = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0))), new W()] };
    async function ds(n) {
      let { aptosConfig: e, sender: t, digitalAssetAddress: r, recipient: o, digitalAssetType: i, options: s } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x1::object::transfer", typeArguments: [_nullishCoalesce(i, () => pe)], functionArguments: [u.from(r), u.from(o)], abi: Dc }, options: s });
    }
    var Bc = { typeParameters: [], parameters: [new m(P()), new m(P()), new m(P()), new m(P()), new C(new m(P())), new C(new m(P())), new C(C.u8()), new W()] };
    async function ls(n) {
      let { aptosConfig: e, account: t, collection: r, description: o, name: i, uri: s, recipient: a, propertyKeys: c, propertyTypes: p, propertyValues: y, options: w } = n;
      if (_optionalChain([c, "optionalAccess", (_158) => _158.length]) !== _optionalChain([y, "optionalAccess", (_159) => _159.length])) throw new Error("Property keys and property values counts do not match");
      if (_optionalChain([p, "optionalAccess", (_160) => _160.length]) !== _optionalChain([y, "optionalAccess", (_161) => _161.length])) throw new Error("Property types and property values counts do not match");
      let S = _optionalChain([p, "optionalAccess", (_162) => _162.map, "call", (_163) => _163((g) => We[g])]);
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::mint_soul_bound", functionArguments: [r, o, i, s, T.MoveString(_nullishCoalesce(c, () => [])), T.MoveString(_nullishCoalesce(S, () => [])), xs(_nullishCoalesce(y, () => []), _nullishCoalesce(S, () => [])), a], abi: Bc }, options: w });
    }
    var Gc = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0)))] };
    async function gs(n) {
      let { aptosConfig: e, creator: t, digitalAssetAddress: r, digitalAssetType: o, options: i } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::burn", typeArguments: [_nullishCoalesce(o, () => pe)], functionArguments: [u.from(r)], abi: Gc }, options: i });
    }
    var Kc = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0)))] };
    async function ms(n) {
      let { aptosConfig: e, creator: t, digitalAssetAddress: r, digitalAssetType: o, options: i } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::freeze_transfer", typeArguments: [_nullishCoalesce(o, () => pe)], functionArguments: [r], abi: Kc }, options: i });
    }
    var Nc = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0)))] };
    async function ys(n) {
      let { aptosConfig: e, creator: t, digitalAssetAddress: r, digitalAssetType: o, options: i } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::unfreeze_transfer", typeArguments: [_nullishCoalesce(o, () => pe)], functionArguments: [r], abi: Nc }, options: i });
    }
    var Oc = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0))), new m(P())] };
    async function fs(n) {
      let { aptosConfig: e, creator: t, description: r, digitalAssetAddress: o, digitalAssetType: i, options: s } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::set_description", typeArguments: [_nullishCoalesce(i, () => pe)], functionArguments: [u.from(o), new b(r)], abi: Oc }, options: s });
    }
    var Fc = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0))), new m(P())] };
    async function As(n) {
      let { aptosConfig: e, creator: t, name: r, digitalAssetAddress: o, digitalAssetType: i, options: s } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::set_name", typeArguments: [_nullishCoalesce(i, () => pe)], functionArguments: [u.from(o), new b(r)], abi: Fc }, options: s });
    }
    var Mc = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0))), new m(P())] };
    async function hs(n) {
      let { aptosConfig: e, creator: t, uri: r, digitalAssetAddress: o, digitalAssetType: i, options: s } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::set_uri", typeArguments: [_nullishCoalesce(i, () => pe)], functionArguments: [u.from(o), new b(r)], abi: Mc }, options: s });
    }
    var qc = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0))), new m(P()), new m(P()), C.u8()] };
    async function Ts(n) {
      let { aptosConfig: e, creator: t, propertyKey: r, propertyType: o, propertyValue: i, digitalAssetAddress: s, digitalAssetType: a, options: c } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::add_property", typeArguments: [_nullishCoalesce(a, () => pe)], functionArguments: [u.from(s), new b(r), new b(We[o]), T.U8(ao(i, We[o]))], abi: qc }, options: c });
    }
    var Vc = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0))), new m(P())] };
    async function bs(n) {
      let { aptosConfig: e, creator: t, propertyKey: r, digitalAssetAddress: o, digitalAssetType: i, options: s } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::remove_property", typeArguments: [_nullishCoalesce(i, () => pe)], functionArguments: [u.from(o), new b(r)], abi: Vc }, options: s });
    }
    var $c = { typeParameters: [{ constraints: ["key"] }], parameters: [new m(ne(new k(0))), new m(P()), new m(P()), C.u8()] };
    async function ws(n) {
      let { aptosConfig: e, creator: t, propertyKey: r, propertyType: o, propertyValue: i, digitalAssetAddress: s, digitalAssetType: a, options: c } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::update_property", typeArguments: [_nullishCoalesce(a, () => pe)], functionArguments: [u.from(s), new b(r), new b(We[o]), ao(i, We[o])], abi: $c }, options: c });
    }
    var Lc = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new m(ne(new k(0))), new m(P()), new k(1)] };
    async function Ss(n) {
      let { aptosConfig: e, creator: t, propertyKey: r, propertyType: o, propertyValue: i, digitalAssetAddress: s, digitalAssetType: a, options: c } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::add_typed_property", typeArguments: [_nullishCoalesce(a, () => pe), We[o]], functionArguments: [u.from(s), new b(r), i], abi: Lc }, options: c });
    }
    var Hc = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new m(ne(new k(0))), new m(P()), new k(1)] };
    async function _s(n) {
      let { aptosConfig: e, creator: t, propertyKey: r, propertyType: o, propertyValue: i, digitalAssetAddress: s, digitalAssetType: a, options: c } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x4::aptos_token::update_typed_property", typeArguments: [_nullishCoalesce(a, () => pe), We[o]], functionArguments: [u.from(s), new b(r), i], abi: Hc }, options: c });
    }
    function xs(n, e) {
      let t = new Array();
      return e.forEach((r, o) => {
        t.push(ao(n[o], r));
      }), t;
    }
    function ao(n, e) {
      let t = ze(e);
      return Nt(n, t, 0, []).bcsToBytes();
    }
    var dn = class {
      constructor(e) {
        this.config = e;
      }
      async getCollectionData(e) {
        await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" });
        let { creatorAddress: t, collectionName: r, options: o } = e, i = u.from(t), s = { collection_name: { _eq: r }, creator_address: { _eq: i.toStringLong() } };
        return _optionalChain([o, "optionalAccess", (_164) => _164.tokenStandard]) && (s.token_standard = { _eq: _nullishCoalesce(_optionalChain([o, "optionalAccess", (_165) => _165.tokenStandard]), () => "v2") }), Ot({ aptosConfig: this.config, options: { where: s } });
      }
      async getCollectionDataByCreatorAddressAndCollectionName(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), ss({ aptosConfig: this.config, ...e });
      }
      async getCollectionDataByCreatorAddress(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), as({ aptosConfig: this.config, ...e });
      }
      async getCollectionDataByCollectionId(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), cs({ aptosConfig: this.config, ...e });
      }
      async getCollectionId(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), us({ aptosConfig: this.config, ...e });
      }
      async getDigitalAssetData(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), ts({ aptosConfig: this.config, ...e });
      }
      async getCurrentDigitalAssetOwnership(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), ns({ aptosConfig: this.config, ...e });
      }
      async getOwnedDigitalAssets(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), rs({ aptosConfig: this.config, ...e });
      }
      async getDigitalAssetActivity(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "token_v2_processor" }), os({ aptosConfig: this.config, ...e });
      }
      async createCollectionTransaction(e) {
        return is({ aptosConfig: this.config, ...e });
      }
      async mintDigitalAssetTransaction(e) {
        return ps({ aptosConfig: this.config, ...e });
      }
      async transferDigitalAssetTransaction(e) {
        return ds({ aptosConfig: this.config, ...e });
      }
      async mintSoulBoundTransaction(e) {
        return ls({ aptosConfig: this.config, ...e });
      }
      async burnDigitalAssetTransaction(e) {
        return gs({ aptosConfig: this.config, ...e });
      }
      async freezeDigitalAssetTransaferTransaction(e) {
        return ms({ aptosConfig: this.config, ...e });
      }
      async unfreezeDigitalAssetTransaferTransaction(e) {
        return ys({ aptosConfig: this.config, ...e });
      }
      async setDigitalAssetDescriptionTransaction(e) {
        return fs({ aptosConfig: this.config, ...e });
      }
      async setDigitalAssetNameTransaction(e) {
        return As({ aptosConfig: this.config, ...e });
      }
      async setDigitalAssetURITransaction(e) {
        return hs({ aptosConfig: this.config, ...e });
      }
      async addDigitalAssetPropertyTransaction(e) {
        return Ts({ aptosConfig: this.config, ...e });
      }
      async removeDigitalAssetPropertyTransaction(e) {
        return bs({ aptosConfig: this.config, ...e });
      }
      async updateDigitalAssetPropertyTransaction(e) {
        return ws({ aptosConfig: this.config, ...e });
      }
      async addDigitalAssetTypedPropertyTransaction(e) {
        return Ss({ aptosConfig: this.config, ...e });
      }
      async updateDigitalAssetTypedPropertyTransaction(e) {
        return _s({ aptosConfig: this.config, ...e });
      }
    };
    var Ps = 300;
    var Qc = (n) => {
      if (n && n.length > Ps) throw new Error(`Event type length exceeds the maximum length of ${Ps}`);
    };
    async function vs(n) {
      let { aptosConfig: e, eventType: t, options: r } = n;
      return ln({ aptosConfig: e, options: { ...r, where: { account_address: { _eq: "0x0000000000000000000000000000000000000000000000000000000000000000" }, creation_number: { _eq: "0" }, sequence_number: { _eq: "0" }, indexed_type: { _eq: t } } } });
    }
    async function Cs(n) {
      let { accountAddress: e, aptosConfig: t, creationNumber: r, options: o } = n, s = { account_address: { _eq: u.from(e).toStringLong() }, creation_number: { _eq: r } };
      return ln({ aptosConfig: t, options: { ...o, where: s } });
    }
    async function Es(n) {
      let { accountAddress: e, aptosConfig: t, eventType: r, options: o } = n, s = { account_address: { _eq: u.from(e).toStringLong() }, indexed_type: { _eq: r } };
      return ln({ aptosConfig: t, options: { ...o, where: s } });
    }
    async function ln(n) {
      let { aptosConfig: e, options: t } = n;
      Qc(_optionalChain([t, "optionalAccess", (_166) => _166.where, "optionalAccess", (_167) => _167.indexed_type, "optionalAccess", (_168) => _168._eq]));
      let r = { query: ci, variables: { where_condition: _optionalChain([t, "optionalAccess", (_169) => _169.where]), offset: _optionalChain([t, "optionalAccess", (_170) => _170.offset]), limit: _optionalChain([t, "optionalAccess", (_171) => _171.limit]), order_by: _optionalChain([t, "optionalAccess", (_172) => _172.orderBy]) } };
      return (await f({ aptosConfig: e, query: r, originMethod: "getEvents" })).events;
    }
    var gn = class {
      constructor(e) {
        this.config = e;
      }
      async getModuleEventsByEventType(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "events_processor" }), vs({ aptosConfig: this.config, ...e });
      }
      async getAccountEventsByCreationNumber(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "events_processor" }), Cs({ aptosConfig: this.config, ...e });
      }
      async getAccountEventsByEventType(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "events_processor" }), Es({ aptosConfig: this.config, ...e });
      }
      async getEvents(e) {
        return await A({ config: this.config, minimumLedgerVersion: _optionalChain([e, "optionalAccess", (_173) => _173.minimumLedgerVersion]), processorType: "events_processor" }), ln({ aptosConfig: this.config, ...e });
      }
    };
    async function Is(n) {
      let { aptosConfig: e, accountAddress: t, amount: r, options: o } = n, i = _optionalChain([o, "optionalAccess", (_174) => _174.timeoutSecs]) || 20, { data: s } = await Lo({ aptosConfig: e, path: "fund", body: { address: u.from(t).toString(), amount: r }, originMethod: "fundAccount" }), a = s.txn_hashes[0], c = await Kt({ aptosConfig: e, transactionHash: a, options: { timeoutSecs: i, checkSuccess: _optionalChain([o, "optionalAccess", (_175) => _175.checkSuccess]) } });
      if (c.type === "user_transaction") return c;
      throw new Error(`Unexpected transaction received for fund account: ${c.type}`);
    }
    var mn = class {
      constructor(e) {
        this.config = e;
      }
      async fundAccount(e) {
        let t = await Is({ aptosConfig: this.config, ...e });
        return (_optionalChain([e, "access", (_176) => _176.options, "optionalAccess", (_177) => _177.waitForIndexer]) === void 0 || _optionalChain([e, "access", (_178) => _178.options, "optionalAccess", (_179) => _179.waitForIndexer])) && await Zn({ aptosConfig: this.config, minimumLedgerVersion: BigInt(t.version), processorType: "fungible_asset_processor" }), t;
      }
    };
    async function cr(n) {
      let { aptosConfig: e, options: t } = n, r = { query: pi, variables: { where_condition: _optionalChain([t, "optionalAccess", (_180) => _180.where]), limit: _optionalChain([t, "optionalAccess", (_181) => _181.limit]), offset: _optionalChain([t, "optionalAccess", (_182) => _182.offset]) } };
      return (await f({ aptosConfig: e, query: r, originMethod: "getFungibleAssetMetadata" })).fungible_asset_metadata;
    }
    async function Us(n) {
      let { aptosConfig: e, options: t } = n, r = { query: ui, variables: { where_condition: _optionalChain([t, "optionalAccess", (_183) => _183.where]), limit: _optionalChain([t, "optionalAccess", (_184) => _184.limit]), offset: _optionalChain([t, "optionalAccess", (_185) => _185.offset]) } };
      return (await f({ aptosConfig: e, query: r, originMethod: "getFungibleAssetActivities" })).fungible_asset_activities;
    }
    async function Rs(n) {
      let { aptosConfig: e, options: t } = n, r = { query: si, variables: { where_condition: _optionalChain([t, "optionalAccess", (_186) => _186.where]), limit: _optionalChain([t, "optionalAccess", (_187) => _187.limit]), offset: _optionalChain([t, "optionalAccess", (_188) => _188.offset]) } };
      return (await f({ aptosConfig: e, query: r, originMethod: "getCurrentFungibleAssetBalances" })).current_fungible_asset_balances;
    }
    var Wc = { typeParameters: [{ constraints: [] }], parameters: [ze("0x1::object::Object"), new W(), new $()] };
    async function zs(n) {
      let { aptosConfig: e, sender: t, fungibleAssetMetadataAddress: r, recipient: o, amount: i, options: s } = n;
      return h({ aptosConfig: e, sender: t.accountAddress, data: { function: "0x1::primary_fungible_store::transfer", typeArguments: ["0x1::fungible_asset::Metadata"], functionArguments: [r, o, i], abi: Wc }, options: s });
    }
    var yn = class {
      constructor(e) {
        this.config = e;
      }
      async getFungibleAssetMetadata(e) {
        return await A({ config: this.config, minimumLedgerVersion: _optionalChain([e, "optionalAccess", (_189) => _189.minimumLedgerVersion]), processorType: "fungible_asset_processor" }), cr({ aptosConfig: this.config, ...e });
      }
      async getFungibleAssetMetadataByAssetType(e) {
        return await A({ config: this.config, minimumLedgerVersion: _optionalChain([e, "optionalAccess", (_190) => _190.minimumLedgerVersion]), processorType: "fungible_asset_processor" }), (await cr({ aptosConfig: this.config, options: { where: { asset_type: { _eq: e.assetType } } } }))[0];
      }
      async getFungibleAssetMetadataByCreatorAddress(e) {
        return await A({ config: this.config, minimumLedgerVersion: _optionalChain([e, "optionalAccess", (_191) => _191.minimumLedgerVersion]), processorType: "fungible_asset_processor" }), await cr({ aptosConfig: this.config, options: { where: { creator_address: { _eq: u.from(e.creatorAddress).toStringLong() } } } });
      }
      async getFungibleAssetActivities(e) {
        return await A({ config: this.config, minimumLedgerVersion: _optionalChain([e, "optionalAccess", (_192) => _192.minimumLedgerVersion]), processorType: "fungible_asset_processor" }), Us({ aptosConfig: this.config, ...e });
      }
      async getCurrentFungibleAssetBalances(e) {
        return await A({ config: this.config, minimumLedgerVersion: _optionalChain([e, "optionalAccess", (_193) => _193.minimumLedgerVersion]), processorType: "fungible_asset_processor" }), Rs({ aptosConfig: this.config, ...e });
      }
      async transferFungibleAsset(e) {
        return zs({ aptosConfig: this.config, ...e });
      }
    };
    async function je(n) {
      let { aptosConfig: e, payload: t, options: r } = n, o = await Qi({ ...t, aptosConfig: e }), i = new Z();
      o.serialize(i);
      let s = i.toUint8Array(), { data: a } = await Oe({ aptosConfig: e, path: "view", originMethod: "view", contentType: "application/x.aptos.view_function+bcs", params: { ledger_version: _optionalChain([r, "optionalAccess", (_194) => _194.ledgerVersion]) }, body: s });
      return a;
    }
    async function ks(n) {
      let { aptosConfig: e, payload: t, options: r } = n, { data: o } = await Oe({ aptosConfig: e, originMethod: "viewJson", path: "view", params: { ledger_version: _optionalChain([r, "optionalAccess", (_195) => _195.ledgerVersion]) }, body: { function: t.function, type_arguments: _nullishCoalesce(t.typeArguments, () => []), arguments: _nullishCoalesce(t.functionArguments, () => []) } });
      return o;
    }
    var fn = class {
      constructor(e) {
        this.config = e;
      }
      async getLedgerInfo() {
        return Ln({ aptosConfig: this.config });
      }
      async getChainId() {
        return (await this.getLedgerInfo()).chain_id;
      }
      async getBlockByVersion(e) {
        return Di({ aptosConfig: this.config, ...e });
      }
      async getBlockByHeight(e) {
        return Bi({ aptosConfig: this.config, ...e });
      }
      async view(e) {
        return je({ aptosConfig: this.config, ...e });
      }
      async viewJson(e) {
        return ks({ aptosConfig: this.config, ...e });
      }
      async getChainTopUserTransactions(e) {
        return yi({ aptosConfig: this.config, ...e });
      }
      async queryIndexer(e) {
        return f({ aptosConfig: this.config, ...e });
      }
      async getIndexerLastSuccessVersion() {
        return Hn({ aptosConfig: this.config });
      }
      async getProcessorStatus(e) {
        return Qn({ aptosConfig: this.config, processorType: e });
      }
    };
    var Ds = ["A name must be between 3 and 63 characters long,", "and can only contain lowercase a-z, 0-9, and hyphens.", "A name may not start or end with a hyphen."].join(" ");
    function Bs(n) {
      return !(!n || n.length < 3 || n.length > 63 || !/^[a-z\d][a-z\d-]{1,61}[a-z\d]$/.test(n));
    }
    function Xe(n) {
      let [e, t, ...r] = n.replace(/\.apt$/, "").split(".");
      if (r.length > 0) throw new Error(`${n} is invalid. A name can only have two parts, a domain and a subdomain separated by a "."`);
      if (!Bs(e)) throw new Error(`${e} is not valid. ${Ds}`);
      if (t && !Bs(t)) throw new Error(`${t} is not valid. ${Ds}`);
      return { domainName: t || e, subdomainName: t ? e : void 0 };
    }
    function Gs(n) {
      if (!n) return false;
      let e = new Date(n.domain_expiration_timestamp).getTime() < Date.now(), t = new Date(n.expiration_timestamp).getTime() < Date.now();
      return n.subdomain && e ? false : n.subdomain && n.subdomain_expiration_policy === 1 ? true : !t;
    }
    var jc = "0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82";
    var Xc = { testnet: "0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c", mainnet: "0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c", local: jc, custom: null, devnet: null };
    function ke(n) {
      let e = Xc[n.network];
      if (!e) throw new Error(`The ANS contract is not deployed to ${n.network}`);
      return e;
    }
    var ur = (n) => {
      if (n && typeof n == "object" && "vec" in n && Array.isArray(n.vec)) return n.vec[0];
    };
    async function Ks(n) {
      let { aptosConfig: e, name: t } = n, r = ke(e), { domainName: o, subdomainName: i } = Xe(t), s = await je({ aptosConfig: e, payload: { function: `${r}::router::get_owner_addr`, functionArguments: [o, i] } }), a = ur(s[0]);
      return a ? u.from(a) : void 0;
    }
    async function Ns(n) {
      let { aptosConfig: e, expiration: t, name: r, sender: o, targetAddress: i, toAddress: s, options: a, transferable: c } = n, p = ke(e), { domainName: y, subdomainName: w } = Xe(r), S = t.policy === "subdomain:independent" || t.policy === "subdomain:follow-domain";
      if (w && !S) throw new Error("Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'");
      if (S && !w) throw new Error(`Policy is set to ${t.policy} but no subdomain was provided`);
      if (t.policy === "domain") {
        let yr = _nullishCoalesce(t.years, () => 1);
        if (yr !== 1) throw new Error("For now, names can only be registered for 1 year at a time");
        let na = yr * 31536e3;
        return await h({ aptosConfig: e, sender: o.accountAddress.toString(), data: { function: `${p}::router::register_domain`, functionArguments: [y, na, i, s] }, options: a });
      }
      if (!w) throw new Error(`${t.policy} requires a subdomain to be provided.`);
      let g = await co({ aptosConfig: e, name: y });
      if (!g) throw new Error("The domain does not exist");
      let E = t.policy === "subdomain:independent" ? t.expirationDate : g;
      if (E > g) throw new Error("The subdomain expiration time cannot be greater than the domain expiration time");
      return await h({ aptosConfig: e, sender: o.accountAddress.toString(), data: { function: `${p}::router::register_subdomain`, functionArguments: [y, w, Math.round(E / 1e3), t.policy === "subdomain:follow-domain" ? 1 : 0, !!c, i, s] }, options: a });
    }
    async function co(n) {
      let { aptosConfig: e, name: t } = n, r = ke(e), { domainName: o, subdomainName: i } = Xe(t);
      try {
        let s = await je({ aptosConfig: e, payload: { function: `${r}::router::get_expiration`, functionArguments: [o, i] } });
        return Number(s[0]) * 1e3;
      } catch (e4) {
        return;
      }
    }
    async function Os(n) {
      let { aptosConfig: e, address: t } = n, r = ke(e), o = await je({ aptosConfig: e, payload: { function: `${r}::router::get_primary_name`, functionArguments: [u.from(t).toString()] } }), i = ur(o[1]), s = ur(o[0]);
      if (i) return [s, i].filter(Boolean).join(".");
    }
    async function Fs(n) {
      let { aptosConfig: e, sender: t, name: r, options: o } = n, i = ke(e);
      if (!r) return await h({ aptosConfig: e, sender: t.accountAddress.toString(), data: { function: `${i}::router::clear_primary_name`, functionArguments: [] }, options: o });
      let { domainName: s, subdomainName: a } = Xe(r);
      return await h({ aptosConfig: e, sender: t.accountAddress.toString(), data: { function: `${i}::router::set_primary_name`, functionArguments: [s, a] }, options: o });
    }
    async function Ms(n) {
      let { aptosConfig: e, name: t } = n, r = ke(e), { domainName: o, subdomainName: i } = Xe(t), s = await je({ aptosConfig: e, payload: { function: `${r}::router::get_target_addr`, functionArguments: [o, i] } }), a = ur(s[0]);
      return a ? u.from(a) : void 0;
    }
    async function qs(n) {
      let { aptosConfig: e, sender: t, name: r, address: o, options: i } = n, s = ke(e), { domainName: a, subdomainName: c } = Xe(r);
      return await h({ aptosConfig: e, sender: t.accountAddress.toString(), data: { function: `${s}::router::set_target_addr`, functionArguments: [a, c, o] }, options: i });
    }
    async function Vs(n) {
      let { aptosConfig: e, name: t } = n, { domainName: r, subdomainName: o = "" } = Xe(t), a = (await f({ aptosConfig: e, query: { query: Gt, variables: { where_condition: { domain: { _eq: r }, subdomain: { _eq: o } }, limit: 1 } }, originMethod: "getName" })).current_aptos_names[0];
      return a && (a = An(a)), Gs(a) ? a : void 0;
    }
    async function $s(n) {
      let { aptosConfig: e, options: t, accountAddress: r } = n, o = await uo({ aptosConfig: e });
      return (await f({ aptosConfig: e, originMethod: "getAccountNames", query: { query: Gt, variables: { limit: _optionalChain([t, "optionalAccess", (_196) => _196.limit]), offset: _optionalChain([t, "optionalAccess", (_197) => _197.offset]), order_by: _optionalChain([t, "optionalAccess", (_198) => _198.orderBy]), where_condition: { ..._nullishCoalesce(_optionalChain([n, "access", (_199) => _199.options, "optionalAccess", (_200) => _200.where]), () => ({})), owner_address: { _eq: r.toString() }, expiration_timestamp: { _gte: o } } } } })).current_aptos_names.map(An);
    }
    async function Ls(n) {
      let { aptosConfig: e, options: t, accountAddress: r } = n, o = await uo({ aptosConfig: e });
      return (await f({ aptosConfig: e, originMethod: "getAccountDomains", query: { query: Gt, variables: { limit: _optionalChain([t, "optionalAccess", (_201) => _201.limit]), offset: _optionalChain([t, "optionalAccess", (_202) => _202.offset]), order_by: _optionalChain([t, "optionalAccess", (_203) => _203.orderBy]), where_condition: { ..._nullishCoalesce(_optionalChain([n, "access", (_204) => _204.options, "optionalAccess", (_205) => _205.where]), () => ({})), owner_address: { _eq: r.toString() }, expiration_timestamp: { _gte: o }, subdomain: { _eq: "" } } } } })).current_aptos_names.map(An);
    }
    async function Hs(n) {
      let { aptosConfig: e, options: t, accountAddress: r } = n, o = await uo({ aptosConfig: e });
      return (await f({ aptosConfig: e, originMethod: "getAccountSubdomains", query: { query: Gt, variables: { limit: _optionalChain([t, "optionalAccess", (_206) => _206.limit]), offset: _optionalChain([t, "optionalAccess", (_207) => _207.offset]), order_by: _optionalChain([t, "optionalAccess", (_208) => _208.orderBy]), where_condition: { ..._nullishCoalesce(_optionalChain([n, "access", (_209) => _209.options, "optionalAccess", (_210) => _210.where]), () => ({})), owner_address: { _eq: r.toString() }, expiration_timestamp: { _gte: o }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(An);
    }
    async function Qs(n) {
      let { aptosConfig: e, options: t, domain: r } = n;
      return (await f({ aptosConfig: e, originMethod: "getDomainSubdomains", query: { query: Gt, variables: { limit: _optionalChain([t, "optionalAccess", (_211) => _211.limit]), offset: _optionalChain([t, "optionalAccess", (_212) => _212.offset]), order_by: _optionalChain([t, "optionalAccess", (_213) => _213.orderBy]), where_condition: { ..._nullishCoalesce(_optionalChain([n, "access", (_214) => _214.options, "optionalAccess", (_215) => _215.where]), () => ({})), domain: { _eq: r }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(An).filter(Gs);
    }
    async function uo(n) {
      let { aptosConfig: e } = n, t = ke(e), [r] = await je({ aptosConfig: e, payload: { function: `${t}::config::reregistration_grace_sec`, functionArguments: [] } }), o = r / 60 / 60 / 24, i = () => /* @__PURE__ */ new Date();
      return new Date(i().setDate(i().getDate() - o)).toISOString();
    }
    async function Ws(n) {
      let { aptosConfig: e, sender: t, name: r, years: o = 1, options: i } = n, s = ke(e), a = o * 31536e3, { domainName: c, subdomainName: p } = Xe(r);
      if (p) throw new Error("Subdomains cannot be renewed");
      if (o !== 1) throw new Error("Currently, only 1 year renewals are supported");
      return await h({ aptosConfig: e, sender: t.accountAddress.toString(), data: { function: `${s}::router::renew_domain`, functionArguments: [c, a] }, options: i });
    }
    function An(n) {
      return { ...n, expiration_timestamp: new Date(n.expiration_timestamp).getTime() };
    }
    var hn = class {
      constructor(e) {
        this.config = e;
      }
      async getOwnerAddress(e) {
        return Ks({ aptosConfig: this.config, ...e });
      }
      async getExpiration(e) {
        return co({ aptosConfig: this.config, ...e });
      }
      async getTargetAddress(e) {
        return Ms({ aptosConfig: this.config, ...e });
      }
      async setTargetAddress(e) {
        return qs({ aptosConfig: this.config, ...e });
      }
      async getPrimaryName(e) {
        return Os({ aptosConfig: this.config, ...e });
      }
      async setPrimaryName(e) {
        return Fs({ aptosConfig: this.config, ...e });
      }
      async registerName(e) {
        return Ns({ aptosConfig: this.config, ...e });
      }
      async renewDomain(e) {
        return Ws({ aptosConfig: this.config, ...e });
      }
      async getName(e) {
        return Vs({ aptosConfig: this.config, ...e });
      }
      async getAccountNames(e) {
        return $s({ aptosConfig: this.config, ...e });
      }
      async getAccountDomains(e) {
        return Ls({ aptosConfig: this.config, ...e });
      }
      async getAccountSubdomains(e) {
        return Hs({ aptosConfig: this.config, ...e });
      }
      async getDomainSubdomains(e) {
        return Qs({ aptosConfig: this.config, ...e });
      }
    };
    async function js(n) {
      let { aptosConfig: e, poolAddress: t } = n, r = u.from(t).toStringLong(), i = await f({ aptosConfig: e, query: { query: Mr, variables: { where_condition: { pool_address: { _eq: r } } } } });
      return i.num_active_delegator_per_pool[0] ? i.num_active_delegator_per_pool[0].num_active_delegator : 0;
    }
    async function Xs(n) {
      let { aptosConfig: e, options: t } = n, r = { query: Mr, variables: { order_by: _optionalChain([t, "optionalAccess", (_216) => _216.orderBy]) } };
      return (await f({ aptosConfig: e, query: r })).num_active_delegator_per_pool;
    }
    async function Ys(n) {
      let { aptosConfig: e, delegatorAddress: t, poolAddress: r } = n, o = { query: ai, variables: { delegatorAddress: u.from(t).toStringLong(), poolAddress: u.from(r).toStringLong() } };
      return (await f({ aptosConfig: e, query: o })).delegated_staking_activities;
    }
    var Tn = class {
      constructor(e) {
        this.config = e;
      }
      async getNumberOfDelegators(e) {
        return await A({ config: this.config, minimumLedgerVersion: _optionalChain([e, "optionalAccess", (_217) => _217.minimumLedgerVersion]), processorType: "stake_processor" }), js({ aptosConfig: this.config, ...e });
      }
      async getNumberOfDelegatorsForAllPools(e) {
        return await A({ config: this.config, minimumLedgerVersion: _optionalChain([e, "optionalAccess", (_218) => _218.minimumLedgerVersion]), processorType: "stake_processor" }), Xs({ aptosConfig: this.config, ...e });
      }
      async getDelegatedStakingActivities(e) {
        return await A({ config: this.config, minimumLedgerVersion: _optionalChain([e, "optionalAccess", (_219) => _219.minimumLedgerVersion]), processorType: "stake_processor" }), Ys({ aptosConfig: this.config, ...e });
      }
    };
    var pr = class {
      constructor(e) {
        this.config = e;
      }
      async simple(e) {
        return h({ aptosConfig: this.config, ...e });
      }
      async multiAgent(e) {
        return h({ aptosConfig: this.config, ...e });
      }
    };
    function po(n, e, t) {
      let r = t.value;
      return t.value = async function(...o) {
        let [i] = o;
        if (i.transaction.feePayerAddress && !i.feePayerAuthenticator) throw new Error("You are submitting a Fee Payer transaction but missing the feePayerAuthenticator");
        return r.apply(this, o);
      }, t;
    }
    function lo(n, e, t) {
      let r = t.value;
      return t.value = async function(...o) {
        let [i] = o;
        if (i.transaction.feePayerAddress && !i.feePayerPublicKey) throw new Error("You are simulating a Fee Payer transaction but missing the feePayerPublicKey");
        return r.apply(this, o);
      }, t;
    }
    var Ft = class {
      constructor(e) {
        this.config = e;
      }
      async simple(e) {
        return so({ aptosConfig: this.config, ...e });
      }
      async multiAgent(e) {
        return so({ aptosConfig: this.config, ...e });
      }
    };
    _chunkBHKSQXUZjs.a.call(void 0, [lo], Ft.prototype, "simple", 1), _chunkBHKSQXUZjs.a.call(void 0, [lo], Ft.prototype, "multiAgent", 1);
    var Mt = class {
      constructor(e) {
        this.config = e;
      }
      async simple(e) {
        return ar({ aptosConfig: this.config, ...e });
      }
      async multiAgent(e) {
        return ar({ aptosConfig: this.config, ...e });
      }
    };
    _chunkBHKSQXUZjs.a.call(void 0, [po], Mt.prototype, "simple", 1), _chunkBHKSQXUZjs.a.call(void 0, [po], Mt.prototype, "multiAgent", 1);
    var dr = class {
      constructor(e, t, r, o, i) {
        this.lastUncommintedNumber = null;
        this.currentNumber = null;
        this.lock = false;
        this.aptosConfig = e, this.account = t, this.maxWaitTime = r, this.maximumInFlight = o, this.sleepTime = i;
      }
      async nextSequenceNumber() {
        for (; this.lock; ) await _chunkBHKSQXUZjs.b.call(void 0, this.sleepTime);
        this.lock = true;
        let e = BigInt(0);
        try {
          if ((this.lastUncommintedNumber === null || this.currentNumber === null) && await this.initialize(), this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight) {
            await this.update();
            let t = _chunkBHKSQXUZjs.c.call(void 0);
            for (; this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight; ) await _chunkBHKSQXUZjs.b.call(void 0, this.sleepTime), _chunkBHKSQXUZjs.c.call(void 0) - t > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : await this.update();
          }
          e = this.currentNumber, this.currentNumber += BigInt(1);
        } catch (t) {
          console.error("error in getting next sequence number for this account", t);
        } finally {
          this.lock = false;
        }
        return e;
      }
      async initialize() {
        let { sequence_number: e } = await Se({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
        this.currentNumber = BigInt(e), this.lastUncommintedNumber = BigInt(e);
      }
      async update() {
        let { sequence_number: e } = await Se({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
        return this.lastUncommintedNumber = BigInt(e), this.lastUncommintedNumber;
      }
      async synchronize() {
        if (this.lastUncommintedNumber !== this.currentNumber) {
          for (; this.lock; ) await _chunkBHKSQXUZjs.b.call(void 0, this.sleepTime);
          this.lock = true;
          try {
            await this.update();
            let e = _chunkBHKSQXUZjs.c.call(void 0);
            for (; this.lastUncommintedNumber !== this.currentNumber; ) _chunkBHKSQXUZjs.c.call(void 0) - e > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : (await _chunkBHKSQXUZjs.b.call(void 0, this.sleepTime), await this.update());
          } catch (e) {
            console.error("error in synchronizing this account sequence number with the one on chain", e);
          } finally {
            this.lock = false;
          }
        }
      }
    };
    var qt = class {
      constructor() {
        this.queue = [];
        this.pendingDequeue = [];
        this.cancelled = false;
      }
      enqueue(e) {
        if (this.cancelled = false, this.pendingDequeue.length > 0) {
          _optionalChain([this, "access", (_220) => _220.pendingDequeue, "access", (_221) => _221.shift, "call", (_222) => _222(), "optionalAccess", (_223) => _223.resolve, "call", (_224) => _224(e)]);
          return;
        }
        this.queue.push(e);
      }
      async dequeue() {
        return this.queue.length > 0 ? Promise.resolve(this.queue.shift()) : new Promise((e, t) => {
          this.pendingDequeue.push({ resolve: e, reject: t });
        });
      }
      isEmpty() {
        return this.queue.length === 0;
      }
      cancel() {
        this.cancelled = true, this.pendingDequeue.forEach(async ({ reject: e }) => {
          e(new Vt("Task cancelled"));
        }), this.pendingDequeue = [], this.queue.length = 0;
      }
      isCancelled() {
        return this.cancelled;
      }
      pendingDequeueLength() {
        return this.pendingDequeue.length;
      }
    };
    var Vt = class extends Error {
    };
    var Zs = "fulfilled";
    var Js = exports.TransactionWorkerEventsEnum = ((i) => (i.TransactionSent = "transactionSent", i.TransactionSendFailed = "transactionSendFailed", i.TransactionExecuted = "transactionExecuted", i.TransactionExecutionFailed = "transactionExecutionFailed", i.ExecutionFinish = "executionFinish", i))(Js || {});
    var lr = exports.TransactionWorker = class extends _eventemitter32.default {
      constructor(t, r, o = 30, i = 100, s = 10) {
        super();
        this.taskQueue = new qt();
        this.transactionsQueue = new qt();
        this.outstandingTransactions = new qt();
        this.sentTransactions = [];
        this.executedTransactions = [];
        this.aptosConfig = t, this.account = r, this.started = false, this.accountSequnceNumber = new dr(t, r, o, i, s);
      }
      async submitNextTransaction() {
        try {
          for (; ; ) {
            let t = await this.accountSequnceNumber.nextSequenceNumber();
            if (t === null) return;
            let r = await this.generateNextTransaction(this.account, t);
            if (!r) return;
            let o = un({ aptosConfig: this.aptosConfig, transaction: r, signer: this.account });
            await this.outstandingTransactions.enqueue([o, t]);
          }
        } catch (t) {
          if (t instanceof Vt) return;
          throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${t}`);
        }
      }
      async processTransactions() {
        try {
          for (; ; ) {
            let t = [], r = [], [o, i] = await this.outstandingTransactions.dequeue();
            for (t.push(o), r.push(i); !this.outstandingTransactions.isEmpty(); ) [o, i] = await this.outstandingTransactions.dequeue(), t.push(o), r.push(i);
            let s = await Promise.allSettled(t);
            for (let a = 0; a < s.length && a < r.length; a += 1) {
              let c = s[a];
              i = r[a], c.status === Zs ? (this.sentTransactions.push([c.value.hash, i, null]), this.emit("transactionSent", { message: `transaction hash ${c.value.hash} has been committed to chain`, transactionHash: c.value.hash }), await this.checkTransaction(c, i)) : (this.sentTransactions.push([c.status, i, c.reason]), this.emit("transactionSendFailed", { message: `failed to commit transaction ${this.sentTransactions.length} with error ${c.reason}`, error: c.reason }));
            }
            this.emit("executionFinish", { message: `execute ${s.length} transactions finished` });
          }
        } catch (t) {
          if (t instanceof Vt) return;
          throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${t}`);
        }
      }
      async checkTransaction(t, r) {
        try {
          let o = [];
          o.push(Kt({ aptosConfig: this.aptosConfig, transactionHash: t.value.hash }));
          let i = await Promise.allSettled(o);
          for (let s = 0; s < i.length; s += 1) {
            let a = i[s];
            a.status === Zs ? (this.executedTransactions.push([a.value.hash, r, null]), this.emit("transactionExecuted", { message: `transaction hash ${a.value.hash} has been executed on chain`, transactionHash: t.value.hash })) : (this.executedTransactions.push([a.status, r, a.reason]), this.emit("transactionExecutionFailed", { message: `failed to execute transaction ${this.executedTransactions.length} with error ${a.reason}`, error: a.reason }));
          }
        } catch (o) {
          throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${o}`);
        }
      }
      async push(t, r) {
        this.transactionsQueue.enqueue([t, r]);
      }
      async generateNextTransaction(t, r) {
        if (this.transactionsQueue.isEmpty()) return;
        let [o, i] = await this.transactionsQueue.dequeue();
        return h({ aptosConfig: this.aptosConfig, sender: t.accountAddress, data: o, options: { ...i, accountSequenceNumber: r } });
      }
      async run() {
        try {
          for (; !this.taskQueue.isCancelled(); ) await (await this.taskQueue.dequeue())();
        } catch (t) {
          throw new Error(`Unable to start transaction batching: ${t}`);
        }
      }
      start() {
        if (this.started) throw new Error("worker has already started");
        this.started = true, this.taskQueue.enqueue(() => this.submitNextTransaction()), this.taskQueue.enqueue(() => this.processTransactions()), this.run();
      }
      stop() {
        if (this.taskQueue.isCancelled()) throw new Error("worker has already stopped");
        this.started = false, this.taskQueue.cancel();
      }
    };
    var gr = class extends _eventemitter32.default {
      constructor(e) {
        super(), this.config = e;
      }
      start(e) {
        let { sender: t } = e;
        this.account = t, this.transactionWorker = new lr(this.config, t), this.transactionWorker.start(), this.registerToEvents();
      }
      push(e) {
        let { data: t, options: r } = e;
        for (let o of t) this.transactionWorker.push(o, r);
      }
      registerToEvents() {
        this.transactionWorker.on("transactionSent", async (e) => {
          this.emit("transactionSent", e);
        }), this.transactionWorker.on("transactionSendFailed", async (e) => {
          this.emit("transactionSendFailed", e);
        }), this.transactionWorker.on("transactionExecuted", async (e) => {
          this.emit("transactionExecuted", e);
        }), this.transactionWorker.on("transactionExecutionFailed", async (e) => {
          this.emit("transactionExecutionFailed", e);
        }), this.transactionWorker.on("executionFinish", async (e) => {
          this.emit("executionFinish", e);
        });
      }
      forSingleAccount(e) {
        try {
          let { sender: t, data: r, options: o } = e;
          this.start({ sender: t }), this.push({ data: r, options: o });
        } catch (t) {
          throw new Error(`failed to submit transactions with error: ${t}`);
        }
      }
    };
    var bn = class {
      constructor(e) {
        this.config = e, this.build = new pr(this.config), this.simulate = new Ft(this.config), this.submit = new Mt(this.config), this.batch = new gr(this.config);
      }
      async getTransactions(e) {
        return Qr({ aptosConfig: this.config, ...e });
      }
      async getTransactionByVersion(e) {
        return zi({ aptosConfig: this.config, ...e });
      }
      async getTransactionByHash(e) {
        return on({ aptosConfig: this.config, ...e });
      }
      async isPendingTransaction(e) {
        return ki({ aptosConfig: this.config, ...e });
      }
      async waitForTransaction(e) {
        return Kt({ aptosConfig: this.config, ...e });
      }
      async getGasPriceEstimation() {
        return Yn({ aptosConfig: this.config });
      }
      getSigningMessage(e) {
        return Yi(e);
      }
      async publishPackageTransaction(e) {
        return Zi({ aptosConfig: this.config, ...e });
      }
      async rotateAuthKey(e) {
        return Ji({ aptosConfig: this.config, ...e });
      }
      sign(e) {
        return sr({ ...e });
      }
      signAsFeePayer(e) {
        let { signer: t, transaction: r } = e;
        if (!r.feePayerAddress) throw new Error(`Transaction ${r} is not a Fee Payer transaction`);
        return r.feePayerAddress = t.accountAddress, sr({ signer: t, transaction: r });
      }
      async batchTransactionsForSingleAccount(e) {
        try {
          let { sender: t, data: r, options: o } = e;
          this.batch.forSingleAccount({ sender: t, data: r, options: o });
        } catch (t) {
          throw new Error(`failed to submit transactions with error: ${t}`);
        }
      }
      async signAndSubmitTransaction(e) {
        let { signer: t, transaction: r } = e;
        return un({ aptosConfig: this.config, signer: t, transaction: r });
      }
    };
    var wn = class {
      constructor(e) {
        this.config = e;
      }
      async getTableItem(e) {
        return Wn({ aptosConfig: this.config, ...e });
      }
      async getTableItemsData(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "default_processor" }), fi({ aptosConfig: this.config, ...e });
      }
      async getTableItemsMetadata(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "default_processor" }), Ai({ aptosConfig: this.config, ...e });
      }
    };
    async function mr(n) {
      let { aptosConfig: e, jwt: t, ephemeralKeyPair: r, uidKey: o = "sub", derivationPath: i } = n, s = { jwt_b64: t, epk: r.getPublicKey().bcsToHex().toStringWithoutPrefix(), exp_date_secs: r.expiryDateSecs, epk_blinder: l.fromHexInput(r.blinder).toStringWithoutPrefix(), uid_key: o, derivation_path: i }, { data: a } = await Ho({ aptosConfig: e, path: "fetch", body: s, originMethod: "getPepper", overrides: { WITH_CREDENTIALS: false } });
      return l.fromHexInput(a.pepper).toUint8Array();
    }
    async function go(n) {
      let { aptosConfig: e, jwt: t, ephemeralKeyPair: r, pepper: o = await mr(n), uidKey: i = "sub" } = n;
      if (l.fromHexInput(o).toUint8Array().length !== we.PEPPER_LENGTH) throw new Error(`Pepper needs to be ${we.PEPPER_LENGTH} bytes`);
      let { maxExpHorizonSecs: s } = await jo({ aptosConfig: e });
      if (s < r.expiryDateSecs - _chunkBHKSQXUZjs.c.call(void 0)) throw Error(`The EphemeralKeyPair is too long lived.  It's lifespan must be less than ${s}`);
      let a = { jwt_b64: t, epk: r.getPublicKey().bcsToHex().toStringWithoutPrefix(), epk_blinder: l.fromHexInput(r.blinder).toStringWithoutPrefix(), exp_date_secs: r.expiryDateSecs, exp_horizon_secs: s, pepper: l.fromHexInput(o).toStringWithoutPrefix(), uid_key: i }, { data: c } = await Qo({ aptosConfig: e, path: "prove", body: a, originMethod: "getProof", overrides: { WITH_CREDENTIALS: false } }), p = c.proof, y = new St({ a: p.a, b: p.b, c: p.c });
      return new Ie({ proof: new _t(y, 0), trainingWheelsSignature: Te.fromHex(c.training_wheels_signature), expHorizonSecs: s });
    }
    async function ea(n) {
      let { aptosConfig: e, jwt: t, uidKey: r, proofFetchCallback: o, pepper: i = await mr(n) } = n, s = go({ ...n, pepper: i }), a = o ? s : await s, c = ee.fromJwtAndPepper({ jwt: t, pepper: i, uidKey: r }), p = await rn({ aptosConfig: e, authenticationKey: c.authKey().derivedAddress() });
      return we.create({ ...n, address: p, proof: a, pepper: i, proofFetchCallback: o });
    }
    var Sn = class {
      constructor(e) {
        this.config = e;
      }
      async getPepper(e) {
        return mr({ aptosConfig: this.config, ...e });
      }
      async getProof(e) {
        return go({ aptosConfig: this.config, ...e });
      }
      async deriveKeylessAccount(e) {
        return ea({ aptosConfig: this.config, ...e });
      }
    };
    async function Jc(n) {
      let { aptosConfig: e, options: t } = n, r = { query: $n, variables: { where_condition: _optionalChain([t, "optionalAccess", (_225) => _225.where]), offset: _optionalChain([t, "optionalAccess", (_226) => _226.offset]), limit: _optionalChain([t, "optionalAccess", (_227) => _227.limit]), order_by: _optionalChain([t, "optionalAccess", (_228) => _228.orderBy]) } };
      return (await f({ aptosConfig: e, query: r, originMethod: "getObjectData" })).current_objects;
    }
    async function ta(n) {
      let { aptosConfig: e, objectAddress: t, options: r } = n, i = { object_address: { _eq: u.from(t).toStringLong() } };
      return (await Jc({ aptosConfig: e, options: { ...r, where: i } }))[0];
    }
    var _n = class {
      constructor(e) {
        this.config = e;
      }
      async getObjectDataByObjectAddress(e) {
        return await A({ config: this.config, minimumLedgerVersion: e.minimumLedgerVersion, processorType: "objects_processor" }), ta({ aptosConfig: this.config, ...e });
      }
    };
    var j = class {
      constructor(e) {
        this.config = new Jn(e), this.account = new sn(this.config), this.ans = new hn(this.config), this.coin = new pn(this.config), this.digitalAsset = new dn(this.config), this.event = new gn(this.config), this.faucet = new mn(this.config), this.fungibleAsset = new yn(this.config), this.general = new fn(this.config), this.staking = new Tn(this.config), this.transaction = new bn(this.config), this.table = new wn(this.config), this.keyless = new Sn(this.config), this.object = new _n(this.config);
      }
    };
    function re(n, e, t) {
      Object.getOwnPropertyNames(e.prototype).forEach((r) => {
        let o = Object.getOwnPropertyDescriptor(e.prototype, r);
        o && (o.value = function(...i) {
          return this[t][r](...i);
        }, Object.defineProperty(n.prototype, r, o));
      });
    }
    re(j, sn, "account");
    re(j, hn, "ans");
    re(j, pn, "coin");
    re(j, dn, "digitalAsset");
    re(j, gn, "event");
    re(j, mn, "faucet");
    re(j, yn, "fungibleAsset");
    re(j, fn, "general");
    re(j, Tn, "staking");
    re(j, bn, "transaction");
    re(j, wn, "table");
    re(j, Sn, "keyless");
    re(j, _n, "object");
    exports.APTOS_BIP44_REGEX = ya;
    exports.APTOS_COIN = ot;
    exports.APTOS_HARDENED_REGEX = ma;
    exports.Account = Le;
    exports.AccountAddress = u;
    exports.AccountAuthenticator = H;
    exports.AccountAuthenticatorEd25519 = fe;
    exports.AccountAuthenticatorMultiEd25519 = Gn;
    exports.AccountAuthenticatorMultiKey = at;
    exports.AccountAuthenticatorSingleKey = Q;
    exports.AccountAuthenticatorVariant = bo;
    exports.AccountPublicKey = ie;
    exports.AccountSequenceNumber = dr;
    exports.AddressInvalidReason = pa;
    exports.AnyPublicKey = D;
    exports.AnyPublicKeyVariant = Ar;
    exports.AnySignature = G;
    exports.AnySignatureVariant = wo;
    exports.Aptos = j;
    exports.AptosApiError = ye;
    exports.AptosApiType = Tt;
    exports.AptosConfig = Jn;
    exports.AuthenticationKey = q;
    exports.Bool = I;
    exports.CKDPriv = Uo;
    exports.ChainId = Pt;
    exports.DEFAULT_MAX_GAS_AMOUNT = Go;
    exports.DEFAULT_TXN_EXP_SEC_FROM_NOW = Ko;
    exports.DEFAULT_TXN_TIMEOUT_SEC = Dn;
    exports.DeriveScheme = xo;
    exports.Deserializer = oe;
    exports.EPK_HORIZON_SECS = Cl;
    exports.Ed25519Account = kt;
    exports.Ed25519PrivateKey = L;
    exports.Ed25519PublicKey = x;
    exports.Ed25519Signature = v;
    exports.EntryFunction = ut;
    exports.EntryFunctionBytes = Cn;
    exports.EphemeralCertificate = wt;
    exports.EphemeralCertificateVariant = Tr;
    exports.EphemeralKeyPair = nn;
    exports.EphemeralPublicKey = rt;
    exports.EphemeralPublicKeyVariant = hr;
    exports.EphemeralSignature = Te;
    exports.EphemeralSignatureVariant = So;
    exports.FeePayerRawTransaction = dt;
    exports.FixedBytes = Je;
    exports.Groth16Zkp = St;
    exports.HARDENED_OFFSET = Co;
    exports.Hex = l;
    exports.HexInvalidReason = ia;
    exports.Identifier = R;
    exports.KeyType = fa;
    exports.KeylessAccount = we;
    exports.KeylessConfiguration = Br;
    exports.KeylessPublicKey = ee;
    exports.KeylessSignature = Ee;
    exports.MAX_AUD_VAL_BYTES = Ha;
    exports.MAX_COMMITED_EPK_BYTES = Rl;
    exports.MAX_EXTRA_FIELD_BYTES = Il;
    exports.MAX_ISS_VAL_BYTES = El;
    exports.MAX_JWT_HEADER_B64_BYTES = Ul;
    exports.MAX_UID_KEY_BYTES = Qa;
    exports.MAX_UID_VAL_BYTES = Wa;
    exports.MimeType = En;
    exports.ModuleId = jt;
    exports.MoveAbility = _o;
    exports.MoveFunctionVisibility = aa;
    exports.MoveOption = M;
    exports.MoveString = b;
    exports.MoveVector = T;
    exports.MultiAgentRawTransaction = pt;
    exports.MultiAgentTransaction = Mn;
    exports.MultiEd25519PublicKey = ft;
    exports.MultiEd25519Signature = tt;
    exports.MultiKey = xt;
    exports.MultiKeyAccount = qn;
    exports.MultiKeySignature = st;
    exports.MultiSig = en;
    exports.MultiSigTransactionPayload = tn;
    exports.Network = Rr;
    exports.NetworkToChainId = zr;
    exports.NetworkToFaucetAPI = qo;
    exports.NetworkToIndexerAPI = Fo;
    exports.NetworkToNetworkName = Id;
    exports.NetworkToNodeAPI = Mo;
    exports.NetworkToPepperAPI = Ir;
    exports.NetworkToProverAPI = Ur;
    exports.ParsingError = Y;
    exports.ProcessorType = ve;
    exports.PublicKey = et;
    exports.RAW_TRANSACTION_SALT = No;
    exports.RAW_TRANSACTION_WITH_DATA_SALT = Cr;
    exports.RawTransaction = ue;
    exports.RawTransactionWithData = Nn;
    exports.RoleType = ca;
    exports.RotationProofChallenge = On;
    exports.Script = Jt;
    exports.ScriptTransactionArgumentVariants = Lt;
    exports.Secp256k1PrivateKey = nt;
    exports.Secp256k1PublicKey = Pe;
    exports.Secp256k1Signature = ht;
    exports.Serializable = d;
    exports.Serializer = Z;
    exports.Signature = B;
    exports.SignedTransaction = lt;
    exports.SigningScheme = Ae;
    exports.SigningSchemeInput = Sr;
    exports.SimpleTransaction = Fn;
    exports.SingleKeyAccount = Dt;
    exports.StructTag = Ue;
    exports.TransactionAuthenticator = Re;
    exports.TransactionAuthenticatorEd25519 = Ct;
    exports.TransactionAuthenticatorFeePayer = It;
    exports.TransactionAuthenticatorMultiAgent = Et;
    exports.TransactionAuthenticatorMultiEd25519 = Nr;
    exports.TransactionAuthenticatorSingleSender = Ut;
    exports.TransactionAuthenticatorVariant = To;
    exports.TransactionPayload = ct;
    exports.TransactionPayloadEntryFunction = Yt;
    exports.TransactionPayloadMultiSig = Zt;
    exports.TransactionPayloadScript = Xt;
    exports.TransactionPayloadVariants = Ao;
    exports.TransactionResponseType = wr;
    exports.TransactionVariants = ho;
    exports.TransactionWorker = lr;
    exports.TransactionWorkerEventsEnum = Js;
    exports.TypeTag = z;
    exports.TypeTagAddress = W;
    exports.TypeTagBool = K;
    exports.TypeTagGeneric = k;
    exports.TypeTagParserError = N;
    exports.TypeTagParserErrorType = mc;
    exports.TypeTagReference = Kn;
    exports.TypeTagSigner = vt;
    exports.TypeTagStruct = m;
    exports.TypeTagU128 = Ve;
    exports.TypeTagU16 = Me;
    exports.TypeTagU256 = $e;
    exports.TypeTagU32 = qe;
    exports.TypeTagU64 = $;
    exports.TypeTagU8 = ce;
    exports.TypeTagVariants = fo;
    exports.TypeTagVector = C;
    exports.U128 = ge;
    exports.U16 = de;
    exports.U256 = me;
    exports.U32 = le;
    exports.U64 = O;
    exports.U8 = F;
    exports.ZeroKnowledgeSig = Ie;
    exports.ZkProof = _t;
    exports.ZkpVariant = br;
    exports.aptosCoinStructTag = Yg;
    exports.aptosRequest = Bn;
    exports.buildTransaction = oo;
    exports.checkOrConvertArgument = Nt;
    exports.convertArgument = ro;
    exports.convertNumber = er;
    exports.createObjectAddress = Kr;
    exports.createResourceAddress = Cg;
    exports.createTokenAddress = Eg;
    exports.deriveKey = _r;
    exports.deriveTransactionType = Or;
    exports.deserializeFromScriptArgument = Za;
    exports.ensureBoolean = fr;
    exports.fetchEntryFunctionAbi = Li;
    exports.fetchFunctionAbi = $i;
    exports.fetchViewFunctionAbi = Hi;
    exports.findFirstNonSignerArg = Vi;
    exports.generateRawTransaction = _c;
    exports.generateSignedTransaction = io;
    exports.generateSignedTransactionForSimulation = Wi;
    exports.generateSigningMessage = Rt;
    exports.generateSigningMessageForSerializable = uy;
    exports.generateSigningMessageForTransaction = zt;
    exports.generateTransactionPayload = ir;
    exports.generateTransactionPayloadWithABI = bc;
    exports.generateUserTransactionHash = nh;
    exports.generateViewFunctionPayload = Qi;
    exports.generateViewFunctionPayloadWithABI = wc;
    exports.get = kr;
    exports.getAptosFullNode = V;
    exports.getAptosPepperService = Yd;
    exports.getAuthenticatorForSimulation = or;
    exports.getFunctionParts = cn;
    exports.getKeylessConfig = jo;
    exports.hashValues = ji;
    exports.isBcsAddress = nr;
    exports.isBcsBool = Wr;
    exports.isBcsFixedBytes = fc;
    exports.isBcsString = jr;
    exports.isBcsU128 = eo;
    exports.isBcsU16 = Yr;
    exports.isBcsU256 = to;
    exports.isBcsU32 = Zr;
    exports.isBcsU64 = Jr;
    exports.isBcsU8 = Xr;
    exports.isBlockEpilogueTransactionResponse = Eu;
    exports.isBlockMetadataTransactionResponse = Pu;
    exports.isBool = Oi;
    exports.isCanonicalEd25519Signature = ha;
    exports.isEd25519Signature = Iu;
    exports.isEmptyOption = Fi;
    exports.isEncodedEntryFunctionArgument = Mi;
    exports.isFeePayerSignature = zu;
    exports.isGenesisTransactionResponse = xu;
    exports.isLargeNumber = tr;
    exports.isMultiAgentSignature = Ru;
    exports.isMultiEd25519Signature = ku;
    exports.isNumber = yc;
    exports.isPendingTransactionResponse = Su;
    exports.isScriptDataInput = qi;
    exports.isSecp256k1Signature = Uu;
    exports.isStateCheckpointTransactionResponse = vu;
    exports.isString = Qe;
    exports.isUserTransactionResponse = _u;
    exports.isValidBIP44Path = Eo;
    exports.isValidHardenedPath = Io;
    exports.isValidatorTransactionResponse = Cu;
    exports.mnemonicToSeed = In;
    exports.normalizeBundle = Vo;
    exports.objectStructTag = ne;
    exports.optionStructTag = Zg;
    exports.outOfRangeErrorMessage = sa;
    exports.paginateWithCursor = bt;
    exports.parseTypeTag = ze;
    exports.post = Wt;
    exports.postAptosFaucet = Lo;
    exports.postAptosFullNode = Oe;
    exports.postAptosIndexer = $o;
    exports.postAptosPepperService = Ho;
    exports.postAptosProvingService = Qo;
    exports.promiseFulfilledStatus = Zs;
    exports.request = $a;
    exports.splitPath = Ro;
    exports.standardizeTypeTags = rr;
    exports.stringStructTag = P;
    exports.throwTypeMismatch = U;
    exports.validateNumberInRange = Be;
  }
});

// node_modules/lodash/lodash.js
var require_lodash = __commonJS({
  "node_modules/lodash/lodash.js"(exports, module) {
    (function() {
      var undefined2;
      var VERSION = "4.17.21";
      var LARGE_ARRAY_SIZE = 200;
      var CORE_ERROR_TEXT = "Unsupported core-js use. Try https://npms.io/search?q=ponyfill.", FUNC_ERROR_TEXT = "Expected a function", INVALID_TEMPL_VAR_ERROR_TEXT = "Invalid `variable` option passed into `_.template`";
      var HASH_UNDEFINED = "__lodash_hash_undefined__";
      var MAX_MEMOIZE_SIZE = 500;
      var PLACEHOLDER = "__lodash_placeholder__";
      var CLONE_DEEP_FLAG = 1, CLONE_FLAT_FLAG = 2, CLONE_SYMBOLS_FLAG = 4;
      var COMPARE_PARTIAL_FLAG = 1, COMPARE_UNORDERED_FLAG = 2;
      var WRAP_BIND_FLAG = 1, WRAP_BIND_KEY_FLAG = 2, WRAP_CURRY_BOUND_FLAG = 4, WRAP_CURRY_FLAG = 8, WRAP_CURRY_RIGHT_FLAG = 16, WRAP_PARTIAL_FLAG = 32, WRAP_PARTIAL_RIGHT_FLAG = 64, WRAP_ARY_FLAG = 128, WRAP_REARG_FLAG = 256, WRAP_FLIP_FLAG = 512;
      var DEFAULT_TRUNC_LENGTH = 30, DEFAULT_TRUNC_OMISSION = "...";
      var HOT_COUNT = 800, HOT_SPAN = 16;
      var LAZY_FILTER_FLAG = 1, LAZY_MAP_FLAG = 2, LAZY_WHILE_FLAG = 3;
      var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 17976931348623157e292, NAN = 0 / 0;
      var MAX_ARRAY_LENGTH = 4294967295, MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1, HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;
      var wrapFlags = [
        ["ary", WRAP_ARY_FLAG],
        ["bind", WRAP_BIND_FLAG],
        ["bindKey", WRAP_BIND_KEY_FLAG],
        ["curry", WRAP_CURRY_FLAG],
        ["curryRight", WRAP_CURRY_RIGHT_FLAG],
        ["flip", WRAP_FLIP_FLAG],
        ["partial", WRAP_PARTIAL_FLAG],
        ["partialRight", WRAP_PARTIAL_RIGHT_FLAG],
        ["rearg", WRAP_REARG_FLAG]
      ];
      var argsTag = "[object Arguments]", arrayTag = "[object Array]", asyncTag = "[object AsyncFunction]", boolTag = "[object Boolean]", dateTag = "[object Date]", domExcTag = "[object DOMException]", errorTag = "[object Error]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", mapTag = "[object Map]", numberTag = "[object Number]", nullTag = "[object Null]", objectTag = "[object Object]", promiseTag = "[object Promise]", proxyTag = "[object Proxy]", regexpTag = "[object RegExp]", setTag = "[object Set]", stringTag = "[object String]", symbolTag = "[object Symbol]", undefinedTag = "[object Undefined]", weakMapTag = "[object WeakMap]", weakSetTag = "[object WeakSet]";
      var arrayBufferTag = "[object ArrayBuffer]", dataViewTag = "[object DataView]", float32Tag = "[object Float32Array]", float64Tag = "[object Float64Array]", int8Tag = "[object Int8Array]", int16Tag = "[object Int16Array]", int32Tag = "[object Int32Array]", uint8Tag = "[object Uint8Array]", uint8ClampedTag = "[object Uint8ClampedArray]", uint16Tag = "[object Uint16Array]", uint32Tag = "[object Uint32Array]";
      var reEmptyStringLeading = /\b__p \+= '';/g, reEmptyStringMiddle = /\b(__p \+=) '' \+/g, reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
      var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g, reUnescapedHtml = /[&<>"']/g, reHasEscapedHtml = RegExp(reEscapedHtml.source), reHasUnescapedHtml = RegExp(reUnescapedHtml.source);
      var reEscape = /<%-([\s\S]+?)%>/g, reEvaluate = /<%([\s\S]+?)%>/g, reInterpolate = /<%=([\s\S]+?)%>/g;
      var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/, reIsPlainProp = /^\w*$/, rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
      var reRegExpChar = /[\\^$.*+?()[\]{}|]/g, reHasRegExpChar = RegExp(reRegExpChar.source);
      var reTrimStart = /^\s+/;
      var reWhitespace = /\s/;
      var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/, reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/, reSplitDetails = /,? & /;
      var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
      var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;
      var reEscapeChar = /\\(\\)?/g;
      var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
      var reFlags = /\w*$/;
      var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
      var reIsBinary = /^0b[01]+$/i;
      var reIsHostCtor = /^\[object .+?Constructor\]$/;
      var reIsOctal = /^0o[0-7]+$/i;
      var reIsUint = /^(?:0|[1-9]\d*)$/;
      var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
      var reNoMatch = /($^)/;
      var reUnescapedString = /['\n\r\u2028\u2029\\]/g;
      var rsAstralRange = "\\ud800-\\udfff", rsComboMarksRange = "\\u0300-\\u036f", reComboHalfMarksRange = "\\ufe20-\\ufe2f", rsComboSymbolsRange = "\\u20d0-\\u20ff", rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange, rsDingbatRange = "\\u2700-\\u27bf", rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff", rsMathOpRange = "\\xac\\xb1\\xd7\\xf7", rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf", rsPunctuationRange = "\\u2000-\\u206f", rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000", rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde", rsVarRange = "\\ufe0e\\ufe0f", rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
      var rsApos = "[']", rsAstral = "[" + rsAstralRange + "]", rsBreak = "[" + rsBreakRange + "]", rsCombo = "[" + rsComboRange + "]", rsDigits = "\\d+", rsDingbat = "[" + rsDingbatRange + "]", rsLower = "[" + rsLowerRange + "]", rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]", rsFitz = "\\ud83c[\\udffb-\\udfff]", rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")", rsNonAstral = "[^" + rsAstralRange + "]", rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}", rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]", rsUpper = "[" + rsUpperRange + "]", rsZWJ = "\\u200d";
      var rsMiscLower = "(?:" + rsLower + "|" + rsMisc + ")", rsMiscUpper = "(?:" + rsUpper + "|" + rsMisc + ")", rsOptContrLower = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?", rsOptContrUpper = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?", reOptMod = rsModifier + "?", rsOptVar = "[" + rsVarRange + "]?", rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*", rsOrdLower = "\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])", rsOrdUpper = "\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])", rsSeq = rsOptVar + reOptMod + rsOptJoin, rsEmoji = "(?:" + [rsDingbat, rsRegional, rsSurrPair].join("|") + ")" + rsSeq, rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
      var reApos = RegExp(rsApos, "g");
      var reComboMark = RegExp(rsCombo, "g");
      var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
      var reUnicodeWord = RegExp([
        rsUpper + "?" + rsLower + "+" + rsOptContrLower + "(?=" + [rsBreak, rsUpper, "$"].join("|") + ")",
        rsMiscUpper + "+" + rsOptContrUpper + "(?=" + [rsBreak, rsUpper + rsMiscLower, "$"].join("|") + ")",
        rsUpper + "?" + rsMiscLower + "+" + rsOptContrLower,
        rsUpper + "+" + rsOptContrUpper,
        rsOrdUpper,
        rsOrdLower,
        rsDigits,
        rsEmoji
      ].join("|"), "g");
      var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboRange + rsVarRange + "]");
      var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
      var contextProps = [
        "Array",
        "Buffer",
        "DataView",
        "Date",
        "Error",
        "Float32Array",
        "Float64Array",
        "Function",
        "Int8Array",
        "Int16Array",
        "Int32Array",
        "Map",
        "Math",
        "Object",
        "Promise",
        "RegExp",
        "Set",
        "String",
        "Symbol",
        "TypeError",
        "Uint8Array",
        "Uint8ClampedArray",
        "Uint16Array",
        "Uint32Array",
        "WeakMap",
        "_",
        "clearTimeout",
        "isFinite",
        "parseInt",
        "setTimeout"
      ];
      var templateCounter = -1;
      var typedArrayTags = {};
      typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
      typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
      var cloneableTags = {};
      cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
      cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
      var deburredLetters = {
        // Latin-1 Supplement block.
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "c",
        "": "D",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "N",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "o",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "Y",
        "": "y",
        "": "y",
        "": "Ae",
        "": "ae",
        "": "Th",
        "": "th",
        "": "ss",
        // Latin Extended-A block.
        "": "A",
        "": "A",
        "": "A",
        "": "a",
        "": "a",
        "": "a",
        "": "C",
        "": "C",
        "": "C",
        "": "C",
        "": "c",
        "": "c",
        "": "c",
        "": "c",
        "": "D",
        "": "D",
        "": "d",
        "": "d",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "E",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "e",
        "": "G",
        "": "G",
        "": "G",
        "": "G",
        "": "g",
        "": "g",
        "": "g",
        "": "g",
        "": "H",
        "": "H",
        "": "h",
        "": "h",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "I",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "i",
        "": "J",
        "": "j",
        "": "K",
        "": "k",
        "": "k",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "L",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "l",
        "": "N",
        "": "N",
        "": "N",
        "": "N",
        "": "n",
        "": "n",
        "": "n",
        "": "n",
        "": "O",
        "": "O",
        "": "O",
        "": "o",
        "": "o",
        "": "o",
        "": "R",
        "": "R",
        "": "R",
        "": "r",
        "": "r",
        "": "r",
        "": "S",
        "": "S",
        "": "S",
        "": "S",
        "": "s",
        "": "s",
        "": "s",
        "": "s",
        "": "T",
        "": "T",
        "": "T",
        "": "t",
        "": "t",
        "": "t",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "U",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "u",
        "": "W",
        "": "w",
        "": "Y",
        "": "y",
        "": "Y",
        "": "Z",
        "": "Z",
        "": "Z",
        "": "z",
        "": "z",
        "": "z",
        "": "IJ",
        "": "ij",
        "": "Oe",
        "": "oe",
        "": "'n",
        "": "s"
      };
      var htmlEscapes = {
        "&": "&amp;",
        "<": "&lt;",
        ">": "&gt;",
        '"': "&quot;",
        "'": "&#39;"
      };
      var htmlUnescapes = {
        "&amp;": "&",
        "&lt;": "<",
        "&gt;": ">",
        "&quot;": '"',
        "&#39;": "'"
      };
      var stringEscapes = {
        "\\": "\\",
        "'": "'",
        "\n": "n",
        "\r": "r",
        "\u2028": "u2028",
        "\u2029": "u2029"
      };
      var freeParseFloat = parseFloat, freeParseInt = parseInt;
      var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
      var freeSelf = typeof self == "object" && self && self.Object === Object && self;
      var root = freeGlobal || freeSelf || Function("return this")();
      var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
      var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
      var moduleExports = freeModule && freeModule.exports === freeExports;
      var freeProcess = moduleExports && freeGlobal.process;
      var nodeUtil = function() {
        try {
          var types = freeModule && freeModule.require && freeModule.require("util").types;
          if (types) {
            return types;
          }
          return freeProcess && freeProcess.binding && freeProcess.binding("util");
        } catch (e) {
        }
      }();
      var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer, nodeIsDate = nodeUtil && nodeUtil.isDate, nodeIsMap = nodeUtil && nodeUtil.isMap, nodeIsRegExp = nodeUtil && nodeUtil.isRegExp, nodeIsSet = nodeUtil && nodeUtil.isSet, nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
      function apply(func, thisArg, args) {
        switch (args.length) {
          case 0:
            return func.call(thisArg);
          case 1:
            return func.call(thisArg, args[0]);
          case 2:
            return func.call(thisArg, args[0], args[1]);
          case 3:
            return func.call(thisArg, args[0], args[1], args[2]);
        }
        return func.apply(thisArg, args);
      }
      function arrayAggregator(array, setter, iteratee, accumulator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          var value = array[index];
          setter(accumulator, value, iteratee(value), array);
        }
        return accumulator;
      }
      function arrayEach(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (iteratee(array[index], index, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEachRight(array, iteratee) {
        var length = array == null ? 0 : array.length;
        while (length--) {
          if (iteratee(array[length], length, array) === false) {
            break;
          }
        }
        return array;
      }
      function arrayEvery(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (!predicate(array[index], index, array)) {
            return false;
          }
        }
        return true;
      }
      function arrayFilter(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (predicate(value, index, array)) {
            result[resIndex++] = value;
          }
        }
        return result;
      }
      function arrayIncludes(array, value) {
        var length = array == null ? 0 : array.length;
        return !!length && baseIndexOf(array, value, 0) > -1;
      }
      function arrayIncludesWith(array, value, comparator) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (comparator(value, array[index])) {
            return true;
          }
        }
        return false;
      }
      function arrayMap(array, iteratee) {
        var index = -1, length = array == null ? 0 : array.length, result = Array(length);
        while (++index < length) {
          result[index] = iteratee(array[index], index, array);
        }
        return result;
      }
      function arrayPush(array, values) {
        var index = -1, length = values.length, offset = array.length;
        while (++index < length) {
          array[offset + index] = values[index];
        }
        return array;
      }
      function arrayReduce(array, iteratee, accumulator, initAccum) {
        var index = -1, length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[++index];
        }
        while (++index < length) {
          accumulator = iteratee(accumulator, array[index], index, array);
        }
        return accumulator;
      }
      function arrayReduceRight(array, iteratee, accumulator, initAccum) {
        var length = array == null ? 0 : array.length;
        if (initAccum && length) {
          accumulator = array[--length];
        }
        while (length--) {
          accumulator = iteratee(accumulator, array[length], length, array);
        }
        return accumulator;
      }
      function arraySome(array, predicate) {
        var index = -1, length = array == null ? 0 : array.length;
        while (++index < length) {
          if (predicate(array[index], index, array)) {
            return true;
          }
        }
        return false;
      }
      var asciiSize = baseProperty("length");
      function asciiToArray(string) {
        return string.split("");
      }
      function asciiWords(string) {
        return string.match(reAsciiWord) || [];
      }
      function baseFindKey(collection, predicate, eachFunc) {
        var result;
        eachFunc(collection, function(value, key, collection2) {
          if (predicate(value, key, collection2)) {
            result = key;
            return false;
          }
        });
        return result;
      }
      function baseFindIndex(array, predicate, fromIndex, fromRight) {
        var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
        while (fromRight ? index-- : ++index < length) {
          if (predicate(array[index], index, array)) {
            return index;
          }
        }
        return -1;
      }
      function baseIndexOf(array, value, fromIndex) {
        return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
      }
      function baseIndexOfWith(array, value, fromIndex, comparator) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (comparator(array[index], value)) {
            return index;
          }
        }
        return -1;
      }
      function baseIsNaN(value) {
        return value !== value;
      }
      function baseMean(array, iteratee) {
        var length = array == null ? 0 : array.length;
        return length ? baseSum(array, iteratee) / length : NAN;
      }
      function baseProperty(key) {
        return function(object) {
          return object == null ? undefined2 : object[key];
        };
      }
      function basePropertyOf(object) {
        return function(key) {
          return object == null ? undefined2 : object[key];
        };
      }
      function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
        eachFunc(collection, function(value, index, collection2) {
          accumulator = initAccum ? (initAccum = false, value) : iteratee(accumulator, value, index, collection2);
        });
        return accumulator;
      }
      function baseSortBy(array, comparer) {
        var length = array.length;
        array.sort(comparer);
        while (length--) {
          array[length] = array[length].value;
        }
        return array;
      }
      function baseSum(array, iteratee) {
        var result, index = -1, length = array.length;
        while (++index < length) {
          var current = iteratee(array[index]);
          if (current !== undefined2) {
            result = result === undefined2 ? current : result + current;
          }
        }
        return result;
      }
      function baseTimes(n, iteratee) {
        var index = -1, result = Array(n);
        while (++index < n) {
          result[index] = iteratee(index);
        }
        return result;
      }
      function baseToPairs(object, props) {
        return arrayMap(props, function(key) {
          return [key, object[key]];
        });
      }
      function baseTrim(string) {
        return string ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, "") : string;
      }
      function baseUnary(func) {
        return function(value) {
          return func(value);
        };
      }
      function baseValues(object, props) {
        return arrayMap(props, function(key) {
          return object[key];
        });
      }
      function cacheHas(cache, key) {
        return cache.has(key);
      }
      function charsStartIndex(strSymbols, chrSymbols) {
        var index = -1, length = strSymbols.length;
        while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function charsEndIndex(strSymbols, chrSymbols) {
        var index = strSymbols.length;
        while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {
        }
        return index;
      }
      function countHolders(array, placeholder) {
        var length = array.length, result = 0;
        while (length--) {
          if (array[length] === placeholder) {
            ++result;
          }
        }
        return result;
      }
      var deburrLetter = basePropertyOf(deburredLetters);
      var escapeHtmlChar = basePropertyOf(htmlEscapes);
      function escapeStringChar(chr) {
        return "\\" + stringEscapes[chr];
      }
      function getValue(object, key) {
        return object == null ? undefined2 : object[key];
      }
      function hasUnicode(string) {
        return reHasUnicode.test(string);
      }
      function hasUnicodeWord(string) {
        return reHasUnicodeWord.test(string);
      }
      function iteratorToArray(iterator) {
        var data, result = [];
        while (!(data = iterator.next()).done) {
          result.push(data.value);
        }
        return result;
      }
      function mapToArray(map) {
        var index = -1, result = Array(map.size);
        map.forEach(function(value, key) {
          result[++index] = [key, value];
        });
        return result;
      }
      function overArg(func, transform) {
        return function(arg) {
          return func(transform(arg));
        };
      }
      function replaceHolders(array, placeholder) {
        var index = -1, length = array.length, resIndex = 0, result = [];
        while (++index < length) {
          var value = array[index];
          if (value === placeholder || value === PLACEHOLDER) {
            array[index] = PLACEHOLDER;
            result[resIndex++] = index;
          }
        }
        return result;
      }
      function setToArray(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = value;
        });
        return result;
      }
      function setToPairs(set) {
        var index = -1, result = Array(set.size);
        set.forEach(function(value) {
          result[++index] = [value, value];
        });
        return result;
      }
      function strictIndexOf(array, value, fromIndex) {
        var index = fromIndex - 1, length = array.length;
        while (++index < length) {
          if (array[index] === value) {
            return index;
          }
        }
        return -1;
      }
      function strictLastIndexOf(array, value, fromIndex) {
        var index = fromIndex + 1;
        while (index--) {
          if (array[index] === value) {
            return index;
          }
        }
        return index;
      }
      function stringSize(string) {
        return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
      }
      function stringToArray(string) {
        return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
      }
      function trimmedEndIndex(string) {
        var index = string.length;
        while (index-- && reWhitespace.test(string.charAt(index))) {
        }
        return index;
      }
      var unescapeHtmlChar = basePropertyOf(htmlUnescapes);
      function unicodeSize(string) {
        var result = reUnicode.lastIndex = 0;
        while (reUnicode.test(string)) {
          ++result;
        }
        return result;
      }
      function unicodeToArray(string) {
        return string.match(reUnicode) || [];
      }
      function unicodeWords(string) {
        return string.match(reUnicodeWord) || [];
      }
      var runInContext = function runInContext2(context) {
        context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));
        var Array2 = context.Array, Date2 = context.Date, Error2 = context.Error, Function2 = context.Function, Math2 = context.Math, Object2 = context.Object, RegExp2 = context.RegExp, String2 = context.String, TypeError2 = context.TypeError;
        var arrayProto = Array2.prototype, funcProto = Function2.prototype, objectProto = Object2.prototype;
        var coreJsData = context["__core-js_shared__"];
        var funcToString = funcProto.toString;
        var hasOwnProperty = objectProto.hasOwnProperty;
        var idCounter = 0;
        var maskSrcKey = function() {
          var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
          return uid ? "Symbol(src)_1." + uid : "";
        }();
        var nativeObjectToString = objectProto.toString;
        var objectCtorString = funcToString.call(Object2);
        var oldDash = root._;
        var reIsNative = RegExp2(
          "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
        );
        var Buffer2 = moduleExports ? context.Buffer : undefined2, Symbol = context.Symbol, Uint8Array2 = context.Uint8Array, allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : undefined2, getPrototype = overArg(Object2.getPrototypeOf, Object2), objectCreate = Object2.create, propertyIsEnumerable = objectProto.propertyIsEnumerable, splice = arrayProto.splice, spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined2, symIterator = Symbol ? Symbol.iterator : undefined2, symToStringTag = Symbol ? Symbol.toStringTag : undefined2;
        var defineProperty = function() {
          try {
            var func = getNative(Object2, "defineProperty");
            func({}, "", {});
            return func;
          } catch (e) {
          }
        }();
        var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout, ctxNow = Date2 && Date2.now !== root.Date.now && Date2.now, ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;
        var nativeCeil = Math2.ceil, nativeFloor = Math2.floor, nativeGetSymbols = Object2.getOwnPropertySymbols, nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : undefined2, nativeIsFinite = context.isFinite, nativeJoin = arrayProto.join, nativeKeys = overArg(Object2.keys, Object2), nativeMax = Math2.max, nativeMin = Math2.min, nativeNow = Date2.now, nativeParseInt = context.parseInt, nativeRandom = Math2.random, nativeReverse = arrayProto.reverse;
        var DataView2 = getNative(context, "DataView"), Map2 = getNative(context, "Map"), Promise2 = getNative(context, "Promise"), Set2 = getNative(context, "Set"), WeakMap2 = getNative(context, "WeakMap"), nativeCreate = getNative(Object2, "create");
        var metaMap = WeakMap2 && new WeakMap2();
        var realNames = {};
        var dataViewCtorString = toSource(DataView2), mapCtorString = toSource(Map2), promiseCtorString = toSource(Promise2), setCtorString = toSource(Set2), weakMapCtorString = toSource(WeakMap2);
        var symbolProto = Symbol ? Symbol.prototype : undefined2, symbolValueOf = symbolProto ? symbolProto.valueOf : undefined2, symbolToString = symbolProto ? symbolProto.toString : undefined2;
        function lodash(value) {
          if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
            if (value instanceof LodashWrapper) {
              return value;
            }
            if (hasOwnProperty.call(value, "__wrapped__")) {
              return wrapperClone(value);
            }
          }
          return new LodashWrapper(value);
        }
        var baseCreate = /* @__PURE__ */ function() {
          function object() {
          }
          return function(proto) {
            if (!isObject(proto)) {
              return {};
            }
            if (objectCreate) {
              return objectCreate(proto);
            }
            object.prototype = proto;
            var result2 = new object();
            object.prototype = undefined2;
            return result2;
          };
        }();
        function baseLodash() {
        }
        function LodashWrapper(value, chainAll) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__chain__ = !!chainAll;
          this.__index__ = 0;
          this.__values__ = undefined2;
        }
        lodash.templateSettings = {
          /**
           * Used to detect `data` property values to be HTML-escaped.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "escape": reEscape,
          /**
           * Used to detect code to be evaluated.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "evaluate": reEvaluate,
          /**
           * Used to detect `data` property values to inject.
           *
           * @memberOf _.templateSettings
           * @type {RegExp}
           */
          "interpolate": reInterpolate,
          /**
           * Used to reference the data object in the template text.
           *
           * @memberOf _.templateSettings
           * @type {string}
           */
          "variable": "",
          /**
           * Used to import variables into the compiled template.
           *
           * @memberOf _.templateSettings
           * @type {Object}
           */
          "imports": {
            /**
             * A reference to the `lodash` function.
             *
             * @memberOf _.templateSettings.imports
             * @type {Function}
             */
            "_": lodash
          }
        };
        lodash.prototype = baseLodash.prototype;
        lodash.prototype.constructor = lodash;
        LodashWrapper.prototype = baseCreate(baseLodash.prototype);
        LodashWrapper.prototype.constructor = LodashWrapper;
        function LazyWrapper(value) {
          this.__wrapped__ = value;
          this.__actions__ = [];
          this.__dir__ = 1;
          this.__filtered__ = false;
          this.__iteratees__ = [];
          this.__takeCount__ = MAX_ARRAY_LENGTH;
          this.__views__ = [];
        }
        function lazyClone() {
          var result2 = new LazyWrapper(this.__wrapped__);
          result2.__actions__ = copyArray(this.__actions__);
          result2.__dir__ = this.__dir__;
          result2.__filtered__ = this.__filtered__;
          result2.__iteratees__ = copyArray(this.__iteratees__);
          result2.__takeCount__ = this.__takeCount__;
          result2.__views__ = copyArray(this.__views__);
          return result2;
        }
        function lazyReverse() {
          if (this.__filtered__) {
            var result2 = new LazyWrapper(this);
            result2.__dir__ = -1;
            result2.__filtered__ = true;
          } else {
            result2 = this.clone();
            result2.__dir__ *= -1;
          }
          return result2;
        }
        function lazyValue() {
          var array = this.__wrapped__.value(), dir = this.__dir__, isArr = isArray(array), isRight = dir < 0, arrLength = isArr ? array.length : 0, view = getView(0, arrLength, this.__views__), start = view.start, end = view.end, length = end - start, index = isRight ? end : start - 1, iteratees = this.__iteratees__, iterLength = iteratees.length, resIndex = 0, takeCount = nativeMin(length, this.__takeCount__);
          if (!isArr || !isRight && arrLength == length && takeCount == length) {
            return baseWrapperValue(array, this.__actions__);
          }
          var result2 = [];
          outer:
            while (length-- && resIndex < takeCount) {
              index += dir;
              var iterIndex = -1, value = array[index];
              while (++iterIndex < iterLength) {
                var data = iteratees[iterIndex], iteratee2 = data.iteratee, type = data.type, computed = iteratee2(value);
                if (type == LAZY_MAP_FLAG) {
                  value = computed;
                } else if (!computed) {
                  if (type == LAZY_FILTER_FLAG) {
                    continue outer;
                  } else {
                    break outer;
                  }
                }
              }
              result2[resIndex++] = value;
            }
          return result2;
        }
        LazyWrapper.prototype = baseCreate(baseLodash.prototype);
        LazyWrapper.prototype.constructor = LazyWrapper;
        function Hash(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function hashClear() {
          this.__data__ = nativeCreate ? nativeCreate(null) : {};
          this.size = 0;
        }
        function hashDelete(key) {
          var result2 = this.has(key) && delete this.__data__[key];
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function hashGet(key) {
          var data = this.__data__;
          if (nativeCreate) {
            var result2 = data[key];
            return result2 === HASH_UNDEFINED ? undefined2 : result2;
          }
          return hasOwnProperty.call(data, key) ? data[key] : undefined2;
        }
        function hashHas(key) {
          var data = this.__data__;
          return nativeCreate ? data[key] !== undefined2 : hasOwnProperty.call(data, key);
        }
        function hashSet(key, value) {
          var data = this.__data__;
          this.size += this.has(key) ? 0 : 1;
          data[key] = nativeCreate && value === undefined2 ? HASH_UNDEFINED : value;
          return this;
        }
        Hash.prototype.clear = hashClear;
        Hash.prototype["delete"] = hashDelete;
        Hash.prototype.get = hashGet;
        Hash.prototype.has = hashHas;
        Hash.prototype.set = hashSet;
        function ListCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function listCacheClear() {
          this.__data__ = [];
          this.size = 0;
        }
        function listCacheDelete(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            return false;
          }
          var lastIndex = data.length - 1;
          if (index == lastIndex) {
            data.pop();
          } else {
            splice.call(data, index, 1);
          }
          --this.size;
          return true;
        }
        function listCacheGet(key) {
          var data = this.__data__, index = assocIndexOf(data, key);
          return index < 0 ? undefined2 : data[index][1];
        }
        function listCacheHas(key) {
          return assocIndexOf(this.__data__, key) > -1;
        }
        function listCacheSet(key, value) {
          var data = this.__data__, index = assocIndexOf(data, key);
          if (index < 0) {
            ++this.size;
            data.push([key, value]);
          } else {
            data[index][1] = value;
          }
          return this;
        }
        ListCache.prototype.clear = listCacheClear;
        ListCache.prototype["delete"] = listCacheDelete;
        ListCache.prototype.get = listCacheGet;
        ListCache.prototype.has = listCacheHas;
        ListCache.prototype.set = listCacheSet;
        function MapCache(entries) {
          var index = -1, length = entries == null ? 0 : entries.length;
          this.clear();
          while (++index < length) {
            var entry = entries[index];
            this.set(entry[0], entry[1]);
          }
        }
        function mapCacheClear() {
          this.size = 0;
          this.__data__ = {
            "hash": new Hash(),
            "map": new (Map2 || ListCache)(),
            "string": new Hash()
          };
        }
        function mapCacheDelete(key) {
          var result2 = getMapData(this, key)["delete"](key);
          this.size -= result2 ? 1 : 0;
          return result2;
        }
        function mapCacheGet(key) {
          return getMapData(this, key).get(key);
        }
        function mapCacheHas(key) {
          return getMapData(this, key).has(key);
        }
        function mapCacheSet(key, value) {
          var data = getMapData(this, key), size2 = data.size;
          data.set(key, value);
          this.size += data.size == size2 ? 0 : 1;
          return this;
        }
        MapCache.prototype.clear = mapCacheClear;
        MapCache.prototype["delete"] = mapCacheDelete;
        MapCache.prototype.get = mapCacheGet;
        MapCache.prototype.has = mapCacheHas;
        MapCache.prototype.set = mapCacheSet;
        function SetCache(values2) {
          var index = -1, length = values2 == null ? 0 : values2.length;
          this.__data__ = new MapCache();
          while (++index < length) {
            this.add(values2[index]);
          }
        }
        function setCacheAdd(value) {
          this.__data__.set(value, HASH_UNDEFINED);
          return this;
        }
        function setCacheHas(value) {
          return this.__data__.has(value);
        }
        SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
        SetCache.prototype.has = setCacheHas;
        function Stack(entries) {
          var data = this.__data__ = new ListCache(entries);
          this.size = data.size;
        }
        function stackClear() {
          this.__data__ = new ListCache();
          this.size = 0;
        }
        function stackDelete(key) {
          var data = this.__data__, result2 = data["delete"](key);
          this.size = data.size;
          return result2;
        }
        function stackGet(key) {
          return this.__data__.get(key);
        }
        function stackHas(key) {
          return this.__data__.has(key);
        }
        function stackSet(key, value) {
          var data = this.__data__;
          if (data instanceof ListCache) {
            var pairs = data.__data__;
            if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
              pairs.push([key, value]);
              this.size = ++data.size;
              return this;
            }
            data = this.__data__ = new MapCache(pairs);
          }
          data.set(key, value);
          this.size = data.size;
          return this;
        }
        Stack.prototype.clear = stackClear;
        Stack.prototype["delete"] = stackDelete;
        Stack.prototype.get = stackGet;
        Stack.prototype.has = stackHas;
        Stack.prototype.set = stackSet;
        function arrayLikeKeys(value, inherited) {
          var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result2 = skipIndexes ? baseTimes(value.length, String2) : [], length = result2.length;
          for (var key in value) {
            if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && // Safari 9 has enumerable `arguments.length` in strict mode.
            (key == "length" || // Node.js 0.10 has enumerable non-index properties on buffers.
            isBuff && (key == "offset" || key == "parent") || // PhantomJS 2 has enumerable non-index properties on typed arrays.
            isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || // Skip index properties.
            isIndex(key, length)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function arraySample(array) {
          var length = array.length;
          return length ? array[baseRandom(0, length - 1)] : undefined2;
        }
        function arraySampleSize(array, n) {
          return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
        }
        function arrayShuffle(array) {
          return shuffleSelf(copyArray(array));
        }
        function assignMergeValue(object, key, value) {
          if (value !== undefined2 && !eq(object[key], value) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assignValue(object, key, value) {
          var objValue = object[key];
          if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined2 && !(key in object)) {
            baseAssignValue(object, key, value);
          }
        }
        function assocIndexOf(array, key) {
          var length = array.length;
          while (length--) {
            if (eq(array[length][0], key)) {
              return length;
            }
          }
          return -1;
        }
        function baseAggregator(collection, setter, iteratee2, accumulator) {
          baseEach(collection, function(value, key, collection2) {
            setter(accumulator, value, iteratee2(value), collection2);
          });
          return accumulator;
        }
        function baseAssign(object, source) {
          return object && copyObject(source, keys(source), object);
        }
        function baseAssignIn(object, source) {
          return object && copyObject(source, keysIn(source), object);
        }
        function baseAssignValue(object, key, value) {
          if (key == "__proto__" && defineProperty) {
            defineProperty(object, key, {
              "configurable": true,
              "enumerable": true,
              "value": value,
              "writable": true
            });
          } else {
            object[key] = value;
          }
        }
        function baseAt(object, paths) {
          var index = -1, length = paths.length, result2 = Array2(length), skip = object == null;
          while (++index < length) {
            result2[index] = skip ? undefined2 : get(object, paths[index]);
          }
          return result2;
        }
        function baseClamp(number, lower, upper) {
          if (number === number) {
            if (upper !== undefined2) {
              number = number <= upper ? number : upper;
            }
            if (lower !== undefined2) {
              number = number >= lower ? number : lower;
            }
          }
          return number;
        }
        function baseClone(value, bitmask, customizer, key, object, stack) {
          var result2, isDeep = bitmask & CLONE_DEEP_FLAG, isFlat = bitmask & CLONE_FLAT_FLAG, isFull = bitmask & CLONE_SYMBOLS_FLAG;
          if (customizer) {
            result2 = object ? customizer(value, key, object, stack) : customizer(value);
          }
          if (result2 !== undefined2) {
            return result2;
          }
          if (!isObject(value)) {
            return value;
          }
          var isArr = isArray(value);
          if (isArr) {
            result2 = initCloneArray(value);
            if (!isDeep) {
              return copyArray(value, result2);
            }
          } else {
            var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
            if (isBuffer(value)) {
              return cloneBuffer(value, isDeep);
            }
            if (tag == objectTag || tag == argsTag || isFunc && !object) {
              result2 = isFlat || isFunc ? {} : initCloneObject(value);
              if (!isDeep) {
                return isFlat ? copySymbolsIn(value, baseAssignIn(result2, value)) : copySymbols(value, baseAssign(result2, value));
              }
            } else {
              if (!cloneableTags[tag]) {
                return object ? value : {};
              }
              result2 = initCloneByTag(value, tag, isDeep);
            }
          }
          stack || (stack = new Stack());
          var stacked = stack.get(value);
          if (stacked) {
            return stacked;
          }
          stack.set(value, result2);
          if (isSet(value)) {
            value.forEach(function(subValue) {
              result2.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
            });
          } else if (isMap(value)) {
            value.forEach(function(subValue, key2) {
              result2.set(key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
            });
          }
          var keysFunc = isFull ? isFlat ? getAllKeysIn : getAllKeys : isFlat ? keysIn : keys;
          var props = isArr ? undefined2 : keysFunc(value);
          arrayEach(props || value, function(subValue, key2) {
            if (props) {
              key2 = subValue;
              subValue = value[key2];
            }
            assignValue(result2, key2, baseClone(subValue, bitmask, customizer, key2, value, stack));
          });
          return result2;
        }
        function baseConforms(source) {
          var props = keys(source);
          return function(object) {
            return baseConformsTo(object, source, props);
          };
        }
        function baseConformsTo(object, source, props) {
          var length = props.length;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (length--) {
            var key = props[length], predicate = source[key], value = object[key];
            if (value === undefined2 && !(key in object) || !predicate(value)) {
              return false;
            }
          }
          return true;
        }
        function baseDelay(func, wait, args) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return setTimeout2(function() {
            func.apply(undefined2, args);
          }, wait);
        }
        function baseDifference(array, values2, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, isCommon = true, length = array.length, result2 = [], valuesLength = values2.length;
          if (!length) {
            return result2;
          }
          if (iteratee2) {
            values2 = arrayMap(values2, baseUnary(iteratee2));
          }
          if (comparator) {
            includes2 = arrayIncludesWith;
            isCommon = false;
          } else if (values2.length >= LARGE_ARRAY_SIZE) {
            includes2 = cacheHas;
            isCommon = false;
            values2 = new SetCache(values2);
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 == null ? value : iteratee2(value);
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var valuesIndex = valuesLength;
                while (valuesIndex--) {
                  if (values2[valuesIndex] === computed) {
                    continue outer;
                  }
                }
                result2.push(value);
              } else if (!includes2(values2, computed, comparator)) {
                result2.push(value);
              }
            }
          return result2;
        }
        var baseEach = createBaseEach(baseForOwn);
        var baseEachRight = createBaseEach(baseForOwnRight, true);
        function baseEvery(collection, predicate) {
          var result2 = true;
          baseEach(collection, function(value, index, collection2) {
            result2 = !!predicate(value, index, collection2);
            return result2;
          });
          return result2;
        }
        function baseExtremum(array, iteratee2, comparator) {
          var index = -1, length = array.length;
          while (++index < length) {
            var value = array[index], current = iteratee2(value);
            if (current != null && (computed === undefined2 ? current === current && !isSymbol(current) : comparator(current, computed))) {
              var computed = current, result2 = value;
            }
          }
          return result2;
        }
        function baseFill(array, value, start, end) {
          var length = array.length;
          start = toInteger(start);
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end === undefined2 || end > length ? length : toInteger(end);
          if (end < 0) {
            end += length;
          }
          end = start > end ? 0 : toLength(end);
          while (start < end) {
            array[start++] = value;
          }
          return array;
        }
        function baseFilter(collection, predicate) {
          var result2 = [];
          baseEach(collection, function(value, index, collection2) {
            if (predicate(value, index, collection2)) {
              result2.push(value);
            }
          });
          return result2;
        }
        function baseFlatten(array, depth, predicate, isStrict, result2) {
          var index = -1, length = array.length;
          predicate || (predicate = isFlattenable);
          result2 || (result2 = []);
          while (++index < length) {
            var value = array[index];
            if (depth > 0 && predicate(value)) {
              if (depth > 1) {
                baseFlatten(value, depth - 1, predicate, isStrict, result2);
              } else {
                arrayPush(result2, value);
              }
            } else if (!isStrict) {
              result2[result2.length] = value;
            }
          }
          return result2;
        }
        var baseFor = createBaseFor();
        var baseForRight = createBaseFor(true);
        function baseForOwn(object, iteratee2) {
          return object && baseFor(object, iteratee2, keys);
        }
        function baseForOwnRight(object, iteratee2) {
          return object && baseForRight(object, iteratee2, keys);
        }
        function baseFunctions(object, props) {
          return arrayFilter(props, function(key) {
            return isFunction(object[key]);
          });
        }
        function baseGet(object, path) {
          path = castPath(path, object);
          var index = 0, length = path.length;
          while (object != null && index < length) {
            object = object[toKey(path[index++])];
          }
          return index && index == length ? object : undefined2;
        }
        function baseGetAllKeys(object, keysFunc, symbolsFunc) {
          var result2 = keysFunc(object);
          return isArray(object) ? result2 : arrayPush(result2, symbolsFunc(object));
        }
        function baseGetTag(value) {
          if (value == null) {
            return value === undefined2 ? undefinedTag : nullTag;
          }
          return symToStringTag && symToStringTag in Object2(value) ? getRawTag(value) : objectToString(value);
        }
        function baseGt(value, other) {
          return value > other;
        }
        function baseHas(object, key) {
          return object != null && hasOwnProperty.call(object, key);
        }
        function baseHasIn(object, key) {
          return object != null && key in Object2(object);
        }
        function baseInRange(number, start, end) {
          return number >= nativeMin(start, end) && number < nativeMax(start, end);
        }
        function baseIntersection(arrays, iteratee2, comparator) {
          var includes2 = comparator ? arrayIncludesWith : arrayIncludes, length = arrays[0].length, othLength = arrays.length, othIndex = othLength, caches = Array2(othLength), maxLength = Infinity, result2 = [];
          while (othIndex--) {
            var array = arrays[othIndex];
            if (othIndex && iteratee2) {
              array = arrayMap(array, baseUnary(iteratee2));
            }
            maxLength = nativeMin(array.length, maxLength);
            caches[othIndex] = !comparator && (iteratee2 || length >= 120 && array.length >= 120) ? new SetCache(othIndex && array) : undefined2;
          }
          array = arrays[0];
          var index = -1, seen = caches[0];
          outer:
            while (++index < length && result2.length < maxLength) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (!(seen ? cacheHas(seen, computed) : includes2(result2, computed, comparator))) {
                othIndex = othLength;
                while (--othIndex) {
                  var cache = caches[othIndex];
                  if (!(cache ? cacheHas(cache, computed) : includes2(arrays[othIndex], computed, comparator))) {
                    continue outer;
                  }
                }
                if (seen) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseInverter(object, setter, iteratee2, accumulator) {
          baseForOwn(object, function(value, key, object2) {
            setter(accumulator, iteratee2(value), key, object2);
          });
          return accumulator;
        }
        function baseInvoke(object, path, args) {
          path = castPath(path, object);
          object = parent(object, path);
          var func = object == null ? object : object[toKey(last(path))];
          return func == null ? undefined2 : apply(func, object, args);
        }
        function baseIsArguments(value) {
          return isObjectLike(value) && baseGetTag(value) == argsTag;
        }
        function baseIsArrayBuffer(value) {
          return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
        }
        function baseIsDate(value) {
          return isObjectLike(value) && baseGetTag(value) == dateTag;
        }
        function baseIsEqual(value, other, bitmask, customizer, stack) {
          if (value === other) {
            return true;
          }
          if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
            return value !== value && other !== other;
          }
          return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
        }
        function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
          var objIsArr = isArray(object), othIsArr = isArray(other), objTag = objIsArr ? arrayTag : getTag(object), othTag = othIsArr ? arrayTag : getTag(other);
          objTag = objTag == argsTag ? objectTag : objTag;
          othTag = othTag == argsTag ? objectTag : othTag;
          var objIsObj = objTag == objectTag, othIsObj = othTag == objectTag, isSameTag = objTag == othTag;
          if (isSameTag && isBuffer(object)) {
            if (!isBuffer(other)) {
              return false;
            }
            objIsArr = true;
            objIsObj = false;
          }
          if (isSameTag && !objIsObj) {
            stack || (stack = new Stack());
            return objIsArr || isTypedArray(object) ? equalArrays(object, other, bitmask, customizer, equalFunc, stack) : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
          }
          if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
            var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
            if (objIsWrapped || othIsWrapped) {
              var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
              stack || (stack = new Stack());
              return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
            }
          }
          if (!isSameTag) {
            return false;
          }
          stack || (stack = new Stack());
          return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
        }
        function baseIsMap(value) {
          return isObjectLike(value) && getTag(value) == mapTag;
        }
        function baseIsMatch(object, source, matchData, customizer) {
          var index = matchData.length, length = index, noCustomizer = !customizer;
          if (object == null) {
            return !length;
          }
          object = Object2(object);
          while (index--) {
            var data = matchData[index];
            if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
              return false;
            }
          }
          while (++index < length) {
            data = matchData[index];
            var key = data[0], objValue = object[key], srcValue = data[1];
            if (noCustomizer && data[2]) {
              if (objValue === undefined2 && !(key in object)) {
                return false;
              }
            } else {
              var stack = new Stack();
              if (customizer) {
                var result2 = customizer(objValue, srcValue, key, object, source, stack);
              }
              if (!(result2 === undefined2 ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack) : result2)) {
                return false;
              }
            }
          }
          return true;
        }
        function baseIsNative(value) {
          if (!isObject(value) || isMasked(value)) {
            return false;
          }
          var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
          return pattern.test(toSource(value));
        }
        function baseIsRegExp(value) {
          return isObjectLike(value) && baseGetTag(value) == regexpTag;
        }
        function baseIsSet(value) {
          return isObjectLike(value) && getTag(value) == setTag;
        }
        function baseIsTypedArray(value) {
          return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
        }
        function baseIteratee(value) {
          if (typeof value == "function") {
            return value;
          }
          if (value == null) {
            return identity;
          }
          if (typeof value == "object") {
            return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
          }
          return property(value);
        }
        function baseKeys(object) {
          if (!isPrototype(object)) {
            return nativeKeys(object);
          }
          var result2 = [];
          for (var key in Object2(object)) {
            if (hasOwnProperty.call(object, key) && key != "constructor") {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseKeysIn(object) {
          if (!isObject(object)) {
            return nativeKeysIn(object);
          }
          var isProto = isPrototype(object), result2 = [];
          for (var key in object) {
            if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
              result2.push(key);
            }
          }
          return result2;
        }
        function baseLt(value, other) {
          return value < other;
        }
        function baseMap(collection, iteratee2) {
          var index = -1, result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value, key, collection2) {
            result2[++index] = iteratee2(value, key, collection2);
          });
          return result2;
        }
        function baseMatches(source) {
          var matchData = getMatchData(source);
          if (matchData.length == 1 && matchData[0][2]) {
            return matchesStrictComparable(matchData[0][0], matchData[0][1]);
          }
          return function(object) {
            return object === source || baseIsMatch(object, source, matchData);
          };
        }
        function baseMatchesProperty(path, srcValue) {
          if (isKey(path) && isStrictComparable(srcValue)) {
            return matchesStrictComparable(toKey(path), srcValue);
          }
          return function(object) {
            var objValue = get(object, path);
            return objValue === undefined2 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
          };
        }
        function baseMerge(object, source, srcIndex, customizer, stack) {
          if (object === source) {
            return;
          }
          baseFor(source, function(srcValue, key) {
            stack || (stack = new Stack());
            if (isObject(srcValue)) {
              baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
            } else {
              var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : undefined2;
              if (newValue === undefined2) {
                newValue = srcValue;
              }
              assignMergeValue(object, key, newValue);
            }
          }, keysIn);
        }
        function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
          var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
          if (stacked) {
            assignMergeValue(object, key, stacked);
            return;
          }
          var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : undefined2;
          var isCommon = newValue === undefined2;
          if (isCommon) {
            var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
            newValue = srcValue;
            if (isArr || isBuff || isTyped) {
              if (isArray(objValue)) {
                newValue = objValue;
              } else if (isArrayLikeObject(objValue)) {
                newValue = copyArray(objValue);
              } else if (isBuff) {
                isCommon = false;
                newValue = cloneBuffer(srcValue, true);
              } else if (isTyped) {
                isCommon = false;
                newValue = cloneTypedArray(srcValue, true);
              } else {
                newValue = [];
              }
            } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
              newValue = objValue;
              if (isArguments(objValue)) {
                newValue = toPlainObject(objValue);
              } else if (!isObject(objValue) || isFunction(objValue)) {
                newValue = initCloneObject(srcValue);
              }
            } else {
              isCommon = false;
            }
          }
          if (isCommon) {
            stack.set(srcValue, newValue);
            mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
            stack["delete"](srcValue);
          }
          assignMergeValue(object, key, newValue);
        }
        function baseNth(array, n) {
          var length = array.length;
          if (!length) {
            return;
          }
          n += n < 0 ? length : 0;
          return isIndex(n, length) ? array[n] : undefined2;
        }
        function baseOrderBy(collection, iteratees, orders) {
          if (iteratees.length) {
            iteratees = arrayMap(iteratees, function(iteratee2) {
              if (isArray(iteratee2)) {
                return function(value) {
                  return baseGet(value, iteratee2.length === 1 ? iteratee2[0] : iteratee2);
                };
              }
              return iteratee2;
            });
          } else {
            iteratees = [identity];
          }
          var index = -1;
          iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
          var result2 = baseMap(collection, function(value, key, collection2) {
            var criteria = arrayMap(iteratees, function(iteratee2) {
              return iteratee2(value);
            });
            return { "criteria": criteria, "index": ++index, "value": value };
          });
          return baseSortBy(result2, function(object, other) {
            return compareMultiple(object, other, orders);
          });
        }
        function basePick(object, paths) {
          return basePickBy(object, paths, function(value, path) {
            return hasIn(object, path);
          });
        }
        function basePickBy(object, paths, predicate) {
          var index = -1, length = paths.length, result2 = {};
          while (++index < length) {
            var path = paths[index], value = baseGet(object, path);
            if (predicate(value, path)) {
              baseSet(result2, castPath(path, object), value);
            }
          }
          return result2;
        }
        function basePropertyDeep(path) {
          return function(object) {
            return baseGet(object, path);
          };
        }
        function basePullAll(array, values2, iteratee2, comparator) {
          var indexOf2 = comparator ? baseIndexOfWith : baseIndexOf, index = -1, length = values2.length, seen = array;
          if (array === values2) {
            values2 = copyArray(values2);
          }
          if (iteratee2) {
            seen = arrayMap(array, baseUnary(iteratee2));
          }
          while (++index < length) {
            var fromIndex = 0, value = values2[index], computed = iteratee2 ? iteratee2(value) : value;
            while ((fromIndex = indexOf2(seen, computed, fromIndex, comparator)) > -1) {
              if (seen !== array) {
                splice.call(seen, fromIndex, 1);
              }
              splice.call(array, fromIndex, 1);
            }
          }
          return array;
        }
        function basePullAt(array, indexes) {
          var length = array ? indexes.length : 0, lastIndex = length - 1;
          while (length--) {
            var index = indexes[length];
            if (length == lastIndex || index !== previous) {
              var previous = index;
              if (isIndex(index)) {
                splice.call(array, index, 1);
              } else {
                baseUnset(array, index);
              }
            }
          }
          return array;
        }
        function baseRandom(lower, upper) {
          return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
        }
        function baseRange(start, end, step, fromRight) {
          var index = -1, length = nativeMax(nativeCeil((end - start) / (step || 1)), 0), result2 = Array2(length);
          while (length--) {
            result2[fromRight ? length : ++index] = start;
            start += step;
          }
          return result2;
        }
        function baseRepeat(string, n) {
          var result2 = "";
          if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
            return result2;
          }
          do {
            if (n % 2) {
              result2 += string;
            }
            n = nativeFloor(n / 2);
            if (n) {
              string += string;
            }
          } while (n);
          return result2;
        }
        function baseRest(func, start) {
          return setToString(overRest(func, start, identity), func + "");
        }
        function baseSample(collection) {
          return arraySample(values(collection));
        }
        function baseSampleSize(collection, n) {
          var array = values(collection);
          return shuffleSelf(array, baseClamp(n, 0, array.length));
        }
        function baseSet(object, path, value, customizer) {
          if (!isObject(object)) {
            return object;
          }
          path = castPath(path, object);
          var index = -1, length = path.length, lastIndex = length - 1, nested = object;
          while (nested != null && ++index < length) {
            var key = toKey(path[index]), newValue = value;
            if (key === "__proto__" || key === "constructor" || key === "prototype") {
              return object;
            }
            if (index != lastIndex) {
              var objValue = nested[key];
              newValue = customizer ? customizer(objValue, key, nested) : undefined2;
              if (newValue === undefined2) {
                newValue = isObject(objValue) ? objValue : isIndex(path[index + 1]) ? [] : {};
              }
            }
            assignValue(nested, key, newValue);
            nested = nested[key];
          }
          return object;
        }
        var baseSetData = !metaMap ? identity : function(func, data) {
          metaMap.set(func, data);
          return func;
        };
        var baseSetToString = !defineProperty ? identity : function(func, string) {
          return defineProperty(func, "toString", {
            "configurable": true,
            "enumerable": false,
            "value": constant(string),
            "writable": true
          });
        };
        function baseShuffle(collection) {
          return shuffleSelf(values(collection));
        }
        function baseSlice(array, start, end) {
          var index = -1, length = array.length;
          if (start < 0) {
            start = -start > length ? 0 : length + start;
          }
          end = end > length ? length : end;
          if (end < 0) {
            end += length;
          }
          length = start > end ? 0 : end - start >>> 0;
          start >>>= 0;
          var result2 = Array2(length);
          while (++index < length) {
            result2[index] = array[index + start];
          }
          return result2;
        }
        function baseSome(collection, predicate) {
          var result2;
          baseEach(collection, function(value, index, collection2) {
            result2 = predicate(value, index, collection2);
            return !result2;
          });
          return !!result2;
        }
        function baseSortedIndex(array, value, retHighest) {
          var low = 0, high = array == null ? low : array.length;
          if (typeof value == "number" && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
            while (low < high) {
              var mid = low + high >>> 1, computed = array[mid];
              if (computed !== null && !isSymbol(computed) && (retHighest ? computed <= value : computed < value)) {
                low = mid + 1;
              } else {
                high = mid;
              }
            }
            return high;
          }
          return baseSortedIndexBy(array, value, identity, retHighest);
        }
        function baseSortedIndexBy(array, value, iteratee2, retHighest) {
          var low = 0, high = array == null ? 0 : array.length;
          if (high === 0) {
            return 0;
          }
          value = iteratee2(value);
          var valIsNaN = value !== value, valIsNull = value === null, valIsSymbol = isSymbol(value), valIsUndefined = value === undefined2;
          while (low < high) {
            var mid = nativeFloor((low + high) / 2), computed = iteratee2(array[mid]), othIsDefined = computed !== undefined2, othIsNull = computed === null, othIsReflexive = computed === computed, othIsSymbol = isSymbol(computed);
            if (valIsNaN) {
              var setLow = retHighest || othIsReflexive;
            } else if (valIsUndefined) {
              setLow = othIsReflexive && (retHighest || othIsDefined);
            } else if (valIsNull) {
              setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
            } else if (valIsSymbol) {
              setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
            } else if (othIsNull || othIsSymbol) {
              setLow = false;
            } else {
              setLow = retHighest ? computed <= value : computed < value;
            }
            if (setLow) {
              low = mid + 1;
            } else {
              high = mid;
            }
          }
          return nativeMin(high, MAX_ARRAY_INDEX);
        }
        function baseSortedUniq(array, iteratee2) {
          var index = -1, length = array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
            if (!index || !eq(computed, seen)) {
              var seen = computed;
              result2[resIndex++] = value === 0 ? 0 : value;
            }
          }
          return result2;
        }
        function baseToNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          return +value;
        }
        function baseToString(value) {
          if (typeof value == "string") {
            return value;
          }
          if (isArray(value)) {
            return arrayMap(value, baseToString) + "";
          }
          if (isSymbol(value)) {
            return symbolToString ? symbolToString.call(value) : "";
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function baseUniq(array, iteratee2, comparator) {
          var index = -1, includes2 = arrayIncludes, length = array.length, isCommon = true, result2 = [], seen = result2;
          if (comparator) {
            isCommon = false;
            includes2 = arrayIncludesWith;
          } else if (length >= LARGE_ARRAY_SIZE) {
            var set2 = iteratee2 ? null : createSet(array);
            if (set2) {
              return setToArray(set2);
            }
            isCommon = false;
            includes2 = cacheHas;
            seen = new SetCache();
          } else {
            seen = iteratee2 ? [] : result2;
          }
          outer:
            while (++index < length) {
              var value = array[index], computed = iteratee2 ? iteratee2(value) : value;
              value = comparator || value !== 0 ? value : 0;
              if (isCommon && computed === computed) {
                var seenIndex = seen.length;
                while (seenIndex--) {
                  if (seen[seenIndex] === computed) {
                    continue outer;
                  }
                }
                if (iteratee2) {
                  seen.push(computed);
                }
                result2.push(value);
              } else if (!includes2(seen, computed, comparator)) {
                if (seen !== result2) {
                  seen.push(computed);
                }
                result2.push(value);
              }
            }
          return result2;
        }
        function baseUnset(object, path) {
          path = castPath(path, object);
          object = parent(object, path);
          return object == null || delete object[toKey(last(path))];
        }
        function baseUpdate(object, path, updater, customizer) {
          return baseSet(object, path, updater(baseGet(object, path)), customizer);
        }
        function baseWhile(array, predicate, isDrop, fromRight) {
          var length = array.length, index = fromRight ? length : -1;
          while ((fromRight ? index-- : ++index < length) && predicate(array[index], index, array)) {
          }
          return isDrop ? baseSlice(array, fromRight ? 0 : index, fromRight ? index + 1 : length) : baseSlice(array, fromRight ? index + 1 : 0, fromRight ? length : index);
        }
        function baseWrapperValue(value, actions) {
          var result2 = value;
          if (result2 instanceof LazyWrapper) {
            result2 = result2.value();
          }
          return arrayReduce(actions, function(result3, action) {
            return action.func.apply(action.thisArg, arrayPush([result3], action.args));
          }, result2);
        }
        function baseXor(arrays, iteratee2, comparator) {
          var length = arrays.length;
          if (length < 2) {
            return length ? baseUniq(arrays[0]) : [];
          }
          var index = -1, result2 = Array2(length);
          while (++index < length) {
            var array = arrays[index], othIndex = -1;
            while (++othIndex < length) {
              if (othIndex != index) {
                result2[index] = baseDifference(result2[index] || array, arrays[othIndex], iteratee2, comparator);
              }
            }
          }
          return baseUniq(baseFlatten(result2, 1), iteratee2, comparator);
        }
        function baseZipObject(props, values2, assignFunc) {
          var index = -1, length = props.length, valsLength = values2.length, result2 = {};
          while (++index < length) {
            var value = index < valsLength ? values2[index] : undefined2;
            assignFunc(result2, props[index], value);
          }
          return result2;
        }
        function castArrayLikeObject(value) {
          return isArrayLikeObject(value) ? value : [];
        }
        function castFunction(value) {
          return typeof value == "function" ? value : identity;
        }
        function castPath(value, object) {
          if (isArray(value)) {
            return value;
          }
          return isKey(value, object) ? [value] : stringToPath(toString(value));
        }
        var castRest = baseRest;
        function castSlice(array, start, end) {
          var length = array.length;
          end = end === undefined2 ? length : end;
          return !start && end >= length ? array : baseSlice(array, start, end);
        }
        var clearTimeout = ctxClearTimeout || function(id) {
          return root.clearTimeout(id);
        };
        function cloneBuffer(buffer, isDeep) {
          if (isDeep) {
            return buffer.slice();
          }
          var length = buffer.length, result2 = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
          buffer.copy(result2);
          return result2;
        }
        function cloneArrayBuffer(arrayBuffer) {
          var result2 = new arrayBuffer.constructor(arrayBuffer.byteLength);
          new Uint8Array2(result2).set(new Uint8Array2(arrayBuffer));
          return result2;
        }
        function cloneDataView(dataView, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
          return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
        }
        function cloneRegExp(regexp) {
          var result2 = new regexp.constructor(regexp.source, reFlags.exec(regexp));
          result2.lastIndex = regexp.lastIndex;
          return result2;
        }
        function cloneSymbol(symbol) {
          return symbolValueOf ? Object2(symbolValueOf.call(symbol)) : {};
        }
        function cloneTypedArray(typedArray, isDeep) {
          var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
          return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
        }
        function compareAscending(value, other) {
          if (value !== other) {
            var valIsDefined = value !== undefined2, valIsNull = value === null, valIsReflexive = value === value, valIsSymbol = isSymbol(value);
            var othIsDefined = other !== undefined2, othIsNull = other === null, othIsReflexive = other === other, othIsSymbol = isSymbol(other);
            if (!othIsNull && !othIsSymbol && !valIsSymbol && value > other || valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol || valIsNull && othIsDefined && othIsReflexive || !valIsDefined && othIsReflexive || !valIsReflexive) {
              return 1;
            }
            if (!valIsNull && !valIsSymbol && !othIsSymbol && value < other || othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol || othIsNull && valIsDefined && valIsReflexive || !othIsDefined && valIsReflexive || !othIsReflexive) {
              return -1;
            }
          }
          return 0;
        }
        function compareMultiple(object, other, orders) {
          var index = -1, objCriteria = object.criteria, othCriteria = other.criteria, length = objCriteria.length, ordersLength = orders.length;
          while (++index < length) {
            var result2 = compareAscending(objCriteria[index], othCriteria[index]);
            if (result2) {
              if (index >= ordersLength) {
                return result2;
              }
              var order = orders[index];
              return result2 * (order == "desc" ? -1 : 1);
            }
          }
          return object.index - other.index;
        }
        function composeArgs(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersLength = holders.length, leftIndex = -1, leftLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(leftLength + rangeLength), isUncurried = !isCurried;
          while (++leftIndex < leftLength) {
            result2[leftIndex] = partials[leftIndex];
          }
          while (++argsIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[holders[argsIndex]] = args[argsIndex];
            }
          }
          while (rangeLength--) {
            result2[leftIndex++] = args[argsIndex++];
          }
          return result2;
        }
        function composeArgsRight(args, partials, holders, isCurried) {
          var argsIndex = -1, argsLength = args.length, holdersIndex = -1, holdersLength = holders.length, rightIndex = -1, rightLength = partials.length, rangeLength = nativeMax(argsLength - holdersLength, 0), result2 = Array2(rangeLength + rightLength), isUncurried = !isCurried;
          while (++argsIndex < rangeLength) {
            result2[argsIndex] = args[argsIndex];
          }
          var offset = argsIndex;
          while (++rightIndex < rightLength) {
            result2[offset + rightIndex] = partials[rightIndex];
          }
          while (++holdersIndex < holdersLength) {
            if (isUncurried || argsIndex < argsLength) {
              result2[offset + holders[holdersIndex]] = args[argsIndex++];
            }
          }
          return result2;
        }
        function copyArray(source, array) {
          var index = -1, length = source.length;
          array || (array = Array2(length));
          while (++index < length) {
            array[index] = source[index];
          }
          return array;
        }
        function copyObject(source, props, object, customizer) {
          var isNew = !object;
          object || (object = {});
          var index = -1, length = props.length;
          while (++index < length) {
            var key = props[index];
            var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined2;
            if (newValue === undefined2) {
              newValue = source[key];
            }
            if (isNew) {
              baseAssignValue(object, key, newValue);
            } else {
              assignValue(object, key, newValue);
            }
          }
          return object;
        }
        function copySymbols(source, object) {
          return copyObject(source, getSymbols(source), object);
        }
        function copySymbolsIn(source, object) {
          return copyObject(source, getSymbolsIn(source), object);
        }
        function createAggregator(setter, initializer) {
          return function(collection, iteratee2) {
            var func = isArray(collection) ? arrayAggregator : baseAggregator, accumulator = initializer ? initializer() : {};
            return func(collection, setter, getIteratee(iteratee2, 2), accumulator);
          };
        }
        function createAssigner(assigner) {
          return baseRest(function(object, sources) {
            var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined2, guard = length > 2 ? sources[2] : undefined2;
            customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined2;
            if (guard && isIterateeCall(sources[0], sources[1], guard)) {
              customizer = length < 3 ? undefined2 : customizer;
              length = 1;
            }
            object = Object2(object);
            while (++index < length) {
              var source = sources[index];
              if (source) {
                assigner(object, source, index, customizer);
              }
            }
            return object;
          });
        }
        function createBaseEach(eachFunc, fromRight) {
          return function(collection, iteratee2) {
            if (collection == null) {
              return collection;
            }
            if (!isArrayLike(collection)) {
              return eachFunc(collection, iteratee2);
            }
            var length = collection.length, index = fromRight ? length : -1, iterable = Object2(collection);
            while (fromRight ? index-- : ++index < length) {
              if (iteratee2(iterable[index], index, iterable) === false) {
                break;
              }
            }
            return collection;
          };
        }
        function createBaseFor(fromRight) {
          return function(object, iteratee2, keysFunc) {
            var index = -1, iterable = Object2(object), props = keysFunc(object), length = props.length;
            while (length--) {
              var key = props[fromRight ? length : ++index];
              if (iteratee2(iterable[key], key, iterable) === false) {
                break;
              }
            }
            return object;
          };
        }
        function createBind(func, bitmask, thisArg) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return fn.apply(isBind ? thisArg : this, arguments);
          }
          return wrapper;
        }
        function createCaseFirst(methodName) {
          return function(string) {
            string = toString(string);
            var strSymbols = hasUnicode(string) ? stringToArray(string) : undefined2;
            var chr = strSymbols ? strSymbols[0] : string.charAt(0);
            var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
            return chr[methodName]() + trailing;
          };
        }
        function createCompounder(callback) {
          return function(string) {
            return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
          };
        }
        function createCtor(Ctor) {
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return new Ctor();
              case 1:
                return new Ctor(args[0]);
              case 2:
                return new Ctor(args[0], args[1]);
              case 3:
                return new Ctor(args[0], args[1], args[2]);
              case 4:
                return new Ctor(args[0], args[1], args[2], args[3]);
              case 5:
                return new Ctor(args[0], args[1], args[2], args[3], args[4]);
              case 6:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
              case 7:
                return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
            }
            var thisBinding = baseCreate(Ctor.prototype), result2 = Ctor.apply(thisBinding, args);
            return isObject(result2) ? result2 : thisBinding;
          };
        }
        function createCurry(func, bitmask, arity) {
          var Ctor = createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length, placeholder = getHolder(wrapper);
            while (index--) {
              args[index] = arguments[index];
            }
            var holders = length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder ? [] : replaceHolders(args, placeholder);
            length -= holders.length;
            if (length < arity) {
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                undefined2,
                args,
                holders,
                undefined2,
                undefined2,
                arity - length
              );
            }
            var fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            return apply(fn, this, args);
          }
          return wrapper;
        }
        function createFind(findIndexFunc) {
          return function(collection, predicate, fromIndex) {
            var iterable = Object2(collection);
            if (!isArrayLike(collection)) {
              var iteratee2 = getIteratee(predicate, 3);
              collection = keys(collection);
              predicate = function(key) {
                return iteratee2(iterable[key], key, iterable);
              };
            }
            var index = findIndexFunc(collection, predicate, fromIndex);
            return index > -1 ? iterable[iteratee2 ? collection[index] : index] : undefined2;
          };
        }
        function createFlow(fromRight) {
          return flatRest(function(funcs) {
            var length = funcs.length, index = length, prereq = LodashWrapper.prototype.thru;
            if (fromRight) {
              funcs.reverse();
            }
            while (index--) {
              var func = funcs[index];
              if (typeof func != "function") {
                throw new TypeError2(FUNC_ERROR_TEXT);
              }
              if (prereq && !wrapper && getFuncName(func) == "wrapper") {
                var wrapper = new LodashWrapper([], true);
              }
            }
            index = wrapper ? index : length;
            while (++index < length) {
              func = funcs[index];
              var funcName = getFuncName(func), data = funcName == "wrapper" ? getData(func) : undefined2;
              if (data && isLaziable(data[0]) && data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) && !data[4].length && data[9] == 1) {
                wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
              } else {
                wrapper = func.length == 1 && isLaziable(func) ? wrapper[funcName]() : wrapper.thru(func);
              }
            }
            return function() {
              var args = arguments, value = args[0];
              if (wrapper && args.length == 1 && isArray(value)) {
                return wrapper.plant(value).value();
              }
              var index2 = 0, result2 = length ? funcs[index2].apply(this, args) : value;
              while (++index2 < length) {
                result2 = funcs[index2].call(this, result2);
              }
              return result2;
            };
          });
        }
        function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary2, arity) {
          var isAry = bitmask & WRAP_ARY_FLAG, isBind = bitmask & WRAP_BIND_FLAG, isBindKey = bitmask & WRAP_BIND_KEY_FLAG, isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG), isFlip = bitmask & WRAP_FLIP_FLAG, Ctor = isBindKey ? undefined2 : createCtor(func);
          function wrapper() {
            var length = arguments.length, args = Array2(length), index = length;
            while (index--) {
              args[index] = arguments[index];
            }
            if (isCurried) {
              var placeholder = getHolder(wrapper), holdersCount = countHolders(args, placeholder);
            }
            if (partials) {
              args = composeArgs(args, partials, holders, isCurried);
            }
            if (partialsRight) {
              args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
            }
            length -= holdersCount;
            if (isCurried && length < arity) {
              var newHolders = replaceHolders(args, placeholder);
              return createRecurry(
                func,
                bitmask,
                createHybrid,
                wrapper.placeholder,
                thisArg,
                args,
                newHolders,
                argPos,
                ary2,
                arity - length
              );
            }
            var thisBinding = isBind ? thisArg : this, fn = isBindKey ? thisBinding[func] : func;
            length = args.length;
            if (argPos) {
              args = reorder(args, argPos);
            } else if (isFlip && length > 1) {
              args.reverse();
            }
            if (isAry && ary2 < length) {
              args.length = ary2;
            }
            if (this && this !== root && this instanceof wrapper) {
              fn = Ctor || createCtor(fn);
            }
            return fn.apply(thisBinding, args);
          }
          return wrapper;
        }
        function createInverter(setter, toIteratee) {
          return function(object, iteratee2) {
            return baseInverter(object, setter, toIteratee(iteratee2), {});
          };
        }
        function createMathOperation(operator, defaultValue) {
          return function(value, other) {
            var result2;
            if (value === undefined2 && other === undefined2) {
              return defaultValue;
            }
            if (value !== undefined2) {
              result2 = value;
            }
            if (other !== undefined2) {
              if (result2 === undefined2) {
                return other;
              }
              if (typeof value == "string" || typeof other == "string") {
                value = baseToString(value);
                other = baseToString(other);
              } else {
                value = baseToNumber(value);
                other = baseToNumber(other);
              }
              result2 = operator(value, other);
            }
            return result2;
          };
        }
        function createOver(arrayFunc) {
          return flatRest(function(iteratees) {
            iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
            return baseRest(function(args) {
              var thisArg = this;
              return arrayFunc(iteratees, function(iteratee2) {
                return apply(iteratee2, thisArg, args);
              });
            });
          });
        }
        function createPadding(length, chars) {
          chars = chars === undefined2 ? " " : baseToString(chars);
          var charsLength = chars.length;
          if (charsLength < 2) {
            return charsLength ? baseRepeat(chars, length) : chars;
          }
          var result2 = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
          return hasUnicode(chars) ? castSlice(stringToArray(result2), 0, length).join("") : result2.slice(0, length);
        }
        function createPartial(func, bitmask, thisArg, partials) {
          var isBind = bitmask & WRAP_BIND_FLAG, Ctor = createCtor(func);
          function wrapper() {
            var argsIndex = -1, argsLength = arguments.length, leftIndex = -1, leftLength = partials.length, args = Array2(leftLength + argsLength), fn = this && this !== root && this instanceof wrapper ? Ctor : func;
            while (++leftIndex < leftLength) {
              args[leftIndex] = partials[leftIndex];
            }
            while (argsLength--) {
              args[leftIndex++] = arguments[++argsIndex];
            }
            return apply(fn, isBind ? thisArg : this, args);
          }
          return wrapper;
        }
        function createRange(fromRight) {
          return function(start, end, step) {
            if (step && typeof step != "number" && isIterateeCall(start, end, step)) {
              end = step = undefined2;
            }
            start = toFinite(start);
            if (end === undefined2) {
              end = start;
              start = 0;
            } else {
              end = toFinite(end);
            }
            step = step === undefined2 ? start < end ? 1 : -1 : toFinite(step);
            return baseRange(start, end, step, fromRight);
          };
        }
        function createRelationalOperation(operator) {
          return function(value, other) {
            if (!(typeof value == "string" && typeof other == "string")) {
              value = toNumber(value);
              other = toNumber(other);
            }
            return operator(value, other);
          };
        }
        function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary2, arity) {
          var isCurry = bitmask & WRAP_CURRY_FLAG, newHolders = isCurry ? holders : undefined2, newHoldersRight = isCurry ? undefined2 : holders, newPartials = isCurry ? partials : undefined2, newPartialsRight = isCurry ? undefined2 : partials;
          bitmask |= isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG;
          bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);
          if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
            bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
          }
          var newData = [
            func,
            bitmask,
            thisArg,
            newPartials,
            newHolders,
            newPartialsRight,
            newHoldersRight,
            argPos,
            ary2,
            arity
          ];
          var result2 = wrapFunc.apply(undefined2, newData);
          if (isLaziable(func)) {
            setData(result2, newData);
          }
          result2.placeholder = placeholder;
          return setWrapToString(result2, func, bitmask);
        }
        function createRound(methodName) {
          var func = Math2[methodName];
          return function(number, precision) {
            number = toNumber(number);
            precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
            if (precision && nativeIsFinite(number)) {
              var pair = (toString(number) + "e").split("e"), value = func(pair[0] + "e" + (+pair[1] + precision));
              pair = (toString(value) + "e").split("e");
              return +(pair[0] + "e" + (+pair[1] - precision));
            }
            return func(number);
          };
        }
        var createSet = !(Set2 && 1 / setToArray(new Set2([, -0]))[1] == INFINITY) ? noop : function(values2) {
          return new Set2(values2);
        };
        function createToPairs(keysFunc) {
          return function(object) {
            var tag = getTag(object);
            if (tag == mapTag) {
              return mapToArray(object);
            }
            if (tag == setTag) {
              return setToPairs(object);
            }
            return baseToPairs(object, keysFunc(object));
          };
        }
        function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary2, arity) {
          var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
          if (!isBindKey && typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var length = partials ? partials.length : 0;
          if (!length) {
            bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
            partials = holders = undefined2;
          }
          ary2 = ary2 === undefined2 ? ary2 : nativeMax(toInteger(ary2), 0);
          arity = arity === undefined2 ? arity : toInteger(arity);
          length -= holders ? holders.length : 0;
          if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
            var partialsRight = partials, holdersRight = holders;
            partials = holders = undefined2;
          }
          var data = isBindKey ? undefined2 : getData(func);
          var newData = [
            func,
            bitmask,
            thisArg,
            partials,
            holders,
            partialsRight,
            holdersRight,
            argPos,
            ary2,
            arity
          ];
          if (data) {
            mergeData(newData, data);
          }
          func = newData[0];
          bitmask = newData[1];
          thisArg = newData[2];
          partials = newData[3];
          holders = newData[4];
          arity = newData[9] = newData[9] === undefined2 ? isBindKey ? 0 : func.length : nativeMax(newData[9] - length, 0);
          if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
            bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
          }
          if (!bitmask || bitmask == WRAP_BIND_FLAG) {
            var result2 = createBind(func, bitmask, thisArg);
          } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
            result2 = createCurry(func, bitmask, arity);
          } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
            result2 = createPartial(func, bitmask, thisArg, partials);
          } else {
            result2 = createHybrid.apply(undefined2, newData);
          }
          var setter = data ? baseSetData : setData;
          return setWrapToString(setter(result2, newData), func, bitmask);
        }
        function customDefaultsAssignIn(objValue, srcValue, key, object) {
          if (objValue === undefined2 || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
            return srcValue;
          }
          return objValue;
        }
        function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
          if (isObject(objValue) && isObject(srcValue)) {
            stack.set(srcValue, objValue);
            baseMerge(objValue, srcValue, undefined2, customDefaultsMerge, stack);
            stack["delete"](srcValue);
          }
          return objValue;
        }
        function customOmitClone(value) {
          return isPlainObject(value) ? undefined2 : value;
        }
        function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, arrLength = array.length, othLength = other.length;
          if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
            return false;
          }
          var arrStacked = stack.get(array);
          var othStacked = stack.get(other);
          if (arrStacked && othStacked) {
            return arrStacked == other && othStacked == array;
          }
          var index = -1, result2 = true, seen = bitmask & COMPARE_UNORDERED_FLAG ? new SetCache() : undefined2;
          stack.set(array, other);
          stack.set(other, array);
          while (++index < arrLength) {
            var arrValue = array[index], othValue = other[index];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
            }
            if (compared !== undefined2) {
              if (compared) {
                continue;
              }
              result2 = false;
              break;
            }
            if (seen) {
              if (!arraySome(other, function(othValue2, othIndex) {
                if (!cacheHas(seen, othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
                result2 = false;
                break;
              }
            } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              result2 = false;
              break;
            }
          }
          stack["delete"](array);
          stack["delete"](other);
          return result2;
        }
        function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
          switch (tag) {
            case dataViewTag:
              if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
                return false;
              }
              object = object.buffer;
              other = other.buffer;
            case arrayBufferTag:
              if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
                return false;
              }
              return true;
            case boolTag:
            case dateTag:
            case numberTag:
              return eq(+object, +other);
            case errorTag:
              return object.name == other.name && object.message == other.message;
            case regexpTag:
            case stringTag:
              return object == other + "";
            case mapTag:
              var convert = mapToArray;
            case setTag:
              var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
              convert || (convert = setToArray);
              if (object.size != other.size && !isPartial) {
                return false;
              }
              var stacked = stack.get(object);
              if (stacked) {
                return stacked == other;
              }
              bitmask |= COMPARE_UNORDERED_FLAG;
              stack.set(object, other);
              var result2 = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
              stack["delete"](object);
              return result2;
            case symbolTag:
              if (symbolValueOf) {
                return symbolValueOf.call(object) == symbolValueOf.call(other);
              }
          }
          return false;
        }
        function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG, objProps = getAllKeys(object), objLength = objProps.length, othProps = getAllKeys(other), othLength = othProps.length;
          if (objLength != othLength && !isPartial) {
            return false;
          }
          var index = objLength;
          while (index--) {
            var key = objProps[index];
            if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
              return false;
            }
          }
          var objStacked = stack.get(object);
          var othStacked = stack.get(other);
          if (objStacked && othStacked) {
            return objStacked == other && othStacked == object;
          }
          var result2 = true;
          stack.set(object, other);
          stack.set(other, object);
          var skipCtor = isPartial;
          while (++index < objLength) {
            key = objProps[index];
            var objValue = object[key], othValue = other[key];
            if (customizer) {
              var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
            }
            if (!(compared === undefined2 ? objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack) : compared)) {
              result2 = false;
              break;
            }
            skipCtor || (skipCtor = key == "constructor");
          }
          if (result2 && !skipCtor) {
            var objCtor = object.constructor, othCtor = other.constructor;
            if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
              result2 = false;
            }
          }
          stack["delete"](object);
          stack["delete"](other);
          return result2;
        }
        function flatRest(func) {
          return setToString(overRest(func, undefined2, flatten), func + "");
        }
        function getAllKeys(object) {
          return baseGetAllKeys(object, keys, getSymbols);
        }
        function getAllKeysIn(object) {
          return baseGetAllKeys(object, keysIn, getSymbolsIn);
        }
        var getData = !metaMap ? noop : function(func) {
          return metaMap.get(func);
        };
        function getFuncName(func) {
          var result2 = func.name + "", array = realNames[result2], length = hasOwnProperty.call(realNames, result2) ? array.length : 0;
          while (length--) {
            var data = array[length], otherFunc = data.func;
            if (otherFunc == null || otherFunc == func) {
              return data.name;
            }
          }
          return result2;
        }
        function getHolder(func) {
          var object = hasOwnProperty.call(lodash, "placeholder") ? lodash : func;
          return object.placeholder;
        }
        function getIteratee() {
          var result2 = lodash.iteratee || iteratee;
          result2 = result2 === iteratee ? baseIteratee : result2;
          return arguments.length ? result2(arguments[0], arguments[1]) : result2;
        }
        function getMapData(map2, key) {
          var data = map2.__data__;
          return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
        }
        function getMatchData(object) {
          var result2 = keys(object), length = result2.length;
          while (length--) {
            var key = result2[length], value = object[key];
            result2[length] = [key, value, isStrictComparable(value)];
          }
          return result2;
        }
        function getNative(object, key) {
          var value = getValue(object, key);
          return baseIsNative(value) ? value : undefined2;
        }
        function getRawTag(value) {
          var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
          try {
            value[symToStringTag] = undefined2;
            var unmasked = true;
          } catch (e) {
          }
          var result2 = nativeObjectToString.call(value);
          if (unmasked) {
            if (isOwn) {
              value[symToStringTag] = tag;
            } else {
              delete value[symToStringTag];
            }
          }
          return result2;
        }
        var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
          if (object == null) {
            return [];
          }
          object = Object2(object);
          return arrayFilter(nativeGetSymbols(object), function(symbol) {
            return propertyIsEnumerable.call(object, symbol);
          });
        };
        var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
          var result2 = [];
          while (object) {
            arrayPush(result2, getSymbols(object));
            object = getPrototype(object);
          }
          return result2;
        };
        var getTag = baseGetTag;
        if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
          getTag = function(value) {
            var result2 = baseGetTag(value), Ctor = result2 == objectTag ? value.constructor : undefined2, ctorString = Ctor ? toSource(Ctor) : "";
            if (ctorString) {
              switch (ctorString) {
                case dataViewCtorString:
                  return dataViewTag;
                case mapCtorString:
                  return mapTag;
                case promiseCtorString:
                  return promiseTag;
                case setCtorString:
                  return setTag;
                case weakMapCtorString:
                  return weakMapTag;
              }
            }
            return result2;
          };
        }
        function getView(start, end, transforms) {
          var index = -1, length = transforms.length;
          while (++index < length) {
            var data = transforms[index], size2 = data.size;
            switch (data.type) {
              case "drop":
                start += size2;
                break;
              case "dropRight":
                end -= size2;
                break;
              case "take":
                end = nativeMin(end, start + size2);
                break;
              case "takeRight":
                start = nativeMax(start, end - size2);
                break;
            }
          }
          return { "start": start, "end": end };
        }
        function getWrapDetails(source) {
          var match = source.match(reWrapDetails);
          return match ? match[1].split(reSplitDetails) : [];
        }
        function hasPath(object, path, hasFunc) {
          path = castPath(path, object);
          var index = -1, length = path.length, result2 = false;
          while (++index < length) {
            var key = toKey(path[index]);
            if (!(result2 = object != null && hasFunc(object, key))) {
              break;
            }
            object = object[key];
          }
          if (result2 || ++index != length) {
            return result2;
          }
          length = object == null ? 0 : object.length;
          return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
        }
        function initCloneArray(array) {
          var length = array.length, result2 = new array.constructor(length);
          if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
            result2.index = array.index;
            result2.input = array.input;
          }
          return result2;
        }
        function initCloneObject(object) {
          return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
        }
        function initCloneByTag(object, tag, isDeep) {
          var Ctor = object.constructor;
          switch (tag) {
            case arrayBufferTag:
              return cloneArrayBuffer(object);
            case boolTag:
            case dateTag:
              return new Ctor(+object);
            case dataViewTag:
              return cloneDataView(object, isDeep);
            case float32Tag:
            case float64Tag:
            case int8Tag:
            case int16Tag:
            case int32Tag:
            case uint8Tag:
            case uint8ClampedTag:
            case uint16Tag:
            case uint32Tag:
              return cloneTypedArray(object, isDeep);
            case mapTag:
              return new Ctor();
            case numberTag:
            case stringTag:
              return new Ctor(object);
            case regexpTag:
              return cloneRegExp(object);
            case setTag:
              return new Ctor();
            case symbolTag:
              return cloneSymbol(object);
          }
        }
        function insertWrapDetails(source, details) {
          var length = details.length;
          if (!length) {
            return source;
          }
          var lastIndex = length - 1;
          details[lastIndex] = (length > 1 ? "& " : "") + details[lastIndex];
          details = details.join(length > 2 ? ", " : " ");
          return source.replace(reWrapComment, "{\n/* [wrapped with " + details + "] */\n");
        }
        function isFlattenable(value) {
          return isArray(value) || isArguments(value) || !!(spreadableSymbol && value && value[spreadableSymbol]);
        }
        function isIndex(value, length) {
          var type = typeof value;
          length = length == null ? MAX_SAFE_INTEGER : length;
          return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
        }
        function isIterateeCall(value, index, object) {
          if (!isObject(object)) {
            return false;
          }
          var type = typeof index;
          if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
            return eq(object[index], value);
          }
          return false;
        }
        function isKey(value, object) {
          if (isArray(value)) {
            return false;
          }
          var type = typeof value;
          if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
            return true;
          }
          return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object2(object);
        }
        function isKeyable(value) {
          var type = typeof value;
          return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
        }
        function isLaziable(func) {
          var funcName = getFuncName(func), other = lodash[funcName];
          if (typeof other != "function" || !(funcName in LazyWrapper.prototype)) {
            return false;
          }
          if (func === other) {
            return true;
          }
          var data = getData(other);
          return !!data && func === data[0];
        }
        function isMasked(func) {
          return !!maskSrcKey && maskSrcKey in func;
        }
        var isMaskable = coreJsData ? isFunction : stubFalse;
        function isPrototype(value) {
          var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
          return value === proto;
        }
        function isStrictComparable(value) {
          return value === value && !isObject(value);
        }
        function matchesStrictComparable(key, srcValue) {
          return function(object) {
            if (object == null) {
              return false;
            }
            return object[key] === srcValue && (srcValue !== undefined2 || key in Object2(object));
          };
        }
        function memoizeCapped(func) {
          var result2 = memoize(func, function(key) {
            if (cache.size === MAX_MEMOIZE_SIZE) {
              cache.clear();
            }
            return key;
          });
          var cache = result2.cache;
          return result2;
        }
        function mergeData(data, source) {
          var bitmask = data[1], srcBitmask = source[1], newBitmask = bitmask | srcBitmask, isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);
          var isCombo = srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_CURRY_FLAG || srcBitmask == WRAP_ARY_FLAG && bitmask == WRAP_REARG_FLAG && data[7].length <= source[8] || srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG) && source[7].length <= source[8] && bitmask == WRAP_CURRY_FLAG;
          if (!(isCommon || isCombo)) {
            return data;
          }
          if (srcBitmask & WRAP_BIND_FLAG) {
            data[2] = source[2];
            newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
          }
          var value = source[3];
          if (value) {
            var partials = data[3];
            data[3] = partials ? composeArgs(partials, value, source[4]) : value;
            data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
          }
          value = source[5];
          if (value) {
            partials = data[5];
            data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
            data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
          }
          value = source[7];
          if (value) {
            data[7] = value;
          }
          if (srcBitmask & WRAP_ARY_FLAG) {
            data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
          }
          if (data[9] == null) {
            data[9] = source[9];
          }
          data[0] = source[0];
          data[1] = newBitmask;
          return data;
        }
        function nativeKeysIn(object) {
          var result2 = [];
          if (object != null) {
            for (var key in Object2(object)) {
              result2.push(key);
            }
          }
          return result2;
        }
        function objectToString(value) {
          return nativeObjectToString.call(value);
        }
        function overRest(func, start, transform2) {
          start = nativeMax(start === undefined2 ? func.length - 1 : start, 0);
          return function() {
            var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array2(length);
            while (++index < length) {
              array[index] = args[start + index];
            }
            index = -1;
            var otherArgs = Array2(start + 1);
            while (++index < start) {
              otherArgs[index] = args[index];
            }
            otherArgs[start] = transform2(array);
            return apply(func, this, otherArgs);
          };
        }
        function parent(object, path) {
          return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
        }
        function reorder(array, indexes) {
          var arrLength = array.length, length = nativeMin(indexes.length, arrLength), oldArray = copyArray(array);
          while (length--) {
            var index = indexes[length];
            array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined2;
          }
          return array;
        }
        function safeGet(object, key) {
          if (key === "constructor" && typeof object[key] === "function") {
            return;
          }
          if (key == "__proto__") {
            return;
          }
          return object[key];
        }
        var setData = shortOut(baseSetData);
        var setTimeout2 = ctxSetTimeout || function(func, wait) {
          return root.setTimeout(func, wait);
        };
        var setToString = shortOut(baseSetToString);
        function setWrapToString(wrapper, reference, bitmask) {
          var source = reference + "";
          return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
        }
        function shortOut(func) {
          var count = 0, lastCalled = 0;
          return function() {
            var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
            lastCalled = stamp;
            if (remaining > 0) {
              if (++count >= HOT_COUNT) {
                return arguments[0];
              }
            } else {
              count = 0;
            }
            return func.apply(undefined2, arguments);
          };
        }
        function shuffleSelf(array, size2) {
          var index = -1, length = array.length, lastIndex = length - 1;
          size2 = size2 === undefined2 ? length : size2;
          while (++index < size2) {
            var rand = baseRandom(index, lastIndex), value = array[rand];
            array[rand] = array[index];
            array[index] = value;
          }
          array.length = size2;
          return array;
        }
        var stringToPath = memoizeCapped(function(string) {
          var result2 = [];
          if (string.charCodeAt(0) === 46) {
            result2.push("");
          }
          string.replace(rePropName, function(match, number, quote, subString) {
            result2.push(quote ? subString.replace(reEscapeChar, "$1") : number || match);
          });
          return result2;
        });
        function toKey(value) {
          if (typeof value == "string" || isSymbol(value)) {
            return value;
          }
          var result2 = value + "";
          return result2 == "0" && 1 / value == -INFINITY ? "-0" : result2;
        }
        function toSource(func) {
          if (func != null) {
            try {
              return funcToString.call(func);
            } catch (e) {
            }
            try {
              return func + "";
            } catch (e) {
            }
          }
          return "";
        }
        function updateWrapDetails(details, bitmask) {
          arrayEach(wrapFlags, function(pair) {
            var value = "_." + pair[0];
            if (bitmask & pair[1] && !arrayIncludes(details, value)) {
              details.push(value);
            }
          });
          return details.sort();
        }
        function wrapperClone(wrapper) {
          if (wrapper instanceof LazyWrapper) {
            return wrapper.clone();
          }
          var result2 = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
          result2.__actions__ = copyArray(wrapper.__actions__);
          result2.__index__ = wrapper.__index__;
          result2.__values__ = wrapper.__values__;
          return result2;
        }
        function chunk(array, size2, guard) {
          if (guard ? isIterateeCall(array, size2, guard) : size2 === undefined2) {
            size2 = 1;
          } else {
            size2 = nativeMax(toInteger(size2), 0);
          }
          var length = array == null ? 0 : array.length;
          if (!length || size2 < 1) {
            return [];
          }
          var index = 0, resIndex = 0, result2 = Array2(nativeCeil(length / size2));
          while (index < length) {
            result2[resIndex++] = baseSlice(array, index, index += size2);
          }
          return result2;
        }
        function compact(array) {
          var index = -1, length = array == null ? 0 : array.length, resIndex = 0, result2 = [];
          while (++index < length) {
            var value = array[index];
            if (value) {
              result2[resIndex++] = value;
            }
          }
          return result2;
        }
        function concat() {
          var length = arguments.length;
          if (!length) {
            return [];
          }
          var args = Array2(length - 1), array = arguments[0], index = length;
          while (index--) {
            args[index - 1] = arguments[index];
          }
          return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
        }
        var difference = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true)) : [];
        });
        var differenceBy = baseRest(function(array, values2) {
          var iteratee2 = last(values2);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2)) : [];
        });
        var differenceWith = baseRest(function(array, values2) {
          var comparator = last(values2);
          if (isArrayLikeObject(comparator)) {
            comparator = undefined2;
          }
          return isArrayLikeObject(array) ? baseDifference(array, baseFlatten(values2, 1, isArrayLikeObject, true), undefined2, comparator) : [];
        });
        function drop(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function dropRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function dropRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true, true) : [];
        }
        function dropWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), true) : [];
        }
        function fill(array, value, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (start && typeof start != "number" && isIterateeCall(array, value, start)) {
            start = 0;
            end = length;
          }
          return baseFill(array, value, start, end);
        }
        function findIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index);
        }
        function findLastIndex(array, predicate, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length - 1;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = fromIndex < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return baseFindIndex(array, getIteratee(predicate, 3), index, true);
        }
        function flatten(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, 1) : [];
        }
        function flattenDeep(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseFlatten(array, INFINITY) : [];
        }
        function flattenDepth(array, depth) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(array, depth);
        }
        function fromPairs(pairs) {
          var index = -1, length = pairs == null ? 0 : pairs.length, result2 = {};
          while (++index < length) {
            var pair = pairs[index];
            result2[pair[0]] = pair[1];
          }
          return result2;
        }
        function head(array) {
          return array && array.length ? array[0] : undefined2;
        }
        function indexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = fromIndex == null ? 0 : toInteger(fromIndex);
          if (index < 0) {
            index = nativeMax(length + index, 0);
          }
          return baseIndexOf(array, value, index);
        }
        function initial(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 0, -1) : [];
        }
        var intersection = baseRest(function(arrays) {
          var mapped = arrayMap(arrays, castArrayLikeObject);
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped) : [];
        });
        var intersectionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          if (iteratee2 === last(mapped)) {
            iteratee2 = undefined2;
          } else {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, getIteratee(iteratee2, 2)) : [];
        });
        var intersectionWith = baseRest(function(arrays) {
          var comparator = last(arrays), mapped = arrayMap(arrays, castArrayLikeObject);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          if (comparator) {
            mapped.pop();
          }
          return mapped.length && mapped[0] === arrays[0] ? baseIntersection(mapped, undefined2, comparator) : [];
        });
        function join(array, separator) {
          return array == null ? "" : nativeJoin.call(array, separator);
        }
        function last(array) {
          var length = array == null ? 0 : array.length;
          return length ? array[length - 1] : undefined2;
        }
        function lastIndexOf(array, value, fromIndex) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return -1;
          }
          var index = length;
          if (fromIndex !== undefined2) {
            index = toInteger(fromIndex);
            index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
          }
          return value === value ? strictLastIndexOf(array, value, index) : baseFindIndex(array, baseIsNaN, index, true);
        }
        function nth(array, n) {
          return array && array.length ? baseNth(array, toInteger(n)) : undefined2;
        }
        var pull = baseRest(pullAll);
        function pullAll(array, values2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2) : array;
        }
        function pullAllBy(array, values2, iteratee2) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, getIteratee(iteratee2, 2)) : array;
        }
        function pullAllWith(array, values2, comparator) {
          return array && array.length && values2 && values2.length ? basePullAll(array, values2, undefined2, comparator) : array;
        }
        var pullAt = flatRest(function(array, indexes) {
          var length = array == null ? 0 : array.length, result2 = baseAt(array, indexes);
          basePullAt(array, arrayMap(indexes, function(index) {
            return isIndex(index, length) ? +index : index;
          }).sort(compareAscending));
          return result2;
        });
        function remove(array, predicate) {
          var result2 = [];
          if (!(array && array.length)) {
            return result2;
          }
          var index = -1, indexes = [], length = array.length;
          predicate = getIteratee(predicate, 3);
          while (++index < length) {
            var value = array[index];
            if (predicate(value, index, array)) {
              result2.push(value);
              indexes.push(index);
            }
          }
          basePullAt(array, indexes);
          return result2;
        }
        function reverse(array) {
          return array == null ? array : nativeReverse.call(array);
        }
        function slice(array, start, end) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          if (end && typeof end != "number" && isIterateeCall(array, start, end)) {
            start = 0;
            end = length;
          } else {
            start = start == null ? 0 : toInteger(start);
            end = end === undefined2 ? length : toInteger(end);
          }
          return baseSlice(array, start, end);
        }
        function sortedIndex(array, value) {
          return baseSortedIndex(array, value);
        }
        function sortedIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2));
        }
        function sortedIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value);
            if (index < length && eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedLastIndex(array, value) {
          return baseSortedIndex(array, value, true);
        }
        function sortedLastIndexBy(array, value, iteratee2) {
          return baseSortedIndexBy(array, value, getIteratee(iteratee2, 2), true);
        }
        function sortedLastIndexOf(array, value) {
          var length = array == null ? 0 : array.length;
          if (length) {
            var index = baseSortedIndex(array, value, true) - 1;
            if (eq(array[index], value)) {
              return index;
            }
          }
          return -1;
        }
        function sortedUniq(array) {
          return array && array.length ? baseSortedUniq(array) : [];
        }
        function sortedUniqBy(array, iteratee2) {
          return array && array.length ? baseSortedUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function tail(array) {
          var length = array == null ? 0 : array.length;
          return length ? baseSlice(array, 1, length) : [];
        }
        function take(array, n, guard) {
          if (!(array && array.length)) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          return baseSlice(array, 0, n < 0 ? 0 : n);
        }
        function takeRight(array, n, guard) {
          var length = array == null ? 0 : array.length;
          if (!length) {
            return [];
          }
          n = guard || n === undefined2 ? 1 : toInteger(n);
          n = length - n;
          return baseSlice(array, n < 0 ? 0 : n, length);
        }
        function takeRightWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3), false, true) : [];
        }
        function takeWhile(array, predicate) {
          return array && array.length ? baseWhile(array, getIteratee(predicate, 3)) : [];
        }
        var union = baseRest(function(arrays) {
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
        });
        var unionBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee2, 2));
        });
        var unionWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined2, comparator);
        });
        function uniq(array) {
          return array && array.length ? baseUniq(array) : [];
        }
        function uniqBy(array, iteratee2) {
          return array && array.length ? baseUniq(array, getIteratee(iteratee2, 2)) : [];
        }
        function uniqWith(array, comparator) {
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return array && array.length ? baseUniq(array, undefined2, comparator) : [];
        }
        function unzip(array) {
          if (!(array && array.length)) {
            return [];
          }
          var length = 0;
          array = arrayFilter(array, function(group) {
            if (isArrayLikeObject(group)) {
              length = nativeMax(group.length, length);
              return true;
            }
          });
          return baseTimes(length, function(index) {
            return arrayMap(array, baseProperty(index));
          });
        }
        function unzipWith(array, iteratee2) {
          if (!(array && array.length)) {
            return [];
          }
          var result2 = unzip(array);
          if (iteratee2 == null) {
            return result2;
          }
          return arrayMap(result2, function(group) {
            return apply(iteratee2, undefined2, group);
          });
        }
        var without = baseRest(function(array, values2) {
          return isArrayLikeObject(array) ? baseDifference(array, values2) : [];
        });
        var xor = baseRest(function(arrays) {
          return baseXor(arrayFilter(arrays, isArrayLikeObject));
        });
        var xorBy = baseRest(function(arrays) {
          var iteratee2 = last(arrays);
          if (isArrayLikeObject(iteratee2)) {
            iteratee2 = undefined2;
          }
          return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee2, 2));
        });
        var xorWith = baseRest(function(arrays) {
          var comparator = last(arrays);
          comparator = typeof comparator == "function" ? comparator : undefined2;
          return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined2, comparator);
        });
        var zip = baseRest(unzip);
        function zipObject(props, values2) {
          return baseZipObject(props || [], values2 || [], assignValue);
        }
        function zipObjectDeep(props, values2) {
          return baseZipObject(props || [], values2 || [], baseSet);
        }
        var zipWith = baseRest(function(arrays) {
          var length = arrays.length, iteratee2 = length > 1 ? arrays[length - 1] : undefined2;
          iteratee2 = typeof iteratee2 == "function" ? (arrays.pop(), iteratee2) : undefined2;
          return unzipWith(arrays, iteratee2);
        });
        function chain(value) {
          var result2 = lodash(value);
          result2.__chain__ = true;
          return result2;
        }
        function tap(value, interceptor) {
          interceptor(value);
          return value;
        }
        function thru(value, interceptor) {
          return interceptor(value);
        }
        var wrapperAt = flatRest(function(paths) {
          var length = paths.length, start = length ? paths[0] : 0, value = this.__wrapped__, interceptor = function(object) {
            return baseAt(object, paths);
          };
          if (length > 1 || this.__actions__.length || !(value instanceof LazyWrapper) || !isIndex(start)) {
            return this.thru(interceptor);
          }
          value = value.slice(start, +start + (length ? 1 : 0));
          value.__actions__.push({
            "func": thru,
            "args": [interceptor],
            "thisArg": undefined2
          });
          return new LodashWrapper(value, this.__chain__).thru(function(array) {
            if (length && !array.length) {
              array.push(undefined2);
            }
            return array;
          });
        });
        function wrapperChain() {
          return chain(this);
        }
        function wrapperCommit() {
          return new LodashWrapper(this.value(), this.__chain__);
        }
        function wrapperNext() {
          if (this.__values__ === undefined2) {
            this.__values__ = toArray(this.value());
          }
          var done = this.__index__ >= this.__values__.length, value = done ? undefined2 : this.__values__[this.__index__++];
          return { "done": done, "value": value };
        }
        function wrapperToIterator() {
          return this;
        }
        function wrapperPlant(value) {
          var result2, parent2 = this;
          while (parent2 instanceof baseLodash) {
            var clone2 = wrapperClone(parent2);
            clone2.__index__ = 0;
            clone2.__values__ = undefined2;
            if (result2) {
              previous.__wrapped__ = clone2;
            } else {
              result2 = clone2;
            }
            var previous = clone2;
            parent2 = parent2.__wrapped__;
          }
          previous.__wrapped__ = value;
          return result2;
        }
        function wrapperReverse() {
          var value = this.__wrapped__;
          if (value instanceof LazyWrapper) {
            var wrapped = value;
            if (this.__actions__.length) {
              wrapped = new LazyWrapper(this);
            }
            wrapped = wrapped.reverse();
            wrapped.__actions__.push({
              "func": thru,
              "args": [reverse],
              "thisArg": undefined2
            });
            return new LodashWrapper(wrapped, this.__chain__);
          }
          return this.thru(reverse);
        }
        function wrapperValue() {
          return baseWrapperValue(this.__wrapped__, this.__actions__);
        }
        var countBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            ++result2[key];
          } else {
            baseAssignValue(result2, key, 1);
          }
        });
        function every(collection, predicate, guard) {
          var func = isArray(collection) ? arrayEvery : baseEvery;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        function filter(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, getIteratee(predicate, 3));
        }
        var find = createFind(findIndex);
        var findLast = createFind(findLastIndex);
        function flatMap(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), 1);
        }
        function flatMapDeep(collection, iteratee2) {
          return baseFlatten(map(collection, iteratee2), INFINITY);
        }
        function flatMapDepth(collection, iteratee2, depth) {
          depth = depth === undefined2 ? 1 : toInteger(depth);
          return baseFlatten(map(collection, iteratee2), depth);
        }
        function forEach(collection, iteratee2) {
          var func = isArray(collection) ? arrayEach : baseEach;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function forEachRight(collection, iteratee2) {
          var func = isArray(collection) ? arrayEachRight : baseEachRight;
          return func(collection, getIteratee(iteratee2, 3));
        }
        var groupBy = createAggregator(function(result2, value, key) {
          if (hasOwnProperty.call(result2, key)) {
            result2[key].push(value);
          } else {
            baseAssignValue(result2, key, [value]);
          }
        });
        function includes(collection, value, fromIndex, guard) {
          collection = isArrayLike(collection) ? collection : values(collection);
          fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
          var length = collection.length;
          if (fromIndex < 0) {
            fromIndex = nativeMax(length + fromIndex, 0);
          }
          return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
        }
        var invokeMap = baseRest(function(collection, path, args) {
          var index = -1, isFunc = typeof path == "function", result2 = isArrayLike(collection) ? Array2(collection.length) : [];
          baseEach(collection, function(value) {
            result2[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
          });
          return result2;
        });
        var keyBy = createAggregator(function(result2, value, key) {
          baseAssignValue(result2, key, value);
        });
        function map(collection, iteratee2) {
          var func = isArray(collection) ? arrayMap : baseMap;
          return func(collection, getIteratee(iteratee2, 3));
        }
        function orderBy(collection, iteratees, orders, guard) {
          if (collection == null) {
            return [];
          }
          if (!isArray(iteratees)) {
            iteratees = iteratees == null ? [] : [iteratees];
          }
          orders = guard ? undefined2 : orders;
          if (!isArray(orders)) {
            orders = orders == null ? [] : [orders];
          }
          return baseOrderBy(collection, iteratees, orders);
        }
        var partition = createAggregator(function(result2, value, key) {
          result2[key ? 0 : 1].push(value);
        }, function() {
          return [[], []];
        });
        function reduce(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduce : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEach);
        }
        function reduceRight(collection, iteratee2, accumulator) {
          var func = isArray(collection) ? arrayReduceRight : baseReduce, initAccum = arguments.length < 3;
          return func(collection, getIteratee(iteratee2, 4), accumulator, initAccum, baseEachRight);
        }
        function reject(collection, predicate) {
          var func = isArray(collection) ? arrayFilter : baseFilter;
          return func(collection, negate(getIteratee(predicate, 3)));
        }
        function sample(collection) {
          var func = isArray(collection) ? arraySample : baseSample;
          return func(collection);
        }
        function sampleSize(collection, n, guard) {
          if (guard ? isIterateeCall(collection, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          var func = isArray(collection) ? arraySampleSize : baseSampleSize;
          return func(collection, n);
        }
        function shuffle(collection) {
          var func = isArray(collection) ? arrayShuffle : baseShuffle;
          return func(collection);
        }
        function size(collection) {
          if (collection == null) {
            return 0;
          }
          if (isArrayLike(collection)) {
            return isString(collection) ? stringSize(collection) : collection.length;
          }
          var tag = getTag(collection);
          if (tag == mapTag || tag == setTag) {
            return collection.size;
          }
          return baseKeys(collection).length;
        }
        function some(collection, predicate, guard) {
          var func = isArray(collection) ? arraySome : baseSome;
          if (guard && isIterateeCall(collection, predicate, guard)) {
            predicate = undefined2;
          }
          return func(collection, getIteratee(predicate, 3));
        }
        var sortBy = baseRest(function(collection, iteratees) {
          if (collection == null) {
            return [];
          }
          var length = iteratees.length;
          if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
            iteratees = [];
          } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
            iteratees = [iteratees[0]];
          }
          return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
        });
        var now = ctxNow || function() {
          return root.Date.now();
        };
        function after(n, func) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n < 1) {
              return func.apply(this, arguments);
            }
          };
        }
        function ary(func, n, guard) {
          n = guard ? undefined2 : n;
          n = func && n == null ? func.length : n;
          return createWrap(func, WRAP_ARY_FLAG, undefined2, undefined2, undefined2, undefined2, n);
        }
        function before(n, func) {
          var result2;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          n = toInteger(n);
          return function() {
            if (--n > 0) {
              result2 = func.apply(this, arguments);
            }
            if (n <= 1) {
              func = undefined2;
            }
            return result2;
          };
        }
        var bind = baseRest(function(func, thisArg, partials) {
          var bitmask = WRAP_BIND_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bind));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(func, bitmask, thisArg, partials, holders);
        });
        var bindKey = baseRest(function(object, key, partials) {
          var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
          if (partials.length) {
            var holders = replaceHolders(partials, getHolder(bindKey));
            bitmask |= WRAP_PARTIAL_FLAG;
          }
          return createWrap(key, bitmask, object, partials, holders);
        });
        function curry(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curry.placeholder;
          return result2;
        }
        function curryRight(func, arity, guard) {
          arity = guard ? undefined2 : arity;
          var result2 = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined2, undefined2, undefined2, undefined2, undefined2, arity);
          result2.placeholder = curryRight.placeholder;
          return result2;
        }
        function debounce(func, wait, options) {
          var lastArgs, lastThis, maxWait, result2, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          wait = toNumber(wait) || 0;
          if (isObject(options)) {
            leading = !!options.leading;
            maxing = "maxWait" in options;
            maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          function invokeFunc(time) {
            var args = lastArgs, thisArg = lastThis;
            lastArgs = lastThis = undefined2;
            lastInvokeTime = time;
            result2 = func.apply(thisArg, args);
            return result2;
          }
          function leadingEdge(time) {
            lastInvokeTime = time;
            timerId = setTimeout2(timerExpired, wait);
            return leading ? invokeFunc(time) : result2;
          }
          function remainingWait(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, timeWaiting = wait - timeSinceLastCall;
            return maxing ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke) : timeWaiting;
          }
          function shouldInvoke(time) {
            var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
            return lastCallTime === undefined2 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
          }
          function timerExpired() {
            var time = now();
            if (shouldInvoke(time)) {
              return trailingEdge(time);
            }
            timerId = setTimeout2(timerExpired, remainingWait(time));
          }
          function trailingEdge(time) {
            timerId = undefined2;
            if (trailing && lastArgs) {
              return invokeFunc(time);
            }
            lastArgs = lastThis = undefined2;
            return result2;
          }
          function cancel() {
            if (timerId !== undefined2) {
              clearTimeout(timerId);
            }
            lastInvokeTime = 0;
            lastArgs = lastCallTime = lastThis = timerId = undefined2;
          }
          function flush() {
            return timerId === undefined2 ? result2 : trailingEdge(now());
          }
          function debounced() {
            var time = now(), isInvoking = shouldInvoke(time);
            lastArgs = arguments;
            lastThis = this;
            lastCallTime = time;
            if (isInvoking) {
              if (timerId === undefined2) {
                return leadingEdge(lastCallTime);
              }
              if (maxing) {
                clearTimeout(timerId);
                timerId = setTimeout2(timerExpired, wait);
                return invokeFunc(lastCallTime);
              }
            }
            if (timerId === undefined2) {
              timerId = setTimeout2(timerExpired, wait);
            }
            return result2;
          }
          debounced.cancel = cancel;
          debounced.flush = flush;
          return debounced;
        }
        var defer = baseRest(function(func, args) {
          return baseDelay(func, 1, args);
        });
        var delay = baseRest(function(func, wait, args) {
          return baseDelay(func, toNumber(wait) || 0, args);
        });
        function flip(func) {
          return createWrap(func, WRAP_FLIP_FLAG);
        }
        function memoize(func, resolver) {
          if (typeof func != "function" || resolver != null && typeof resolver != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          var memoized = function() {
            var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
            if (cache.has(key)) {
              return cache.get(key);
            }
            var result2 = func.apply(this, args);
            memoized.cache = cache.set(key, result2) || cache;
            return result2;
          };
          memoized.cache = new (memoize.Cache || MapCache)();
          return memoized;
        }
        memoize.Cache = MapCache;
        function negate(predicate) {
          if (typeof predicate != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          return function() {
            var args = arguments;
            switch (args.length) {
              case 0:
                return !predicate.call(this);
              case 1:
                return !predicate.call(this, args[0]);
              case 2:
                return !predicate.call(this, args[0], args[1]);
              case 3:
                return !predicate.call(this, args[0], args[1], args[2]);
            }
            return !predicate.apply(this, args);
          };
        }
        function once(func) {
          return before(2, func);
        }
        var overArgs = castRest(function(func, transforms) {
          transforms = transforms.length == 1 && isArray(transforms[0]) ? arrayMap(transforms[0], baseUnary(getIteratee())) : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));
          var funcsLength = transforms.length;
          return baseRest(function(args) {
            var index = -1, length = nativeMin(args.length, funcsLength);
            while (++index < length) {
              args[index] = transforms[index].call(this, args[index]);
            }
            return apply(func, this, args);
          });
        });
        var partial = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partial));
          return createWrap(func, WRAP_PARTIAL_FLAG, undefined2, partials, holders);
        });
        var partialRight = baseRest(function(func, partials) {
          var holders = replaceHolders(partials, getHolder(partialRight));
          return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined2, partials, holders);
        });
        var rearg = flatRest(function(func, indexes) {
          return createWrap(func, WRAP_REARG_FLAG, undefined2, undefined2, undefined2, indexes);
        });
        function rest(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start === undefined2 ? start : toInteger(start);
          return baseRest(func, start);
        }
        function spread(func, start) {
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          start = start == null ? 0 : nativeMax(toInteger(start), 0);
          return baseRest(function(args) {
            var array = args[start], otherArgs = castSlice(args, 0, start);
            if (array) {
              arrayPush(otherArgs, array);
            }
            return apply(func, this, otherArgs);
          });
        }
        function throttle(func, wait, options) {
          var leading = true, trailing = true;
          if (typeof func != "function") {
            throw new TypeError2(FUNC_ERROR_TEXT);
          }
          if (isObject(options)) {
            leading = "leading" in options ? !!options.leading : leading;
            trailing = "trailing" in options ? !!options.trailing : trailing;
          }
          return debounce(func, wait, {
            "leading": leading,
            "maxWait": wait,
            "trailing": trailing
          });
        }
        function unary(func) {
          return ary(func, 1);
        }
        function wrap(value, wrapper) {
          return partial(castFunction(wrapper), value);
        }
        function castArray() {
          if (!arguments.length) {
            return [];
          }
          var value = arguments[0];
          return isArray(value) ? value : [value];
        }
        function clone(value) {
          return baseClone(value, CLONE_SYMBOLS_FLAG);
        }
        function cloneWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
        }
        function cloneDeep(value) {
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
        }
        function cloneDeepWith(value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
        }
        function conformsTo(object, source) {
          return source == null || baseConformsTo(object, source, keys(source));
        }
        function eq(value, other) {
          return value === other || value !== value && other !== other;
        }
        var gt = createRelationalOperation(baseGt);
        var gte = createRelationalOperation(function(value, other) {
          return value >= other;
        });
        var isArguments = baseIsArguments(/* @__PURE__ */ function() {
          return arguments;
        }()) ? baseIsArguments : function(value) {
          return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
        };
        var isArray = Array2.isArray;
        var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;
        function isArrayLike(value) {
          return value != null && isLength(value.length) && !isFunction(value);
        }
        function isArrayLikeObject(value) {
          return isObjectLike(value) && isArrayLike(value);
        }
        function isBoolean(value) {
          return value === true || value === false || isObjectLike(value) && baseGetTag(value) == boolTag;
        }
        var isBuffer = nativeIsBuffer || stubFalse;
        var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;
        function isElement(value) {
          return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
        }
        function isEmpty(value) {
          if (value == null) {
            return true;
          }
          if (isArrayLike(value) && (isArray(value) || typeof value == "string" || typeof value.splice == "function" || isBuffer(value) || isTypedArray(value) || isArguments(value))) {
            return !value.length;
          }
          var tag = getTag(value);
          if (tag == mapTag || tag == setTag) {
            return !value.size;
          }
          if (isPrototype(value)) {
            return !baseKeys(value).length;
          }
          for (var key in value) {
            if (hasOwnProperty.call(value, key)) {
              return false;
            }
          }
          return true;
        }
        function isEqual(value, other) {
          return baseIsEqual(value, other);
        }
        function isEqualWith(value, other, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          var result2 = customizer ? customizer(value, other) : undefined2;
          return result2 === undefined2 ? baseIsEqual(value, other, undefined2, customizer) : !!result2;
        }
        function isError(value) {
          if (!isObjectLike(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == errorTag || tag == domExcTag || typeof value.message == "string" && typeof value.name == "string" && !isPlainObject(value);
        }
        function isFinite(value) {
          return typeof value == "number" && nativeIsFinite(value);
        }
        function isFunction(value) {
          if (!isObject(value)) {
            return false;
          }
          var tag = baseGetTag(value);
          return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
        }
        function isInteger(value) {
          return typeof value == "number" && value == toInteger(value);
        }
        function isLength(value) {
          return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
        }
        function isObject(value) {
          var type = typeof value;
          return value != null && (type == "object" || type == "function");
        }
        function isObjectLike(value) {
          return value != null && typeof value == "object";
        }
        var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;
        function isMatch(object, source) {
          return object === source || baseIsMatch(object, source, getMatchData(source));
        }
        function isMatchWith(object, source, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return baseIsMatch(object, source, getMatchData(source), customizer);
        }
        function isNaN2(value) {
          return isNumber(value) && value != +value;
        }
        function isNative(value) {
          if (isMaskable(value)) {
            throw new Error2(CORE_ERROR_TEXT);
          }
          return baseIsNative(value);
        }
        function isNull(value) {
          return value === null;
        }
        function isNil(value) {
          return value == null;
        }
        function isNumber(value) {
          return typeof value == "number" || isObjectLike(value) && baseGetTag(value) == numberTag;
        }
        function isPlainObject(value) {
          if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
            return false;
          }
          var proto = getPrototype(value);
          if (proto === null) {
            return true;
          }
          var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
          return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
        }
        var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;
        function isSafeInteger(value) {
          return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
        }
        var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;
        function isString(value) {
          return typeof value == "string" || !isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag;
        }
        function isSymbol(value) {
          return typeof value == "symbol" || isObjectLike(value) && baseGetTag(value) == symbolTag;
        }
        var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
        function isUndefined(value) {
          return value === undefined2;
        }
        function isWeakMap(value) {
          return isObjectLike(value) && getTag(value) == weakMapTag;
        }
        function isWeakSet(value) {
          return isObjectLike(value) && baseGetTag(value) == weakSetTag;
        }
        var lt = createRelationalOperation(baseLt);
        var lte = createRelationalOperation(function(value, other) {
          return value <= other;
        });
        function toArray(value) {
          if (!value) {
            return [];
          }
          if (isArrayLike(value)) {
            return isString(value) ? stringToArray(value) : copyArray(value);
          }
          if (symIterator && value[symIterator]) {
            return iteratorToArray(value[symIterator]());
          }
          var tag = getTag(value), func = tag == mapTag ? mapToArray : tag == setTag ? setToArray : values;
          return func(value);
        }
        function toFinite(value) {
          if (!value) {
            return value === 0 ? value : 0;
          }
          value = toNumber(value);
          if (value === INFINITY || value === -INFINITY) {
            var sign = value < 0 ? -1 : 1;
            return sign * MAX_INTEGER;
          }
          return value === value ? value : 0;
        }
        function toInteger(value) {
          var result2 = toFinite(value), remainder = result2 % 1;
          return result2 === result2 ? remainder ? result2 - remainder : result2 : 0;
        }
        function toLength(value) {
          return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
        }
        function toNumber(value) {
          if (typeof value == "number") {
            return value;
          }
          if (isSymbol(value)) {
            return NAN;
          }
          if (isObject(value)) {
            var other = typeof value.valueOf == "function" ? value.valueOf() : value;
            value = isObject(other) ? other + "" : other;
          }
          if (typeof value != "string") {
            return value === 0 ? value : +value;
          }
          value = baseTrim(value);
          var isBinary = reIsBinary.test(value);
          return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
        }
        function toPlainObject(value) {
          return copyObject(value, keysIn(value));
        }
        function toSafeInteger(value) {
          return value ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER) : value === 0 ? value : 0;
        }
        function toString(value) {
          return value == null ? "" : baseToString(value);
        }
        var assign = createAssigner(function(object, source) {
          if (isPrototype(source) || isArrayLike(source)) {
            copyObject(source, keys(source), object);
            return;
          }
          for (var key in source) {
            if (hasOwnProperty.call(source, key)) {
              assignValue(object, key, source[key]);
            }
          }
        });
        var assignIn = createAssigner(function(object, source) {
          copyObject(source, keysIn(source), object);
        });
        var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keysIn(source), object, customizer);
        });
        var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
          copyObject(source, keys(source), object, customizer);
        });
        var at = flatRest(baseAt);
        function create(prototype, properties) {
          var result2 = baseCreate(prototype);
          return properties == null ? result2 : baseAssign(result2, properties);
        }
        var defaults = baseRest(function(object, sources) {
          object = Object2(object);
          var index = -1;
          var length = sources.length;
          var guard = length > 2 ? sources[2] : undefined2;
          if (guard && isIterateeCall(sources[0], sources[1], guard)) {
            length = 1;
          }
          while (++index < length) {
            var source = sources[index];
            var props = keysIn(source);
            var propsIndex = -1;
            var propsLength = props.length;
            while (++propsIndex < propsLength) {
              var key = props[propsIndex];
              var value = object[key];
              if (value === undefined2 || eq(value, objectProto[key]) && !hasOwnProperty.call(object, key)) {
                object[key] = source[key];
              }
            }
          }
          return object;
        });
        var defaultsDeep = baseRest(function(args) {
          args.push(undefined2, customDefaultsMerge);
          return apply(mergeWith, undefined2, args);
        });
        function findKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
        }
        function findLastKey(object, predicate) {
          return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
        }
        function forIn(object, iteratee2) {
          return object == null ? object : baseFor(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forInRight(object, iteratee2) {
          return object == null ? object : baseForRight(object, getIteratee(iteratee2, 3), keysIn);
        }
        function forOwn(object, iteratee2) {
          return object && baseForOwn(object, getIteratee(iteratee2, 3));
        }
        function forOwnRight(object, iteratee2) {
          return object && baseForOwnRight(object, getIteratee(iteratee2, 3));
        }
        function functions(object) {
          return object == null ? [] : baseFunctions(object, keys(object));
        }
        function functionsIn(object) {
          return object == null ? [] : baseFunctions(object, keysIn(object));
        }
        function get(object, path, defaultValue) {
          var result2 = object == null ? undefined2 : baseGet(object, path);
          return result2 === undefined2 ? defaultValue : result2;
        }
        function has(object, path) {
          return object != null && hasPath(object, path, baseHas);
        }
        function hasIn(object, path) {
          return object != null && hasPath(object, path, baseHasIn);
        }
        var invert = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          result2[value] = key;
        }, constant(identity));
        var invertBy = createInverter(function(result2, value, key) {
          if (value != null && typeof value.toString != "function") {
            value = nativeObjectToString.call(value);
          }
          if (hasOwnProperty.call(result2, value)) {
            result2[value].push(key);
          } else {
            result2[value] = [key];
          }
        }, getIteratee);
        var invoke = baseRest(baseInvoke);
        function keys(object) {
          return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
        }
        function keysIn(object) {
          return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
        }
        function mapKeys(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, iteratee2(value, key, object2), value);
          });
          return result2;
        }
        function mapValues(object, iteratee2) {
          var result2 = {};
          iteratee2 = getIteratee(iteratee2, 3);
          baseForOwn(object, function(value, key, object2) {
            baseAssignValue(result2, key, iteratee2(value, key, object2));
          });
          return result2;
        }
        var merge = createAssigner(function(object, source, srcIndex) {
          baseMerge(object, source, srcIndex);
        });
        var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
          baseMerge(object, source, srcIndex, customizer);
        });
        var omit = flatRest(function(object, paths) {
          var result2 = {};
          if (object == null) {
            return result2;
          }
          var isDeep = false;
          paths = arrayMap(paths, function(path) {
            path = castPath(path, object);
            isDeep || (isDeep = path.length > 1);
            return path;
          });
          copyObject(object, getAllKeysIn(object), result2);
          if (isDeep) {
            result2 = baseClone(result2, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
          }
          var length = paths.length;
          while (length--) {
            baseUnset(result2, paths[length]);
          }
          return result2;
        });
        function omitBy(object, predicate) {
          return pickBy(object, negate(getIteratee(predicate)));
        }
        var pick = flatRest(function(object, paths) {
          return object == null ? {} : basePick(object, paths);
        });
        function pickBy(object, predicate) {
          if (object == null) {
            return {};
          }
          var props = arrayMap(getAllKeysIn(object), function(prop) {
            return [prop];
          });
          predicate = getIteratee(predicate);
          return basePickBy(object, props, function(value, path) {
            return predicate(value, path[0]);
          });
        }
        function result(object, path, defaultValue) {
          path = castPath(path, object);
          var index = -1, length = path.length;
          if (!length) {
            length = 1;
            object = undefined2;
          }
          while (++index < length) {
            var value = object == null ? undefined2 : object[toKey(path[index])];
            if (value === undefined2) {
              index = length;
              value = defaultValue;
            }
            object = isFunction(value) ? value.call(object) : value;
          }
          return object;
        }
        function set(object, path, value) {
          return object == null ? object : baseSet(object, path, value);
        }
        function setWith(object, path, value, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseSet(object, path, value, customizer);
        }
        var toPairs = createToPairs(keys);
        var toPairsIn = createToPairs(keysIn);
        function transform(object, iteratee2, accumulator) {
          var isArr = isArray(object), isArrLike = isArr || isBuffer(object) || isTypedArray(object);
          iteratee2 = getIteratee(iteratee2, 4);
          if (accumulator == null) {
            var Ctor = object && object.constructor;
            if (isArrLike) {
              accumulator = isArr ? new Ctor() : [];
            } else if (isObject(object)) {
              accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
            } else {
              accumulator = {};
            }
          }
          (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object2) {
            return iteratee2(accumulator, value, index, object2);
          });
          return accumulator;
        }
        function unset(object, path) {
          return object == null ? true : baseUnset(object, path);
        }
        function update(object, path, updater) {
          return object == null ? object : baseUpdate(object, path, castFunction(updater));
        }
        function updateWith(object, path, updater, customizer) {
          customizer = typeof customizer == "function" ? customizer : undefined2;
          return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
        }
        function values(object) {
          return object == null ? [] : baseValues(object, keys(object));
        }
        function valuesIn(object) {
          return object == null ? [] : baseValues(object, keysIn(object));
        }
        function clamp(number, lower, upper) {
          if (upper === undefined2) {
            upper = lower;
            lower = undefined2;
          }
          if (upper !== undefined2) {
            upper = toNumber(upper);
            upper = upper === upper ? upper : 0;
          }
          if (lower !== undefined2) {
            lower = toNumber(lower);
            lower = lower === lower ? lower : 0;
          }
          return baseClamp(toNumber(number), lower, upper);
        }
        function inRange(number, start, end) {
          start = toFinite(start);
          if (end === undefined2) {
            end = start;
            start = 0;
          } else {
            end = toFinite(end);
          }
          number = toNumber(number);
          return baseInRange(number, start, end);
        }
        function random(lower, upper, floating) {
          if (floating && typeof floating != "boolean" && isIterateeCall(lower, upper, floating)) {
            upper = floating = undefined2;
          }
          if (floating === undefined2) {
            if (typeof upper == "boolean") {
              floating = upper;
              upper = undefined2;
            } else if (typeof lower == "boolean") {
              floating = lower;
              lower = undefined2;
            }
          }
          if (lower === undefined2 && upper === undefined2) {
            lower = 0;
            upper = 1;
          } else {
            lower = toFinite(lower);
            if (upper === undefined2) {
              upper = lower;
              lower = 0;
            } else {
              upper = toFinite(upper);
            }
          }
          if (lower > upper) {
            var temp = lower;
            lower = upper;
            upper = temp;
          }
          if (floating || lower % 1 || upper % 1) {
            var rand = nativeRandom();
            return nativeMin(lower + rand * (upper - lower + freeParseFloat("1e-" + ((rand + "").length - 1))), upper);
          }
          return baseRandom(lower, upper);
        }
        var camelCase = createCompounder(function(result2, word, index) {
          word = word.toLowerCase();
          return result2 + (index ? capitalize(word) : word);
        });
        function capitalize(string) {
          return upperFirst(toString(string).toLowerCase());
        }
        function deburr(string) {
          string = toString(string);
          return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
        }
        function endsWith(string, target, position) {
          string = toString(string);
          target = baseToString(target);
          var length = string.length;
          position = position === undefined2 ? length : baseClamp(toInteger(position), 0, length);
          var end = position;
          position -= target.length;
          return position >= 0 && string.slice(position, end) == target;
        }
        function escape(string) {
          string = toString(string);
          return string && reHasUnescapedHtml.test(string) ? string.replace(reUnescapedHtml, escapeHtmlChar) : string;
        }
        function escapeRegExp(string) {
          string = toString(string);
          return string && reHasRegExpChar.test(string) ? string.replace(reRegExpChar, "\\$&") : string;
        }
        var kebabCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "-" : "") + word.toLowerCase();
        });
        var lowerCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toLowerCase();
        });
        var lowerFirst = createCaseFirst("toLowerCase");
        function pad(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          if (!length || strLength >= length) {
            return string;
          }
          var mid = (length - strLength) / 2;
          return createPadding(nativeFloor(mid), chars) + string + createPadding(nativeCeil(mid), chars);
        }
        function padEnd(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? string + createPadding(length - strLength, chars) : string;
        }
        function padStart(string, length, chars) {
          string = toString(string);
          length = toInteger(length);
          var strLength = length ? stringSize(string) : 0;
          return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
        }
        function parseInt2(string, radix, guard) {
          if (guard || radix == null) {
            radix = 0;
          } else if (radix) {
            radix = +radix;
          }
          return nativeParseInt(toString(string).replace(reTrimStart, ""), radix || 0);
        }
        function repeat(string, n, guard) {
          if (guard ? isIterateeCall(string, n, guard) : n === undefined2) {
            n = 1;
          } else {
            n = toInteger(n);
          }
          return baseRepeat(toString(string), n);
        }
        function replace() {
          var args = arguments, string = toString(args[0]);
          return args.length < 3 ? string : string.replace(args[1], args[2]);
        }
        var snakeCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? "_" : "") + word.toLowerCase();
        });
        function split(string, separator, limit) {
          if (limit && typeof limit != "number" && isIterateeCall(string, separator, limit)) {
            separator = limit = undefined2;
          }
          limit = limit === undefined2 ? MAX_ARRAY_LENGTH : limit >>> 0;
          if (!limit) {
            return [];
          }
          string = toString(string);
          if (string && (typeof separator == "string" || separator != null && !isRegExp(separator))) {
            separator = baseToString(separator);
            if (!separator && hasUnicode(string)) {
              return castSlice(stringToArray(string), 0, limit);
            }
          }
          return string.split(separator, limit);
        }
        var startCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + upperFirst(word);
        });
        function startsWith(string, target, position) {
          string = toString(string);
          position = position == null ? 0 : baseClamp(toInteger(position), 0, string.length);
          target = baseToString(target);
          return string.slice(position, position + target.length) == target;
        }
        function template(string, options, guard) {
          var settings = lodash.templateSettings;
          if (guard && isIterateeCall(string, options, guard)) {
            options = undefined2;
          }
          string = toString(string);
          options = assignInWith({}, options, settings, customDefaultsAssignIn);
          var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn), importsKeys = keys(imports), importsValues = baseValues(imports, importsKeys);
          var isEscaping, isEvaluating, index = 0, interpolate = options.interpolate || reNoMatch, source = "__p += '";
          var reDelimiters = RegExp2(
            (options.escape || reNoMatch).source + "|" + interpolate.source + "|" + (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + "|" + (options.evaluate || reNoMatch).source + "|$",
            "g"
          );
          var sourceURL = "//# sourceURL=" + (hasOwnProperty.call(options, "sourceURL") ? (options.sourceURL + "").replace(/\s/g, " ") : "lodash.templateSources[" + ++templateCounter + "]") + "\n";
          string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
            interpolateValue || (interpolateValue = esTemplateValue);
            source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);
            if (escapeValue) {
              isEscaping = true;
              source += "' +\n__e(" + escapeValue + ") +\n'";
            }
            if (evaluateValue) {
              isEvaluating = true;
              source += "';\n" + evaluateValue + ";\n__p += '";
            }
            if (interpolateValue) {
              source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
            }
            index = offset + match.length;
            return match;
          });
          source += "';\n";
          var variable = hasOwnProperty.call(options, "variable") && options.variable;
          if (!variable) {
            source = "with (obj) {\n" + source + "\n}\n";
          } else if (reForbiddenIdentifierChars.test(variable)) {
            throw new Error2(INVALID_TEMPL_VAR_ERROR_TEXT);
          }
          source = (isEvaluating ? source.replace(reEmptyStringLeading, "") : source).replace(reEmptyStringMiddle, "$1").replace(reEmptyStringTrailing, "$1;");
          source = "function(" + (variable || "obj") + ") {\n" + (variable ? "" : "obj || (obj = {});\n") + "var __t, __p = ''" + (isEscaping ? ", __e = _.escape" : "") + (isEvaluating ? ", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n" : ";\n") + source + "return __p\n}";
          var result2 = attempt(function() {
            return Function2(importsKeys, sourceURL + "return " + source).apply(undefined2, importsValues);
          });
          result2.source = source;
          if (isError(result2)) {
            throw result2;
          }
          return result2;
        }
        function toLower(value) {
          return toString(value).toLowerCase();
        }
        function toUpper(value) {
          return toString(value).toUpperCase();
        }
        function trim(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return baseTrim(string);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), chrSymbols = stringToArray(chars), start = charsStartIndex(strSymbols, chrSymbols), end = charsEndIndex(strSymbols, chrSymbols) + 1;
          return castSlice(strSymbols, start, end).join("");
        }
        function trimEnd(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.slice(0, trimmedEndIndex(string) + 1);
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;
          return castSlice(strSymbols, 0, end).join("");
        }
        function trimStart(string, chars, guard) {
          string = toString(string);
          if (string && (guard || chars === undefined2)) {
            return string.replace(reTrimStart, "");
          }
          if (!string || !(chars = baseToString(chars))) {
            return string;
          }
          var strSymbols = stringToArray(string), start = charsStartIndex(strSymbols, stringToArray(chars));
          return castSlice(strSymbols, start).join("");
        }
        function truncate(string, options) {
          var length = DEFAULT_TRUNC_LENGTH, omission = DEFAULT_TRUNC_OMISSION;
          if (isObject(options)) {
            var separator = "separator" in options ? options.separator : separator;
            length = "length" in options ? toInteger(options.length) : length;
            omission = "omission" in options ? baseToString(options.omission) : omission;
          }
          string = toString(string);
          var strLength = string.length;
          if (hasUnicode(string)) {
            var strSymbols = stringToArray(string);
            strLength = strSymbols.length;
          }
          if (length >= strLength) {
            return string;
          }
          var end = length - stringSize(omission);
          if (end < 1) {
            return omission;
          }
          var result2 = strSymbols ? castSlice(strSymbols, 0, end).join("") : string.slice(0, end);
          if (separator === undefined2) {
            return result2 + omission;
          }
          if (strSymbols) {
            end += result2.length - end;
          }
          if (isRegExp(separator)) {
            if (string.slice(end).search(separator)) {
              var match, substring = result2;
              if (!separator.global) {
                separator = RegExp2(separator.source, toString(reFlags.exec(separator)) + "g");
              }
              separator.lastIndex = 0;
              while (match = separator.exec(substring)) {
                var newEnd = match.index;
              }
              result2 = result2.slice(0, newEnd === undefined2 ? end : newEnd);
            }
          } else if (string.indexOf(baseToString(separator), end) != end) {
            var index = result2.lastIndexOf(separator);
            if (index > -1) {
              result2 = result2.slice(0, index);
            }
          }
          return result2 + omission;
        }
        function unescape(string) {
          string = toString(string);
          return string && reHasEscapedHtml.test(string) ? string.replace(reEscapedHtml, unescapeHtmlChar) : string;
        }
        var upperCase = createCompounder(function(result2, word, index) {
          return result2 + (index ? " " : "") + word.toUpperCase();
        });
        var upperFirst = createCaseFirst("toUpperCase");
        function words(string, pattern, guard) {
          string = toString(string);
          pattern = guard ? undefined2 : pattern;
          if (pattern === undefined2) {
            return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
          }
          return string.match(pattern) || [];
        }
        var attempt = baseRest(function(func, args) {
          try {
            return apply(func, undefined2, args);
          } catch (e) {
            return isError(e) ? e : new Error2(e);
          }
        });
        var bindAll = flatRest(function(object, methodNames) {
          arrayEach(methodNames, function(key) {
            key = toKey(key);
            baseAssignValue(object, key, bind(object[key], object));
          });
          return object;
        });
        function cond(pairs) {
          var length = pairs == null ? 0 : pairs.length, toIteratee = getIteratee();
          pairs = !length ? [] : arrayMap(pairs, function(pair) {
            if (typeof pair[1] != "function") {
              throw new TypeError2(FUNC_ERROR_TEXT);
            }
            return [toIteratee(pair[0]), pair[1]];
          });
          return baseRest(function(args) {
            var index = -1;
            while (++index < length) {
              var pair = pairs[index];
              if (apply(pair[0], this, args)) {
                return apply(pair[1], this, args);
              }
            }
          });
        }
        function conforms(source) {
          return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
        }
        function constant(value) {
          return function() {
            return value;
          };
        }
        function defaultTo(value, defaultValue) {
          return value == null || value !== value ? defaultValue : value;
        }
        var flow = createFlow();
        var flowRight = createFlow(true);
        function identity(value) {
          return value;
        }
        function iteratee(func) {
          return baseIteratee(typeof func == "function" ? func : baseClone(func, CLONE_DEEP_FLAG));
        }
        function matches(source) {
          return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
        }
        function matchesProperty(path, srcValue) {
          return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
        }
        var method = baseRest(function(path, args) {
          return function(object) {
            return baseInvoke(object, path, args);
          };
        });
        var methodOf = baseRest(function(object, args) {
          return function(path) {
            return baseInvoke(object, path, args);
          };
        });
        function mixin(object, source, options) {
          var props = keys(source), methodNames = baseFunctions(source, props);
          if (options == null && !(isObject(source) && (methodNames.length || !props.length))) {
            options = source;
            source = object;
            object = this;
            methodNames = baseFunctions(source, keys(source));
          }
          var chain2 = !(isObject(options) && "chain" in options) || !!options.chain, isFunc = isFunction(object);
          arrayEach(methodNames, function(methodName) {
            var func = source[methodName];
            object[methodName] = func;
            if (isFunc) {
              object.prototype[methodName] = function() {
                var chainAll = this.__chain__;
                if (chain2 || chainAll) {
                  var result2 = object(this.__wrapped__), actions = result2.__actions__ = copyArray(this.__actions__);
                  actions.push({ "func": func, "args": arguments, "thisArg": object });
                  result2.__chain__ = chainAll;
                  return result2;
                }
                return func.apply(object, arrayPush([this.value()], arguments));
              };
            }
          });
          return object;
        }
        function noConflict() {
          if (root._ === this) {
            root._ = oldDash;
          }
          return this;
        }
        function noop() {
        }
        function nthArg(n) {
          n = toInteger(n);
          return baseRest(function(args) {
            return baseNth(args, n);
          });
        }
        var over = createOver(arrayMap);
        var overEvery = createOver(arrayEvery);
        var overSome = createOver(arraySome);
        function property(path) {
          return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
        }
        function propertyOf(object) {
          return function(path) {
            return object == null ? undefined2 : baseGet(object, path);
          };
        }
        var range = createRange();
        var rangeRight = createRange(true);
        function stubArray() {
          return [];
        }
        function stubFalse() {
          return false;
        }
        function stubObject() {
          return {};
        }
        function stubString() {
          return "";
        }
        function stubTrue() {
          return true;
        }
        function times(n, iteratee2) {
          n = toInteger(n);
          if (n < 1 || n > MAX_SAFE_INTEGER) {
            return [];
          }
          var index = MAX_ARRAY_LENGTH, length = nativeMin(n, MAX_ARRAY_LENGTH);
          iteratee2 = getIteratee(iteratee2);
          n -= MAX_ARRAY_LENGTH;
          var result2 = baseTimes(length, iteratee2);
          while (++index < n) {
            iteratee2(index);
          }
          return result2;
        }
        function toPath(value) {
          if (isArray(value)) {
            return arrayMap(value, toKey);
          }
          return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
        }
        function uniqueId(prefix) {
          var id = ++idCounter;
          return toString(prefix) + id;
        }
        var add = createMathOperation(function(augend, addend) {
          return augend + addend;
        }, 0);
        var ceil = createRound("ceil");
        var divide = createMathOperation(function(dividend, divisor) {
          return dividend / divisor;
        }, 1);
        var floor = createRound("floor");
        function max(array) {
          return array && array.length ? baseExtremum(array, identity, baseGt) : undefined2;
        }
        function maxBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseGt) : undefined2;
        }
        function mean(array) {
          return baseMean(array, identity);
        }
        function meanBy(array, iteratee2) {
          return baseMean(array, getIteratee(iteratee2, 2));
        }
        function min(array) {
          return array && array.length ? baseExtremum(array, identity, baseLt) : undefined2;
        }
        function minBy(array, iteratee2) {
          return array && array.length ? baseExtremum(array, getIteratee(iteratee2, 2), baseLt) : undefined2;
        }
        var multiply = createMathOperation(function(multiplier, multiplicand) {
          return multiplier * multiplicand;
        }, 1);
        var round = createRound("round");
        var subtract = createMathOperation(function(minuend, subtrahend) {
          return minuend - subtrahend;
        }, 0);
        function sum(array) {
          return array && array.length ? baseSum(array, identity) : 0;
        }
        function sumBy(array, iteratee2) {
          return array && array.length ? baseSum(array, getIteratee(iteratee2, 2)) : 0;
        }
        lodash.after = after;
        lodash.ary = ary;
        lodash.assign = assign;
        lodash.assignIn = assignIn;
        lodash.assignInWith = assignInWith;
        lodash.assignWith = assignWith;
        lodash.at = at;
        lodash.before = before;
        lodash.bind = bind;
        lodash.bindAll = bindAll;
        lodash.bindKey = bindKey;
        lodash.castArray = castArray;
        lodash.chain = chain;
        lodash.chunk = chunk;
        lodash.compact = compact;
        lodash.concat = concat;
        lodash.cond = cond;
        lodash.conforms = conforms;
        lodash.constant = constant;
        lodash.countBy = countBy;
        lodash.create = create;
        lodash.curry = curry;
        lodash.curryRight = curryRight;
        lodash.debounce = debounce;
        lodash.defaults = defaults;
        lodash.defaultsDeep = defaultsDeep;
        lodash.defer = defer;
        lodash.delay = delay;
        lodash.difference = difference;
        lodash.differenceBy = differenceBy;
        lodash.differenceWith = differenceWith;
        lodash.drop = drop;
        lodash.dropRight = dropRight;
        lodash.dropRightWhile = dropRightWhile;
        lodash.dropWhile = dropWhile;
        lodash.fill = fill;
        lodash.filter = filter;
        lodash.flatMap = flatMap;
        lodash.flatMapDeep = flatMapDeep;
        lodash.flatMapDepth = flatMapDepth;
        lodash.flatten = flatten;
        lodash.flattenDeep = flattenDeep;
        lodash.flattenDepth = flattenDepth;
        lodash.flip = flip;
        lodash.flow = flow;
        lodash.flowRight = flowRight;
        lodash.fromPairs = fromPairs;
        lodash.functions = functions;
        lodash.functionsIn = functionsIn;
        lodash.groupBy = groupBy;
        lodash.initial = initial;
        lodash.intersection = intersection;
        lodash.intersectionBy = intersectionBy;
        lodash.intersectionWith = intersectionWith;
        lodash.invert = invert;
        lodash.invertBy = invertBy;
        lodash.invokeMap = invokeMap;
        lodash.iteratee = iteratee;
        lodash.keyBy = keyBy;
        lodash.keys = keys;
        lodash.keysIn = keysIn;
        lodash.map = map;
        lodash.mapKeys = mapKeys;
        lodash.mapValues = mapValues;
        lodash.matches = matches;
        lodash.matchesProperty = matchesProperty;
        lodash.memoize = memoize;
        lodash.merge = merge;
        lodash.mergeWith = mergeWith;
        lodash.method = method;
        lodash.methodOf = methodOf;
        lodash.mixin = mixin;
        lodash.negate = negate;
        lodash.nthArg = nthArg;
        lodash.omit = omit;
        lodash.omitBy = omitBy;
        lodash.once = once;
        lodash.orderBy = orderBy;
        lodash.over = over;
        lodash.overArgs = overArgs;
        lodash.overEvery = overEvery;
        lodash.overSome = overSome;
        lodash.partial = partial;
        lodash.partialRight = partialRight;
        lodash.partition = partition;
        lodash.pick = pick;
        lodash.pickBy = pickBy;
        lodash.property = property;
        lodash.propertyOf = propertyOf;
        lodash.pull = pull;
        lodash.pullAll = pullAll;
        lodash.pullAllBy = pullAllBy;
        lodash.pullAllWith = pullAllWith;
        lodash.pullAt = pullAt;
        lodash.range = range;
        lodash.rangeRight = rangeRight;
        lodash.rearg = rearg;
        lodash.reject = reject;
        lodash.remove = remove;
        lodash.rest = rest;
        lodash.reverse = reverse;
        lodash.sampleSize = sampleSize;
        lodash.set = set;
        lodash.setWith = setWith;
        lodash.shuffle = shuffle;
        lodash.slice = slice;
        lodash.sortBy = sortBy;
        lodash.sortedUniq = sortedUniq;
        lodash.sortedUniqBy = sortedUniqBy;
        lodash.split = split;
        lodash.spread = spread;
        lodash.tail = tail;
        lodash.take = take;
        lodash.takeRight = takeRight;
        lodash.takeRightWhile = takeRightWhile;
        lodash.takeWhile = takeWhile;
        lodash.tap = tap;
        lodash.throttle = throttle;
        lodash.thru = thru;
        lodash.toArray = toArray;
        lodash.toPairs = toPairs;
        lodash.toPairsIn = toPairsIn;
        lodash.toPath = toPath;
        lodash.toPlainObject = toPlainObject;
        lodash.transform = transform;
        lodash.unary = unary;
        lodash.union = union;
        lodash.unionBy = unionBy;
        lodash.unionWith = unionWith;
        lodash.uniq = uniq;
        lodash.uniqBy = uniqBy;
        lodash.uniqWith = uniqWith;
        lodash.unset = unset;
        lodash.unzip = unzip;
        lodash.unzipWith = unzipWith;
        lodash.update = update;
        lodash.updateWith = updateWith;
        lodash.values = values;
        lodash.valuesIn = valuesIn;
        lodash.without = without;
        lodash.words = words;
        lodash.wrap = wrap;
        lodash.xor = xor;
        lodash.xorBy = xorBy;
        lodash.xorWith = xorWith;
        lodash.zip = zip;
        lodash.zipObject = zipObject;
        lodash.zipObjectDeep = zipObjectDeep;
        lodash.zipWith = zipWith;
        lodash.entries = toPairs;
        lodash.entriesIn = toPairsIn;
        lodash.extend = assignIn;
        lodash.extendWith = assignInWith;
        mixin(lodash, lodash);
        lodash.add = add;
        lodash.attempt = attempt;
        lodash.camelCase = camelCase;
        lodash.capitalize = capitalize;
        lodash.ceil = ceil;
        lodash.clamp = clamp;
        lodash.clone = clone;
        lodash.cloneDeep = cloneDeep;
        lodash.cloneDeepWith = cloneDeepWith;
        lodash.cloneWith = cloneWith;
        lodash.conformsTo = conformsTo;
        lodash.deburr = deburr;
        lodash.defaultTo = defaultTo;
        lodash.divide = divide;
        lodash.endsWith = endsWith;
        lodash.eq = eq;
        lodash.escape = escape;
        lodash.escapeRegExp = escapeRegExp;
        lodash.every = every;
        lodash.find = find;
        lodash.findIndex = findIndex;
        lodash.findKey = findKey;
        lodash.findLast = findLast;
        lodash.findLastIndex = findLastIndex;
        lodash.findLastKey = findLastKey;
        lodash.floor = floor;
        lodash.forEach = forEach;
        lodash.forEachRight = forEachRight;
        lodash.forIn = forIn;
        lodash.forInRight = forInRight;
        lodash.forOwn = forOwn;
        lodash.forOwnRight = forOwnRight;
        lodash.get = get;
        lodash.gt = gt;
        lodash.gte = gte;
        lodash.has = has;
        lodash.hasIn = hasIn;
        lodash.head = head;
        lodash.identity = identity;
        lodash.includes = includes;
        lodash.indexOf = indexOf;
        lodash.inRange = inRange;
        lodash.invoke = invoke;
        lodash.isArguments = isArguments;
        lodash.isArray = isArray;
        lodash.isArrayBuffer = isArrayBuffer;
        lodash.isArrayLike = isArrayLike;
        lodash.isArrayLikeObject = isArrayLikeObject;
        lodash.isBoolean = isBoolean;
        lodash.isBuffer = isBuffer;
        lodash.isDate = isDate;
        lodash.isElement = isElement;
        lodash.isEmpty = isEmpty;
        lodash.isEqual = isEqual;
        lodash.isEqualWith = isEqualWith;
        lodash.isError = isError;
        lodash.isFinite = isFinite;
        lodash.isFunction = isFunction;
        lodash.isInteger = isInteger;
        lodash.isLength = isLength;
        lodash.isMap = isMap;
        lodash.isMatch = isMatch;
        lodash.isMatchWith = isMatchWith;
        lodash.isNaN = isNaN2;
        lodash.isNative = isNative;
        lodash.isNil = isNil;
        lodash.isNull = isNull;
        lodash.isNumber = isNumber;
        lodash.isObject = isObject;
        lodash.isObjectLike = isObjectLike;
        lodash.isPlainObject = isPlainObject;
        lodash.isRegExp = isRegExp;
        lodash.isSafeInteger = isSafeInteger;
        lodash.isSet = isSet;
        lodash.isString = isString;
        lodash.isSymbol = isSymbol;
        lodash.isTypedArray = isTypedArray;
        lodash.isUndefined = isUndefined;
        lodash.isWeakMap = isWeakMap;
        lodash.isWeakSet = isWeakSet;
        lodash.join = join;
        lodash.kebabCase = kebabCase;
        lodash.last = last;
        lodash.lastIndexOf = lastIndexOf;
        lodash.lowerCase = lowerCase;
        lodash.lowerFirst = lowerFirst;
        lodash.lt = lt;
        lodash.lte = lte;
        lodash.max = max;
        lodash.maxBy = maxBy;
        lodash.mean = mean;
        lodash.meanBy = meanBy;
        lodash.min = min;
        lodash.minBy = minBy;
        lodash.stubArray = stubArray;
        lodash.stubFalse = stubFalse;
        lodash.stubObject = stubObject;
        lodash.stubString = stubString;
        lodash.stubTrue = stubTrue;
        lodash.multiply = multiply;
        lodash.nth = nth;
        lodash.noConflict = noConflict;
        lodash.noop = noop;
        lodash.now = now;
        lodash.pad = pad;
        lodash.padEnd = padEnd;
        lodash.padStart = padStart;
        lodash.parseInt = parseInt2;
        lodash.random = random;
        lodash.reduce = reduce;
        lodash.reduceRight = reduceRight;
        lodash.repeat = repeat;
        lodash.replace = replace;
        lodash.result = result;
        lodash.round = round;
        lodash.runInContext = runInContext2;
        lodash.sample = sample;
        lodash.size = size;
        lodash.snakeCase = snakeCase;
        lodash.some = some;
        lodash.sortedIndex = sortedIndex;
        lodash.sortedIndexBy = sortedIndexBy;
        lodash.sortedIndexOf = sortedIndexOf;
        lodash.sortedLastIndex = sortedLastIndex;
        lodash.sortedLastIndexBy = sortedLastIndexBy;
        lodash.sortedLastIndexOf = sortedLastIndexOf;
        lodash.startCase = startCase;
        lodash.startsWith = startsWith;
        lodash.subtract = subtract;
        lodash.sum = sum;
        lodash.sumBy = sumBy;
        lodash.template = template;
        lodash.times = times;
        lodash.toFinite = toFinite;
        lodash.toInteger = toInteger;
        lodash.toLength = toLength;
        lodash.toLower = toLower;
        lodash.toNumber = toNumber;
        lodash.toSafeInteger = toSafeInteger;
        lodash.toString = toString;
        lodash.toUpper = toUpper;
        lodash.trim = trim;
        lodash.trimEnd = trimEnd;
        lodash.trimStart = trimStart;
        lodash.truncate = truncate;
        lodash.unescape = unescape;
        lodash.uniqueId = uniqueId;
        lodash.upperCase = upperCase;
        lodash.upperFirst = upperFirst;
        lodash.each = forEach;
        lodash.eachRight = forEachRight;
        lodash.first = head;
        mixin(lodash, function() {
          var source = {};
          baseForOwn(lodash, function(func, methodName) {
            if (!hasOwnProperty.call(lodash.prototype, methodName)) {
              source[methodName] = func;
            }
          });
          return source;
        }(), { "chain": false });
        lodash.VERSION = VERSION;
        arrayEach(["bind", "bindKey", "curry", "curryRight", "partial", "partialRight"], function(methodName) {
          lodash[methodName].placeholder = lodash;
        });
        arrayEach(["drop", "take"], function(methodName, index) {
          LazyWrapper.prototype[methodName] = function(n) {
            n = n === undefined2 ? 1 : nativeMax(toInteger(n), 0);
            var result2 = this.__filtered__ && !index ? new LazyWrapper(this) : this.clone();
            if (result2.__filtered__) {
              result2.__takeCount__ = nativeMin(n, result2.__takeCount__);
            } else {
              result2.__views__.push({
                "size": nativeMin(n, MAX_ARRAY_LENGTH),
                "type": methodName + (result2.__dir__ < 0 ? "Right" : "")
              });
            }
            return result2;
          };
          LazyWrapper.prototype[methodName + "Right"] = function(n) {
            return this.reverse()[methodName](n).reverse();
          };
        });
        arrayEach(["filter", "map", "takeWhile"], function(methodName, index) {
          var type = index + 1, isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;
          LazyWrapper.prototype[methodName] = function(iteratee2) {
            var result2 = this.clone();
            result2.__iteratees__.push({
              "iteratee": getIteratee(iteratee2, 3),
              "type": type
            });
            result2.__filtered__ = result2.__filtered__ || isFilter;
            return result2;
          };
        });
        arrayEach(["head", "last"], function(methodName, index) {
          var takeName = "take" + (index ? "Right" : "");
          LazyWrapper.prototype[methodName] = function() {
            return this[takeName](1).value()[0];
          };
        });
        arrayEach(["initial", "tail"], function(methodName, index) {
          var dropName = "drop" + (index ? "" : "Right");
          LazyWrapper.prototype[methodName] = function() {
            return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
          };
        });
        LazyWrapper.prototype.compact = function() {
          return this.filter(identity);
        };
        LazyWrapper.prototype.find = function(predicate) {
          return this.filter(predicate).head();
        };
        LazyWrapper.prototype.findLast = function(predicate) {
          return this.reverse().find(predicate);
        };
        LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
          if (typeof path == "function") {
            return new LazyWrapper(this);
          }
          return this.map(function(value) {
            return baseInvoke(value, path, args);
          });
        });
        LazyWrapper.prototype.reject = function(predicate) {
          return this.filter(negate(getIteratee(predicate)));
        };
        LazyWrapper.prototype.slice = function(start, end) {
          start = toInteger(start);
          var result2 = this;
          if (result2.__filtered__ && (start > 0 || end < 0)) {
            return new LazyWrapper(result2);
          }
          if (start < 0) {
            result2 = result2.takeRight(-start);
          } else if (start) {
            result2 = result2.drop(start);
          }
          if (end !== undefined2) {
            end = toInteger(end);
            result2 = end < 0 ? result2.dropRight(-end) : result2.take(end - start);
          }
          return result2;
        };
        LazyWrapper.prototype.takeRightWhile = function(predicate) {
          return this.reverse().takeWhile(predicate).reverse();
        };
        LazyWrapper.prototype.toArray = function() {
          return this.take(MAX_ARRAY_LENGTH);
        };
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName), isTaker = /^(?:head|last)$/.test(methodName), lodashFunc = lodash[isTaker ? "take" + (methodName == "last" ? "Right" : "") : methodName], retUnwrapped = isTaker || /^find/.test(methodName);
          if (!lodashFunc) {
            return;
          }
          lodash.prototype[methodName] = function() {
            var value = this.__wrapped__, args = isTaker ? [1] : arguments, isLazy = value instanceof LazyWrapper, iteratee2 = args[0], useLazy = isLazy || isArray(value);
            var interceptor = function(value2) {
              var result3 = lodashFunc.apply(lodash, arrayPush([value2], args));
              return isTaker && chainAll ? result3[0] : result3;
            };
            if (useLazy && checkIteratee && typeof iteratee2 == "function" && iteratee2.length != 1) {
              isLazy = useLazy = false;
            }
            var chainAll = this.__chain__, isHybrid = !!this.__actions__.length, isUnwrapped = retUnwrapped && !chainAll, onlyLazy = isLazy && !isHybrid;
            if (!retUnwrapped && useLazy) {
              value = onlyLazy ? value : new LazyWrapper(this);
              var result2 = func.apply(value, args);
              result2.__actions__.push({ "func": thru, "args": [interceptor], "thisArg": undefined2 });
              return new LodashWrapper(result2, chainAll);
            }
            if (isUnwrapped && onlyLazy) {
              return func.apply(this, args);
            }
            result2 = this.thru(interceptor);
            return isUnwrapped ? isTaker ? result2.value()[0] : result2.value() : result2;
          };
        });
        arrayEach(["pop", "push", "shift", "sort", "splice", "unshift"], function(methodName) {
          var func = arrayProto[methodName], chainName = /^(?:push|sort|unshift)$/.test(methodName) ? "tap" : "thru", retUnwrapped = /^(?:pop|shift)$/.test(methodName);
          lodash.prototype[methodName] = function() {
            var args = arguments;
            if (retUnwrapped && !this.__chain__) {
              var value = this.value();
              return func.apply(isArray(value) ? value : [], args);
            }
            return this[chainName](function(value2) {
              return func.apply(isArray(value2) ? value2 : [], args);
            });
          };
        });
        baseForOwn(LazyWrapper.prototype, function(func, methodName) {
          var lodashFunc = lodash[methodName];
          if (lodashFunc) {
            var key = lodashFunc.name + "";
            if (!hasOwnProperty.call(realNames, key)) {
              realNames[key] = [];
            }
            realNames[key].push({ "name": methodName, "func": lodashFunc });
          }
        });
        realNames[createHybrid(undefined2, WRAP_BIND_KEY_FLAG).name] = [{
          "name": "wrapper",
          "func": undefined2
        }];
        LazyWrapper.prototype.clone = lazyClone;
        LazyWrapper.prototype.reverse = lazyReverse;
        LazyWrapper.prototype.value = lazyValue;
        lodash.prototype.at = wrapperAt;
        lodash.prototype.chain = wrapperChain;
        lodash.prototype.commit = wrapperCommit;
        lodash.prototype.next = wrapperNext;
        lodash.prototype.plant = wrapperPlant;
        lodash.prototype.reverse = wrapperReverse;
        lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;
        lodash.prototype.first = lodash.prototype.head;
        if (symIterator) {
          lodash.prototype[symIterator] = wrapperToIterator;
        }
        return lodash;
      };
      var _ = runInContext();
      if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
        root._ = _;
        define(function() {
          return _;
        });
      } else if (freeModule) {
        (freeModule.exports = _)._ = _;
        freeExports._ = _;
      } else {
        root._ = _;
      }
    }).call(exports);
  }
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS({
  "node_modules/bignumber.js/bignumber.js"(exports, module) {
    (function(globalObject) {
      "use strict";
      var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
      function clone(configObject) {
        var div, convertBase, parseNumeric, P = BigNumber2.prototype = { constructor: BigNumber2, toString: null, valueOf: null }, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
          prefix: "",
          groupSize: 3,
          secondaryGroupSize: 0,
          groupSeparator: ",",
          decimalSeparator: ".",
          fractionGroupSize: 0,
          fractionGroupSeparator: "",
          // non-breaking space
          suffix: ""
        }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz", alphabetHasNormalDecimalDigits = true;
        function BigNumber2(v, b) {
          var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
          if (!(x instanceof BigNumber2)) return new BigNumber2(v, b);
          if (b == null) {
            if (v && v._isBigNumber === true) {
              x.s = v.s;
              if (!v.c || v.e > MAX_EXP) {
                x.c = x.e = null;
              } else if (v.e < MIN_EXP) {
                x.c = [x.e = 0];
              } else {
                x.e = v.e;
                x.c = v.c.slice();
              }
              return;
            }
            if ((isNum = typeof v == "number") && v * 0 == 0) {
              x.s = 1 / v < 0 ? (v = -v, -1) : 1;
              if (v === ~~v) {
                for (e = 0, i = v; i >= 10; i /= 10, e++) ;
                if (e > MAX_EXP) {
                  x.c = x.e = null;
                } else {
                  x.e = e;
                  x.c = [v];
                }
                return;
              }
              str = String(v);
            } else {
              if (!isNumeric.test(str = String(v))) return parseNumeric(x, str, isNum);
              x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
            }
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            if ((i = str.search(/e/i)) > 0) {
              if (e < 0) e = i;
              e += +str.slice(i + 1);
              str = str.substring(0, i);
            } else if (e < 0) {
              e = str.length;
            }
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            if (b == 10 && alphabetHasNormalDecimalDigits) {
              x = new BigNumber2(v);
              return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
            }
            str = String(v);
            if (isNum = typeof v == "number") {
              if (v * 0 != 0) return parseNumeric(x, str, isNum, b);
              x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
              if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
                throw Error(tooManyDigits + v);
              }
            } else {
              x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
            }
            alphabet = ALPHABET.slice(0, b);
            e = i = 0;
            for (len = str.length; i < len; i++) {
              if (alphabet.indexOf(c = str.charAt(i)) < 0) {
                if (c == ".") {
                  if (i > e) {
                    e = len;
                    continue;
                  }
                } else if (!caseChanged) {
                  if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                    caseChanged = true;
                    i = -1;
                    e = 0;
                    continue;
                  }
                }
                return parseNumeric(x, String(v), isNum, b);
              }
            }
            isNum = false;
            str = convertBase(str, b, 10, x.s);
            if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
            else e = str.length;
          }
          for (i = 0; str.charCodeAt(i) === 48; i++) ;
          for (len = str.length; str.charCodeAt(--len) === 48; ) ;
          if (str = str.slice(i, ++len)) {
            len -= i;
            if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
              throw Error(tooManyDigits + x.s * v);
            }
            if ((e = e - i - 1) > MAX_EXP) {
              x.c = x.e = null;
            } else if (e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = e;
              x.c = [];
              i = (e + 1) % LOG_BASE;
              if (e < 0) i += LOG_BASE;
              if (i < len) {
                if (i) x.c.push(+str.slice(0, i));
                for (len -= LOG_BASE; i < len; ) {
                  x.c.push(+str.slice(i, i += LOG_BASE));
                }
                i = LOG_BASE - (str = str.slice(i)).length;
              } else {
                i -= len;
              }
              for (; i--; str += "0") ;
              x.c.push(+str);
            }
          } else {
            x.c = [x.e = 0];
          }
        }
        BigNumber2.clone = clone;
        BigNumber2.ROUND_UP = 0;
        BigNumber2.ROUND_DOWN = 1;
        BigNumber2.ROUND_CEIL = 2;
        BigNumber2.ROUND_FLOOR = 3;
        BigNumber2.ROUND_HALF_UP = 4;
        BigNumber2.ROUND_HALF_DOWN = 5;
        BigNumber2.ROUND_HALF_EVEN = 6;
        BigNumber2.ROUND_HALF_CEIL = 7;
        BigNumber2.ROUND_HALF_FLOOR = 8;
        BigNumber2.EUCLID = 9;
        BigNumber2.config = BigNumber2.set = function(obj) {
          var p, v;
          if (obj != null) {
            if (typeof obj == "object") {
              if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                DECIMAL_PLACES = v;
              }
              if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
                v = obj[p];
                intCheck(v, 0, 8, p);
                ROUNDING_MODE = v;
              }
              if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, 0, p);
                  intCheck(v[1], 0, MAX, p);
                  TO_EXP_NEG = v[0];
                  TO_EXP_POS = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
                }
              }
              if (obj.hasOwnProperty(p = "RANGE")) {
                v = obj[p];
                if (v && v.pop) {
                  intCheck(v[0], -MAX, -1, p);
                  intCheck(v[1], 1, MAX, p);
                  MIN_EXP = v[0];
                  MAX_EXP = v[1];
                } else {
                  intCheck(v, -MAX, MAX, p);
                  if (v) {
                    MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                  } else {
                    throw Error(bignumberError + p + " cannot be zero: " + v);
                  }
                }
              }
              if (obj.hasOwnProperty(p = "CRYPTO")) {
                v = obj[p];
                if (v === !!v) {
                  if (v) {
                    if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                      CRYPTO = v;
                    } else {
                      CRYPTO = !v;
                      throw Error(bignumberError + "crypto unavailable");
                    }
                  } else {
                    CRYPTO = v;
                  }
                } else {
                  throw Error(bignumberError + p + " not true or false: " + v);
                }
              }
              if (obj.hasOwnProperty(p = "MODULO_MODE")) {
                v = obj[p];
                intCheck(v, 0, 9, p);
                MODULO_MODE = v;
              }
              if (obj.hasOwnProperty(p = "POW_PRECISION")) {
                v = obj[p];
                intCheck(v, 0, MAX, p);
                POW_PRECISION = v;
              }
              if (obj.hasOwnProperty(p = "FORMAT")) {
                v = obj[p];
                if (typeof v == "object") FORMAT = v;
                else throw Error(bignumberError + p + " not an object: " + v);
              }
              if (obj.hasOwnProperty(p = "ALPHABET")) {
                v = obj[p];
                if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                  alphabetHasNormalDecimalDigits = v.slice(0, 10) == "0123456789";
                  ALPHABET = v;
                } else {
                  throw Error(bignumberError + p + " invalid: " + v);
                }
              }
            } else {
              throw Error(bignumberError + "Object expected: " + obj);
            }
          }
          return {
            DECIMAL_PLACES,
            ROUNDING_MODE,
            EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
            RANGE: [MIN_EXP, MAX_EXP],
            CRYPTO,
            MODULO_MODE,
            POW_PRECISION,
            FORMAT,
            ALPHABET
          };
        };
        BigNumber2.isBigNumber = function(v) {
          if (!v || v._isBigNumber !== true) return false;
          if (!BigNumber2.DEBUG) return true;
          var i, n, c = v.c, e = v.e, s = v.s;
          out: if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1) return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1) i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n)) break out;
                }
                if (n !== 0) return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
          throw Error(bignumberError + "Invalid BigNumber: " + v);
        };
        BigNumber2.maximum = BigNumber2.max = function() {
          return maxOrMin(arguments, -1);
        };
        BigNumber2.minimum = BigNumber2.min = function() {
          return maxOrMin(arguments, 1);
        };
        BigNumber2.random = function() {
          var pow2_53 = 9007199254740992;
          var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
            return mathfloor(Math.random() * pow2_53);
          } : function() {
            return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
          };
          return function(dp) {
            var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
            if (dp == null) dp = DECIMAL_PLACES;
            else intCheck(dp, 0, MAX);
            k = mathceil(dp / LOG_BASE);
            if (CRYPTO) {
              if (crypto.getRandomValues) {
                a = crypto.getRandomValues(new Uint32Array(k *= 2));
                for (; i < k; ) {
                  v = a[i] * 131072 + (a[i + 1] >>> 11);
                  if (v >= 9e15) {
                    b = crypto.getRandomValues(new Uint32Array(2));
                    a[i] = b[0];
                    a[i + 1] = b[1];
                  } else {
                    c.push(v % 1e14);
                    i += 2;
                  }
                }
                i = k / 2;
              } else if (crypto.randomBytes) {
                a = crypto.randomBytes(k *= 7);
                for (; i < k; ) {
                  v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                  if (v >= 9e15) {
                    crypto.randomBytes(7).copy(a, i);
                  } else {
                    c.push(v % 1e14);
                    i += 7;
                  }
                }
                i = k / 7;
              } else {
                CRYPTO = false;
                throw Error(bignumberError + "crypto unavailable");
              }
            }
            if (!CRYPTO) {
              for (; i < k; ) {
                v = random53bitInt();
                if (v < 9e15) c[i++] = v % 1e14;
              }
            }
            k = c[--i];
            dp %= LOG_BASE;
            if (k && dp) {
              v = POWS_TEN[LOG_BASE - dp];
              c[i] = mathfloor(k / v) * v;
            }
            for (; c[i] === 0; c.pop(), i--) ;
            if (i < 0) {
              c = [e = 0];
            } else {
              for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE) ;
              for (i = 1, v = c[0]; v >= 10; v /= 10, i++) ;
              if (i < LOG_BASE) e -= LOG_BASE - i;
            }
            rand.e = e;
            rand.c = c;
            return rand;
          };
        }();
        BigNumber2.sum = function() {
          var i = 1, args = arguments, sum = new BigNumber2(args[0]);
          for (; i < args.length; ) sum = sum.plus(args[i++]);
          return sum;
        };
        convertBase = /* @__PURE__ */ function() {
          var decimal = "0123456789";
          function toBaseOut(str, baseIn, baseOut, alphabet) {
            var j, arr = [0], arrL, i = 0, len = str.length;
            for (; i < len; ) {
              for (arrL = arr.length; arrL--; arr[arrL] *= baseIn) ;
              arr[0] += alphabet.indexOf(str.charAt(i++));
              for (j = 0; j < arr.length; j++) {
                if (arr[j] > baseOut - 1) {
                  if (arr[j + 1] == null) arr[j + 1] = 0;
                  arr[j + 1] += arr[j] / baseOut | 0;
                  arr[j] %= baseOut;
                }
              }
            }
            return arr.reverse();
          }
          return function(str, baseIn, baseOut, sign, callerIsToString) {
            var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
            if (i >= 0) {
              k = POW_PRECISION;
              POW_PRECISION = 0;
              str = str.replace(".", "");
              y = new BigNumber2(baseIn);
              x = y.pow(str.length - i);
              POW_PRECISION = k;
              y.c = toBaseOut(
                toFixedPoint(coeffToString(x.c), x.e, "0"),
                10,
                baseOut,
                decimal
              );
              y.e = y.c.length;
            }
            xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
            e = k = xc.length;
            for (; xc[--k] == 0; xc.pop()) ;
            if (!xc[0]) return alphabet.charAt(0);
            if (i < 0) {
              --e;
            } else {
              x.c = xc;
              x.e = e;
              x.s = sign;
              x = div(x, y, dp, rm, baseOut);
              xc = x.c;
              r = x.r;
              e = x.e;
            }
            d = e + dp + 1;
            i = xc[d];
            k = baseOut / 2;
            r = r || d < 0 || xc[d + 1] != null;
            r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
            if (d < 1 || !xc[0]) {
              str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
            } else {
              xc.length = d;
              if (r) {
                for (--baseOut; ++xc[--d] > baseOut; ) {
                  xc[d] = 0;
                  if (!d) {
                    ++e;
                    xc = [1].concat(xc);
                  }
                }
              }
              for (k = xc.length; !xc[--k]; ) ;
              for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++])) ;
              str = toFixedPoint(str, e, alphabet.charAt(0));
            }
            return str;
          };
        }();
        div = /* @__PURE__ */ function() {
          function multiply(x, k, base) {
            var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
            for (x = x.slice(); i--; ) {
              xlo = x[i] % SQRT_BASE;
              xhi = x[i] / SQRT_BASE | 0;
              m = khi * xlo + xhi * klo;
              temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
              carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
              x[i] = temp % base;
            }
            if (carry) x = [carry].concat(x);
            return x;
          }
          function compare2(a, b, aL, bL) {
            var i, cmp;
            if (aL != bL) {
              cmp = aL > bL ? 1 : -1;
            } else {
              for (i = cmp = 0; i < aL; i++) {
                if (a[i] != b[i]) {
                  cmp = a[i] > b[i] ? 1 : -1;
                  break;
                }
              }
            }
            return cmp;
          }
          function subtract(a, b, aL, base) {
            var i = 0;
            for (; aL--; ) {
              a[aL] -= i;
              i = a[aL] < b[aL] ? 1 : 0;
              a[aL] = i * base + a[aL] - b[aL];
            }
            for (; !a[0] && a.length > 1; a.splice(0, 1)) ;
          }
          return function(x, y, dp, rm, base) {
            var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
            if (!xc || !xc[0] || !yc || !yc[0]) {
              return new BigNumber2(
                // Return NaN if either NaN, or both Infinity or 0.
                !x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : (
                  // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                  xc && xc[0] == 0 || !yc ? s * 0 : s / 0
                )
              );
            }
            q = new BigNumber2(s);
            qc = q.c = [];
            e = x.e - y.e;
            s = dp + e + 1;
            if (!base) {
              base = BASE;
              e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
              s = s / LOG_BASE | 0;
            }
            for (i = 0; yc[i] == (xc[i] || 0); i++) ;
            if (yc[i] > (xc[i] || 0)) e--;
            if (s < 0) {
              qc.push(1);
              more = true;
            } else {
              xL = xc.length;
              yL = yc.length;
              i = 0;
              s += 2;
              n = mathfloor(base / (yc[0] + 1));
              if (n > 1) {
                yc = multiply(yc, n, base);
                xc = multiply(xc, n, base);
                yL = yc.length;
                xL = xc.length;
              }
              xi = yL;
              rem = xc.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; rem[remL++] = 0) ;
              yz = yc.slice();
              yz = [0].concat(yz);
              yc0 = yc[0];
              if (yc[1] >= base / 2) yc0++;
              do {
                n = 0;
                cmp = compare2(yc, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  n = mathfloor(rem0 / yc0);
                  if (n > 1) {
                    if (n >= base) n = base - 1;
                    prod = multiply(yc, n, base);
                    prodL = prod.length;
                    remL = rem.length;
                    while (compare2(prod, rem, prodL, remL) == 1) {
                      n--;
                      subtract(prod, yL < prodL ? yz : yc, prodL, base);
                      prodL = prod.length;
                      cmp = 1;
                    }
                  } else {
                    if (n == 0) {
                      cmp = n = 1;
                    }
                    prod = yc.slice();
                    prodL = prod.length;
                  }
                  if (prodL < remL) prod = [0].concat(prod);
                  subtract(rem, prod, remL, base);
                  remL = rem.length;
                  if (cmp == -1) {
                    while (compare2(yc, rem, yL, remL) < 1) {
                      n++;
                      subtract(rem, yL < remL ? yz : yc, remL, base);
                      remL = rem.length;
                    }
                  }
                } else if (cmp === 0) {
                  n++;
                  rem = [0];
                }
                qc[i++] = n;
                if (rem[0]) {
                  rem[remL++] = xc[xi] || 0;
                } else {
                  rem = [xc[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] != null) && s--);
              more = rem[0] != null;
              if (!qc[0]) qc.splice(0, 1);
            }
            if (base == BASE) {
              for (i = 1, s = qc[0]; s >= 10; s /= 10, i++) ;
              round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
            } else {
              q.e = e;
              q.r = +more;
            }
            return q;
          };
        }();
        function format(n, i, rm, id) {
          var c0, e, ne, len, str;
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          if (!n.c) return n.toString();
          c0 = n.c[0];
          ne = n.e;
          if (i == null) {
            str = coeffToString(n.c);
            str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
          } else {
            n = round(new BigNumber2(n), i, rm);
            e = n.e;
            str = coeffToString(n.c);
            len = str.length;
            if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
              for (; len < i; str += "0", len++) ;
              str = toExponential(str, e);
            } else {
              i -= ne;
              str = toFixedPoint(str, e, "0");
              if (e + 1 > len) {
                if (--i > 0) for (str += "."; i--; str += "0") ;
              } else {
                i += e - len;
                if (i > 0) {
                  if (e + 1 == len) str += ".";
                  for (; i--; str += "0") ;
                }
              }
            }
          }
          return n.s < 0 && c0 ? "-" + str : str;
        }
        function maxOrMin(args, n) {
          var k, y, i = 1, x = new BigNumber2(args[0]);
          for (; i < args.length; i++) {
            y = new BigNumber2(args[i]);
            if (!y.s || (k = compare(x, y)) === n || k === 0 && x.s === n) {
              x = y;
            }
          }
          return x;
        }
        function normalise(n, c, e) {
          var i = 1, j = c.length;
          for (; !c[--j]; c.pop()) ;
          for (j = c[0]; j >= 10; j /= 10, i++) ;
          if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
            n.c = n.e = null;
          } else if (e < MIN_EXP) {
            n.c = [n.e = 0];
          } else {
            n.e = e;
            n.c = c;
          }
          return n;
        }
        parseNumeric = /* @__PURE__ */ function() {
          var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
          return function(x, str, isNum, b) {
            var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
            if (isInfinityOrNaN.test(s)) {
              x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
            } else {
              if (!isNum) {
                s = s.replace(basePrefix, function(m, p1, p2) {
                  base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                  return !b || b == base ? p1 : m;
                });
                if (b) {
                  base = b;
                  s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
                }
                if (str != s) return new BigNumber2(s, base);
              }
              if (BigNumber2.DEBUG) {
                throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
              }
              x.s = null;
            }
            x.c = x.e = null;
          };
        }();
        function round(x, sd, rm, r) {
          var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
          if (xc) {
            out: {
              for (d = 1, k = xc[0]; k >= 10; k /= 10, d++) ;
              i = sd - d;
              if (i < 0) {
                i += LOG_BASE;
                j = sd;
                n = xc[ni = 0];
                rd = mathfloor(n / pows10[d - j - 1] % 10);
              } else {
                ni = mathceil((i + 1) / LOG_BASE);
                if (ni >= xc.length) {
                  if (r) {
                    for (; xc.length <= ni; xc.push(0)) ;
                    n = rd = 0;
                    d = 1;
                    i %= LOG_BASE;
                    j = i - LOG_BASE + 1;
                  } else {
                    break out;
                  }
                } else {
                  n = k = xc[ni];
                  for (d = 1; k >= 10; k /= 10, d++) ;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + d;
                  rd = j < 0 ? 0 : mathfloor(n / pows10[d - j - 1] % 10);
                }
              }
              r = r || sd < 0 || // Are there any non-zero digits after the rounding digit?
              // The expression  n % pows10[d - j - 1]  returns all digits of n to the right
              // of the digit at j, e.g. if n is 908714 and j is 2, the expression gives 714.
              xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
              r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
              (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
              if (sd < 1 || !xc[0]) {
                xc.length = 0;
                if (r) {
                  sd -= x.e + 1;
                  xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                  x.e = -sd || 0;
                } else {
                  xc[0] = x.e = 0;
                }
                return x;
              }
              if (i == 0) {
                xc.length = ni;
                k = 1;
                ni--;
              } else {
                xc.length = ni + 1;
                k = pows10[LOG_BASE - i];
                xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
              }
              if (r) {
                for (; ; ) {
                  if (ni == 0) {
                    for (i = 1, j = xc[0]; j >= 10; j /= 10, i++) ;
                    j = xc[0] += k;
                    for (k = 1; j >= 10; j /= 10, k++) ;
                    if (i != k) {
                      x.e++;
                      if (xc[0] == BASE) xc[0] = 1;
                    }
                    break;
                  } else {
                    xc[ni] += k;
                    if (xc[ni] != BASE) break;
                    xc[ni--] = 0;
                    k = 1;
                  }
                }
              }
              for (i = xc.length; xc[--i] === 0; xc.pop()) ;
            }
            if (x.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (x.e < MIN_EXP) {
              x.c = [x.e = 0];
            }
          }
          return x;
        }
        function valueOf(n) {
          var str, e = n.e;
          if (e === null) return n.toString();
          str = coeffToString(n.c);
          str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
          return n.s < 0 ? "-" + str : str;
        }
        P.absoluteValue = P.abs = function() {
          var x = new BigNumber2(this);
          if (x.s < 0) x.s = 1;
          return x;
        };
        P.comparedTo = function(y, b) {
          return compare(this, new BigNumber2(y, b));
        };
        P.decimalPlaces = P.dp = function(dp, rm) {
          var c, n, v, x = this;
          if (dp != null) {
            intCheck(dp, 0, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), dp + x.e + 1, rm);
          }
          if (!(c = x.c)) return null;
          n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
          if (v = c[v]) for (; v % 10 == 0; v /= 10, n--) ;
          if (n < 0) n = 0;
          return n;
        };
        P.dividedBy = P.div = function(y, b) {
          return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
        };
        P.dividedToIntegerBy = P.idiv = function(y, b) {
          return div(this, new BigNumber2(y, b), 0, 1);
        };
        P.exponentiatedBy = P.pow = function(n, m) {
          var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
          n = new BigNumber2(n);
          if (n.c && !n.isInteger()) {
            throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
          }
          if (m != null) m = new BigNumber2(m);
          nIsBig = n.e > 14;
          if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
            y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? n.s * (2 - isOdd(n)) : +valueOf(n)));
            return m ? y.mod(m) : y;
          }
          nIsNeg = n.s < 0;
          if (m) {
            if (m.c ? !m.c[0] : !m.s) return new BigNumber2(NaN);
            isModExp = !nIsNeg && x.isInteger() && m.isInteger();
            if (isModExp) x = x.mod(m);
          } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
            k = x.s < 0 && isOdd(n) ? -0 : 0;
            if (x.e > -1) k = 1 / k;
            return new BigNumber2(nIsNeg ? 1 / k : k);
          } else if (POW_PRECISION) {
            k = mathceil(POW_PRECISION / LOG_BASE + 2);
          }
          if (nIsBig) {
            half = new BigNumber2(0.5);
            if (nIsNeg) n.s = 1;
            nIsOdd = isOdd(n);
          } else {
            i = Math.abs(+valueOf(n));
            nIsOdd = i % 2;
          }
          y = new BigNumber2(ONE);
          for (; ; ) {
            if (nIsOdd) {
              y = y.times(x);
              if (!y.c) break;
              if (k) {
                if (y.c.length > k) y.c.length = k;
              } else if (isModExp) {
                y = y.mod(m);
              }
            }
            if (i) {
              i = mathfloor(i / 2);
              if (i === 0) break;
              nIsOdd = i % 2;
            } else {
              n = n.times(half);
              round(n, n.e + 1, 1);
              if (n.e > 14) {
                nIsOdd = isOdd(n);
              } else {
                i = +valueOf(n);
                if (i === 0) break;
                nIsOdd = i % 2;
              }
            }
            x = x.times(x);
            if (k) {
              if (x.c && x.c.length > k) x.c.length = k;
            } else if (isModExp) {
              x = x.mod(m);
            }
          }
          if (isModExp) return y;
          if (nIsNeg) y = ONE.div(y);
          return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
        };
        P.integerValue = function(rm) {
          var n = new BigNumber2(this);
          if (rm == null) rm = ROUNDING_MODE;
          else intCheck(rm, 0, 8);
          return round(n, n.e + 1, rm);
        };
        P.isEqualTo = P.eq = function(y, b) {
          return compare(this, new BigNumber2(y, b)) === 0;
        };
        P.isFinite = function() {
          return !!this.c;
        };
        P.isGreaterThan = P.gt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) > 0;
        };
        P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
        };
        P.isInteger = function() {
          return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
        };
        P.isLessThan = P.lt = function(y, b) {
          return compare(this, new BigNumber2(y, b)) < 0;
        };
        P.isLessThanOrEqualTo = P.lte = function(y, b) {
          return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
        };
        P.isNaN = function() {
          return !this.s;
        };
        P.isNegative = function() {
          return this.s < 0;
        };
        P.isPositive = function() {
          return this.s > 0;
        };
        P.isZero = function() {
          return !!this.c && this.c[0] == 0;
        };
        P.minus = function(y, b) {
          var i, j, t, xLTy, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.plus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
            if (!xc[0] || !yc[0]) {
              return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : (
                // IEEE 754 (2008) 6.3: n - n = -0 when rounding to -Infinity
                ROUNDING_MODE == 3 ? -0 : 0
              ));
            }
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (xLTy = a < 0) {
              a = -a;
              t = xc;
            } else {
              ye = xe;
              t = yc;
            }
            t.reverse();
            for (b = a; b--; t.push(0)) ;
            t.reverse();
          } else {
            j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
            for (a = b = 0; b < j; b++) {
              if (xc[b] != yc[b]) {
                xLTy = xc[b] < yc[b];
                break;
              }
            }
          }
          if (xLTy) {
            t = xc;
            xc = yc;
            yc = t;
            y.s = -y.s;
          }
          b = (j = yc.length) - (i = xc.length);
          if (b > 0) for (; b--; xc[i++] = 0) ;
          b = BASE - 1;
          for (; j > a; ) {
            if (xc[--j] < yc[j]) {
              for (i = j; i && !xc[--i]; xc[i] = b) ;
              --xc[i];
              xc[j] += BASE;
            }
            xc[j] -= yc[j];
          }
          for (; xc[0] == 0; xc.splice(0, 1), --ye) ;
          if (!xc[0]) {
            y.s = ROUNDING_MODE == 3 ? -1 : 1;
            y.c = [y.e = 0];
            return y;
          }
          return normalise(y, xc, ye);
        };
        P.modulo = P.mod = function(y, b) {
          var q, s, x = this;
          y = new BigNumber2(y, b);
          if (!x.c || !y.s || y.c && !y.c[0]) {
            return new BigNumber2(NaN);
          } else if (!y.c || x.c && !x.c[0]) {
            return new BigNumber2(x);
          }
          if (MODULO_MODE == 9) {
            s = y.s;
            y.s = 1;
            q = div(x, y, 0, 3);
            y.s = s;
            q.s *= s;
          } else {
            q = div(x, y, 0, MODULO_MODE);
          }
          y = x.minus(q.times(y));
          if (!y.c[0] && MODULO_MODE == 1) y.s = x.s;
          return y;
        };
        P.multipliedBy = P.times = function(y, b) {
          var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
          if (!xc || !yc || !xc[0] || !yc[0]) {
            if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
              y.c = y.e = y.s = null;
            } else {
              y.s *= x.s;
              if (!xc || !yc) {
                y.c = y.e = null;
              } else {
                y.c = [0];
                y.e = 0;
              }
            }
            return y;
          }
          e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
          y.s *= x.s;
          xcL = xc.length;
          ycL = yc.length;
          if (xcL < ycL) {
            zc = xc;
            xc = yc;
            yc = zc;
            i = xcL;
            xcL = ycL;
            ycL = i;
          }
          for (i = xcL + ycL, zc = []; i--; zc.push(0)) ;
          base = BASE;
          sqrtBase = SQRT_BASE;
          for (i = ycL; --i >= 0; ) {
            c = 0;
            ylo = yc[i] % sqrtBase;
            yhi = yc[i] / sqrtBase | 0;
            for (k = xcL, j = i + k; j > i; ) {
              xlo = xc[--k] % sqrtBase;
              xhi = xc[k] / sqrtBase | 0;
              m = yhi * xlo + xhi * ylo;
              xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
              c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
              zc[j--] = xlo % base;
            }
            zc[j] = c;
          }
          if (c) {
            ++e;
          } else {
            zc.splice(0, 1);
          }
          return normalise(y, zc, e);
        };
        P.negated = function() {
          var x = new BigNumber2(this);
          x.s = -x.s || null;
          return x;
        };
        P.plus = function(y, b) {
          var t, x = this, a = x.s;
          y = new BigNumber2(y, b);
          b = y.s;
          if (!a || !b) return new BigNumber2(NaN);
          if (a != b) {
            y.s = -b;
            return x.minus(y);
          }
          var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
          if (!xe || !ye) {
            if (!xc || !yc) return new BigNumber2(a / 0);
            if (!xc[0] || !yc[0]) return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
          }
          xe = bitFloor(xe);
          ye = bitFloor(ye);
          xc = xc.slice();
          if (a = xe - ye) {
            if (a > 0) {
              ye = xe;
              t = yc;
            } else {
              a = -a;
              t = xc;
            }
            t.reverse();
            for (; a--; t.push(0)) ;
            t.reverse();
          }
          a = xc.length;
          b = yc.length;
          if (a - b < 0) {
            t = yc;
            yc = xc;
            xc = t;
            b = a;
          }
          for (a = 0; b; ) {
            a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
            xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
          }
          if (a) {
            xc = [a].concat(xc);
            ++ye;
          }
          return normalise(y, xc, ye);
        };
        P.precision = P.sd = function(sd, rm) {
          var c, n, v, x = this;
          if (sd != null && sd !== !!sd) {
            intCheck(sd, 1, MAX);
            if (rm == null) rm = ROUNDING_MODE;
            else intCheck(rm, 0, 8);
            return round(new BigNumber2(x), sd, rm);
          }
          if (!(c = x.c)) return null;
          v = c.length - 1;
          n = v * LOG_BASE + 1;
          if (v = c[v]) {
            for (; v % 10 == 0; v /= 10, n--) ;
            for (v = c[0]; v >= 10; v /= 10, n++) ;
          }
          if (sd && x.e + 1 > n) n = x.e + 1;
          return n;
        };
        P.shiftedBy = function(k) {
          intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
          return this.times("1e" + k);
        };
        P.squareRoot = P.sqrt = function() {
          var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
          if (s !== 1 || !c || !c[0]) {
            return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
          }
          s = Math.sqrt(+valueOf(x));
          if (s == 0 || s == 1 / 0) {
            n = coeffToString(c);
            if ((n.length + e) % 2 == 0) n += "0";
            s = Math.sqrt(+n);
            e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
            if (s == 1 / 0) {
              n = "5e" + e;
            } else {
              n = s.toExponential();
              n = n.slice(0, n.indexOf("e") + 1) + e;
            }
            r = new BigNumber2(n);
          } else {
            r = new BigNumber2(s + "");
          }
          if (r.c[0]) {
            e = r.e;
            s = e + dp;
            if (s < 3) s = 0;
            for (; ; ) {
              t = r;
              r = half.times(t.plus(div(x, t, dp, 1)));
              if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
                if (r.e < e) --s;
                n = n.slice(s - 3, s + 1);
                if (n == "9999" || !rep && n == "4999") {
                  if (!rep) {
                    round(t, t.e + DECIMAL_PLACES + 2, 0);
                    if (t.times(t).eq(x)) {
                      r = t;
                      break;
                    }
                  }
                  dp += 4;
                  s += 4;
                  rep = 1;
                } else {
                  if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                    round(r, r.e + DECIMAL_PLACES + 2, 1);
                    m = !r.times(r).eq(x);
                  }
                  break;
                }
              }
            }
          }
          return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
        };
        P.toExponential = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp++;
          }
          return format(this, dp, rm, 1);
        };
        P.toFixed = function(dp, rm) {
          if (dp != null) {
            intCheck(dp, 0, MAX);
            dp = dp + this.e + 1;
          }
          return format(this, dp, rm);
        };
        P.toFormat = function(dp, rm, format2) {
          var str, x = this;
          if (format2 == null) {
            if (dp != null && rm && typeof rm == "object") {
              format2 = rm;
              rm = null;
            } else if (dp && typeof dp == "object") {
              format2 = dp;
              dp = rm = null;
            } else {
              format2 = FORMAT;
            }
          } else if (typeof format2 != "object") {
            throw Error(bignumberError + "Argument not an object: " + format2);
          }
          str = x.toFixed(dp, rm);
          if (x.c) {
            var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
            if (g2) {
              i = g1;
              g1 = g2;
              g2 = i;
              len -= i;
            }
            if (g1 > 0 && len > 0) {
              i = len % g1 || g1;
              intPart = intDigits.substr(0, i);
              for (; i < len; i += g1) intPart += groupSeparator + intDigits.substr(i, g1);
              if (g2 > 0) intPart += groupSeparator + intDigits.slice(i);
              if (isNeg) intPart = "-" + intPart;
            }
            str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(
              new RegExp("\\d{" + g2 + "}\\B", "g"),
              "$&" + (format2.fractionGroupSeparator || "")
            ) : fractionPart) : intPart;
          }
          return (format2.prefix || "") + str + (format2.suffix || "");
        };
        P.toFraction = function(md) {
          var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
          if (md != null) {
            n = new BigNumber2(md);
            if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
              throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
            }
          }
          if (!xc) return new BigNumber2(x);
          d = new BigNumber2(ONE);
          n1 = d0 = new BigNumber2(ONE);
          d1 = n0 = new BigNumber2(ONE);
          s = coeffToString(xc);
          e = d.e = s.length - x.e - 1;
          d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
          md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
          exp = MAX_EXP;
          MAX_EXP = 1 / 0;
          n = new BigNumber2(s);
          n0.c[0] = 0;
          for (; ; ) {
            q = div(n, d, 0, 1);
            d2 = d0.plus(q.times(d1));
            if (d2.comparedTo(md) == 1) break;
            d0 = d1;
            d1 = d2;
            n1 = n0.plus(q.times(d2 = n1));
            n0 = d2;
            d = n.minus(q.times(d2 = d));
            n = d2;
          }
          d2 = div(md.minus(d0), d1, 0, 1);
          n0 = n0.plus(d2.times(n1));
          d0 = d0.plus(d2.times(d1));
          n0.s = n1.s = x.s;
          e = e * 2;
          r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(
            div(n0, d0, e, ROUNDING_MODE).minus(x).abs()
          ) < 1 ? [n1, d1] : [n0, d0];
          MAX_EXP = exp;
          return r;
        };
        P.toNumber = function() {
          return +valueOf(this);
        };
        P.toPrecision = function(sd, rm) {
          if (sd != null) intCheck(sd, 1, MAX);
          return format(this, sd, rm, 2);
        };
        P.toString = function(b) {
          var str, n = this, s = n.s, e = n.e;
          if (e === null) {
            if (s) {
              str = "Infinity";
              if (s < 0) str = "-" + str;
            } else {
              str = "NaN";
            }
          } else {
            if (b == null) {
              str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
            } else if (b === 10 && alphabetHasNormalDecimalDigits) {
              n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
              str = toFixedPoint(coeffToString(n.c), n.e, "0");
            } else {
              intCheck(b, 2, ALPHABET.length, "Base");
              str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
            }
            if (s < 0 && n.c[0]) str = "-" + str;
          }
          return str;
        };
        P.valueOf = P.toJSON = function() {
          return valueOf(this);
        };
        P._isBigNumber = true;
        if (configObject != null) BigNumber2.set(configObject);
        return BigNumber2;
      }
      function bitFloor(n) {
        var i = n | 0;
        return n > 0 || n === i ? i : i - 1;
      }
      function coeffToString(a) {
        var s, z, i = 1, j = a.length, r = a[0] + "";
        for (; i < j; ) {
          s = a[i++] + "";
          z = LOG_BASE - s.length;
          for (; z--; s = "0" + s) ;
          r += s;
        }
        for (j = r.length; r.charCodeAt(--j) === 48; ) ;
        return r.slice(0, j + 1 || 1);
      }
      function compare(x, y) {
        var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
        if (!i || !j) return null;
        a = xc && !xc[0];
        b = yc && !yc[0];
        if (a || b) return a ? b ? 0 : -j : i;
        if (i != j) return i;
        a = i < 0;
        b = k == l;
        if (!xc || !yc) return b ? 0 : !xc ^ a ? 1 : -1;
        if (!b) return k > l ^ a ? 1 : -1;
        j = (k = xc.length) < (l = yc.length) ? k : l;
        for (i = 0; i < j; i++) if (xc[i] != yc[i]) return xc[i] > yc[i] ^ a ? 1 : -1;
        return k == l ? 0 : k > l ^ a ? 1 : -1;
      }
      function intCheck(n, min, max, name) {
        if (n < min || n > max || n !== mathfloor(n)) {
          throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
        }
      }
      function isOdd(n) {
        var k = n.c.length - 1;
        return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
      }
      function toExponential(str, e) {
        return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
      }
      function toFixedPoint(str, e, z) {
        var len, zs;
        if (e < 0) {
          for (zs = z + "."; ++e; zs += z) ;
          str = zs + str;
        } else {
          len = str.length;
          if (++e > len) {
            for (zs = z, e -= len; --e; zs += z) ;
            str += zs;
          } else if (e < len) {
            str = str.slice(0, e) + "." + str.slice(e);
          }
        }
        return str;
      }
      BigNumber = clone();
      BigNumber["default"] = BigNumber.BigNumber = BigNumber;
      if (typeof define == "function" && define.amd) {
        define(function() {
          return BigNumber;
        });
      } else if (typeof module != "undefined" && module.exports) {
        module.exports = BigNumber;
      } else {
        if (!globalObject) {
          globalObject = typeof self != "undefined" && self ? self : window;
        }
        globalObject.BigNumber = BigNumber;
      }
    })(exports);
  }
});

// node_modules/@thalalabs/surf/build/cjs/ensureTypes.js
var require_ensureTypes = __commonJS({
  "node_modules/@thalalabs/surf/build/cjs/ensureTypes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ensureBigInt = exports.ensureNumber = exports.ensureBoolean = void 0;
    function assertType(val, types, message) {
      if (!(types == null ? void 0 : types.includes(typeof val))) {
        throw new Error(message || `Invalid arg: ${val} type should be ${types instanceof Array ? types.join(" or ") : types}`);
      }
    }
    function ensureBoolean(val) {
      assertType(val, ["boolean", "string"]);
      if (typeof val === "boolean") {
        return val;
      }
      if (val === "true") {
        return true;
      }
      if (val === "false") {
        return false;
      }
      throw new Error("Invalid boolean string.");
    }
    exports.ensureBoolean = ensureBoolean;
    function ensureNumber(val) {
      assertType(val, ["number", "string"]);
      if (typeof val === "number") {
        return val;
      }
      const res = Number.parseInt(val, 10);
      if (Number.isNaN(res)) {
        throw new Error("Invalid number string.");
      }
      return res;
    }
    exports.ensureNumber = ensureNumber;
    function ensureBigInt(val) {
      assertType(val, ["number", "bigint", "string"]);
      return BigInt(val);
    }
    exports.ensureBigInt = ensureBigInt;
  }
});

// node_modules/@thalalabs/surf/build/cjs/core/createViewPayload.js
var require_createViewPayload = __commonJS({
  "node_modules/@thalalabs/surf/build/cjs/core/createViewPayload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createViewPayload = void 0;
    var ensureTypes_js_1 = require_ensureTypes();
    var ts_sdk_1 = require_common();
    function createViewPayload(abi, payload) {
      const fnAbi = abi.exposed_functions.filter((f) => f.name === payload.function)[0];
      const type_arguments = payload.typeArguments;
      const val_arguments = payload.functionArguments;
      if (fnAbi === void 0)
        throw new Error(`Function ${payload.function} not found in ABI`);
      if (fnAbi.params.length !== val_arguments.length)
        throw new Error(`Function ${payload.function} expects ${fnAbi.params.length} arguments, but ${payload.functionArguments.length} were provided`);
      if (fnAbi.generic_type_params.length !== type_arguments.length)
        throw new Error(`Function ${payload.function} expects ${fnAbi.generic_type_params.length} type arguments, but ${payload.functionArguments.length} were provided`);
      const args = fnAbi.params.map((type, i) => {
        const arg = payload.functionArguments[i];
        if (["u8", "u16", "u32"].includes(type)) {
          return (0, ensureTypes_js_1.ensureNumber)(arg);
        } else if (["u64", "u128", "u256"].includes(type)) {
          if (!(arg == null ? void 0 : arg.toString)) {
            throw new Error(`Expecting a bigint, but got ${arg}`);
          }
          return arg.toString();
        } else if (type.includes("vector")) {
          return encodeVector(type, arg);
        } else {
          return arg;
        }
      });
      return {
        function: `${payload.address ?? abi.address}::${abi.name}::${payload.function}`,
        functionArguments: args,
        typeArguments: payload.typeArguments,
        abi: constructViewAbiObj(fnAbi)
      };
    }
    exports.createViewPayload = createViewPayload;
    function constructViewAbiObj(abi) {
      if (!abi.is_view) {
        throw new Error(`not an view function`);
      }
      const params = [];
      for (let i = 0; i < abi.params.length; i += 1) {
        params.push((0, ts_sdk_1.parseTypeTag)(abi.params[i], { allowGenerics: true }));
      }
      const returnTypes = [];
      for (let i = 0; i < abi.return.length; i += 1) {
        returnTypes.push((0, ts_sdk_1.parseTypeTag)(abi.return[i], { allowGenerics: true }));
      }
      return {
        typeParameters: abi.generic_type_params,
        parameters: params,
        returnTypes
      };
    }
    function encodeVector(type, value) {
      const regex = /vector<([^]+)>/;
      const match = type.match(regex);
      if (!match) {
        throw new Error(`Unsupported type: ${type}`);
      }
      const innerType = match[1];
      if (!innerType) {
        throw new Error(`Unsupported type: ${type}`);
      }
      if (innerType === "u8") {
        if (typeof value === "string" || value instanceof Uint8Array)
          return value;
        if (Array.isArray(value)) {
          return value;
        }
        throw new Error(`Invalid u8 value: ${value}`);
      } else if (["bool", "u16", "u32"].includes(innerType)) {
        return value;
      } else if (["u64", "u128", "u256"].includes(innerType)) {
        return value.map((v) => v.toString());
      } else {
        return value;
      }
    }
  }
});

// node_modules/@thalalabs/surf/build/cjs/core/createEntryPayload.js
var require_createEntryPayload = __commonJS({
  "node_modules/@thalalabs/surf/build/cjs/core/createEntryPayload.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEntryPayload = void 0;
    function createEntryPayload(abi, payload) {
      const fnAbi = abi.exposed_functions.filter((f) => f.name === payload.function)[0];
      if (fnAbi === void 0)
        throw new Error(`Function ${payload.function} not found in ABI`);
      const typeArguments = payload.typeArguments;
      const valArguments = payload.functionArguments;
      const abiArgs = fnAbi.params[0] === "&signer" ? fnAbi.params.slice(1) : fnAbi.params;
      if (fnAbi === void 0)
        throw new Error(`Function ${payload.function} not found in ABI`);
      if (abiArgs.length !== valArguments.length)
        throw new Error(`Function ${payload.function} expects ${fnAbi.params.length} arguments, but ${payload.functionArguments.length} were provided`);
      if (fnAbi.generic_type_params.length !== typeArguments.length)
        throw new Error(`Function ${payload.function} expects ${fnAbi.generic_type_params.length} type arguments, but ${payload.typeArguments.length} were provided`);
      return {
        typeArguments: payload.typeArguments,
        functionArguments: payload.functionArguments,
        function: `${payload.address ?? abi.address}::${abi.name}::${payload.function}`
      };
    }
    exports.createEntryPayload = createEntryPayload;
  }
});

// node_modules/@thalalabs/surf/build/cjs/core/Client.js
var require_Client = __commonJS({
  "node_modules/@thalalabs/surf/build/cjs/core/Client.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Client = exports.createSurfClient = void 0;
    var createViewPayload_js_1 = require_createViewPayload();
    var createEntryPayload_js_1 = require_createEntryPayload();
    function createSurfClient(aptosClient) {
      return new Client(aptosClient);
    }
    exports.createSurfClient = createSurfClient;
    var Client = class {
      constructor(client) {
        Object.defineProperty(this, "client", {
          enumerable: true,
          configurable: true,
          writable: true,
          value: void 0
        });
        this.client = client;
      }
      async view(args) {
        return await this.client.view(args);
      }
      async submitTransaction(args) {
        const transaction = await this.client.transaction.build.simple({
          sender: args.signer.accountAddress.toString(),
          data: args.payload
        });
        const transactionRes = await this.client.transaction.signAndSubmitTransaction({
          signer: args.signer,
          transaction
        });
        return await this.client.waitForTransaction({
          transactionHash: transactionRes.hash,
          options: args.options ?? {}
        });
      }
      async simulateTransaction(args) {
        const transaction = await this.client.transaction.build.simple({
          sender: args.sender,
          data: args.payload
        });
        return (await this.client.transaction.simulate.simple({
          signerPublicKey: args.publicKey,
          transaction
        }))[0];
      }
      async fetchABI(address, moduleName) {
        return (await this.client.getAccountModule({
          accountAddress: address,
          moduleName
        })).abi;
      }
      useABI(abi, address) {
        return {
          view: new Proxy({}, {
            get: (_, prop) => {
              const functionName = prop.toString();
              return (...args) => {
                const payload = (0, createViewPayload_js_1.createViewPayload)(abi, {
                  address: address ?? abi.address,
                  function: functionName,
                  typeArguments: args[0].typeArguments,
                  functionArguments: args[0].functionArguments
                });
                return this.view({
                  payload,
                  options: {
                    ledgerVersion: args[0].ledgerVersion
                  }
                });
              };
            }
          }),
          entry: new Proxy({}, {
            get: (_, prop) => {
              const functionName = prop.toString();
              return (...args) => {
                const payload = (0, createEntryPayload_js_1.createEntryPayload)(abi, {
                  address: address ?? abi.address,
                  function: functionName,
                  typeArguments: args[0].typeArguments,
                  functionArguments: args[0].functionArguments
                });
                const account = args[0].account;
                return args[0].isSimulation ? this.simulateTransaction({
                  publicKey: account.publicKey,
                  sender: account.accountAddress.toString(),
                  payload
                }) : this.submitTransaction({
                  signer: args[0].account,
                  payload
                });
              };
            }
          }),
          resource: new Proxy({}, {
            get: (_, prop) => {
              let structName = prop.toString();
              return (...args) => {
                if (args[0].typeArguments.length !== 0) {
                  structName += `<${args[0].typeArguments.join(",")}>`;
                }
                const account = args[0].account;
                return this.client.getAccountResource({
                  accountAddress: account,
                  resourceType: `${address ?? abi.address}::${abi.name}::${structName}`,
                  options: {
                    ledgerVersion: args[0].ledgerVersion
                  }
                });
              };
            }
          })
        };
      }
    };
    exports.Client = Client;
  }
});

// node_modules/@thalalabs/surf/build/cjs/core/index.js
var require_core = __commonJS({
  "node_modules/@thalalabs/surf/build/cjs/core/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createEntryPayload = exports.createViewPayload = exports.createSurfClient = exports.MoveTsClient = void 0;
    var Client_js_1 = require_Client();
    Object.defineProperty(exports, "MoveTsClient", { enumerable: true, get: function() {
      return Client_js_1.Client;
    } });
    Object.defineProperty(exports, "createSurfClient", { enumerable: true, get: function() {
      return Client_js_1.createSurfClient;
    } });
    var createViewPayload_js_1 = require_createViewPayload();
    Object.defineProperty(exports, "createViewPayload", { enumerable: true, get: function() {
      return createViewPayload_js_1.createViewPayload;
    } });
    var createEntryPayload_js_1 = require_createEntryPayload();
    Object.defineProperty(exports, "createEntryPayload", { enumerable: true, get: function() {
      return createEntryPayload_js_1.createEntryPayload;
    } });
  }
});

// node_modules/@thalalabs/surf/build/cjs/index.js
var require_cjs2 = __commonJS({
  "node_modules/@thalalabs/surf/build/cjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSurfClient = exports.createEntryPayload = exports.createViewPayload = void 0;
    var index_js_1 = require_core();
    Object.defineProperty(exports, "createViewPayload", { enumerable: true, get: function() {
      return index_js_1.createViewPayload;
    } });
    Object.defineProperty(exports, "createEntryPayload", { enumerable: true, get: function() {
      return index_js_1.createEntryPayload;
    } });
    Object.defineProperty(exports, "createSurfClient", { enumerable: true, get: function() {
      return index_js_1.createSurfClient;
    } });
  }
});

// node_modules/@thalalabs/router-sdk/dist/index.js
var require_dist2 = __commonJS({
  "node_modules/@thalalabs/router-sdk/dist/index.js"(exports, module) {
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __defProps = Object.defineProperties;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getOwnPropSymbols = Object.getOwnPropertySymbols;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __propIsEnum = Object.prototype.propertyIsEnumerable;
    var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
    var __spreadValues = (a, b) => {
      for (var prop in b || (b = {}))
        if (__hasOwnProp.call(b, prop))
          __defNormalProp(a, prop, b[prop]);
      if (__getOwnPropSymbols)
        for (var prop of __getOwnPropSymbols(b)) {
          if (__propIsEnum.call(b, prop))
            __defNormalProp(a, prop, b[prop]);
        }
      return a;
    };
    var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
    var __export = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __async = (__this, __arguments, generator) => {
      return new Promise((resolve, reject) => {
        var fulfilled = (value) => {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        };
        var rejected = (value) => {
          try {
            step(generator.throw(value));
          } catch (e) {
            reject(e);
          }
        };
        var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
        step((generator = generator.apply(__this, __arguments)).next());
      });
    };
    var src_exports = {};
    __export(src_exports, {
      PoolDataClient: () => PoolDataClient,
      ThalaswapRouter: () => ThalaswapRouter
    });
    module.exports = __toCommonJS(src_exports);
    var import_thalaswap_math = require_dist();
    function calcOutGivenIn(amountIn, pool, fromIndex, toIndex) {
      const { poolType, balances, swapFee, weights, amp } = pool;
      if (poolType === "Stable") {
        return (0, import_thalaswap_math.calcOutGivenInStable)(
          amountIn,
          fromIndex,
          toIndex,
          balances,
          amp,
          swapFee
        );
      } else if (poolType === "Weighted") {
        const weightFrom = weights[fromIndex];
        const weightTo = weights[toIndex];
        return (0, import_thalaswap_math.calcOutGivenInWeighted)(
          balances[fromIndex],
          weightFrom,
          balances[toIndex],
          weightTo,
          amountIn,
          swapFee
        );
      } else {
        throw new Error("Invalid pool type");
      }
    }
    function calcInGivenOut(amountOut, pool, fromIndex, toIndex) {
      const { poolType, balances, swapFee, weights, amp } = pool;
      if (balances[toIndex] <= amountOut) {
        throw new Error("Insufficient balance");
      }
      if (poolType === "Stable") {
        return (0, import_thalaswap_math.calcInGivenOutStable)(
          amountOut,
          fromIndex,
          toIndex,
          balances,
          amp,
          swapFee
        );
      } else if (poolType === "Weighted") {
        return (0, import_thalaswap_math.calcInGivenOutWeighted)(
          balances[fromIndex],
          weights[fromIndex],
          balances[toIndex],
          weights[toIndex],
          amountOut,
          swapFee
        );
      } else {
        throw new Error("Invalid pool type");
      }
    }
    function calcPriceImpactPercentage(amountIn, amountOut, pool, fromIndex, toIndex) {
      const { poolType, balances, weights, amp } = pool;
      if (poolType === "Stable") {
        return (0, import_thalaswap_math.calcPriceImpactPercentageStable)(
          amountIn,
          amountOut,
          fromIndex,
          toIndex,
          balances,
          amp
        );
      } else if (poolType === "Weighted") {
        return (0, import_thalaswap_math.calcPriceImpactPercentageWeighted)(
          amountIn,
          amountOut,
          balances[fromIndex],
          balances[toIndex],
          weights[fromIndex],
          weights[toIndex]
        );
      } else {
        throw new Error("Invalid pool type");
      }
    }
    function findRouteGivenExactInput(graph, startToken, endToken, amountIn, maxHops, maxAllowedSwapPercentage) {
      const tokens = Object.keys(graph);
      const distances = {};
      const predecessors = {};
      const defaultDistance = -Infinity;
      for (const token of tokens) {
        distances[token] = {};
        predecessors[token] = {};
      }
      distances[startToken][0] = amountIn;
      for (let i = 0; i < maxHops; i++) {
        for (const [_, edges] of Object.entries(graph)) {
          for (const edge of edges) {
            const fromToken = edge.pool.coinAddresses[edge.fromIndex];
            const toToken = edge.pool.coinAddresses[edge.toIndex];
            if (fromToken === endToken || toToken === startToken)
              continue;
            if (distances[fromToken][i] === void 0)
              continue;
            if (distances[fromToken][i] / edge.pool.balances[edge.fromIndex] > maxAllowedSwapPercentage)
              continue;
            const newDistance = calcOutGivenIn(
              distances[fromToken][i],
              edge.pool,
              edge.fromIndex,
              edge.toIndex
            );
            const nextHop = i + 1;
            if (newDistance > (distances[toToken][nextHop] || defaultDistance)) {
              distances[toToken][nextHop] = newDistance;
              predecessors[toToken][nextHop] = {
                token: fromToken,
                pool: edge.pool
              };
            }
          }
        }
      }
      let maxDistance = -Infinity;
      let hops = 0;
      for (let i = 1; i <= maxHops; i++) {
        const distance = distances[endToken][i];
        if (distance && distance > maxDistance) {
          maxDistance = distance;
          hops = i;
        }
      }
      if (maxDistance === -Infinity) {
        console.error("No path found");
        return null;
      }
      const path = [];
      let currentToken = endToken;
      while (hops > 0) {
        const { token, pool } = predecessors[currentToken][hops];
        path.push({ from: token, to: currentToken, pool });
        currentToken = token;
        hops--;
      }
      path.reverse();
      let priceImpactPercentage = 0;
      let currentAmountIn = amountIn;
      for (const pathSegment of path) {
        const fromIndex = pathSegment.pool.coinAddresses.indexOf(pathSegment.from);
        const toIndex = pathSegment.pool.coinAddresses.indexOf(pathSegment.to);
        const amoutOutNoFees = calcOutGivenIn(
          currentAmountIn,
          __spreadProps(__spreadValues({}, pathSegment.pool), { swapFee: 0 }),
          fromIndex,
          toIndex
        );
        const currentPriceImpact = calcPriceImpactPercentage(
          currentAmountIn,
          amoutOutNoFees,
          pathSegment.pool,
          fromIndex,
          toIndex
        );
        if (currentPriceImpact > priceImpactPercentage) {
          priceImpactPercentage = currentPriceImpact;
        }
        currentAmountIn = amoutOutNoFees;
      }
      return {
        path,
        amountIn,
        amountOut: maxDistance,
        priceImpactPercentage,
        type: "exact_input"
      };
    }
    function findRouteGivenExactOutput(graph, startToken, endToken, amountOut, maxHops, maxAllowedSwapPercentage) {
      const tokens = Object.keys(graph);
      const distances = {};
      const predecessors = {};
      const defaultDistance = Infinity;
      for (const token of tokens) {
        distances[token] = {};
        predecessors[token] = {};
      }
      distances[endToken][0] = amountOut;
      for (let i = 0; i < maxHops; i++) {
        for (const [_, edges] of Object.entries(graph)) {
          for (const edge of edges) {
            const fromToken = edge.pool.coinAddresses[edge.fromIndex];
            const toToken = edge.pool.coinAddresses[edge.toIndex];
            if (fromToken === endToken || toToken === startToken)
              continue;
            if (distances[toToken][i] === void 0)
              continue;
            if (distances[toToken][i] / edge.pool.balances[edge.toIndex] > maxAllowedSwapPercentage)
              continue;
            try {
              const newDistance = calcInGivenOut(
                distances[toToken][i],
                edge.pool,
                edge.fromIndex,
                edge.toIndex
              );
              const nextHop = i + 1;
              if (newDistance < (distances[fromToken][nextHop] || defaultDistance)) {
                distances[fromToken][nextHop] = newDistance;
                predecessors[fromToken][nextHop] = {
                  token: toToken,
                  pool: edge.pool
                };
              }
            } catch (error) {
            }
          }
        }
      }
      let minDistance = Infinity;
      let hops = 0;
      for (let i = 1; i <= maxHops; i++) {
        const distance = distances[startToken][i];
        if (distance && distance < minDistance) {
          minDistance = distance;
          hops = i;
        }
      }
      if (minDistance === Infinity) {
        console.error("No path found");
        return null;
      }
      const path = [];
      let currentToken = startToken;
      while (hops > 0) {
        const { token, pool } = predecessors[currentToken][hops];
        path.push({ from: currentToken, to: token, pool });
        currentToken = token;
        hops--;
      }
      let priceImpactPercentage = 0;
      let currentAmountOut = amountOut;
      path.reverse();
      for (const pathSegment of path) {
        const fromIndex = pathSegment.pool.coinAddresses.indexOf(pathSegment.from);
        const toIndex = pathSegment.pool.coinAddresses.indexOf(pathSegment.to);
        const amoutInNoFees = calcInGivenOut(
          currentAmountOut,
          __spreadProps(__spreadValues({}, pathSegment.pool), { swapFee: 0 }),
          fromIndex,
          toIndex
        );
        const currentPriceImpact = calcPriceImpactPercentage(
          amoutInNoFees,
          currentAmountOut,
          pathSegment.pool,
          fromIndex,
          toIndex
        );
        if (currentPriceImpact > priceImpactPercentage) {
          priceImpactPercentage = currentPriceImpact;
        }
        currentAmountOut = amoutInNoFees;
      }
      return {
        path: path.reverse(),
        amountIn: minDistance,
        amountOut,
        priceImpactPercentage,
        type: "exact_output"
      };
    }
    var import_ts_sdk = require_common();
    var import_lodash = require_lodash();
    var import_bignumber = __toESM(require_bignumber());
    var BN_TEN = new import_bignumber.default(10);
    function scaleDown(v, decimals) {
      return new import_bignumber.default(v).dividedBy(BN_TEN.exponentiatedBy(decimals)).toNumber();
    }
    function parsePoolMetadata(poolType, resourceAddress) {
      const NULL_PATTERN = new RegExp(`${resourceAddress}::base_pool::Null`);
      const [liquidityPoolType, poolTypeArgs] = parseLiquidityPoolType(
        poolType,
        resourceAddress
      );
      const nullIndex = poolTypeArgs.slice(0, 4).findIndex((e) => NULL_PATTERN.test(e));
      const numCoins = nullIndex === -1 ? 4 : nullIndex;
      const coinAddresses = poolTypeArgs.slice(0, numCoins);
      const weights = liquidityPoolType === "Weighted" ? poolTypeArgs.slice(4, 4 + numCoins).map((weight) => parseInt(weight.match(/.*::Weight_(\d+)/)[1])) : [];
      return {
        type: poolType,
        poolType: liquidityPoolType,
        numCoins,
        coinAddresses,
        weights
      };
    }
    function parseLiquidityPoolType(poolType, resourceAddress) {
      const WEIGHTED_POOL_PATTERN = new RegExp(
        `${resourceAddress}::weighted_pool::WeightedPool<(.*)>`
      );
      const STABLE_POOL_PATTERN = new RegExp(
        `${resourceAddress}::stable_pool::StablePool<(.*)>`
      );
      const matchWeightedPool = poolType.match(WEIGHTED_POOL_PATTERN);
      if (matchWeightedPool) {
        return ["Weighted", matchWeightedPool[1].split(",").map((e) => e.trim())];
      }
      const matchStablePool = poolType.match(STABLE_POOL_PATTERN);
      if (matchStablePool) {
        return ["Stable", matchStablePool[1].split(",").map((e) => e.trim())];
      }
      throw new Error(`Invalid poolType: ${poolType}`);
    }
    var ZERO = BigInt(0);
    var ONE = BigInt(1);
    var fp64ToFloat = (a) => {
      let mask = BigInt("0xffffffff000000000000000000000000");
      if ((a & mask) != ZERO) {
        throw new Error("too large");
      }
      mask = BigInt("0x10000000000000000");
      let base = 1;
      let result = 0;
      for (let i = 0; i < 32; ++i) {
        if ((a & mask) != ZERO) {
          result += base;
        }
        base *= 2;
        mask = mask << ONE;
      }
      mask = BigInt("0x8000000000000000");
      base = 0.5;
      for (let i = 0; i < 32; ++i) {
        if ((a & mask) != ZERO) {
          result += base;
        }
        base /= 2;
        mask = mask >> ONE;
      }
      return result;
    };
    var PoolDataClient = class {
      constructor(network, fullnode, resourceAddress) {
        this.poolData = null;
        this.lastUpdated = 0;
        this.expiry = 1e4;
        this.retryLimit = 3;
        this.coins = [];
        this.resourceAddress = resourceAddress;
        this.client = new import_ts_sdk.Aptos(
          new import_ts_sdk.AptosConfig({
            network,
            fullnode
          })
        );
      }
      getPoolData() {
        return __async(this, null, function* () {
          const currentTime = Date.now();
          if (!this.poolData || currentTime - this.lastUpdated > this.expiry) {
            for (let i = 0; i < this.retryLimit; i++) {
              try {
                const resources = yield this.client.getAccountResources({
                  accountAddress: this.resourceAddress
                });
                const poolResources = resources.filter(
                  (r) => r.type.startsWith(
                    `${this.resourceAddress}::weighted_pool::WeightedPool<`
                  ) || r.type.startsWith(
                    `${this.resourceAddress}::stable_pool::StablePool<`
                  )
                );
                const allCoinAddress = (0, import_lodash.uniq)(
                  poolResources.reduce((acc, resource) => {
                    const metadata = parsePoolMetadata(
                      resource.type,
                      this.resourceAddress
                    );
                    metadata.coinAddresses.forEach((coin) => {
                      coin && acc.push(coin);
                    });
                    return acc;
                  }, [])
                );
                yield Promise.all(
                  allCoinAddress.map((address) => __async(this, null, function* () {
                    if (this.coins.find((c) => c.address === address))
                      return;
                    const coin = {
                      address,
                      decimals: (yield this.client.view({
                        payload: {
                          function: "0x1::coin::decimals",
                          functionArguments: [],
                          typeArguments: [
                            address
                          ]
                        }
                      }))[0]
                    };
                    this.coins.push(coin);
                  }))
                );
                const pools = poolResources.reduce((acc, resource) => {
                  try {
                    const metadata = parsePoolMetadata(
                      resource.type,
                      this.resourceAddress
                    );
                    const [coin0, coin1, coin2, coin3] = metadata.coinAddresses.map(
                      (addr) => this.coins.find((c) => c.address === addr)
                    );
                    acc.push({
                      type: metadata.type,
                      weights: metadata.weights.map((w) => Number(w) / 100),
                      poolType: metadata.poolType,
                      amp: resource.data.amp_factor ? Number(resource.data.amp_factor) : void 0,
                      asset0: coin0,
                      asset1: coin1,
                      asset2: coin2,
                      asset3: coin3,
                      balance0: scaleDown(
                        resource.data.asset_0.value,
                        coin0.decimals
                      ),
                      balance1: scaleDown(
                        resource.data.asset_1.value,
                        coin1.decimals
                      ),
                      balance2: coin2 ? scaleDown(resource.data.asset_2.value, coin2.decimals) : void 0,
                      balance3: coin3 ? scaleDown(resource.data.asset_3.value, coin3.decimals) : void 0,
                      swapFee: fp64ToFloat(BigInt(resource.data.swap_fee_ratio.v))
                    });
                  } catch (e) {
                    console.error("failed to add pool", resource.type, e);
                  }
                  return acc;
                }, []);
                this.poolData = {
                  pools,
                  coins: this.coins
                };
                this.lastUpdated = currentTime;
                return this.poolData;
              } catch (error) {
                console.error("Failed to get pool data:", error);
                if (i < this.retryLimit - 1) {
                  console.log("Retrying...");
                } else {
                  console.log("Failed after retrying.");
                  throw error;
                }
              }
            }
          }
          return this.poolData;
        });
      }
    };
    var import_surf = require_cjs2();
    var STABLE_POOL_SCRIPTS_ABI = {
      address: "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af",
      name: "stable_pool_scripts",
      friends: [],
      exposed_functions: [
        {
          name: "add_liquidity",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64", "u64", "u64"],
          return: []
        },
        {
          name: "remove_liquidity",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64", "u64", "u64", "u64"],
          return: []
        },
        {
          name: "swap_exact_in",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64"],
          return: []
        },
        {
          name: "swap_exact_out",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64"],
          return: []
        }
      ],
      structs: []
    };
    var WEIGHTED_POOL_SCRIPTS_ABI = {
      address: "0x48271d39d0b05bd6efca2278f22277d6fcc375504f9839fd73f74ace240861af",
      name: "weighted_pool_scripts",
      friends: [],
      exposed_functions: [
        {
          name: "add_liquidity",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: [
            "&signer",
            "u64",
            "u64",
            "u64",
            "u64",
            "u64",
            "u64",
            "u64",
            "u64"
          ],
          return: []
        },
        {
          name: "remove_liquidity",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64", "u64", "u64", "u64"],
          return: []
        },
        {
          name: "swap_exact_in",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64"],
          return: []
        },
        {
          name: "swap_exact_out",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64"],
          return: []
        }
      ],
      structs: []
    };
    var MULTIHOP_ROUTER_ABI = {
      address: "0x60955b957956d79bc80b096d3e41bad525dd400d8ce957cdeb05719ed1e4fc26",
      name: "router",
      friends: [],
      exposed_functions: [
        {
          name: "swap_exact_in_2",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64"],
          return: []
        },
        {
          name: "swap_exact_in_3",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64"],
          return: []
        },
        {
          name: "swap_exact_out_2",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64"],
          return: []
        },
        {
          name: "swap_exact_out_3",
          visibility: "public",
          is_entry: true,
          is_view: false,
          generic_type_params: [
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            },
            {
              constraints: []
            }
          ],
          params: ["&signer", "u64", "u64"],
          return: []
        }
      ],
      structs: []
    };
    var encodeWeight = (weight, resourceAddress) => {
      return `${resourceAddress}::weighted_pool::Weight_${Math.floor(weight * 100).toString()}`;
    };
    var DEFAULT_MAX_ALLOWED_SWAP_PERCENTAGE = 0.5;
    var encodePoolType = (pool, extendStableArgs, resourceAddress) => {
      const NULL_TYPE = `${resourceAddress}::base_pool::Null`;
      const NULL_4 = Array(4).fill(NULL_TYPE);
      if (pool.poolType === "Stable") {
        const typeArgs = NULL_4.map(
          (nullType, i) => i < pool.coinAddresses.length ? pool.coinAddresses[i] : nullType
        );
        return extendStableArgs ? typeArgs.concat(NULL_4) : typeArgs;
      } else {
        const typeArgsForCoins = NULL_4.map(
          (nullType, i) => i < pool.coinAddresses.length ? pool.coinAddresses[i] : nullType
        );
        const typeArgsForWeights = NULL_4.map(
          (nullType, i) => i < pool.weights.length ? encodeWeight(pool.weights[i], resourceAddress) : nullType
        );
        return typeArgsForCoins.concat(typeArgsForWeights);
      }
    };
    var calcMinReceivedValue = (expectedAmountOut, slippage) => expectedAmountOut * (1 - slippage / 100);
    var calcMaxSoldValue = (expectedAmountIn, slippage) => expectedAmountIn * (1 + slippage / 100);
    var scaleUp = (amount, decimals) => {
      return Math.floor(amount * Math.pow(10, decimals));
    };
    var ThalaswapRouter = class {
      constructor(network, fullnode, resourceAddress, multirouterAddress, options) {
        this.graph = null;
        this.coins = null;
        this.resourceAddress = resourceAddress;
        this.multirouterAddress = multirouterAddress;
        this.client = new PoolDataClient(network, fullnode, resourceAddress);
        this.options = options != null ? options : {};
      }
      setPoolDataClient(client) {
        this.client = client;
      }
      refreshData() {
        return __async(this, null, function* () {
          const poolData = yield this.client.getPoolData();
          const pools = poolData.pools;
          this.coins = poolData.coins;
          this.graph = yield this.buildGraph(pools);
        });
      }
      buildGraph(pools) {
        return __async(this, null, function* () {
          const tokens = /* @__PURE__ */ new Set();
          const graph = {};
          for (const pool of pools) {
            if (this.options.poolFilter && !this.options.poolFilter(pool)) {
              continue;
            }
            const assets = ["asset0", "asset1", "asset2", "asset3"].filter((a) => pool[a]).map((a) => pool[a]);
            const balances = ["balance0", "balance1", "balance2", "balance3"].filter((b, i) => assets[i]).map((b) => pool[b]);
            const weights = pool.poolType === "Weighted" ? pool.weights : void 0;
            const amp = pool.poolType === "Stable" ? pool.amp : void 0;
            const convertedPool = {
              coinAddresses: assets.map((a) => a.address),
              balances,
              poolType: pool.poolType,
              swapFee: pool.swapFee,
              weights,
              amp
            };
            for (let i = 0; i < assets.length; i++) {
              const token = assets[i].address;
              tokens.add(token);
              for (let j = 0; j < assets.length; j++) {
                if (i !== j) {
                  if (!graph[token])
                    graph[token] = [];
                  graph[token].push({
                    pool: convertedPool,
                    fromIndex: i,
                    toIndex: j
                  });
                }
              }
            }
          }
          return graph;
        });
      }
      getRouteGivenExactInput(startToken, endToken, amountIn, maxHops = 3) {
        return __async(this, null, function* () {
          var _a;
          yield this.refreshData();
          if (!this.graph) {
            console.error("Failed to load pools");
            return null;
          }
          return findRouteGivenExactInput(
            this.graph,
            startToken,
            endToken,
            amountIn,
            maxHops,
            (_a = this.options.maxAllowedSwapPercentage) != null ? _a : DEFAULT_MAX_ALLOWED_SWAP_PERCENTAGE
          );
        });
      }
      getRouteGivenExactOutput(startToken, endToken, amountOut, maxHops = 3) {
        return __async(this, null, function* () {
          var _a;
          yield this.refreshData();
          if (!this.graph) {
            console.error("Failed to load pools");
            return null;
          }
          return findRouteGivenExactOutput(
            this.graph,
            startToken,
            endToken,
            amountOut,
            maxHops,
            (_a = this.options.maxAllowedSwapPercentage) != null ? _a : DEFAULT_MAX_ALLOWED_SWAP_PERCENTAGE
          );
        });
      }
      // balanceCoinIn is the user's balance of input coin. If it's specified, this function will check
      // (1) for exact-in type of swap, throw an error if the user doesn't have enough balance to perform the swap.
      // (2) for exact-out type of swap, the maximum input amount is limited by the user's balance.
      encodeRoute(route, slippagePercentage, balanceCoinIn) {
        if (route.path.length === 0 || route.path.length > 3) {
          throw new Error("Invalid route");
        }
        const tokenInDecimals = this.coins.find(
          (coin) => coin.address === route.path[0].from
        ).decimals;
        const tokenOutDecimals = this.coins.find(
          (coin) => coin.address === route.path[route.path.length - 1].to
        ).decimals;
        let amountInArg;
        let amountOutArg;
        if (route.type === "exact_input") {
          if (balanceCoinIn !== void 0 && balanceCoinIn < route.amountIn) {
            throw new Error("Insufficient balance");
          }
          amountInArg = scaleUp(route.amountIn, tokenInDecimals);
          amountOutArg = scaleUp(
            calcMinReceivedValue(route.amountOut, slippagePercentage),
            tokenOutDecimals
          );
        } else {
          const maxSoldValueAfterSlippage = calcMaxSoldValue(
            route.amountIn,
            slippagePercentage
          );
          amountInArg = scaleUp(
            balanceCoinIn !== void 0 ? Math.min(balanceCoinIn, maxSoldValueAfterSlippage) : maxSoldValueAfterSlippage,
            tokenInDecimals
          );
          amountOutArg = scaleUp(route.amountOut, tokenOutDecimals);
        }
        if (route.path.length == 1) {
          const path = route.path[0];
          const functionName = route.type === "exact_input" ? "swap_exact_in" : "swap_exact_out";
          const abi = path.pool.poolType === "Stable" ? STABLE_POOL_SCRIPTS_ABI : WEIGHTED_POOL_SCRIPTS_ABI;
          const typeArgs = encodePoolType(
            path.pool,
            false,
            this.resourceAddress
          ).concat([path.from, path.to]);
          return (0, import_surf.createEntryPayload)(abi, {
            function: functionName,
            typeArguments: typeArgs,
            functionArguments: [amountInArg, amountOutArg],
            address: this.resourceAddress
          });
        } else if (route.path.length == 2) {
          const path0 = route.path[0];
          const path1 = route.path[1];
          const typeArgs = encodePoolType(path0.pool, true, this.resourceAddress).concat(encodePoolType(path1.pool, true, this.resourceAddress)).concat([path0.from, path0.to, path1.to]);
          const functionName = route.type === "exact_input" ? "swap_exact_in_2" : "swap_exact_out_2";
          return (0, import_surf.createEntryPayload)(MULTIHOP_ROUTER_ABI, {
            function: functionName,
            typeArguments: typeArgs,
            functionArguments: [amountInArg, amountOutArg],
            address: this.multirouterAddress
          });
        } else {
          const path0 = route.path[0];
          const path1 = route.path[1];
          const path2 = route.path[2];
          const typeArgs = encodePoolType(path0.pool, true, this.resourceAddress).concat(encodePoolType(path1.pool, true, this.resourceAddress)).concat(encodePoolType(path2.pool, true, this.resourceAddress)).concat([path0.from, path0.to, path1.to, path2.to]);
          const functionName = route.type === "exact_input" ? "swap_exact_in_3" : "swap_exact_out_3";
          return (0, import_surf.createEntryPayload)(MULTIHOP_ROUTER_ABI, {
            function: functionName,
            typeArguments: typeArgs,
            functionArguments: [amountInArg, amountOutArg],
            address: this.multirouterAddress
          });
        }
      }
    };
  }
});
export default require_dist2();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

lodash/lodash.js:
  (**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   *)
*/
//# sourceMappingURL=@thalalabs_router-sdk.js.map
