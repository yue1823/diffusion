import {
  require_index_browser,
  require_lib
} from "./chunk-UXO2HZ2E.js";
import {
  require_buffer,
  require_nacl_fast
} from "./chunk-4MO5LSUJ.js";
import {
  require_eventemitter3
} from "./chunk-KEMPSE3P.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/aptos/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number(n) {
      if (!Number.isSafeInteger(n) || n < 0)
        throw new Error(`Wrong positive integer: ${n}`);
    }
    exports.number = number;
    function bool(b) {
      if (typeof b !== "boolean")
        throw new Error(`Expected boolean, not ${b}`);
    }
    exports.bool = bool;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    function bytes(b, ...lengths) {
      if (!isBytes(b))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
    }
    exports.bytes = bytes;
    function hash(hash2) {
      if (typeof hash2 !== "function" || typeof hash2.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number(hash2.outputLen);
      number(hash2.blockLen);
    }
    exports.hash = hash;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert = { number, bool, bytes, hash, exists, output };
    exports.default = assert;
  }
});

// node_modules/aptos/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/aptos/node_modules/@noble/hashes/utils.js
var require_utils = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u8;
    var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u32;
    function isBytes(a) {
      return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
    }
    var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView;
    var rotr = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
    function bytesToHex(bytes) {
      if (!isBytes(bytes))
        throw new Error("Uint8Array expected");
      let hex = "";
      for (let i = 0; i < bytes.length; i++) {
        hex += hexes[bytes[i]];
      }
      return hex;
    }
    exports.bytesToHex = bytesToHex;
    var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
    function asciiToBase16(char) {
      if (char >= asciis._0 && char <= asciis._9)
        return char - asciis._0;
      if (char >= asciis._A && char <= asciis._F)
        return char - (asciis._A - 10);
      if (char >= asciis._a && char <= asciis._f)
        return char - (asciis._a - 10);
      return;
    }
    function hexToBytes(hex) {
      if (typeof hex !== "string")
        throw new Error("hex string expected, got " + typeof hex);
      const hl = hex.length;
      const al = hl / 2;
      if (hl % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + hl);
      const array = new Uint8Array(al);
      for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
        const n1 = asciiToBase16(hex.charCodeAt(hi));
        const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
        if (n1 === void 0 || n2 === void 0) {
          const char = hex[hi] + hex[hi + 1];
          throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
        }
        array[ai] = n1 * 16 + n2;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop(iters, tick, cb) {
      let ts = Date.now();
      for (let i = 0; i < iters; i++) {
        cb(i);
        const diff = Date.now() - ts;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts += diff;
      }
    }
    exports.asyncLoop = asyncLoop;
    function utf8ToBytes(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes;
    function toBytes(data) {
      if (typeof data === "string")
        data = utf8ToBytes(data);
      if (!isBytes(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes;
    function concatBytes(...arrays) {
      let sum = 0;
      for (let i = 0; i < arrays.length; i++) {
        const a = arrays[i];
        if (!isBytes(a))
          throw new Error("Uint8Array expected");
        sum += a.length;
      }
      const res = new Uint8Array(sum);
      for (let i = 0, pad = 0; i < arrays.length; i++) {
        const a = arrays[i];
        res.set(a, pad);
        pad += a.length;
      }
      return res;
    }
    exports.concatBytes = concatBytes;
    var Hash = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash;
    var toStr = {}.toString;
    function checkOpts(defaults, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults, opts);
      return merged;
    }
    exports.checkOpts = checkOpts;
    function wrapConstructor(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes;
  }
});

// node_modules/aptos/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    var HMAC = class extends utils_js_1.Hash {
      constructor(hash, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad = new Uint8Array(blockLen);
        pad.set(key.length > blockLen ? hash.create().update(key).digest() : key);
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54;
        this.iHash.update(pad);
        this.oHash = hash.create();
        for (let i = 0; i < pad.length; i++)
          pad[i] ^= 54 ^ 92;
        this.oHash.update(pad);
        pad.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to) {
        to || (to = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to = to;
        to.finished = finished;
        to.destroyed = destroyed;
        to.blockLen = blockLen;
        to.outputLen = outputLen;
        to.oHash = oHash._cloneInto(to.oHash);
        to.iHash = iHash._cloneInto(to.iHash);
        return to;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC;
    var hmac = (hash, key, message) => new HMAC(hash, key).update(message).digest();
    exports.hmac = hmac;
    exports.hmac.create = (hash, key) => new HMAC(hash, key);
  }
});

// node_modules/aptos/node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2Async = exports.pbkdf2 = void 0;
    var _assert_js_1 = require_assert();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils();
    function pbkdf2Init(hash, _password, _salt, _opts) {
      (0, _assert_js_1.hash)(hash);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c, dkLen, asyncTick } = opts;
      (0, _assert_js_1.number)(c);
      (0, _assert_js_1.number)(dkLen);
      (0, _assert_js_1.number)(asyncTick);
      if (c < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output(PRF, PRFSalt, DK, prfW, u) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u.fill(0);
      return DK;
    }
    function pbkdf2(hash, password, salt, opts) {
      const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        for (let ui = 1; ui < c; ui++) {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        }
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2 = pbkdf2;
    async function pbkdf2Async(hash, password, salt, opts) {
      const { c, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init(hash, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u = new Uint8Array(PRF.outputLen);
      for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
        const Ti = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
        Ti.set(u.subarray(0, Ti.length));
        await (0, utils_js_1.asyncLoop)(c - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u).digestInto(u);
          for (let i = 0; i < Ti.length; i++)
            Ti[i] ^= u[i];
        });
      }
      return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
    }
    exports.pbkdf2Async = pbkdf2Async;
  }
});

// node_modules/aptos/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils();
    function setBigUint64(view, byteOffset, value, isLE) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE);
      const _32n = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n & _u32_max);
      const wl = Number(value & _u32_max);
      const h = isLE ? 4 : 0;
      const l = isLE ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE);
      view.setUint32(byteOffset + l, wl, isLE);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer, view, blockLen, isLE } = this;
        let { pos } = this;
        buffer[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i = pos; i < blockLen; i++)
          buffer[i] = 0;
        setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i = 0; i < outLen; i++)
          oview.setUint32(4 * i, state[i], isLE);
      }
      digest() {
        const { buffer, outputLen } = this;
        this.digestInto(buffer);
        const res = buffer.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to) {
        to || (to = new this.constructor());
        to.set(...this.get());
        const { blockLen, buffer, length, finished, destroyed, pos } = this;
        to.length = length;
        to.pos = pos;
        to.finished = finished;
        to.destroyed = destroyed;
        if (length % blockLen)
          to.buffer.set(buffer);
        return to;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/aptos/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils();
    var Chi = (a, b, c) => a & b ^ ~a & c;
    var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
    var SHA256_K = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W = new Uint32Array(64);
    var SHA256 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B, C, D, E, F, G, H } = this;
        return [A, B, C, D, E, F, G, H];
      }
      // prettier-ignore
      set(A, B, C, D, E, F, G, H) {
        this.A = A | 0;
        this.B = B | 0;
        this.C = C | 0;
        this.D = D | 0;
        this.E = E | 0;
        this.F = F | 0;
        this.G = G | 0;
        this.H = H | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4)
          SHA256_W[i] = view.getUint32(offset, false);
        for (let i = 16; i < 64; i++) {
          const W15 = SHA256_W[i - 15];
          const W2 = SHA256_W[i - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W2, 17) ^ (0, utils_js_1.rotr)(W2, 19) ^ W2 >>> 10;
          SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
        }
        let { A, B, C, D, E, F, G, H } = this;
        for (let i = 0; i < 64; i++) {
          const sigma1 = (0, utils_js_1.rotr)(E, 6) ^ (0, utils_js_1.rotr)(E, 11) ^ (0, utils_js_1.rotr)(E, 25);
          const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T2 = sigma0 + Maj(A, B, C) | 0;
          H = G;
          G = F;
          F = E;
          E = D + T1 | 0;
          D = C;
          C = B;
          B = A;
          A = T1 + T2 | 0;
        }
        A = A + this.A | 0;
        B = B + this.B | 0;
        C = C + this.C | 0;
        D = D + this.D | 0;
        E = E + this.E | 0;
        F = F + this.F | 0;
        G = G + this.G | 0;
        H = H + this.H | 0;
        this.set(A, B, C, D, E, F, G, H);
      }
      roundClean() {
        SHA256_W.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA224 = class extends SHA256 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA256());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA224());
  }
});

// node_modules/aptos/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK64 = BigInt(2 ** 32 - 1);
    var _32n = BigInt(32);
    function fromBig(n, le = false) {
      if (le)
        return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
      return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
    }
    exports.fromBig = fromBig;
    function split(lst, le = false) {
      let Ah = new Uint32Array(lst.length);
      let Al = new Uint32Array(lst.length);
      for (let i = 0; i < lst.length; i++) {
        const { h, l } = fromBig(lst[i], le);
        [Ah[i], Al[i]] = [h, l];
      }
      return [Ah, Al];
    }
    exports.split = split;
    var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
    exports.toBig = toBig;
    var shrSH = (h, _l, s) => h >>> s;
    exports.shrSH = shrSH;
    var shrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.shrSL = shrSL;
    var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
    exports.rotrSH = rotrSH;
    var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
    exports.rotrSL = rotrSL;
    var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
    exports.rotrBH = rotrBH;
    var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
    exports.rotrBL = rotrBL;
    var rotr32H = (_h, l) => l;
    exports.rotr32H = rotr32H;
    var rotr32L = (h, _l) => h;
    exports.rotr32L = rotr32L;
    var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
    exports.rotlSH = rotlSH;
    var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
    exports.rotlSL = rotlSL;
    var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
    exports.rotlBH = rotlBH;
    var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
    exports.rotlBL = rotlBL;
    function add(Ah, Al, Bh, Bl) {
      const l = (Al >>> 0) + (Bl >>> 0);
      return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
    }
    exports.add = add;
    var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
    exports.add3L = add3L;
    var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H;
    var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
    exports.add4L = add4L;
    var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H;
    var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
    exports.add5L = add5L;
    var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H;
    var u64 = {
      fromBig,
      split,
      toBig,
      shrSH,
      shrSL,
      rotrSH,
      rotrSL,
      rotrBH,
      rotrBL,
      rotr32H,
      rotr32L,
      rotlSH,
      rotlSL,
      rotlBH,
      rotlBL,
      add,
      add3L,
      add3H,
      add4L,
      add4H,
      add5H,
      add5L
    };
    exports.default = u64;
  }
});

// node_modules/aptos/node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
    var _sha2_js_1 = require_sha2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA512_Kh, SHA512_Kl] = (() => _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n) => BigInt(n))))();
    var SHA512_W_H = new Uint32Array(80);
    var SHA512_W_L = new Uint32Array(80);
    var SHA512 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
      }
      // prettier-ignore
      set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
        this.Ah = Ah | 0;
        this.Al = Al | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl | 0;
        this.Eh = Eh | 0;
        this.El = El | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl | 0;
      }
      process(view, offset) {
        for (let i = 0; i < 16; i++, offset += 4) {
          SHA512_W_H[i] = view.getUint32(offset);
          SHA512_W_L[i] = view.getUint32(offset += 4);
        }
        for (let i = 16; i < 80; i++) {
          const W15h = SHA512_W_H[i - 15] | 0;
          const W15l = SHA512_W_L[i - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H[i - 2] | 0;
          const W2l = SHA512_W_L[i - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
          SHA512_W_H[i] = SUMh | 0;
          SHA512_W_L[i] = SUMl | 0;
        }
        let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
        for (let i = 0; i < 80; i++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El, 14) ^ _u64_js_1.default.rotrSH(Eh, El, 18) ^ _u64_js_1.default.rotrBH(Eh, El, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El, 14) ^ _u64_js_1.default.rotrSL(Eh, El, 18) ^ _u64_js_1.default.rotrBL(Eh, El, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El & Fl ^ ~El & Gl;
          const T1ll = _u64_js_1.default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al, 28) ^ _u64_js_1.default.rotrBH(Ah, Al, 34) ^ _u64_js_1.default.rotrBH(Ah, Al, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al, 28) ^ _u64_js_1.default.rotrBL(Ah, Al, 34) ^ _u64_js_1.default.rotrBL(Ah, Al, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
          Hh = Gh | 0;
          Hl = Gl | 0;
          Gh = Fh | 0;
          Gl = Fl | 0;
          Fh = Eh | 0;
          Fl = El | 0;
          ({ h: Eh, l: El } = _u64_js_1.default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl = Cl | 0;
          Ch = Bh | 0;
          Cl = Bl | 0;
          Bh = Ah | 0;
          Bl = Al | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al = All | 0;
        }
        ({ h: Ah, l: Al } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
        ({ h: Bh, l: Bl } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
        ({ h: Ch, l: Cl } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
        ({ h: Dh, l: Dl } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
        ({ h: Eh, l: El } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
        ({ h: Fh, l: Fl } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
        ({ h: Gh, l: Gl } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
        ({ h: Hh, l: Hl } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
        this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
      }
      roundClean() {
        SHA512_W_H.fill(0);
        SHA512_W_L.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA512;
    var SHA512_224 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_256 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA384 = class extends SHA512 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA512());
    exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_224());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_256());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA384());
  }
});

// node_modules/aptos/node_modules/@scure/bip39/index.js
var require_bip39 = __commonJS({
  "node_modules/aptos/node_modules/@scure/bip39/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mnemonicToSeedSync = exports.mnemonicToSeed = exports.validateMnemonic = exports.entropyToMnemonic = exports.mnemonicToEntropy = exports.generateMnemonic = void 0;
    var _assert_1 = require_assert();
    var pbkdf2_1 = require_pbkdf2();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var utils_1 = require_utils();
    var base_1 = require_lib();
    var isJapanese = (wordlist) => wordlist[0] === "あいこくしん";
    function nfkd(str) {
      if (typeof str !== "string")
        throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
      return str.normalize("NFKD");
    }
    function normalize(str) {
      const norm = nfkd(str);
      const words = norm.split(" ");
      if (![12, 15, 18, 21, 24].includes(words.length))
        throw new Error("Invalid mnemonic");
      return { nfkd: norm, words };
    }
    function assertEntropy(entropy) {
      _assert_1.default.bytes(entropy, 16, 20, 24, 28, 32);
    }
    function generateMnemonic(wordlist, strength = 128) {
      _assert_1.default.number(strength);
      if (strength % 32 !== 0 || strength > 256)
        throw new TypeError("Invalid entropy");
      return entropyToMnemonic((0, utils_1.randomBytes)(strength / 8), wordlist);
    }
    exports.generateMnemonic = generateMnemonic;
    var calcChecksum = (entropy) => {
      const bitsLeft = 8 - entropy.length / 4;
      return new Uint8Array([(0, sha256_1.sha256)(entropy)[0] >> bitsLeft << bitsLeft]);
    };
    function getCoder(wordlist) {
      if (!Array.isArray(wordlist) || wordlist.length !== 2048 || typeof wordlist[0] !== "string")
        throw new Error("Worlist: expected array of 2048 strings");
      wordlist.forEach((i) => {
        if (typeof i !== "string")
          throw new Error(`Wordlist: non-string element: ${i}`);
      });
      return base_1.utils.chain(base_1.utils.checksum(1, calcChecksum), base_1.utils.radix2(11, true), base_1.utils.alphabet(wordlist));
    }
    function mnemonicToEntropy(mnemonic, wordlist) {
      const { words } = normalize(mnemonic);
      const entropy = getCoder(wordlist).decode(words);
      assertEntropy(entropy);
      return entropy;
    }
    exports.mnemonicToEntropy = mnemonicToEntropy;
    function entropyToMnemonic(entropy, wordlist) {
      assertEntropy(entropy);
      const words = getCoder(wordlist).encode(entropy);
      return words.join(isJapanese(wordlist) ? "　" : " ");
    }
    exports.entropyToMnemonic = entropyToMnemonic;
    function validateMnemonic(mnemonic, wordlist) {
      try {
        mnemonicToEntropy(mnemonic, wordlist);
      } catch (e) {
        return false;
      }
      return true;
    }
    exports.validateMnemonic = validateMnemonic;
    var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
    function mnemonicToSeed(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2Async)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeed = mnemonicToSeed;
    function mnemonicToSeedSync(mnemonic, passphrase = "") {
      return (0, pbkdf2_1.pbkdf2)(sha512_1.sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
    }
    exports.mnemonicToSeedSync = mnemonicToSeedSync;
  }
});

// node_modules/aptos/node_modules/@noble/hashes/sha3.js
var require_sha3 = __commonJS({
  "node_modules/aptos/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n = BigInt(0);
    var _1n = BigInt(1);
    var _2n = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R = _1n, x = 1, y = 0; round < 24; round++) {
      [x, y] = [y, (2 * x + 3 * y) % 5];
      SHA3_PI.push(2 * (5 * y + x));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t = _0n;
      for (let j = 0; j < 7; j++) {
        R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
        if (R & _2n)
          t ^= _1n << (_1n << BigInt(j)) - _1n;
      }
      _SHA3_IOTA.push(t);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBH)(h, l, s) : (0, _u64_js_1.rotlSH)(h, l, s);
    var rotlL = (h, l, s) => s > 32 ? (0, _u64_js_1.rotlBL)(h, l, s) : (0, _u64_js_1.rotlSL)(h, l, s);
    function keccakP(s, rounds = 24) {
      const B = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x = 0; x < 10; x++)
          B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
        for (let x = 0; x < 10; x += 2) {
          const idx1 = (x + 8) % 10;
          const idx0 = (x + 2) % 10;
          const B0 = B[idx0];
          const B1 = B[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B[idx1];
          const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
          for (let y = 0; y < 50; y += 10) {
            s[x + y] ^= Th;
            s[x + y + 1] ^= Tl;
          }
        }
        let curH = s[2];
        let curL = s[3];
        for (let t = 0; t < 24; t++) {
          const shift = SHA3_ROTL[t];
          const Th = rotlH(curH, curL, shift);
          const Tl = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t];
          curH = s[PI];
          curL = s[PI + 1];
          s[PI] = Th;
          s[PI + 1] = Tl;
        }
        for (let y = 0; y < 50; y += 10) {
          for (let x = 0; x < 10; x++)
            B[x] = s[y + x];
          for (let x = 0; x < 10; x++)
            s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
        }
        s[0] ^= SHA3_IOTA_H[round];
        s[1] ^= SHA3_IOTA_L[round];
      }
      B.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i = 0; i < take; i++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to.state32.set(this.state32);
        to.pos = this.pos;
        to.posOut = this.posOut;
        to.finished = this.finished;
        to.rounds = rounds;
        to.suffix = suffix;
        to.outputLen = outputLen;
        to.enableXOF = enableXOF;
        to.destroyed = this.destroyed;
        return to;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/aptos/dist/index.js
var require_dist = __commonJS({
  "node_modules/aptos/dist/index.js"(exports, module) {
    "use strict";
    var __create = Object.create;
    var __defProp = Object.defineProperty;
    var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
    var __getOwnPropNames = Object.getOwnPropertyNames;
    var __getProtoOf = Object.getPrototypeOf;
    var __hasOwnProp = Object.prototype.hasOwnProperty;
    var __export2 = (target, all) => {
      for (var name in all)
        __defProp(target, name, { get: all[name], enumerable: true });
    };
    var __copyProps = (to, from, except, desc) => {
      if (from && typeof from === "object" || typeof from === "function") {
        for (let key of __getOwnPropNames(from))
          if (!__hasOwnProp.call(to, key) && key !== except)
            __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
      }
      return to;
    };
    var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
      // If the importer is in node compatibility mode or this is not an ESM
      // file that has been converted to a CommonJS file using a Babel-
      // compatible transform (i.e. "__esModule" has not been set), then set
      // "default" to the CommonJS "module.exports" for node compatibility.
      isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
      mod
    ));
    var __toCommonJS2 = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
    var __decorateClass = (decorators, target, key, kind) => {
      var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
      for (var i = decorators.length - 1, decorator; i >= 0; i--)
        if (decorator = decorators[i])
          result = (kind ? decorator(target, key, result) : decorator(result)) || result;
      if (kind && result)
        __defProp(target, key, result);
      return result;
    };
    var src_exports = {};
    __export2(src_exports, {
      APTOS_COIN: () => APTOS_COIN,
      AccountSequenceNumber: () => AccountSequenceNumber,
      Account_Transactions_Select_Column: () => Account_Transactions_Select_Column,
      Address_Events_Summary_Select_Column: () => Address_Events_Summary_Select_Column,
      Address_Version_From_Events_Select_Column: () => Address_Version_From_Events_Select_Column,
      Address_Version_From_Move_Resources_Select_Column: () => Address_Version_From_Move_Resources_Select_Column,
      AnsClient: () => AnsClient,
      ApiError: () => ApiError,
      AptosAccount: () => AptosAccount,
      AptosApiError: () => AptosApiError,
      AptosClient: () => AptosClient,
      AptosToken: () => AptosToken,
      BCS: () => bcs_exports,
      Block_Metadata_Transactions_Select_Column: () => Block_Metadata_Transactions_Select_Column,
      CKDPriv: () => CKDPriv,
      COIN_TRANSFER: () => COIN_TRANSFER,
      CoinClient: () => CoinClient,
      Coin_Activities_Select_Column: () => Coin_Activities_Select_Column,
      Coin_Balances_Select_Column: () => Coin_Balances_Select_Column,
      Coin_Infos_Select_Column: () => Coin_Infos_Select_Column,
      Coin_Supply_Select_Column: () => Coin_Supply_Select_Column,
      Collection_Datas_Select_Column: () => Collection_Datas_Select_Column,
      Current_Ans_Lookup_Select_Column: () => Current_Ans_Lookup_Select_Column,
      Current_Ans_Lookup_V2_Select_Column: () => Current_Ans_Lookup_V2_Select_Column,
      Current_Aptos_Names_Select_Column: () => Current_Aptos_Names_Select_Column,
      Current_Coin_Balances_Select_Column: () => Current_Coin_Balances_Select_Column,
      Current_Collection_Datas_Select_Column: () => Current_Collection_Datas_Select_Column,
      Current_Collection_Ownership_V2_View_Select_Column: () => Current_Collection_Ownership_V2_View_Select_Column,
      Current_Collections_V2_Select_Column: () => Current_Collections_V2_Select_Column,
      Current_Delegated_Staking_Pool_Balances_Select_Column: () => Current_Delegated_Staking_Pool_Balances_Select_Column,
      Current_Delegated_Voter_Select_Column: () => Current_Delegated_Voter_Select_Column,
      Current_Delegator_Balances_Select_Column: () => Current_Delegator_Balances_Select_Column,
      Current_Fungible_Asset_Balances_Select_Column: () => Current_Fungible_Asset_Balances_Select_Column,
      Current_Objects_Select_Column: () => Current_Objects_Select_Column,
      Current_Staking_Pool_Voter_Select_Column: () => Current_Staking_Pool_Voter_Select_Column,
      Current_Table_Items_Select_Column: () => Current_Table_Items_Select_Column,
      Current_Token_Datas_Select_Column: () => Current_Token_Datas_Select_Column,
      Current_Token_Datas_V2_Select_Column: () => Current_Token_Datas_V2_Select_Column,
      Current_Token_Ownerships_Select_Column: () => Current_Token_Ownerships_Select_Column,
      Current_Token_Ownerships_V2_Select_Column: () => Current_Token_Ownerships_V2_Select_Column,
      Current_Token_Pending_Claims_Select_Column: () => Current_Token_Pending_Claims_Select_Column,
      Cursor_Ordering: () => Cursor_Ordering,
      Delegated_Staking_Activities_Select_Column: () => Delegated_Staking_Activities_Select_Column,
      Delegated_Staking_Pools_Select_Column: () => Delegated_Staking_Pools_Select_Column,
      Delegator_Distinct_Pool_Select_Column: () => Delegator_Distinct_Pool_Select_Column,
      Events_Select_Column: () => Events_Select_Column,
      FailedTransactionError: () => FailedTransactionError,
      FaucetClient: () => FaucetClient,
      FungibleAssetClient: () => FungibleAssetClient,
      Fungible_Asset_Activities_Select_Column: () => Fungible_Asset_Activities_Select_Column,
      Fungible_Asset_Metadata_Select_Column: () => Fungible_Asset_Metadata_Select_Column,
      HexString: () => HexString,
      IndexerClient: () => IndexerClient,
      Indexer_Status_Select_Column: () => Indexer_Status_Select_Column,
      Ledger_Infos_Select_Column: () => Ledger_Infos_Select_Column,
      Move_Resources_Select_Column: () => Move_Resources_Select_Column,
      Network: () => Network,
      NetworkToIndexerAPI: () => NetworkToIndexerAPI,
      NetworkToNodeAPI: () => NetworkToNodeAPI,
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column: () => Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column,
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column: () => Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column,
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column: () => Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column,
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column: () => Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column,
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column: () => Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column,
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column: () => Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column,
      NodeAPIToNetwork: () => NodeAPIToNetwork,
      Num_Active_Delegator_Per_Pool_Select_Column: () => Num_Active_Delegator_Per_Pool_Select_Column,
      Order_By: () => Order_By,
      Processor_Status_Select_Column: () => Processor_Status_Select_Column,
      PropertyMap: () => PropertyMap,
      PropertyValue: () => PropertyValue,
      Proposal_Votes_Select_Column: () => Proposal_Votes_Select_Column,
      Provider: () => Provider,
      TRANSFER_COINS: () => TRANSFER_COINS,
      Table_Items_Select_Column: () => Table_Items_Select_Column,
      Table_Metadatas_Select_Column: () => Table_Metadatas_Select_Column,
      TokenClient: () => TokenClient,
      TokenTypes: () => token_types_exports,
      Token_Activities_Select_Column: () => Token_Activities_Select_Column,
      Token_Activities_V2_Select_Column: () => Token_Activities_V2_Select_Column,
      Token_Datas_Select_Column: () => Token_Datas_Select_Column,
      Token_Ownerships_Select_Column: () => Token_Ownerships_Select_Column,
      Tokens_Select_Column: () => Tokens_Select_Column,
      TransactionBuilder: () => TransactionBuilder,
      TransactionBuilderABI: () => TransactionBuilderABI,
      TransactionBuilderEd25519: () => TransactionBuilderEd25519,
      TransactionBuilderMultiEd25519: () => TransactionBuilderMultiEd25519,
      TransactionBuilderRemoteABI: () => TransactionBuilderRemoteABI,
      TransactionWorker: () => TransactionWorker,
      TransactionWorkerEvents: () => TransactionWorkerEvents,
      TxnBuilderTypes: () => aptos_types_exports,
      TypeTagParser: () => TypeTagParser,
      Types: () => generated_exports,
      User_Transactions_Select_Column: () => User_Transactions_Select_Column,
      WaitForTransactionError: () => WaitForTransactionError,
      ansContractsMap: () => ansContractsMap,
      aptosRequest: () => aptosRequest,
      argToTransactionArgument: () => argToTransactionArgument,
      derivePath: () => derivePath,
      deserializePropertyMap: () => deserializePropertyMap,
      deserializeValueBasedOnTypeTag: () => deserializeValueBasedOnTypeTag,
      ensureBigInt: () => ensureBigInt,
      ensureBoolean: () => ensureBoolean,
      ensureNumber: () => ensureNumber,
      get: () => get,
      getAddressFromAccountOrAddress: () => getAddressFromAccountOrAddress,
      getMasterKeyFromSeed: () => getMasterKeyFromSeed,
      getPropertyType: () => getPropertyType,
      getPropertyValueRaw: () => getPropertyValueRaw,
      getPublicKey: () => getPublicKey,
      getSinglePropertyValueRaw: () => getSinglePropertyValueRaw,
      isValidPath: () => isValidPath,
      nameComponentPattern: () => nameComponentPattern,
      namePattern: () => namePattern,
      post: () => post,
      serializeArg: () => serializeArg
    });
    module.exports = __toCommonJS2(src_exports);
    var import_tweetnacl2 = __toESM(require_nacl_fast());
    var bip39 = __toESM(require_bip39());
    var import_utils6 = require_utils();
    var import_sha256 = require_sha256();
    var import_sha33 = require_sha3();
    var import_tweetnacl = __toESM(require_nacl_fast());
    var import_hmac = require_hmac();
    var import_sha512 = require_sha512();
    var import_utils = require_utils();
    var pathRegex = /^m(\/[0-9]+')+$/;
    var replaceDerive = (val) => val.replace("'", "");
    var HMAC_KEY = "ed25519 seed";
    var HARDENED_OFFSET = 2147483648;
    var getMasterKeyFromSeed = (seed) => {
      const h = import_hmac.hmac.create(import_sha512.sha512, HMAC_KEY);
      const I = h.update((0, import_utils.hexToBytes)(seed)).digest();
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    };
    var CKDPriv = ({ key, chainCode }, index) => {
      const buffer = new ArrayBuffer(4);
      new DataView(buffer).setUint32(0, index);
      const indexBytes = new Uint8Array(buffer);
      const zero = new Uint8Array([0]);
      const data = new Uint8Array([...zero, ...key, ...indexBytes]);
      const I = import_hmac.hmac.create(import_sha512.sha512, chainCode).update(data).digest();
      const IL = I.slice(0, 32);
      const IR = I.slice(32);
      return {
        key: IL,
        chainCode: IR
      };
    };
    var getPublicKey = (privateKey, withZeroByte = true) => {
      const keyPair = import_tweetnacl.default.sign.keyPair.fromSeed(privateKey);
      const signPk = keyPair.secretKey.subarray(32);
      const zero = new Uint8Array([0]);
      return withZeroByte ? new Uint8Array([...zero, ...signPk]) : signPk;
    };
    var isValidPath = (path) => {
      if (!pathRegex.test(path)) {
        return false;
      }
      return !path.split("/").slice(1).map(replaceDerive).some(Number.isNaN);
    };
    var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
      if (!isValidPath(path)) {
        throw new Error("Invalid derivation path");
      }
      const { key, chainCode } = getMasterKeyFromSeed(seed);
      const segments = path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10));
      return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), { key, chainCode });
    };
    var VERSION = "1.21.0";
    async function sleep(timeMs) {
      return new Promise((resolve) => {
        setTimeout(resolve, timeMs);
      });
    }
    var DEFAULT_VERSION_PATH_BASE = "/v1";
    function fixNodeUrl(nodeUrl) {
      let out = `${nodeUrl}`;
      if (out.endsWith("/")) {
        out = out.substring(0, out.length - 1);
      }
      if (!out.endsWith(DEFAULT_VERSION_PATH_BASE)) {
        out = `${out}${DEFAULT_VERSION_PATH_BASE}`;
      }
      return out;
    }
    var DEFAULT_MAX_GAS_AMOUNT = 2e5;
    var DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;
    var DEFAULT_TXN_TIMEOUT_SEC = 20;
    var APTOS_COIN = "0x1::aptos_coin::AptosCoin";
    var CUSTOM_REQUEST_HEADER = { "x-aptos-client": `aptos-ts-sdk/${VERSION}` };
    function Memoize(args) {
      let hashFunction;
      let ttlMs;
      let tags;
      if (typeof args === "object") {
        hashFunction = args.hashFunction;
        ttlMs = args.ttlMs;
        tags = args.tags;
      } else {
        hashFunction = args;
      }
      return (target, propertyKey, descriptor) => {
        if (descriptor.value != null) {
          descriptor.value = getNewFunction(descriptor.value, hashFunction, ttlMs, tags);
        } else if (descriptor.get != null) {
          descriptor.get = getNewFunction(descriptor.get, hashFunction, ttlMs, tags);
        } else {
          throw new Error("Only put a Memoize() decorator on a method or get accessor.");
        }
      };
    }
    function MemoizeExpiring(ttlMs, hashFunction) {
      return Memoize({
        ttlMs,
        hashFunction
      });
    }
    var clearCacheTagsMap = /* @__PURE__ */ new Map();
    function clear(tags) {
      const cleared = /* @__PURE__ */ new Set();
      for (const tag of tags) {
        const maps = clearCacheTagsMap.get(tag);
        if (maps) {
          for (const mp of maps) {
            if (!cleared.has(mp)) {
              mp.clear();
              cleared.add(mp);
            }
          }
        }
      }
      return cleared.size;
    }
    function getNewFunction(originalMethod, hashFunction, ttlMs = 0, tags) {
      const propMapName = Symbol("__memoized_map__");
      return function(...args) {
        let returnedValue;
        const that = this;
        if (!that.hasOwnProperty(propMapName)) {
          Object.defineProperty(that, propMapName, {
            configurable: false,
            enumerable: false,
            writable: false,
            value: /* @__PURE__ */ new Map()
          });
        }
        const myMap = that[propMapName];
        if (Array.isArray(tags)) {
          for (const tag of tags) {
            if (clearCacheTagsMap.has(tag)) {
              clearCacheTagsMap.get(tag).push(myMap);
            } else {
              clearCacheTagsMap.set(tag, [myMap]);
            }
          }
        }
        if (hashFunction || args.length > 0 || ttlMs > 0) {
          let hashKey;
          if (hashFunction === true) {
            hashKey = args.map((a) => a.toString()).join("!");
          } else if (hashFunction) {
            hashKey = hashFunction.apply(that, args);
          } else {
            hashKey = args[0];
          }
          const timestampKey = `${hashKey}__timestamp`;
          let isExpired = false;
          if (ttlMs > 0) {
            if (!myMap.has(timestampKey)) {
              isExpired = true;
            } else {
              const timestamp = myMap.get(timestampKey);
              isExpired = Date.now() - timestamp > ttlMs;
            }
          }
          if (myMap.has(hashKey) && !isExpired) {
            returnedValue = myMap.get(hashKey);
          } else {
            returnedValue = originalMethod.apply(that, args);
            myMap.set(hashKey, returnedValue);
            if (ttlMs > 0) {
              myMap.set(timestampKey, Date.now());
            }
          }
        } else {
          const hashKey = that;
          if (myMap.has(hashKey)) {
            returnedValue = myMap.get(hashKey);
          } else {
            returnedValue = originalMethod.apply(that, args);
            myMap.set(hashKey, returnedValue);
          }
        }
        return returnedValue;
      };
    }
    var import_aptos_client = __toESM(require_index_browser());
    var AptosApiError = class extends Error {
      constructor(request2, response, message) {
        super(message);
        this.name = "AptosApiError";
        this.url = response.url;
        this.status = response.status;
        this.statusText = response.statusText;
        this.data = response.data;
        this.request = request2;
      }
    };
    var errors = {
      400: "Bad Request",
      401: "Unauthorized",
      403: "Forbidden",
      404: "Not Found",
      429: "Too Many Requests",
      500: "Internal Server Error",
      502: "Bad Gateway",
      503: "Service Unavailable"
    };
    async function request(url, method, body, contentType, params, overrides) {
      const headers = {
        ...overrides == null ? void 0 : overrides.HEADERS,
        "x-aptos-client": `aptos-ts-sdk/${VERSION}`,
        "content-type": contentType != null ? contentType : "application/json"
      };
      if (overrides == null ? void 0 : overrides.TOKEN) {
        headers.Authorization = `Bearer ${overrides == null ? void 0 : overrides.TOKEN}`;
      }
      const response = await (0, import_aptos_client.default)({ url, method, body, params, headers, overrides });
      return response;
    }
    async function aptosRequest(options) {
      const { url, endpoint, method, body, contentType, params, overrides } = options;
      const fullEndpoint = `${url}/${endpoint != null ? endpoint : ""}`;
      const response = await request(fullEndpoint, method, body, contentType, params, overrides);
      const result = {
        status: response.status,
        statusText: response.statusText,
        data: response.data,
        headers: response.headers,
        config: response.config,
        url: fullEndpoint
      };
      if (result.status >= 200 && result.status < 300) {
        return result;
      }
      const errorMessage = errors[result.status];
      throw new AptosApiError(options, result, errorMessage != null ? errorMessage : "Generic Error");
    }
    async function get(options) {
      const response = await aptosRequest({ ...options, method: "GET" });
      return response;
    }
    async function post(options) {
      const response = await aptosRequest({ ...options, method: "POST" });
      return response;
    }
    async function paginateWithCursor(options) {
      const out = [];
      let cursor;
      const requestParams = options.params;
      while (true) {
        requestParams.start = cursor;
        const response = await get({
          url: options.url,
          endpoint: options.endpoint,
          params: requestParams,
          originMethod: options.originMethod,
          overrides: options.overrides
        });
        cursor = response.headers["x-aptos-cursor"];
        delete response.headers;
        out.push(...response.data);
        if (cursor === null || cursor === void 0) {
          break;
        }
      }
      return out;
    }
    var NetworkToIndexerAPI = {
      mainnet: "https://indexer.mainnet.aptoslabs.com/v1/graphql",
      testnet: "https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql",
      devnet: "https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql",
      local: "http://127.0.0.1:8090/v1/graphql"
    };
    var NetworkToNodeAPI = {
      mainnet: "https://fullnode.mainnet.aptoslabs.com/v1",
      testnet: "https://fullnode.testnet.aptoslabs.com/v1",
      devnet: "https://fullnode.devnet.aptoslabs.com/v1",
      local: "http://127.0.0.1:8080/v1"
    };
    var NodeAPIToNetwork = {
      "https://fullnode.mainnet.aptoslabs.com/v1": "mainnet",
      "https://fullnode.testnet.aptoslabs.com/v1": "testnet",
      "https://fullnode.devnet.aptoslabs.com/v1": "devnet",
      "http://127.0.0.1:8080/v1": "local"
    };
    var Network = ((Network3) => {
      Network3["MAINNET"] = "mainnet";
      Network3["TESTNET"] = "testnet";
      Network3["DEVNET"] = "devnet";
      Network3["LOCAL"] = "local";
      return Network3;
    })(Network || {});
    var import_utils2 = require_utils();
    var HexString = class _HexString {
      /**
       * Creates new hex string from Buffer
       * @param buffer A buffer to convert
       * @returns New HexString
       */
      static fromBuffer(buffer) {
        return _HexString.fromUint8Array(buffer);
      }
      /**
       * Creates new hex string from Uint8Array
       * @param arr Uint8Array to convert
       * @returns New HexString
       */
      static fromUint8Array(arr) {
        return new _HexString((0, import_utils2.bytesToHex)(arr));
      }
      /**
       * Ensures `hexString` is instance of `HexString` class
       * @param hexString String to check
       * @returns New HexString if `hexString` is regular string or `hexString` if it is HexString instance
       * @example
       * ```
       *  const regularString = "string";
       *  const hexString = new HexString("string"); // "0xstring"
       *  HexString.ensure(regularString); // "0xstring"
       *  HexString.ensure(hexString); // "0xstring"
       * ```
       */
      static ensure(hexString) {
        if (typeof hexString === "string") {
          return new _HexString(hexString);
        }
        return hexString;
      }
      /**
       * Creates new HexString instance from regular string. If specified string already starts with "0x" prefix,
       * it will not add another one
       * @param hexString String to convert
       * @example
       * ```
       *  const string = "string";
       *  new HexString(string); // "0xstring"
       * ```
       */
      constructor(hexString) {
        if (hexString.startsWith("0x")) {
          this.hexString = hexString;
        } else {
          this.hexString = `0x${hexString}`;
        }
      }
      /**
       * Getter for inner hexString
       * @returns Inner hex string
       */
      hex() {
        return this.hexString;
      }
      /**
       * Getter for inner hexString without prefix
       * @returns Inner hex string without prefix
       * @example
       * ```
       *  const hexString = new HexString("string"); // "0xstring"
       *  hexString.noPrefix(); // "string"
       * ```
       */
      noPrefix() {
        return this.hexString.slice(2);
      }
      /**
       * Overrides default `toString` method
       * @returns Inner hex string
       */
      toString() {
        return this.hex();
      }
      /**
       * Trimmes extra zeroes in the begining of a string
       * @returns Inner hexString without leading zeroes
       * @example
       * ```
       *  new HexString("0x000000string").toShortString(); // result = "0xstring"
       * ```
       */
      toShortString() {
        const trimmed = this.hexString.replace(/^0x0*/, "");
        return `0x${trimmed}`;
      }
      /**
       * Converts hex string to a Uint8Array
       * @returns Uint8Array from inner hexString without prefix
       */
      toUint8Array() {
        return Uint8Array.from((0, import_utils2.hexToBytes)(this.noPrefix()));
      }
    };
    var aptos_types_exports = {};
    __export2(aptos_types_exports, {
      AccountAddress: () => AccountAddress,
      AccountAuthenticator: () => AccountAuthenticator,
      AccountAuthenticatorEd25519: () => AccountAuthenticatorEd25519,
      AccountAuthenticatorMultiEd25519: () => AccountAuthenticatorMultiEd25519,
      ArgumentABI: () => ArgumentABI,
      AuthenticationKey: () => AuthenticationKey,
      ChainId: () => ChainId,
      ChangeSet: () => ChangeSet,
      Ed25519PublicKey: () => Ed25519PublicKey,
      Ed25519Signature: () => Ed25519Signature,
      EntryFunction: () => EntryFunction,
      EntryFunctionABI: () => EntryFunctionABI,
      FeePayerRawTransaction: () => FeePayerRawTransaction,
      Identifier: () => Identifier,
      Module: () => Module,
      ModuleId: () => ModuleId,
      MultiAgentRawTransaction: () => MultiAgentRawTransaction,
      MultiEd25519PublicKey: () => MultiEd25519PublicKey,
      MultiEd25519Signature: () => MultiEd25519Signature,
      MultiSig: () => MultiSig,
      MultiSigTransactionPayload: () => MultiSigTransactionPayload,
      RawTransaction: () => RawTransaction,
      RawTransactionWithData: () => RawTransactionWithData,
      RotationProofChallenge: () => RotationProofChallenge,
      Script: () => Script,
      ScriptABI: () => ScriptABI,
      SignedTransaction: () => SignedTransaction,
      StructTag: () => StructTag,
      Transaction: () => Transaction,
      TransactionArgument: () => TransactionArgument,
      TransactionArgumentAddress: () => TransactionArgumentAddress,
      TransactionArgumentBool: () => TransactionArgumentBool,
      TransactionArgumentU128: () => TransactionArgumentU128,
      TransactionArgumentU16: () => TransactionArgumentU16,
      TransactionArgumentU256: () => TransactionArgumentU256,
      TransactionArgumentU32: () => TransactionArgumentU32,
      TransactionArgumentU64: () => TransactionArgumentU64,
      TransactionArgumentU8: () => TransactionArgumentU8,
      TransactionArgumentU8Vector: () => TransactionArgumentU8Vector,
      TransactionAuthenticator: () => TransactionAuthenticator,
      TransactionAuthenticatorEd25519: () => TransactionAuthenticatorEd25519,
      TransactionAuthenticatorFeePayer: () => TransactionAuthenticatorFeePayer,
      TransactionAuthenticatorMultiAgent: () => TransactionAuthenticatorMultiAgent,
      TransactionAuthenticatorMultiEd25519: () => TransactionAuthenticatorMultiEd25519,
      TransactionPayload: () => TransactionPayload,
      TransactionPayloadEntryFunction: () => TransactionPayloadEntryFunction,
      TransactionPayloadMultisig: () => TransactionPayloadMultisig,
      TransactionPayloadScript: () => TransactionPayloadScript,
      TransactionScriptABI: () => TransactionScriptABI,
      TypeArgumentABI: () => TypeArgumentABI,
      TypeTag: () => TypeTag,
      TypeTagAddress: () => TypeTagAddress,
      TypeTagBool: () => TypeTagBool,
      TypeTagParser: () => TypeTagParser,
      TypeTagParserError: () => TypeTagParserError,
      TypeTagSigner: () => TypeTagSigner,
      TypeTagStruct: () => TypeTagStruct,
      TypeTagU128: () => TypeTagU128,
      TypeTagU16: () => TypeTagU16,
      TypeTagU256: () => TypeTagU256,
      TypeTagU32: () => TypeTagU32,
      TypeTagU64: () => TypeTagU64,
      TypeTagU8: () => TypeTagU8,
      TypeTagVector: () => TypeTagVector,
      UserTransaction: () => UserTransaction,
      WriteSet: () => WriteSet,
      objectStructTag: () => objectStructTag,
      optionStructTag: () => optionStructTag,
      stringStructTag: () => stringStructTag
    });
    var bcs_exports = {};
    __export2(bcs_exports, {
      Deserializer: () => Deserializer,
      Serializer: () => Serializer,
      bcsSerializeBool: () => bcsSerializeBool,
      bcsSerializeBytes: () => bcsSerializeBytes,
      bcsSerializeFixedBytes: () => bcsSerializeFixedBytes,
      bcsSerializeStr: () => bcsSerializeStr,
      bcsSerializeU128: () => bcsSerializeU128,
      bcsSerializeU16: () => bcsSerializeU16,
      bcsSerializeU256: () => bcsSerializeU256,
      bcsSerializeU32: () => bcsSerializeU32,
      bcsSerializeU8: () => bcsSerializeU8,
      bcsSerializeUint64: () => bcsSerializeUint64,
      bcsToBytes: () => bcsToBytes,
      deserializeVector: () => deserializeVector,
      serializeVector: () => serializeVector,
      serializeVectorWithFunc: () => serializeVectorWithFunc
    });
    var MAX_U8_NUMBER = 2 ** 8 - 1;
    var MAX_U16_NUMBER = 2 ** 16 - 1;
    var MAX_U32_NUMBER = 2 ** 32 - 1;
    var MAX_U64_BIG_INT = BigInt(2 ** 64) - BigInt(1);
    var MAX_U128_BIG_INT = BigInt(2 ** 128) - BigInt(1);
    var MAX_U256_BIG_INT = BigInt(2 ** 256) - BigInt(1);
    var Serializer = class {
      constructor() {
        this.buffer = new ArrayBuffer(64);
        this.offset = 0;
      }
      ensureBufferWillHandleSize(bytes) {
        while (this.buffer.byteLength < this.offset + bytes) {
          const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);
          new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
          this.buffer = newBuffer;
        }
      }
      serialize(values) {
        this.ensureBufferWillHandleSize(values.length);
        new Uint8Array(this.buffer, this.offset).set(values);
        this.offset += values.length;
      }
      serializeWithFunction(fn, bytesLength, value) {
        this.ensureBufferWillHandleSize(bytesLength);
        const dv = new DataView(this.buffer, this.offset);
        fn.apply(dv, [0, value, true]);
        this.offset += bytesLength;
      }
      /**
       * Serializes a string. UTF8 string is supported. Serializes the string's bytes length "l" first,
       * and then serializes "l" bytes of the string content.
       *
       * BCS layout for "string": string_length | string_content. string_length is the bytes length of
       * the string that is uleb128 encoded. string_length is a u32 integer.
       *
       * @example
       * ```ts
       * const serializer = new Serializer();
       * serializer.serializeStr("çå∞≠¢õß∂ƒ∫");
       * assert(serializer.getBytes() === new Uint8Array([24, 0xc3, 0xa7, 0xc3, 0xa5, 0xe2, 0x88, 0x9e,
       * 0xe2, 0x89, 0xa0, 0xc2, 0xa2, 0xc3, 0xb5, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xc6, 0x92, 0xe2, 0x88, 0xab]));
       * ```
       */
      serializeStr(value) {
        const textEncoder = new TextEncoder();
        this.serializeBytes(textEncoder.encode(value));
      }
      /**
       * Serializes an array of bytes.
       *
       * BCS layout for "bytes": bytes_length | bytes. bytes_length is the length of the bytes array that is
       * uleb128 encoded. bytes_length is a u32 integer.
       */
      serializeBytes(value) {
        this.serializeU32AsUleb128(value.length);
        this.serialize(value);
      }
      /**
       * Serializes an array of bytes with known length. Therefore length doesn't need to be
       * serialized to help deserialization.  When deserializing, the number of
       * bytes to deserialize needs to be passed in.
       */
      serializeFixedBytes(value) {
        this.serialize(value);
      }
      /**
       * Serializes a boolean value.
       *
       * BCS layout for "boolean": One byte. "0x01" for True and "0x00" for False.
       */
      serializeBool(value) {
        if (typeof value !== "boolean") {
          throw new Error("Value needs to be a boolean");
        }
        const byteValue = value ? 1 : 0;
        this.serialize(new Uint8Array([byteValue]));
      }
      serializeU8(value) {
        this.serialize(new Uint8Array([value]));
      }
      serializeU16(value) {
        this.serializeWithFunction(DataView.prototype.setUint16, 2, value);
      }
      serializeU32(value) {
        this.serializeWithFunction(DataView.prototype.setUint32, 4, value);
      }
      serializeU64(value) {
        const low = BigInt(value.toString()) & BigInt(MAX_U32_NUMBER);
        const high = BigInt(value.toString()) >> BigInt(32);
        this.serializeU32(Number(low));
        this.serializeU32(Number(high));
      }
      serializeU128(value) {
        const low = BigInt(value.toString()) & MAX_U64_BIG_INT;
        const high = BigInt(value.toString()) >> BigInt(64);
        this.serializeU64(low);
        this.serializeU64(high);
      }
      serializeU256(value) {
        const low = BigInt(value.toString()) & MAX_U128_BIG_INT;
        const high = BigInt(value.toString()) >> BigInt(128);
        this.serializeU128(low);
        this.serializeU128(high);
      }
      serializeU32AsUleb128(val) {
        let value = val;
        const valueArray = [];
        while (value >>> 7 !== 0) {
          valueArray.push(value & 127 | 128);
          value >>>= 7;
        }
        valueArray.push(value);
        this.serialize(new Uint8Array(valueArray));
      }
      /**
       * Returns the buffered bytes
       */
      getBytes() {
        return new Uint8Array(this.buffer).slice(0, this.offset);
      }
    };
    __decorateClass([
      checkNumberRange(0, MAX_U8_NUMBER)
    ], Serializer.prototype, "serializeU8", 1);
    __decorateClass([
      checkNumberRange(0, MAX_U16_NUMBER)
    ], Serializer.prototype, "serializeU16", 1);
    __decorateClass([
      checkNumberRange(0, MAX_U32_NUMBER)
    ], Serializer.prototype, "serializeU32", 1);
    __decorateClass([
      checkNumberRange(BigInt(0), MAX_U64_BIG_INT)
    ], Serializer.prototype, "serializeU64", 1);
    __decorateClass([
      checkNumberRange(BigInt(0), MAX_U128_BIG_INT)
    ], Serializer.prototype, "serializeU128", 1);
    __decorateClass([
      checkNumberRange(BigInt(0), MAX_U256_BIG_INT)
    ], Serializer.prototype, "serializeU256", 1);
    __decorateClass([
      checkNumberRange(0, MAX_U32_NUMBER)
    ], Serializer.prototype, "serializeU32AsUleb128", 1);
    function checkNumberRange(minValue, maxValue, message) {
      return (target, propertyKey, descriptor) => {
        const childFunction = descriptor.value;
        descriptor.value = function deco(value) {
          const valueBigInt = BigInt(value.toString());
          if (valueBigInt > BigInt(maxValue.toString()) || valueBigInt < BigInt(minValue.toString())) {
            throw new Error(message || "Value is out of range");
          }
          childFunction.apply(this, [value]);
        };
        return descriptor;
      };
    }
    var Deserializer = class {
      constructor(data) {
        this.buffer = new ArrayBuffer(data.length);
        new Uint8Array(this.buffer).set(data, 0);
        this.offset = 0;
      }
      read(length) {
        if (this.offset + length > this.buffer.byteLength) {
          throw new Error("Reached to the end of buffer");
        }
        const bytes = this.buffer.slice(this.offset, this.offset + length);
        this.offset += length;
        return bytes;
      }
      /**
       * Deserializes a string. UTF8 string is supported. Reads the string's bytes length "l" first,
       * and then reads "l" bytes of content. Decodes the byte array into a string.
       *
       * BCS layout for "string": string_length | string_content. string_length is the bytes length of
       * the string that is uleb128 encoded. string_length is a u32 integer.
       *
       * @example
       * ```ts
       * const deserializer = new Deserializer(new Uint8Array([24, 0xc3, 0xa7, 0xc3, 0xa5, 0xe2, 0x88, 0x9e,
       * 0xe2, 0x89, 0xa0, 0xc2, 0xa2, 0xc3, 0xb5, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xc6, 0x92, 0xe2, 0x88, 0xab]));
       * assert(deserializer.deserializeStr() === "çå∞≠¢õß∂ƒ∫");
       * ```
       */
      deserializeStr() {
        const value = this.deserializeBytes();
        const textDecoder = new TextDecoder();
        return textDecoder.decode(value);
      }
      /**
       * Deserializes an array of bytes.
       *
       * BCS layout for "bytes": bytes_length | bytes. bytes_length is the length of the bytes array that is
       * uleb128 encoded. bytes_length is a u32 integer.
       */
      deserializeBytes() {
        const len = this.deserializeUleb128AsU32();
        return new Uint8Array(this.read(len));
      }
      /**
       * Deserializes an array of bytes. The number of bytes to read is already known.
       *
       */
      deserializeFixedBytes(len) {
        return new Uint8Array(this.read(len));
      }
      /**
       * Deserializes a boolean value.
       *
       * BCS layout for "boolean": One byte. "0x01" for True and "0x00" for False.
       */
      deserializeBool() {
        const bool = new Uint8Array(this.read(1))[0];
        if (bool !== 1 && bool !== 0) {
          throw new Error("Invalid boolean value");
        }
        return bool === 1;
      }
      /**
       * Deserializes a uint8 number.
       *
       * BCS layout for "uint8": One byte. Binary format in little-endian representation.
       */
      deserializeU8() {
        return new DataView(this.read(1)).getUint8(0);
      }
      /**
       * Deserializes a uint16 number.
       *
       * BCS layout for "uint16": Two bytes. Binary format in little-endian representation.
       * @example
       * ```ts
       * const deserializer = new Deserializer(new Uint8Array([0x34, 0x12]));
       * assert(deserializer.deserializeU16() === 4660);
       * ```
       */
      deserializeU16() {
        return new DataView(this.read(2)).getUint16(0, true);
      }
      /**
       * Deserializes a uint32 number.
       *
       * BCS layout for "uint32": Four bytes. Binary format in little-endian representation.
       * @example
       * ```ts
       * const deserializer = new Deserializer(new Uint8Array([0x78, 0x56, 0x34, 0x12]));
       * assert(deserializer.deserializeU32() === 305419896);
       * ```
       */
      deserializeU32() {
        return new DataView(this.read(4)).getUint32(0, true);
      }
      /**
       * Deserializes a uint64 number.
       *
       * BCS layout for "uint64": Eight bytes. Binary format in little-endian representation.
       * @example
       * ```ts
       * const deserializer = new Deserializer(new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));
       * assert(deserializer.deserializeU64() === 1311768467750121216);
       * ```
       */
      deserializeU64() {
        const low = this.deserializeU32();
        const high = this.deserializeU32();
        return BigInt(BigInt(high) << BigInt(32) | BigInt(low));
      }
      /**
       * Deserializes a uint128 number.
       *
       * BCS layout for "uint128": Sixteen bytes. Binary format in little-endian representation.
       */
      deserializeU128() {
        const low = this.deserializeU64();
        const high = this.deserializeU64();
        return BigInt(high << BigInt(64) | low);
      }
      /**
       * Deserializes a uint256 number.
       *
       * BCS layout for "uint256": Thirty-two bytes. Binary format in little-endian representation.
       */
      deserializeU256() {
        const low = this.deserializeU128();
        const high = this.deserializeU128();
        return BigInt(high << BigInt(128) | low);
      }
      /**
       * Deserializes a uleb128 encoded uint32 number.
       *
       * BCS use uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values
       */
      deserializeUleb128AsU32() {
        let value = BigInt(0);
        let shift = 0;
        while (value < MAX_U32_NUMBER) {
          const byte = this.deserializeU8();
          value |= BigInt(byte & 127) << BigInt(shift);
          if ((byte & 128) === 0) {
            break;
          }
          shift += 7;
        }
        if (value > MAX_U32_NUMBER) {
          throw new Error("Overflow while parsing uleb128-encoded uint32 value");
        }
        return Number(value);
      }
    };
    function serializeVector(value, serializer) {
      serializer.serializeU32AsUleb128(value.length);
      value.forEach((item) => {
        item.serialize(serializer);
      });
    }
    function serializeVectorWithFunc(value, func) {
      const serializer = new Serializer();
      serializer.serializeU32AsUleb128(value.length);
      const f = serializer[func];
      value.forEach((item) => {
        f.call(serializer, item);
      });
      return serializer.getBytes();
    }
    function deserializeVector(deserializer, cls) {
      const length = deserializer.deserializeUleb128AsU32();
      const list = [];
      for (let i = 0; i < length; i += 1) {
        list.push(cls.deserialize(deserializer));
      }
      return list;
    }
    function bcsToBytes(value) {
      const serializer = new Serializer();
      value.serialize(serializer);
      return serializer.getBytes();
    }
    function bcsSerializeUint64(value) {
      const serializer = new Serializer();
      serializer.serializeU64(value);
      return serializer.getBytes();
    }
    function bcsSerializeU8(value) {
      const serializer = new Serializer();
      serializer.serializeU8(value);
      return serializer.getBytes();
    }
    function bcsSerializeU16(value) {
      const serializer = new Serializer();
      serializer.serializeU16(value);
      return serializer.getBytes();
    }
    function bcsSerializeU32(value) {
      const serializer = new Serializer();
      serializer.serializeU32(value);
      return serializer.getBytes();
    }
    function bcsSerializeU128(value) {
      const serializer = new Serializer();
      serializer.serializeU128(value);
      return serializer.getBytes();
    }
    function bcsSerializeU256(value) {
      const serializer = new Serializer();
      serializer.serializeU256(value);
      return serializer.getBytes();
    }
    function bcsSerializeBool(value) {
      const serializer = new Serializer();
      serializer.serializeBool(value);
      return serializer.getBytes();
    }
    function bcsSerializeStr(value) {
      const serializer = new Serializer();
      serializer.serializeStr(value);
      return serializer.getBytes();
    }
    function bcsSerializeBytes(value) {
      const serializer = new Serializer();
      serializer.serializeBytes(value);
      return serializer.getBytes();
    }
    function bcsSerializeFixedBytes(value) {
      const serializer = new Serializer();
      serializer.serializeFixedBytes(value);
      return serializer.getBytes();
    }
    var import_sha3 = require_sha3();
    var _AccountAddress = class _AccountAddress2 {
      constructor(address) {
        if (address.length !== _AccountAddress2.LENGTH) {
          throw new Error("Expected address of length 32");
        }
        this.address = address;
      }
      /**
       * Creates AccountAddress from a hex string.
       * @param addr Hex string can be with a prefix or without a prefix,
       *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.
       */
      static fromHex(addr) {
        let address = HexString.ensure(addr);
        if (address.noPrefix().length % 2 !== 0) {
          address = new HexString(`0${address.noPrefix()}`);
        }
        const addressBytes = address.toUint8Array();
        if (addressBytes.length > _AccountAddress2.LENGTH) {
          throw new Error("Hex string is too long. Address's length is 32 bytes.");
        } else if (addressBytes.length === _AccountAddress2.LENGTH) {
          return new _AccountAddress2(addressBytes);
        }
        const res = new Uint8Array(_AccountAddress2.LENGTH);
        res.set(addressBytes, _AccountAddress2.LENGTH - addressBytes.length);
        return new _AccountAddress2(res);
      }
      /**
       * Checks if the string is a valid AccountAddress
       * @param addr Hex string can be with a prefix or without a prefix,
       *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.
       */
      static isValid(addr) {
        if (addr === "") {
          return false;
        }
        let address = HexString.ensure(addr);
        if (address.noPrefix().length % 2 !== 0) {
          address = new HexString(`0${address.noPrefix()}`);
        }
        const addressBytes = address.toUint8Array();
        return addressBytes.length <= _AccountAddress2.LENGTH;
      }
      /**
       * Return a hex string from account Address.
       */
      toHexString() {
        return HexString.fromUint8Array(this.address).hex();
      }
      serialize(serializer) {
        serializer.serializeFixedBytes(this.address);
      }
      static deserialize(deserializer) {
        return new _AccountAddress2(deserializer.deserializeFixedBytes(_AccountAddress2.LENGTH));
      }
      /**
       * Standardizes an address to the format "0x" followed by 64 lowercase hexadecimal digits.
       */
      static standardizeAddress(address) {
        const lowercaseAddress = address.toLowerCase();
        const addressWithoutPrefix = lowercaseAddress.startsWith("0x") ? lowercaseAddress.slice(2) : lowercaseAddress;
        const addressWithPadding = addressWithoutPrefix.padStart(64, "0");
        return `0x${addressWithPadding}`;
      }
    };
    _AccountAddress.LENGTH = 32;
    _AccountAddress.CORE_CODE_ADDRESS = _AccountAddress.fromHex("0x1");
    var AccountAddress = _AccountAddress;
    var _Ed25519PublicKey = class _Ed25519PublicKey2 {
      constructor(value) {
        if (value.length !== _Ed25519PublicKey2.LENGTH) {
          throw new Error(`Ed25519PublicKey length should be ${_Ed25519PublicKey2.LENGTH}`);
        }
        this.value = value;
      }
      toBytes() {
        return this.value;
      }
      serialize(serializer) {
        serializer.serializeBytes(this.value);
      }
      static deserialize(deserializer) {
        const value = deserializer.deserializeBytes();
        return new _Ed25519PublicKey2(value);
      }
    };
    _Ed25519PublicKey.LENGTH = 32;
    var Ed25519PublicKey = _Ed25519PublicKey;
    var _Ed25519Signature = class _Ed25519Signature2 {
      constructor(value) {
        this.value = value;
        if (value.length !== _Ed25519Signature2.LENGTH) {
          throw new Error(`Ed25519Signature length should be ${_Ed25519Signature2.LENGTH}`);
        }
      }
      serialize(serializer) {
        serializer.serializeBytes(this.value);
      }
      static deserialize(deserializer) {
        const value = deserializer.deserializeBytes();
        return new _Ed25519Signature2(value);
      }
    };
    _Ed25519Signature.LENGTH = 64;
    var Ed25519Signature = _Ed25519Signature;
    var MAX_SIGNATURES_SUPPORTED = 32;
    var MultiEd25519PublicKey = class _MultiEd25519PublicKey {
      /**
       * Public key for a K-of-N multisig transaction. A K-of-N multisig transaction means that for such a
       * transaction to be executed, at least K out of the N authorized signers have signed the transaction
       * and passed the check conducted by the chain.
       *
       * @see {@link
       * https://aptos.dev/guides/creating-a-signed-transaction#multisignature-transactions | Creating a Signed Transaction}
       *
       * @param public_keys A list of public keys
       * @param threshold At least "threshold" signatures must be valid
       */
      constructor(public_keys, threshold) {
        this.public_keys = public_keys;
        this.threshold = threshold;
        if (threshold > MAX_SIGNATURES_SUPPORTED) {
          throw new Error(`"threshold" cannot be larger than ${MAX_SIGNATURES_SUPPORTED}`);
        }
      }
      /**
       * Converts a MultiEd25519PublicKey into bytes with: bytes = p1_bytes | ... | pn_bytes | threshold
       */
      toBytes() {
        const bytes = new Uint8Array(this.public_keys.length * Ed25519PublicKey.LENGTH + 1);
        this.public_keys.forEach((k, i) => {
          bytes.set(k.value, i * Ed25519PublicKey.LENGTH);
        });
        bytes[this.public_keys.length * Ed25519PublicKey.LENGTH] = this.threshold;
        return bytes;
      }
      serialize(serializer) {
        serializer.serializeBytes(this.toBytes());
      }
      static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        const threshold = bytes[bytes.length - 1];
        const keys = [];
        for (let i = 0; i < bytes.length - 1; i += Ed25519PublicKey.LENGTH) {
          const begin = i;
          keys.push(new Ed25519PublicKey(bytes.subarray(begin, begin + Ed25519PublicKey.LENGTH)));
        }
        return new _MultiEd25519PublicKey(keys, threshold);
      }
    };
    var _MultiEd25519Signature = class _MultiEd25519Signature2 {
      /**
       * Signature for a K-of-N multisig transaction.
       *
       * @see {@link
       * https://aptos.dev/guides/creating-a-signed-transaction#multisignature-transactions | Creating a Signed Transaction}
       *
       * @param signatures A list of ed25519 signatures
       * @param bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth
       * signature should be provided in `signatures`. Bits are read from left to right
       */
      constructor(signatures, bitmap) {
        this.signatures = signatures;
        this.bitmap = bitmap;
        if (bitmap.length !== _MultiEd25519Signature2.BITMAP_LEN) {
          throw new Error(`"bitmap" length should be ${_MultiEd25519Signature2.BITMAP_LEN}`);
        }
      }
      /**
       * Converts a MultiEd25519Signature into bytes with `bytes = s1_bytes | ... | sn_bytes | bitmap`
       */
      toBytes() {
        const bytes = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + _MultiEd25519Signature2.BITMAP_LEN);
        this.signatures.forEach((k, i) => {
          bytes.set(k.value, i * Ed25519Signature.LENGTH);
        });
        bytes.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);
        return bytes;
      }
      /**
       * Helper method to create a bitmap out of the specified bit positions
       * @param bits The bitmap positions that should be set. A position starts at index 0.
       * Valid position should range between 0 and 31.
       * @example
       * Here's an example of valid `bits`
       * ```
       * [0, 2, 31]
       * ```
       * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.
       * The result bitmap should be 0b1010000000000000000000000000001
       *
       * @returns bitmap that is 32bit long
       */
      static createBitmap(bits) {
        const firstBitInByte = 128;
        const bitmap = new Uint8Array([0, 0, 0, 0]);
        const dupCheckSet = /* @__PURE__ */ new Set();
        bits.forEach((bit) => {
          if (bit >= MAX_SIGNATURES_SUPPORTED) {
            throw new Error(`Invalid bit value ${bit}.`);
          }
          if (dupCheckSet.has(bit)) {
            throw new Error("Duplicated bits detected.");
          }
          dupCheckSet.add(bit);
          const byteOffset = Math.floor(bit / 8);
          let byte = bitmap[byteOffset];
          byte |= firstBitInByte >> bit % 8;
          bitmap[byteOffset] = byte;
        });
        return bitmap;
      }
      serialize(serializer) {
        serializer.serializeBytes(this.toBytes());
      }
      static deserialize(deserializer) {
        const bytes = deserializer.deserializeBytes();
        const bitmap = bytes.subarray(bytes.length - 4);
        const sigs = [];
        for (let i = 0; i < bytes.length - bitmap.length; i += Ed25519Signature.LENGTH) {
          const begin = i;
          sigs.push(new Ed25519Signature(bytes.subarray(begin, begin + Ed25519Signature.LENGTH)));
        }
        return new _MultiEd25519Signature2(sigs, bitmap);
      }
    };
    _MultiEd25519Signature.BITMAP_LEN = 4;
    var MultiEd25519Signature = _MultiEd25519Signature;
    var TransactionAuthenticator = class {
      static deserialize(deserializer) {
        const index = deserializer.deserializeUleb128AsU32();
        switch (index) {
          case 0:
            return TransactionAuthenticatorEd25519.load(deserializer);
          case 1:
            return TransactionAuthenticatorMultiEd25519.load(deserializer);
          case 2:
            return TransactionAuthenticatorMultiAgent.load(deserializer);
          case 3:
            return TransactionAuthenticatorFeePayer.load(deserializer);
          default:
            throw new Error(`Unknown variant index for TransactionAuthenticator: ${index}`);
        }
      }
    };
    var TransactionAuthenticatorEd25519 = class _TransactionAuthenticatorEd25519 extends TransactionAuthenticator {
      /**
       * An authenticator for single signature.
       *
       * @param public_key Client's public key.
       * @param signature Signature of a raw transaction.
       * @see {@link https://aptos.dev/guides/creating-a-signed-transaction/ | Creating a Signed Transaction}
       * for details about generating a signature.
       */
      constructor(public_key, signature) {
        super();
        this.public_key = public_key;
        this.signature = signature;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
        this.public_key.serialize(serializer);
        this.signature.serialize(serializer);
      }
      static load(deserializer) {
        const public_key = Ed25519PublicKey.deserialize(deserializer);
        const signature = Ed25519Signature.deserialize(deserializer);
        return new _TransactionAuthenticatorEd25519(public_key, signature);
      }
    };
    var TransactionAuthenticatorMultiEd25519 = class _TransactionAuthenticatorMultiEd25519 extends TransactionAuthenticator {
      /**
       * An authenticator for multiple signatures.
       *
       * @param public_key
       * @param signature
       *
       */
      constructor(public_key, signature) {
        super();
        this.public_key = public_key;
        this.signature = signature;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(1);
        this.public_key.serialize(serializer);
        this.signature.serialize(serializer);
      }
      static load(deserializer) {
        const public_key = MultiEd25519PublicKey.deserialize(deserializer);
        const signature = MultiEd25519Signature.deserialize(deserializer);
        return new _TransactionAuthenticatorMultiEd25519(public_key, signature);
      }
    };
    var TransactionAuthenticatorMultiAgent = class _TransactionAuthenticatorMultiAgent extends TransactionAuthenticator {
      constructor(sender, secondary_signer_addresses, secondary_signers) {
        super();
        this.sender = sender;
        this.secondary_signer_addresses = secondary_signer_addresses;
        this.secondary_signers = secondary_signers;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(2);
        this.sender.serialize(serializer);
        serializeVector(this.secondary_signer_addresses, serializer);
        serializeVector(this.secondary_signers, serializer);
      }
      static load(deserializer) {
        const sender = AccountAuthenticator.deserialize(deserializer);
        const secondary_signer_addresses = deserializeVector(deserializer, AccountAddress);
        const secondary_signers = deserializeVector(deserializer, AccountAuthenticator);
        return new _TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);
      }
    };
    var TransactionAuthenticatorFeePayer = class _TransactionAuthenticatorFeePayer extends TransactionAuthenticator {
      constructor(sender, secondary_signer_addresses, secondary_signers, fee_payer) {
        super();
        this.sender = sender;
        this.secondary_signer_addresses = secondary_signer_addresses;
        this.secondary_signers = secondary_signers;
        this.fee_payer = fee_payer;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(3);
        this.sender.serialize(serializer);
        serializeVector(this.secondary_signer_addresses, serializer);
        serializeVector(this.secondary_signers, serializer);
        this.fee_payer.address.serialize(serializer);
        this.fee_payer.authenticator.serialize(serializer);
      }
      static load(deserializer) {
        const sender = AccountAuthenticator.deserialize(deserializer);
        const secondary_signer_addresses = deserializeVector(deserializer, AccountAddress);
        const secondary_signers = deserializeVector(deserializer, AccountAuthenticator);
        const address = AccountAddress.deserialize(deserializer);
        const authenticator = AccountAuthenticator.deserialize(deserializer);
        const fee_payer = { address, authenticator };
        return new _TransactionAuthenticatorFeePayer(sender, secondary_signer_addresses, secondary_signers, fee_payer);
      }
    };
    var AccountAuthenticator = class {
      static deserialize(deserializer) {
        const index = deserializer.deserializeUleb128AsU32();
        switch (index) {
          case 0:
            return AccountAuthenticatorEd25519.load(deserializer);
          case 1:
            return AccountAuthenticatorMultiEd25519.load(deserializer);
          default:
            throw new Error(`Unknown variant index for AccountAuthenticator: ${index}`);
        }
      }
    };
    var AccountAuthenticatorEd25519 = class _AccountAuthenticatorEd25519 extends AccountAuthenticator {
      constructor(public_key, signature) {
        super();
        this.public_key = public_key;
        this.signature = signature;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
        this.public_key.serialize(serializer);
        this.signature.serialize(serializer);
      }
      static load(deserializer) {
        const public_key = Ed25519PublicKey.deserialize(deserializer);
        const signature = Ed25519Signature.deserialize(deserializer);
        return new _AccountAuthenticatorEd25519(public_key, signature);
      }
    };
    var AccountAuthenticatorMultiEd25519 = class _AccountAuthenticatorMultiEd25519 extends AccountAuthenticator {
      constructor(public_key, signature) {
        super();
        this.public_key = public_key;
        this.signature = signature;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(1);
        this.public_key.serialize(serializer);
        this.signature.serialize(serializer);
      }
      static load(deserializer) {
        const public_key = MultiEd25519PublicKey.deserialize(deserializer);
        const signature = MultiEd25519Signature.deserialize(deserializer);
        return new _AccountAuthenticatorMultiEd25519(public_key, signature);
      }
    };
    var Identifier = class _Identifier {
      constructor(value) {
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeStr(this.value);
      }
      static deserialize(deserializer) {
        const value = deserializer.deserializeStr();
        return new _Identifier(value);
      }
    };
    var TypeTag = class {
      static deserialize(deserializer) {
        const index = deserializer.deserializeUleb128AsU32();
        switch (index) {
          case 0:
            return TypeTagBool.load(deserializer);
          case 1:
            return TypeTagU8.load(deserializer);
          case 2:
            return TypeTagU64.load(deserializer);
          case 3:
            return TypeTagU128.load(deserializer);
          case 4:
            return TypeTagAddress.load(deserializer);
          case 5:
            return TypeTagSigner.load(deserializer);
          case 6:
            return TypeTagVector.load(deserializer);
          case 7:
            return TypeTagStruct.load(deserializer);
          case 8:
            return TypeTagU16.load(deserializer);
          case 9:
            return TypeTagU32.load(deserializer);
          case 10:
            return TypeTagU256.load(deserializer);
          default:
            throw new Error(`Unknown variant index for TypeTag: ${index}`);
        }
      }
    };
    var TypeTagBool = class _TypeTagBool extends TypeTag {
      serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
      }
      static load(_deserializer) {
        return new _TypeTagBool();
      }
    };
    var TypeTagU8 = class _TypeTagU8 extends TypeTag {
      serialize(serializer) {
        serializer.serializeU32AsUleb128(1);
      }
      static load(_deserializer) {
        return new _TypeTagU8();
      }
    };
    var TypeTagU16 = class _TypeTagU16 extends TypeTag {
      serialize(serializer) {
        serializer.serializeU32AsUleb128(8);
      }
      static load(_deserializer) {
        return new _TypeTagU16();
      }
    };
    var TypeTagU32 = class _TypeTagU32 extends TypeTag {
      serialize(serializer) {
        serializer.serializeU32AsUleb128(9);
      }
      static load(_deserializer) {
        return new _TypeTagU32();
      }
    };
    var TypeTagU64 = class _TypeTagU64 extends TypeTag {
      serialize(serializer) {
        serializer.serializeU32AsUleb128(2);
      }
      static load(_deserializer) {
        return new _TypeTagU64();
      }
    };
    var TypeTagU128 = class _TypeTagU128 extends TypeTag {
      serialize(serializer) {
        serializer.serializeU32AsUleb128(3);
      }
      static load(_deserializer) {
        return new _TypeTagU128();
      }
    };
    var TypeTagU256 = class _TypeTagU256 extends TypeTag {
      serialize(serializer) {
        serializer.serializeU32AsUleb128(10);
      }
      static load(_deserializer) {
        return new _TypeTagU256();
      }
    };
    var TypeTagAddress = class _TypeTagAddress extends TypeTag {
      serialize(serializer) {
        serializer.serializeU32AsUleb128(4);
      }
      static load(_deserializer) {
        return new _TypeTagAddress();
      }
    };
    var TypeTagSigner = class _TypeTagSigner extends TypeTag {
      serialize(serializer) {
        serializer.serializeU32AsUleb128(5);
      }
      static load(_deserializer) {
        return new _TypeTagSigner();
      }
    };
    var TypeTagVector = class _TypeTagVector extends TypeTag {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(6);
        this.value.serialize(serializer);
      }
      static load(deserializer) {
        const value = TypeTag.deserialize(deserializer);
        return new _TypeTagVector(value);
      }
    };
    var TypeTagStruct = class _TypeTagStruct extends TypeTag {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(7);
        this.value.serialize(serializer);
      }
      static load(deserializer) {
        const value = StructTag.deserialize(deserializer);
        return new _TypeTagStruct(value);
      }
      isStringTypeTag() {
        if (this.value.module_name.value === "string" && this.value.name.value === "String" && this.value.address.toHexString() === AccountAddress.CORE_CODE_ADDRESS.toHexString()) {
          return true;
        }
        return false;
      }
    };
    var StructTag = class _StructTag {
      constructor(address, module_name, name, type_args) {
        this.address = address;
        this.module_name = module_name;
        this.name = name;
        this.type_args = type_args;
      }
      /**
       * Converts a string literal to a StructTag
       * @param structTag String literal in format "AcountAddress::module_name::ResourceName",
       *   e.g. "0x1::aptos_coin::AptosCoin"
       * @returns
       */
      static fromString(structTag) {
        const typeTagStruct = new TypeTagParser(structTag).parseTypeTag();
        return new _StructTag(
          typeTagStruct.value.address,
          typeTagStruct.value.module_name,
          typeTagStruct.value.name,
          typeTagStruct.value.type_args
        );
      }
      serialize(serializer) {
        this.address.serialize(serializer);
        this.module_name.serialize(serializer);
        this.name.serialize(serializer);
        serializeVector(this.type_args, serializer);
      }
      static deserialize(deserializer) {
        const address = AccountAddress.deserialize(deserializer);
        const moduleName = Identifier.deserialize(deserializer);
        const name = Identifier.deserialize(deserializer);
        const typeArgs = deserializeVector(deserializer, TypeTag);
        return new _StructTag(address, moduleName, name, typeArgs);
      }
    };
    var stringStructTag = new StructTag(
      AccountAddress.fromHex("0x1"),
      new Identifier("string"),
      new Identifier("String"),
      []
    );
    function optionStructTag(typeArg) {
      return new StructTag(AccountAddress.fromHex("0x1"), new Identifier("option"), new Identifier("Option"), [typeArg]);
    }
    function objectStructTag(typeArg) {
      return new StructTag(AccountAddress.fromHex("0x1"), new Identifier("object"), new Identifier("Object"), [typeArg]);
    }
    function bail(message) {
      throw new TypeTagParserError(message);
    }
    function isWhiteSpace(c) {
      if (c.match(/\s/)) {
        return true;
      }
      return false;
    }
    function isValidAlphabetic(c) {
      if (c.match(/[_A-Za-z0-9]/g)) {
        return true;
      }
      return false;
    }
    function isGeneric(c) {
      if (c.match(/T\d+/g)) {
        return true;
      }
      return false;
    }
    function nextToken(tagStr, pos) {
      const c = tagStr[pos];
      if (c === ":") {
        if (tagStr.slice(pos, pos + 2) === "::") {
          return [["COLON", "::"], 2];
        }
        bail("Unrecognized token.");
      } else if (c === "<") {
        return [["LT", "<"], 1];
      } else if (c === ">") {
        return [["GT", ">"], 1];
      } else if (c === ",") {
        return [["COMMA", ","], 1];
      } else if (isWhiteSpace(c)) {
        let res = "";
        for (let i = pos; i < tagStr.length; i += 1) {
          const char = tagStr[i];
          if (isWhiteSpace(char)) {
            res = `${res}${char}`;
          } else {
            break;
          }
        }
        return [["SPACE", res], res.length];
      } else if (isValidAlphabetic(c)) {
        let res = "";
        for (let i = pos; i < tagStr.length; i += 1) {
          const char = tagStr[i];
          if (isValidAlphabetic(char)) {
            res = `${res}${char}`;
          } else {
            break;
          }
        }
        if (isGeneric(res)) {
          return [["GENERIC", res], res.length];
        }
        return [["IDENT", res], res.length];
      }
      throw new Error("Unrecognized token.");
    }
    function tokenize(tagStr) {
      let pos = 0;
      const tokens = [];
      while (pos < tagStr.length) {
        const [token, size] = nextToken(tagStr, pos);
        if (token[0] !== "SPACE") {
          tokens.push(token);
        }
        pos += size;
      }
      return tokens;
    }
    var TypeTagParser = class _TypeTagParser {
      constructor(tagStr, typeTags) {
        this.typeTags = [];
        this.tokens = tokenize(tagStr);
        this.typeTags = typeTags || [];
      }
      consume(targetToken) {
        const token = this.tokens.shift();
        if (!token || token[1] !== targetToken) {
          bail("Invalid type tag.");
        }
      }
      /**
       * Consumes all of an unused generic field, mostly applicable to object
       *
       * Note: This is recursive.  it can be problematic if there's bad input
       * @private
       */
      consumeWholeGeneric() {
        this.consume("<");
        while (this.tokens[0][1] !== ">") {
          if (this.tokens[0][1] === "<") {
            this.consumeWholeGeneric();
          } else {
            this.tokens.shift();
          }
        }
        this.consume(">");
      }
      parseCommaList(endToken, allowTraillingComma) {
        const res = [];
        if (this.tokens.length <= 0) {
          bail("Invalid type tag.");
        }
        while (this.tokens[0][1] !== endToken) {
          res.push(this.parseTypeTag());
          if (this.tokens.length > 0 && this.tokens[0][1] === endToken) {
            break;
          }
          this.consume(",");
          if (this.tokens.length > 0 && this.tokens[0][1] === endToken && allowTraillingComma) {
            break;
          }
          if (this.tokens.length <= 0) {
            bail("Invalid type tag.");
          }
        }
        return res;
      }
      parseTypeTag() {
        if (this.tokens.length === 0) {
          bail("Invalid type tag.");
        }
        const [tokenTy, tokenVal] = this.tokens.shift();
        if (tokenVal === "u8") {
          return new TypeTagU8();
        }
        if (tokenVal === "u16") {
          return new TypeTagU16();
        }
        if (tokenVal === "u32") {
          return new TypeTagU32();
        }
        if (tokenVal === "u64") {
          return new TypeTagU64();
        }
        if (tokenVal === "u128") {
          return new TypeTagU128();
        }
        if (tokenVal === "u256") {
          return new TypeTagU256();
        }
        if (tokenVal === "bool") {
          return new TypeTagBool();
        }
        if (tokenVal === "address") {
          return new TypeTagAddress();
        }
        if (tokenVal === "vector") {
          this.consume("<");
          const res = this.parseTypeTag();
          this.consume(">");
          return new TypeTagVector(res);
        }
        if (tokenVal === "string") {
          return new TypeTagStruct(stringStructTag);
        }
        if (tokenTy === "IDENT" && (tokenVal.startsWith("0x") || tokenVal.startsWith("0X"))) {
          const address = AccountAddress.fromHex(tokenVal);
          this.consume("::");
          const [moduleTokenTy, module2] = this.tokens.shift();
          if (moduleTokenTy !== "IDENT") {
            bail("Invalid type tag.");
          }
          this.consume("::");
          const [nameTokenTy, name] = this.tokens.shift();
          if (nameTokenTy !== "IDENT") {
            bail("Invalid type tag.");
          }
          if (AccountAddress.CORE_CODE_ADDRESS.toHexString() === address.toHexString() && module2 === "object" && name === "Object") {
            this.consumeWholeGeneric();
            return new TypeTagAddress();
          }
          let tyTags = [];
          if (this.tokens.length > 0 && this.tokens[0][1] === "<") {
            this.consume("<");
            tyTags = this.parseCommaList(">", true);
            this.consume(">");
          }
          const structTag = new StructTag(address, new Identifier(module2), new Identifier(name), tyTags);
          return new TypeTagStruct(structTag);
        }
        if (tokenTy === "GENERIC") {
          if (this.typeTags.length === 0) {
            bail("Can't convert generic type since no typeTags were specified.");
          }
          const idx = parseInt(tokenVal.substring(1), 10);
          return new _TypeTagParser(this.typeTags[idx]).parseTypeTag();
        }
        throw new Error("Invalid type tag.");
      }
    };
    var TypeTagParserError = class extends Error {
      constructor(message) {
        super(message);
        this.name = "TypeTagParserError";
      }
    };
    var RawTransaction = class _RawTransaction {
      /**
       * RawTransactions contain the metadata and payloads that can be submitted to Aptos chain for execution.
       * RawTransactions must be signed before Aptos chain can execute them.
       *
       * @param sender Account address of the sender.
       * @param sequence_number Sequence number of this transaction. This must match the sequence number stored in
       *   the sender's account at the time the transaction executes.
       * @param payload Instructions for the Aptos Blockchain, including publishing a module,
       *   execute a entry function or execute a script payload.
       * @param max_gas_amount Maximum total gas to spend for this transaction. The account must have more
       *   than this gas or the transaction will be discarded during validation.
       * @param gas_unit_price Price to be paid per gas unit.
       * @param expiration_timestamp_secs The blockchain timestamp at which the blockchain would discard this transaction.
       * @param chain_id The chain ID of the blockchain that this transaction is intended to be run on.
       */
      constructor(sender, sequence_number, payload, max_gas_amount, gas_unit_price, expiration_timestamp_secs, chain_id) {
        this.sender = sender;
        this.sequence_number = sequence_number;
        this.payload = payload;
        this.max_gas_amount = max_gas_amount;
        this.gas_unit_price = gas_unit_price;
        this.expiration_timestamp_secs = expiration_timestamp_secs;
        this.chain_id = chain_id;
      }
      serialize(serializer) {
        this.sender.serialize(serializer);
        serializer.serializeU64(this.sequence_number);
        this.payload.serialize(serializer);
        serializer.serializeU64(this.max_gas_amount);
        serializer.serializeU64(this.gas_unit_price);
        serializer.serializeU64(this.expiration_timestamp_secs);
        this.chain_id.serialize(serializer);
      }
      static deserialize(deserializer) {
        const sender = AccountAddress.deserialize(deserializer);
        const sequence_number = deserializer.deserializeU64();
        const payload = TransactionPayload.deserialize(deserializer);
        const max_gas_amount = deserializer.deserializeU64();
        const gas_unit_price = deserializer.deserializeU64();
        const expiration_timestamp_secs = deserializer.deserializeU64();
        const chain_id = ChainId.deserialize(deserializer);
        return new _RawTransaction(
          sender,
          sequence_number,
          payload,
          max_gas_amount,
          gas_unit_price,
          expiration_timestamp_secs,
          chain_id
        );
      }
    };
    var Script = class _Script {
      /**
       * Scripts contain the Move bytecodes payload that can be submitted to Aptos chain for execution.
       * @param code Move bytecode
       * @param ty_args Type arguments that bytecode requires.
       *
       * @example
       * A coin transfer function has one type argument "CoinType".
       * ```
       * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
       * ```
       * @param args Arugments to bytecode function.
       *
       * @example
       * A coin transfer function has three arugments "from", "to" and "amount".
       * ```
       * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
       * ```
       */
      constructor(code, ty_args, args) {
        this.code = code;
        this.ty_args = ty_args;
        this.args = args;
      }
      serialize(serializer) {
        serializer.serializeBytes(this.code);
        serializeVector(this.ty_args, serializer);
        serializeVector(this.args, serializer);
      }
      static deserialize(deserializer) {
        const code = deserializer.deserializeBytes();
        const ty_args = deserializeVector(deserializer, TypeTag);
        const args = deserializeVector(deserializer, TransactionArgument);
        return new _Script(code, ty_args, args);
      }
    };
    var EntryFunction = class _EntryFunction {
      /**
       * Contains the payload to run a function within a module.
       * @param module_name Fully qualified module name. ModuleId consists of account address and module name.
       * @param function_name The function to run.
       * @param ty_args Type arguments that move function requires.
       *
       * @example
       * A coin transfer function has one type argument "CoinType".
       * ```
       * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
       * ```
       * @param args Arugments to the move function.
       *
       * @example
       * A coin transfer function has three arugments "from", "to" and "amount".
       * ```
       * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
       * ```
       */
      constructor(module_name, function_name, ty_args, args) {
        this.module_name = module_name;
        this.function_name = function_name;
        this.ty_args = ty_args;
        this.args = args;
      }
      /**
       *
       * @param module Fully qualified module name in format "AccountAddress::module_name" e.g. "0x1::coin"
       * @param func Function name
       * @param ty_args Type arguments that move function requires.
       *
       * @example
       * A coin transfer function has one type argument "CoinType".
       * ```
       * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
       * ```
       * @param args Arugments to the move function.
       *
       * @example
       * A coin transfer function has three arugments "from", "to" and "amount".
       * ```
       * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
       * ```
       * @returns
       */
      static natural(module2, func, ty_args, args) {
        return new _EntryFunction(ModuleId.fromStr(module2), new Identifier(func), ty_args, args);
      }
      /**
       * `natual` is deprecated, please use `natural`
       *
       * @deprecated.
       */
      static natual(module2, func, ty_args, args) {
        return _EntryFunction.natural(module2, func, ty_args, args);
      }
      serialize(serializer) {
        this.module_name.serialize(serializer);
        this.function_name.serialize(serializer);
        serializeVector(this.ty_args, serializer);
        serializer.serializeU32AsUleb128(this.args.length);
        this.args.forEach((item) => {
          serializer.serializeBytes(item);
        });
      }
      static deserialize(deserializer) {
        const module_name = ModuleId.deserialize(deserializer);
        const function_name = Identifier.deserialize(deserializer);
        const ty_args = deserializeVector(deserializer, TypeTag);
        const length = deserializer.deserializeUleb128AsU32();
        const list = [];
        for (let i = 0; i < length; i += 1) {
          list.push(deserializer.deserializeBytes());
        }
        const args = list;
        return new _EntryFunction(module_name, function_name, ty_args, args);
      }
    };
    var MultiSigTransactionPayload = class _MultiSigTransactionPayload {
      /**
       * Contains the payload to run a multisig account transaction.
       * @param transaction_payload The payload of the multisig transaction. This can only be EntryFunction for now but
       * Script might be supported in the future.
       */
      constructor(transaction_payload) {
        this.transaction_payload = transaction_payload;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
        this.transaction_payload.serialize(serializer);
      }
      static deserialize(deserializer) {
        deserializer.deserializeUleb128AsU32();
        return new _MultiSigTransactionPayload(EntryFunction.deserialize(deserializer));
      }
    };
    var MultiSig = class _MultiSig {
      /**
       * Contains the payload to run a multisig account transaction.
       * @param multisig_address The multisig account address the transaction will be executed as.
       * @param transaction_payload The payload of the multisig transaction. This is optional when executing a multisig
       *  transaction whose payload is already stored on chain.
       */
      constructor(multisig_address, transaction_payload) {
        this.multisig_address = multisig_address;
        this.transaction_payload = transaction_payload;
      }
      serialize(serializer) {
        this.multisig_address.serialize(serializer);
        if (this.transaction_payload === void 0) {
          serializer.serializeBool(false);
        } else {
          serializer.serializeBool(true);
          this.transaction_payload.serialize(serializer);
        }
      }
      static deserialize(deserializer) {
        const multisig_address = AccountAddress.deserialize(deserializer);
        const payloadPresent = deserializer.deserializeBool();
        let transaction_payload;
        if (payloadPresent) {
          transaction_payload = MultiSigTransactionPayload.deserialize(deserializer);
        }
        return new _MultiSig(multisig_address, transaction_payload);
      }
    };
    var Module = class _Module {
      /**
       * Contains the bytecode of a Move module that can be published to the Aptos chain.
       * @param code Move bytecode of a module.
       */
      constructor(code) {
        this.code = code;
      }
      serialize(serializer) {
        serializer.serializeBytes(this.code);
      }
      static deserialize(deserializer) {
        const code = deserializer.deserializeBytes();
        return new _Module(code);
      }
    };
    var ModuleId = class _ModuleId {
      /**
       * Full name of a module.
       * @param address The account address.
       * @param name The name of the module under the account at "address".
       */
      constructor(address, name) {
        this.address = address;
        this.name = name;
      }
      /**
       * Converts a string literal to a ModuleId
       * @param moduleId String literal in format "AccountAddress::module_name", e.g. "0x1::coin"
       * @returns
       */
      static fromStr(moduleId) {
        const parts = moduleId.split("::");
        if (parts.length !== 2) {
          throw new Error("Invalid module id.");
        }
        return new _ModuleId(AccountAddress.fromHex(new HexString(parts[0])), new Identifier(parts[1]));
      }
      serialize(serializer) {
        this.address.serialize(serializer);
        this.name.serialize(serializer);
      }
      static deserialize(deserializer) {
        const address = AccountAddress.deserialize(deserializer);
        const name = Identifier.deserialize(deserializer);
        return new _ModuleId(address, name);
      }
    };
    var ChangeSet = class {
      serialize(serializer) {
        throw new Error("Not implemented.");
      }
      static deserialize(deserializer) {
        throw new Error("Not implemented.");
      }
    };
    var WriteSet = class {
      serialize(serializer) {
        throw new Error("Not implmented.");
      }
      static deserialize(deserializer) {
        throw new Error("Not implmented.");
      }
    };
    var SignedTransaction = class _SignedTransaction {
      /**
       * A SignedTransaction consists of a raw transaction and an authenticator. The authenticator
       * contains a client's public key and the signature of the raw transaction.
       *
       * @see {@link https://aptos.dev/guides/creating-a-signed-transaction/ | Creating a Signed Transaction}
       *
       * @param raw_txn
       * @param authenticator Contains a client's public key and the signature of the raw transaction.
       *   Authenticator has 3 flavors: single signature, multi-signature and multi-agent.
       *   @see authenticator.ts for details.
       */
      constructor(raw_txn, authenticator) {
        this.raw_txn = raw_txn;
        this.authenticator = authenticator;
      }
      serialize(serializer) {
        this.raw_txn.serialize(serializer);
        this.authenticator.serialize(serializer);
      }
      static deserialize(deserializer) {
        const raw_txn = RawTransaction.deserialize(deserializer);
        const authenticator = TransactionAuthenticator.deserialize(deserializer);
        return new _SignedTransaction(raw_txn, authenticator);
      }
    };
    var RawTransactionWithData = class {
      static deserialize(deserializer) {
        const index = deserializer.deserializeUleb128AsU32();
        switch (index) {
          case 0:
            return MultiAgentRawTransaction.load(deserializer);
          case 1:
            return FeePayerRawTransaction.load(deserializer);
          default:
            throw new Error(`Unknown variant index for RawTransactionWithData: ${index}`);
        }
      }
    };
    var MultiAgentRawTransaction = class _MultiAgentRawTransaction extends RawTransactionWithData {
      constructor(raw_txn, secondary_signer_addresses) {
        super();
        this.raw_txn = raw_txn;
        this.secondary_signer_addresses = secondary_signer_addresses;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
        this.raw_txn.serialize(serializer);
        serializeVector(this.secondary_signer_addresses, serializer);
      }
      static load(deserializer) {
        const rawTxn = RawTransaction.deserialize(deserializer);
        const secondarySignerAddresses = deserializeVector(deserializer, AccountAddress);
        return new _MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);
      }
    };
    var FeePayerRawTransaction = class _FeePayerRawTransaction extends RawTransactionWithData {
      constructor(raw_txn, secondary_signer_addresses, fee_payer_address) {
        super();
        this.raw_txn = raw_txn;
        this.secondary_signer_addresses = secondary_signer_addresses;
        this.fee_payer_address = fee_payer_address;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(1);
        this.raw_txn.serialize(serializer);
        serializeVector(this.secondary_signer_addresses, serializer);
        this.fee_payer_address.serialize(serializer);
      }
      static load(deserializer) {
        const rawTxn = RawTransaction.deserialize(deserializer);
        const secondarySignerAddresses = deserializeVector(deserializer, AccountAddress);
        const feePayerAddress = AccountAddress.deserialize(deserializer);
        return new _FeePayerRawTransaction(rawTxn, secondarySignerAddresses, feePayerAddress);
      }
    };
    var TransactionPayload = class {
      static deserialize(deserializer) {
        const index = deserializer.deserializeUleb128AsU32();
        switch (index) {
          case 0:
            return TransactionPayloadScript.load(deserializer);
          case 2:
            return TransactionPayloadEntryFunction.load(deserializer);
          case 3:
            return TransactionPayloadMultisig.load(deserializer);
          default:
            throw new Error(`Unknown variant index for TransactionPayload: ${index}`);
        }
      }
    };
    var TransactionPayloadScript = class _TransactionPayloadScript extends TransactionPayload {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
        this.value.serialize(serializer);
      }
      static load(deserializer) {
        const value = Script.deserialize(deserializer);
        return new _TransactionPayloadScript(value);
      }
    };
    var TransactionPayloadEntryFunction = class _TransactionPayloadEntryFunction extends TransactionPayload {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(2);
        this.value.serialize(serializer);
      }
      static load(deserializer) {
        const value = EntryFunction.deserialize(deserializer);
        return new _TransactionPayloadEntryFunction(value);
      }
    };
    var TransactionPayloadMultisig = class _TransactionPayloadMultisig extends TransactionPayload {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(3);
        this.value.serialize(serializer);
      }
      static load(deserializer) {
        const value = MultiSig.deserialize(deserializer);
        return new _TransactionPayloadMultisig(value);
      }
    };
    var ChainId = class _ChainId {
      constructor(value) {
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU8(this.value);
      }
      static deserialize(deserializer) {
        const value = deserializer.deserializeU8();
        return new _ChainId(value);
      }
    };
    var TransactionArgument = class {
      static deserialize(deserializer) {
        const index = deserializer.deserializeUleb128AsU32();
        switch (index) {
          case 0:
            return TransactionArgumentU8.load(deserializer);
          case 1:
            return TransactionArgumentU64.load(deserializer);
          case 2:
            return TransactionArgumentU128.load(deserializer);
          case 3:
            return TransactionArgumentAddress.load(deserializer);
          case 4:
            return TransactionArgumentU8Vector.load(deserializer);
          case 5:
            return TransactionArgumentBool.load(deserializer);
          case 6:
            return TransactionArgumentU16.load(deserializer);
          case 7:
            return TransactionArgumentU32.load(deserializer);
          case 8:
            return TransactionArgumentU256.load(deserializer);
          default:
            throw new Error(`Unknown variant index for TransactionArgument: ${index}`);
        }
      }
    };
    var TransactionArgumentU8 = class _TransactionArgumentU8 extends TransactionArgument {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
        serializer.serializeU8(this.value);
      }
      static load(deserializer) {
        const value = deserializer.deserializeU8();
        return new _TransactionArgumentU8(value);
      }
    };
    var TransactionArgumentU16 = class _TransactionArgumentU16 extends TransactionArgument {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(6);
        serializer.serializeU16(this.value);
      }
      static load(deserializer) {
        const value = deserializer.deserializeU16();
        return new _TransactionArgumentU16(value);
      }
    };
    var TransactionArgumentU32 = class _TransactionArgumentU32 extends TransactionArgument {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(7);
        serializer.serializeU32(this.value);
      }
      static load(deserializer) {
        const value = deserializer.deserializeU32();
        return new _TransactionArgumentU32(value);
      }
    };
    var TransactionArgumentU64 = class _TransactionArgumentU64 extends TransactionArgument {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(1);
        serializer.serializeU64(this.value);
      }
      static load(deserializer) {
        const value = deserializer.deserializeU64();
        return new _TransactionArgumentU64(value);
      }
    };
    var TransactionArgumentU128 = class _TransactionArgumentU128 extends TransactionArgument {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(2);
        serializer.serializeU128(this.value);
      }
      static load(deserializer) {
        const value = deserializer.deserializeU128();
        return new _TransactionArgumentU128(value);
      }
    };
    var TransactionArgumentU256 = class _TransactionArgumentU256 extends TransactionArgument {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(8);
        serializer.serializeU256(this.value);
      }
      static load(deserializer) {
        const value = deserializer.deserializeU256();
        return new _TransactionArgumentU256(value);
      }
    };
    var TransactionArgumentAddress = class _TransactionArgumentAddress extends TransactionArgument {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(3);
        this.value.serialize(serializer);
      }
      static load(deserializer) {
        const value = AccountAddress.deserialize(deserializer);
        return new _TransactionArgumentAddress(value);
      }
    };
    var TransactionArgumentU8Vector = class _TransactionArgumentU8Vector extends TransactionArgument {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(4);
        serializer.serializeBytes(this.value);
      }
      static load(deserializer) {
        const value = deserializer.deserializeBytes();
        return new _TransactionArgumentU8Vector(value);
      }
    };
    var TransactionArgumentBool = class _TransactionArgumentBool extends TransactionArgument {
      constructor(value) {
        super();
        this.value = value;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(5);
        serializer.serializeBool(this.value);
      }
      static load(deserializer) {
        const value = deserializer.deserializeBool();
        return new _TransactionArgumentBool(value);
      }
    };
    var Transaction = class {
      getHashSalt() {
        const hash = import_sha3.sha3_256.create();
        hash.update("APTOS::Transaction");
        return hash.digest();
      }
      static deserialize(deserializer) {
        const index = deserializer.deserializeUleb128AsU32();
        switch (index) {
          case 0:
            return UserTransaction.load(deserializer);
          default:
            throw new Error(`Unknown variant index for Transaction: ${index}`);
        }
      }
    };
    var UserTransaction = class _UserTransaction extends Transaction {
      constructor(value) {
        super();
        this.value = value;
      }
      hash() {
        const hash = import_sha3.sha3_256.create();
        hash.update(this.getHashSalt());
        hash.update(bcsToBytes(this));
        return hash.digest();
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
        this.value.serialize(serializer);
      }
      static load(deserializer) {
        return new _UserTransaction(SignedTransaction.deserialize(deserializer));
      }
    };
    var TypeArgumentABI = class _TypeArgumentABI {
      /**
       * Constructs a TypeArgumentABI instance.
       * @param name
       */
      constructor(name) {
        this.name = name;
      }
      serialize(serializer) {
        serializer.serializeStr(this.name);
      }
      static deserialize(deserializer) {
        const name = deserializer.deserializeStr();
        return new _TypeArgumentABI(name);
      }
    };
    var ArgumentABI = class _ArgumentABI {
      /**
       * Constructs an ArgumentABI instance.
       * @param name
       * @param type_tag
       */
      constructor(name, type_tag) {
        this.name = name;
        this.type_tag = type_tag;
      }
      serialize(serializer) {
        serializer.serializeStr(this.name);
        this.type_tag.serialize(serializer);
      }
      static deserialize(deserializer) {
        const name = deserializer.deserializeStr();
        const typeTag = TypeTag.deserialize(deserializer);
        return new _ArgumentABI(name, typeTag);
      }
    };
    var ScriptABI = class {
      static deserialize(deserializer) {
        const index = deserializer.deserializeUleb128AsU32();
        switch (index) {
          case 0:
            return TransactionScriptABI.load(deserializer);
          case 1:
            return EntryFunctionABI.load(deserializer);
          default:
            throw new Error(`Unknown variant index for TransactionPayload: ${index}`);
        }
      }
    };
    var TransactionScriptABI = class _TransactionScriptABI extends ScriptABI {
      /**
       * Constructs a TransactionScriptABI instance.
       * @param name Entry function name
       * @param doc
       * @param code
       * @param ty_args
       * @param args
       */
      constructor(name, doc, code, ty_args, args) {
        super();
        this.name = name;
        this.doc = doc;
        this.code = code;
        this.ty_args = ty_args;
        this.args = args;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(0);
        serializer.serializeStr(this.name);
        serializer.serializeStr(this.doc);
        serializer.serializeBytes(this.code);
        serializeVector(this.ty_args, serializer);
        serializeVector(this.args, serializer);
      }
      static load(deserializer) {
        const name = deserializer.deserializeStr();
        const doc = deserializer.deserializeStr();
        const code = deserializer.deserializeBytes();
        const tyArgs = deserializeVector(deserializer, TypeArgumentABI);
        const args = deserializeVector(deserializer, ArgumentABI);
        return new _TransactionScriptABI(name, doc, code, tyArgs, args);
      }
    };
    var EntryFunctionABI = class _EntryFunctionABI extends ScriptABI {
      /**
       * Constructs a EntryFunctionABI instance
       * @param name
       * @param module_name Fully qualified module id
       * @param doc
       * @param ty_args
       * @param args
       */
      constructor(name, module_name, doc, ty_args, args) {
        super();
        this.name = name;
        this.module_name = module_name;
        this.doc = doc;
        this.ty_args = ty_args;
        this.args = args;
      }
      serialize(serializer) {
        serializer.serializeU32AsUleb128(1);
        serializer.serializeStr(this.name);
        this.module_name.serialize(serializer);
        serializer.serializeStr(this.doc);
        serializeVector(this.ty_args, serializer);
        serializeVector(this.args, serializer);
      }
      static load(deserializer) {
        const name = deserializer.deserializeStr();
        const moduleName = ModuleId.deserialize(deserializer);
        const doc = deserializer.deserializeStr();
        const tyArgs = deserializeVector(deserializer, TypeArgumentABI);
        const args = deserializeVector(deserializer, ArgumentABI);
        return new _EntryFunctionABI(name, moduleName, doc, tyArgs, args);
      }
    };
    var import_sha32 = require_sha3();
    var _AuthenticationKey = class _AuthenticationKey2 {
      constructor(bytes) {
        if (bytes.length !== _AuthenticationKey2.LENGTH) {
          throw new Error("Expected a byte array of length 32");
        }
        this.bytes = bytes;
      }
      /**
       * Converts a K-of-N MultiEd25519PublicKey to AuthenticationKey with:
       * `auth_key = sha3-256(p_1 | … | p_n | K | 0x01)`. `K` represents the K-of-N required for
       * authenticating the transaction. `0x01` is the 1-byte scheme for multisig.
       */
      static fromMultiEd25519PublicKey(publicKey) {
        const pubKeyBytes = publicKey.toBytes();
        const bytes = new Uint8Array(pubKeyBytes.length + 1);
        bytes.set(pubKeyBytes);
        bytes.set([_AuthenticationKey2.MULTI_ED25519_SCHEME], pubKeyBytes.length);
        const hash = import_sha32.sha3_256.create();
        hash.update(bytes);
        return new _AuthenticationKey2(hash.digest());
      }
      static fromEd25519PublicKey(publicKey) {
        const pubKeyBytes = publicKey.value;
        const bytes = new Uint8Array(pubKeyBytes.length + 1);
        bytes.set(pubKeyBytes);
        bytes.set([_AuthenticationKey2.ED25519_SCHEME], pubKeyBytes.length);
        const hash = import_sha32.sha3_256.create();
        hash.update(bytes);
        return new _AuthenticationKey2(hash.digest());
      }
      /**
       * Derives an account address from AuthenticationKey. Since current AccountAddress is 32 bytes,
       * AuthenticationKey bytes are directly translated to AccountAddress.
       */
      derivedAddress() {
        return HexString.fromUint8Array(this.bytes);
      }
    };
    _AuthenticationKey.LENGTH = 32;
    _AuthenticationKey.MULTI_ED25519_SCHEME = 1;
    _AuthenticationKey.ED25519_SCHEME = 0;
    _AuthenticationKey.DERIVE_RESOURCE_ACCOUNT_SCHEME = 255;
    var AuthenticationKey = _AuthenticationKey;
    var RotationProofChallenge = class {
      constructor(accountAddress, moduleName, structName, sequenceNumber, originator, currentAuthKey, newPublicKey) {
        this.accountAddress = accountAddress;
        this.moduleName = moduleName;
        this.structName = structName;
        this.sequenceNumber = sequenceNumber;
        this.originator = originator;
        this.currentAuthKey = currentAuthKey;
        this.newPublicKey = newPublicKey;
      }
      serialize(serializer) {
        this.accountAddress.serialize(serializer);
        serializer.serializeStr(this.moduleName);
        serializer.serializeStr(this.structName);
        serializer.serializeU64(this.sequenceNumber);
        this.originator.serialize(serializer);
        this.currentAuthKey.serialize(serializer);
        serializer.serializeBytes(this.newPublicKey);
      }
    };
    var _AptosAccount = class _AptosAccount2 {
      static fromAptosAccountObject(obj) {
        return new _AptosAccount2(HexString.ensure(obj.privateKeyHex).toUint8Array(), obj.address);
      }
      /**
       * Check's if the derive path is valid
       */
      static isValidPath(path) {
        return /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'+$/.test(path);
      }
      /**
       * Creates new account with bip44 path and mnemonics,
       * @param path. (e.g. m/44'/637'/0'/0'/0')
       * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
       * @param mnemonics.
       * @returns AptosAccount
       */
      static fromDerivePath(path, mnemonics) {
        if (!_AptosAccount2.isValidPath(path)) {
          throw new Error("Invalid derivation path");
        }
        const normalizeMnemonics = mnemonics.trim().split(/\s+/).map((part) => part.toLowerCase()).join(" ");
        const { key } = derivePath(path, (0, import_utils6.bytesToHex)(bip39.mnemonicToSeedSync(normalizeMnemonics)));
        return new _AptosAccount2(key);
      }
      /**
       * Creates new account instance. Constructor allows passing in an address,
       * to handle account key rotation, where auth_key != public_key
       * @param privateKeyBytes  Private key from which account key pair will be generated.
       * If not specified, new key pair is going to be created.
       * @param address Account address (e.g. 0xe8012714cd17606cee7188a2a365eef3fe760be598750678c8c5954eb548a591).
       * If not specified, a new one will be generated from public key
       */
      constructor(privateKeyBytes, address) {
        if (privateKeyBytes) {
          this.signingKey = import_tweetnacl2.default.sign.keyPair.fromSeed(privateKeyBytes.slice(0, 32));
        } else {
          this.signingKey = import_tweetnacl2.default.sign.keyPair();
        }
        this.accountAddress = HexString.ensure(address || this.authKey().hex());
      }
      /**
       * This is the key by which Aptos account is referenced.
       * It is the 32-byte of the SHA-3 256 cryptographic hash
       * of the public key(s) concatenated with a signature scheme identifier byte
       * @returns Address associated with the given account
       */
      address() {
        return this.accountAddress;
      }
      authKey() {
        const pubKey = new Ed25519PublicKey(this.signingKey.publicKey);
        const authKey = AuthenticationKey.fromEd25519PublicKey(pubKey);
        return authKey.derivedAddress();
      }
      /**
       * Takes source address and seeds and returns the resource account address
       * @param sourceAddress Address used to derive the resource account
       * @param seed The seed bytes
       * @returns The resource account address
       */
      static getResourceAccountAddress(sourceAddress, seed) {
        const source = bcsToBytes(AccountAddress.fromHex(sourceAddress));
        const bytes = new Uint8Array([...source, ...seed, AuthenticationKey.DERIVE_RESOURCE_ACCOUNT_SCHEME]);
        const hash = import_sha33.sha3_256.create();
        hash.update(bytes);
        return HexString.fromUint8Array(hash.digest());
      }
      /**
       * Takes creator address and collection name and returns the collection id hash.
       * Collection id hash are generated as sha256 hash of (`creator_address::collection_name`)
       *
       * @param creatorAddress Collection creator address
       * @param collectionName The collection name
       * @returns The collection id hash
       */
      static getCollectionID(creatorAddress, collectionName) {
        const seed = new TextEncoder().encode(`${creatorAddress}::${collectionName}`);
        const hash = import_sha256.sha256.create();
        hash.update(seed);
        return HexString.fromUint8Array(hash.digest());
      }
      /**
       * This key is generated with Ed25519 scheme.
       * Public key is used to check a signature of transaction, signed by given account
       * @returns The public key for the associated account
       */
      pubKey() {
        return HexString.fromUint8Array(this.signingKey.publicKey);
      }
      /**
       * Signs specified `buffer` with account's private key
       * @param buffer A buffer to sign
       * @returns A signature HexString
       */
      signBuffer(buffer) {
        const signature = import_tweetnacl2.default.sign.detached(buffer, this.signingKey.secretKey);
        return HexString.fromUint8Array(signature);
      }
      /**
       * Signs specified `hexString` with account's private key
       * @param hexString A regular string or HexString to sign
       * @returns A signature HexString
       */
      signHexString(hexString) {
        const toSign = HexString.ensure(hexString).toUint8Array();
        return this.signBuffer(toSign);
      }
      /**
       * Verifies the signature of the message with the public key of the account
       * @param message a signed message
       * @param signature the signature of the message
       */
      verifySignature(message, signature) {
        const rawMessage = HexString.ensure(message).toUint8Array();
        const rawSignature = HexString.ensure(signature).toUint8Array();
        return import_tweetnacl2.default.sign.detached.verify(rawMessage, rawSignature, this.signingKey.publicKey);
      }
      /**
       * Derives account address, public key and private key
       * @returns AptosAccountObject instance.
       * @example An example of the returned AptosAccountObject object
       * ```
       * {
       *    address: "0xe8012714cd17606cee7188a2a365eef3fe760be598750678c8c5954eb548a591",
       *    publicKeyHex: "0xf56d8524faf79fbc0f48c13aeed3b0ce5dd376b4db93b8130a107c0a5e04ba04",
       *    privateKeyHex: `0x009c9f7c992a06cfafe916f125d8adb7a395fca243e264a8e56a4b3e6accf940
       *      d2b11e9ece3049ce60e3c7b4a1c58aebfa9298e29a30a58a67f1998646135204`
       * }
       * ```
       */
      toPrivateKeyObject() {
        return {
          address: this.address().hex(),
          publicKeyHex: this.pubKey().hex(),
          privateKeyHex: HexString.fromUint8Array(this.signingKey.secretKey.slice(0, 32)).hex()
        };
      }
    };
    __decorateClass([
      Memoize()
    ], _AptosAccount.prototype, "authKey", 1);
    var AptosAccount = _AptosAccount;
    function getAddressFromAccountOrAddress(accountOrAddress) {
      return accountOrAddress instanceof AptosAccount ? accountOrAddress.address() : HexString.ensure(accountOrAddress);
    }
    var CurrentTokenOwnershipFieldsFragmentDoc = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
    var TokenDataFieldsFragmentDoc = `
    fragment TokenDataFields on current_token_datas {
  creator_address
  collection_name
  description
  metadata_uri
  name
  token_data_id_hash
  collection_data_id_hash
}
    `;
    var CollectionDataFieldsFragmentDoc = `
    fragment CollectionDataFields on current_collection_datas {
  metadata_uri
  supply
  description
  collection_name
  collection_data_id_hash
  table_handle
  creator_address
}
    `;
    var TokenActivitiesFieldsFragmentDoc = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
    var GetAccountCoinsDataCount = `
    query getAccountCoinsDataCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
    var GetAccountCoinsData = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
    var GetAccountCurrentTokens = `
    query getAccountCurrentTokens($address: String!, $offset: Int, $limit: Int) {
  current_token_ownerships(
    where: {owner_address: {_eq: $address}, amount: {_gt: 0}}
    order_by: [{last_transaction_version: desc}, {creator_address: asc}, {collection_name: asc}, {name: asc}]
    offset: $offset
    limit: $limit
  ) {
    amount
    current_token_data {
      ...TokenDataFields
    }
    current_collection_data {
      ...CollectionDataFields
    }
    last_transaction_version
    property_version
  }
}
    ${TokenDataFieldsFragmentDoc}
${CollectionDataFieldsFragmentDoc}`;
    var GetAccountTokensCount = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
    var GetAccountTransactionsCount = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
    var GetAccountTransactionsData = `
    query getAccountTransactionsData($where_condition: account_transactions_bool_exp!, $offset: Int, $limit: Int, $order_by: [account_transactions_order_by!]) {
  account_transactions(
    where: $where_condition
    order_by: $order_by
    limit: $limit
    offset: $offset
  ) {
    token_activities_v2 {
      ...TokenActivitiesFields
    }
    transaction_version
    account_address
  }
}
    ${TokenActivitiesFieldsFragmentDoc}`;
    var GetCollectionData = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collections_v2_order_by!]) {
  current_collections_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    max_supply
    mutable_description
    mutable_uri
    table_handle_v1
    token_standard
    total_minted_v2
    uri
  }
}
    `;
    var GetCollectionsWithOwnedTokens = `
    query getCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
    var GetCurrentObjects = `
    query getCurrentObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
    var GetDelegatedStakingActivities = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
    var GetIndexerLedgerInfo = `
    query getIndexerLedgerInfo {
  ledger_infos {
    chain_id
  }
}
    `;
    var GetNumberOfDelegators = `
    query getNumberOfDelegators($poolAddress: String) {
  num_active_delegator_per_pool(
    where: {pool_address: {_eq: $poolAddress}, num_active_delegator: {_gt: "0"}}
    distinct_on: pool_address
  ) {
    num_active_delegator
    pool_address
  }
}
    `;
    var GetOwnedTokens = `
    query getOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
    var GetOwnedTokensByTokenData = `
    query getOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
    var GetTokenActivities = `
    query getTokenActivities($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${TokenActivitiesFieldsFragmentDoc}`;
    var GetTokenActivitiesCount = `
    query getTokenActivitiesCount($token_id: String) {
  token_activities_v2_aggregate(where: {token_data_id: {_eq: $token_id}}) {
    aggregate {
      count
    }
  }
}
    `;
    var GetTokenCurrentOwnerData = `
    query getTokenCurrentOwnerData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
    var GetTokenData = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
    var GetTokenOwnedFromCollection = `
    query getTokenOwnedFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
    var GetTokenOwnersData = `
    query getTokenOwnersData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
    var GetTopUserTransactions = `
    query getTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
    var GetUserTransactions = `
    query getUserTransactions($where_condition: user_transactions_bool_exp!, $offset: Int, $limit: Int, $order_by: [user_transactions_order_by!]) {
  user_transactions(
    order_by: $order_by
    where: $where_condition
    limit: $limit
    offset: $offset
  ) {
    version
  }
}
    `;
    var import_sha34 = require_sha3();
    function assertType(val, types, message) {
      if (!(types == null ? void 0 : types.includes(typeof val))) {
        throw new Error(
          message || `Invalid arg: ${val} type should be ${types instanceof Array ? types.join(" or ") : types}`
        );
      }
    }
    function ensureBoolean(val) {
      assertType(val, ["boolean", "string"]);
      if (typeof val === "boolean") {
        return val;
      }
      if (val === "true") {
        return true;
      }
      if (val === "false") {
        return false;
      }
      throw new Error("Invalid boolean string.");
    }
    function ensureNumber(val) {
      assertType(val, ["number", "string"]);
      if (typeof val === "number") {
        return val;
      }
      const res = Number.parseInt(val, 10);
      if (Number.isNaN(res)) {
        throw new Error("Invalid number string.");
      }
      return res;
    }
    function ensureBigInt(val) {
      assertType(val, ["number", "bigint", "string"]);
      return BigInt(val);
    }
    function serializeArg(argVal, argType, serializer) {
      serializeArgInner(argVal, argType, serializer, 0);
    }
    function serializeArgInner(argVal, argType, serializer, depth) {
      if (argType instanceof TypeTagBool) {
        serializer.serializeBool(ensureBoolean(argVal));
      } else if (argType instanceof TypeTagU8) {
        serializer.serializeU8(ensureNumber(argVal));
      } else if (argType instanceof TypeTagU16) {
        serializer.serializeU16(ensureNumber(argVal));
      } else if (argType instanceof TypeTagU32) {
        serializer.serializeU32(ensureNumber(argVal));
      } else if (argType instanceof TypeTagU64) {
        serializer.serializeU64(ensureBigInt(argVal));
      } else if (argType instanceof TypeTagU128) {
        serializer.serializeU128(ensureBigInt(argVal));
      } else if (argType instanceof TypeTagU256) {
        serializer.serializeU256(ensureBigInt(argVal));
      } else if (argType instanceof TypeTagAddress) {
        serializeAddress(argVal, serializer);
      } else if (argType instanceof TypeTagVector) {
        serializeVector2(argVal, argType, serializer, depth);
      } else if (argType instanceof TypeTagStruct) {
        serializeStruct(argVal, argType, serializer, depth);
      } else {
        throw new Error("Unsupported arg type.");
      }
    }
    function serializeAddress(argVal, serializer) {
      let addr;
      if (typeof argVal === "string" || argVal instanceof HexString) {
        addr = AccountAddress.fromHex(argVal);
      } else if (argVal instanceof AccountAddress) {
        addr = argVal;
      } else {
        throw new Error("Invalid account address.");
      }
      addr.serialize(serializer);
    }
    function serializeVector2(argVal, argType, serializer, depth) {
      if (argType.value instanceof TypeTagU8) {
        if (argVal instanceof Uint8Array) {
          serializer.serializeBytes(argVal);
          return;
        }
        if (argVal instanceof HexString) {
          serializer.serializeBytes(argVal.toUint8Array());
          return;
        }
        if (typeof argVal === "string") {
          serializer.serializeStr(argVal);
          return;
        }
      }
      if (!Array.isArray(argVal)) {
        throw new Error("Invalid vector args.");
      }
      serializer.serializeU32AsUleb128(argVal.length);
      argVal.forEach((arg) => serializeArgInner(arg, argType.value, serializer, depth + 1));
    }
    function serializeStruct(argVal, argType, serializer, depth) {
      const { address, module_name: moduleName, name, type_args: typeArgs } = argType.value;
      const structType = `${HexString.fromUint8Array(address.address).toShortString()}::${moduleName.value}::${name.value}`;
      if (structType === "0x1::string::String") {
        assertType(argVal, ["string"]);
        serializer.serializeStr(argVal);
      } else if (structType === "0x1::object::Object") {
        serializeAddress(argVal, serializer);
      } else if (structType === "0x1::option::Option") {
        if (typeArgs.length !== 1) {
          throw new Error(`Option has the wrong number of type arguments ${typeArgs.length}`);
        }
        serializeOption(argVal, typeArgs[0], serializer, depth);
      } else {
        throw new Error("Unsupported struct type in function argument");
      }
    }
    function serializeOption(argVal, argType, serializer, depth) {
      if (argVal === void 0 || argVal === null) {
        serializer.serializeU32AsUleb128(0);
      } else {
        serializer.serializeU32AsUleb128(1);
        serializeArgInner(argVal, argType, serializer, depth + 1);
      }
    }
    function argToTransactionArgument(argVal, argType) {
      if (argType instanceof TypeTagBool) {
        return new TransactionArgumentBool(ensureBoolean(argVal));
      }
      if (argType instanceof TypeTagU8) {
        return new TransactionArgumentU8(ensureNumber(argVal));
      }
      if (argType instanceof TypeTagU16) {
        return new TransactionArgumentU16(ensureNumber(argVal));
      }
      if (argType instanceof TypeTagU32) {
        return new TransactionArgumentU32(ensureNumber(argVal));
      }
      if (argType instanceof TypeTagU64) {
        return new TransactionArgumentU64(ensureBigInt(argVal));
      }
      if (argType instanceof TypeTagU128) {
        return new TransactionArgumentU128(ensureBigInt(argVal));
      }
      if (argType instanceof TypeTagU256) {
        return new TransactionArgumentU256(ensureBigInt(argVal));
      }
      if (argType instanceof TypeTagAddress) {
        let addr;
        if (typeof argVal === "string" || argVal instanceof HexString) {
          addr = AccountAddress.fromHex(argVal);
        } else if (argVal instanceof AccountAddress) {
          addr = argVal;
        } else {
          throw new Error("Invalid account address.");
        }
        return new TransactionArgumentAddress(addr);
      }
      if (argType instanceof TypeTagVector && argType.value instanceof TypeTagU8) {
        if (!(argVal instanceof Uint8Array)) {
          throw new Error(`${argVal} should be an instance of Uint8Array`);
        }
        return new TransactionArgumentU8Vector(argVal);
      }
      throw new Error("Unknown type for TransactionArgument.");
    }
    var RAW_TRANSACTION_SALT = "APTOS::RawTransaction";
    var RAW_TRANSACTION_WITH_DATA_SALT = "APTOS::RawTransactionWithData";
    var TransactionBuilder = class {
      constructor(signingFunction, rawTxnBuilder) {
        this.rawTxnBuilder = rawTxnBuilder;
        this.signingFunction = signingFunction;
      }
      /**
       * Builds a RawTransaction. Relays the call to TransactionBuilderABI.build
       * @param func
       * @param ty_tags
       * @param args
       */
      build(func, ty_tags, args) {
        if (!this.rawTxnBuilder) {
          throw new Error("this.rawTxnBuilder doesn't exist.");
        }
        return this.rawTxnBuilder.build(func, ty_tags, args);
      }
      /** Generates a Signing Message out of a raw transaction. */
      static getSigningMessage(rawTxn) {
        const hash = import_sha34.sha3_256.create();
        if (rawTxn instanceof RawTransaction) {
          hash.update(RAW_TRANSACTION_SALT);
        } else if (rawTxn instanceof MultiAgentRawTransaction) {
          hash.update(RAW_TRANSACTION_WITH_DATA_SALT);
        } else if (rawTxn instanceof FeePayerRawTransaction) {
          hash.update(RAW_TRANSACTION_WITH_DATA_SALT);
        } else {
          throw new Error("Unknown transaction type.");
        }
        const prefix = hash.digest();
        const body = bcsToBytes(rawTxn);
        const mergedArray = new Uint8Array(prefix.length + body.length);
        mergedArray.set(prefix);
        mergedArray.set(body, prefix.length);
        return mergedArray;
      }
    };
    var TransactionBuilderEd25519 = class extends TransactionBuilder {
      constructor(signingFunction, publicKey, rawTxnBuilder) {
        super(signingFunction, rawTxnBuilder);
        this.publicKey = publicKey;
      }
      rawToSigned(rawTxn) {
        const signingMessage = TransactionBuilder.getSigningMessage(rawTxn);
        const signature = this.signingFunction(signingMessage);
        const authenticator = new TransactionAuthenticatorEd25519(
          new Ed25519PublicKey(this.publicKey),
          signature
        );
        return new SignedTransaction(rawTxn, authenticator);
      }
      /** Signs a raw transaction and returns a bcs serialized transaction. */
      sign(rawTxn) {
        return bcsToBytes(this.rawToSigned(rawTxn));
      }
    };
    var TransactionBuilderMultiEd25519 = class extends TransactionBuilder {
      constructor(signingFunction, publicKey) {
        super(signingFunction);
        this.publicKey = publicKey;
      }
      rawToSigned(rawTxn) {
        const signingMessage = TransactionBuilder.getSigningMessage(rawTxn);
        const signature = this.signingFunction(signingMessage);
        const authenticator = new TransactionAuthenticatorMultiEd25519(this.publicKey, signature);
        return new SignedTransaction(rawTxn, authenticator);
      }
      /** Signs a raw transaction and returns a bcs serialized transaction. */
      sign(rawTxn) {
        return bcsToBytes(this.rawToSigned(rawTxn));
      }
    };
    var TransactionBuilderABI = class _TransactionBuilderABI {
      /**
       * Constructs a TransactionBuilderABI instance
       * @param abis List of binary ABIs.
       * @param builderConfig Configs for creating a raw transaction.
       */
      constructor(abis, builderConfig) {
        this.abiMap = /* @__PURE__ */ new Map();
        abis.forEach((abi) => {
          const deserializer = new Deserializer(abi);
          const scriptABI = ScriptABI.deserialize(deserializer);
          let k;
          if (scriptABI instanceof EntryFunctionABI) {
            const funcABI = scriptABI;
            const { address: addr, name: moduleName } = funcABI.module_name;
            k = `${HexString.fromUint8Array(addr.address).toShortString()}::${moduleName.value}::${funcABI.name}`;
          } else {
            const funcABI = scriptABI;
            k = funcABI.name;
          }
          if (this.abiMap.has(k)) {
            throw new Error("Found conflicting ABI interfaces");
          }
          this.abiMap.set(k, scriptABI);
        });
        this.builderConfig = {
          maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),
          expSecFromNow: DEFAULT_TXN_EXP_SEC_FROM_NOW,
          ...builderConfig
        };
      }
      static toBCSArgs(abiArgs, args) {
        if (abiArgs.length !== args.length) {
          throw new Error("Wrong number of args provided.");
        }
        return args.map((arg, i) => {
          const serializer = new Serializer();
          serializeArg(arg, abiArgs[i].type_tag, serializer);
          return serializer.getBytes();
        });
      }
      static toTransactionArguments(abiArgs, args) {
        if (abiArgs.length !== args.length) {
          throw new Error("Wrong number of args provided.");
        }
        return args.map((arg, i) => argToTransactionArgument(arg, abiArgs[i].type_tag));
      }
      setSequenceNumber(seqNumber) {
        this.builderConfig.sequenceNumber = BigInt(seqNumber);
      }
      /**
       * Builds a TransactionPayload. For dApps, chain ID and account sequence numbers are only known to the wallet.
       * Instead of building a RawTransaction (requires chainID and sequenceNumber), dApps can build a TransactionPayload
       * and pass the payload to the wallet for signing and sending.
       * @param func Fully qualified func names, e.g. 0x1::aptos_account::transfer
       * @param ty_tags TypeTag strings
       * @param args Function arguments
       * @returns TransactionPayload
       */
      buildTransactionPayload(func, ty_tags, args) {
        const typeTags = ty_tags.map((ty_arg) => new TypeTagParser(ty_arg).parseTypeTag());
        let payload;
        if (!this.abiMap.has(func)) {
          throw new Error(`Cannot find function: ${func}`);
        }
        const scriptABI = this.abiMap.get(func);
        if (scriptABI instanceof EntryFunctionABI) {
          const funcABI = scriptABI;
          const bcsArgs = _TransactionBuilderABI.toBCSArgs(funcABI.args, args);
          payload = new TransactionPayloadEntryFunction(
            new EntryFunction(funcABI.module_name, new Identifier(funcABI.name), typeTags, bcsArgs)
          );
        } else if (scriptABI instanceof TransactionScriptABI) {
          const funcABI = scriptABI;
          const scriptArgs = _TransactionBuilderABI.toTransactionArguments(funcABI.args, args);
          payload = new TransactionPayloadScript(new Script(funcABI.code, typeTags, scriptArgs));
        } else {
          throw new Error("Unknown ABI format.");
        }
        return payload;
      }
      /**
       * Builds a RawTransaction
       * @param func Fully qualified func names, e.g. 0x1::aptos_account::transfer
       * @param ty_tags TypeTag strings.
       * @example Below are valid value examples
       * ```
       * // Structs are in format `AccountAddress::ModuleName::StructName`
       * 0x1::aptos_coin::AptosCoin
       * // Vectors are in format `vector<other_tag_string>`
       * vector<0x1::aptos_coin::AptosCoin>
       * bool
       * u8
       * u16
       * u32
       * u64
       * u128
       * u256
       * address
       * ```
       * @param args Function arguments
       * @returns RawTransaction
       */
      build(func, ty_tags, args) {
        const { sender, sequenceNumber, gasUnitPrice, maxGasAmount, expSecFromNow, chainId } = this.builderConfig;
        if (!gasUnitPrice) {
          throw new Error("No gasUnitPrice provided.");
        }
        const senderAccount = sender instanceof AccountAddress ? sender : AccountAddress.fromHex(sender);
        const expTimestampSec = BigInt(Math.floor(Date.now() / 1e3) + Number(expSecFromNow));
        const payload = this.buildTransactionPayload(func, ty_tags, args);
        if (payload) {
          return new RawTransaction(
            senderAccount,
            BigInt(sequenceNumber),
            payload,
            BigInt(maxGasAmount),
            BigInt(gasUnitPrice),
            expTimestampSec,
            new ChainId(Number(chainId))
          );
        }
        throw new Error("Invalid ABI.");
      }
    };
    var TransactionBuilderRemoteABI = class {
      // We don't want the builder to depend on the actual AptosClient. There might be circular dependencies.
      constructor(aptosClient2, builderConfig) {
        this.aptosClient = aptosClient2;
        this.builderConfig = builderConfig;
      }
      async fetchABI(addr) {
        const modules = await this.aptosClient.getAccountModules(addr);
        const abis = modules.map((module2) => module2.abi).flatMap(
          (abi) => abi.exposed_functions.filter((ef) => ef.is_entry).map(
            (ef) => ({
              fullName: `${abi.address}::${abi.name}::${ef.name}`,
              ...ef
            })
          )
        );
        const abiMap = /* @__PURE__ */ new Map();
        abis.forEach((abi) => {
          abiMap.set(abi.fullName, abi);
        });
        return abiMap;
      }
      /**
       * Builds a raw transaction. Only support script function a.k.a entry function payloads
       *
       * @param func fully qualified function name in format <address>::<module>::<function>, e.g. 0x1::coin::transfer
       * @param ty_tags
       * @param args
       * @returns RawTransaction
       */
      async build(func, ty_tags, args) {
        const normlize = (s) => s.replace(/^0[xX]0*/g, "0x");
        func = normlize(func);
        const funcNameParts = func.split("::");
        if (funcNameParts.length !== 3) {
          throw new Error(
            // eslint-disable-next-line max-len
            "'func' needs to be a fully qualified function name in format <address>::<module>::<function>, e.g. 0x1::coin::transfer"
          );
        }
        const [addr, module2] = func.split("::");
        const abiMap = await this.fetchABI(addr);
        if (!abiMap.has(func)) {
          throw new Error(`${func} doesn't exist.`);
        }
        const funcAbi = abiMap.get(func);
        const abiArgs = funcAbi.params.filter((param) => param !== "signer" && param !== "&signer");
        const typeArgABIs = abiArgs.map(
          (abiArg, i) => new ArgumentABI(`var${i}`, new TypeTagParser(abiArg, ty_tags).parseTypeTag())
        );
        const entryFunctionABI = new EntryFunctionABI(
          funcAbi.name,
          ModuleId.fromStr(`${addr}::${module2}`),
          "",
          // Doc string
          funcAbi.generic_type_params.map((_, i) => new TypeArgumentABI(`${i}`)),
          typeArgABIs
        );
        const { sender, ...rest } = this.builderConfig;
        const senderAddress = sender instanceof AccountAddress ? HexString.fromUint8Array(sender.address) : sender;
        const [{ sequence_number: sequenceNumber }, chainId, { gas_estimate: gasUnitPrice }] = await Promise.all([
          (rest == null ? void 0 : rest.sequenceNumber) ? Promise.resolve({ sequence_number: rest == null ? void 0 : rest.sequenceNumber }) : this.aptosClient.getAccount(senderAddress),
          (rest == null ? void 0 : rest.chainId) ? Promise.resolve(rest == null ? void 0 : rest.chainId) : this.aptosClient.getChainId(),
          (rest == null ? void 0 : rest.gasUnitPrice) ? Promise.resolve({ gas_estimate: rest == null ? void 0 : rest.gasUnitPrice }) : this.aptosClient.estimateGasPrice()
        ]);
        const builderABI = new TransactionBuilderABI([bcsToBytes(entryFunctionABI)], {
          sender,
          sequenceNumber,
          chainId,
          gasUnitPrice: BigInt(gasUnitPrice),
          ...rest
        });
        return builderABI.build(func, ty_tags, args);
      }
    };
    __decorateClass([
      MemoizeExpiring(10 * 60 * 1e3)
    ], TransactionBuilderRemoteABI.prototype, "fetchABI", 1);
    var _AptosClient = class _AptosClient2 {
      /**
       * Build a client configured to connect to an Aptos node at the given URL.
       *
       * Note: If you forget to append `/v1` to the URL, the client constructor
       * will automatically append it. If you don't want this URL processing to
       * take place, set doNotFixNodeUrl to true.
       *
       * @param nodeUrl URL of the Aptos Node API endpoint.
       * @param config Additional configuration options for the generated Axios client.
       */
      constructor(nodeUrl, config, doNotFixNodeUrl = false) {
        if (!nodeUrl) {
          throw new Error("Node URL cannot be empty.");
        }
        if (doNotFixNodeUrl) {
          this.nodeUrl = nodeUrl;
        } else {
          this.nodeUrl = fixNodeUrl(nodeUrl);
        }
        this.config = config === void 0 || config === null ? {} : { ...config };
      }
      async getAccount(accountAddress) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `accounts/${HexString.ensure(accountAddress).hex()}`,
          originMethod: "getAccount",
          overrides: { ...this.config }
        });
        return data;
      }
      async getAccountTransactions(accountAddress, query) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `accounts/${HexString.ensure(accountAddress).hex()}/transactions`,
          originMethod: "getAccountTransactions",
          params: { start: query == null ? void 0 : query.start, limit: query == null ? void 0 : query.limit },
          overrides: { ...this.config }
        });
        return data;
      }
      async getAccountModules(accountAddress, query) {
        const out = await paginateWithCursor({
          url: this.nodeUrl,
          endpoint: `accounts/${accountAddress}/modules`,
          params: { ledger_version: query == null ? void 0 : query.ledgerVersion, limit: 1e3 },
          originMethod: "getAccountModules",
          overrides: { ...this.config }
        });
        return out;
      }
      async getAccountModule(accountAddress, moduleName, query) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `accounts/${HexString.ensure(accountAddress).hex()}/module/${moduleName}`,
          originMethod: "getAccountModule",
          params: { ledger_version: query == null ? void 0 : query.ledgerVersion },
          overrides: { ...this.config }
        });
        return data;
      }
      async getAccountResources(accountAddress, query) {
        const out = await paginateWithCursor({
          url: this.nodeUrl,
          endpoint: `accounts/${accountAddress}/resources`,
          params: { ledger_version: query == null ? void 0 : query.ledgerVersion, limit: 9999 },
          originMethod: "getAccountResources",
          overrides: { ...this.config }
        });
        return out;
      }
      async getAccountResource(accountAddress, resourceType, query) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `accounts/${HexString.ensure(accountAddress).hex()}/resource/${resourceType}`,
          originMethod: "getAccountResource",
          params: { ledger_version: query == null ? void 0 : query.ledgerVersion },
          overrides: { ...this.config }
        });
        return data;
      }
      /** Generates a signed transaction that can be submitted to the chain for execution. */
      static generateBCSTransaction(accountFrom, rawTxn) {
        const txnBuilder = new TransactionBuilderEd25519((signingMessage) => {
          const sigHexStr = accountFrom.signBuffer(signingMessage);
          return new aptos_types_exports.Ed25519Signature(sigHexStr.toUint8Array());
        }, accountFrom.pubKey().toUint8Array());
        return txnBuilder.sign(rawTxn);
      }
      /**
       * Note: Unless you have a specific reason for using this, it'll probably be simpler
       * to use `simulateTransaction`.
       *
       * Generates a BCS transaction that can be submitted to the chain for simulation.
       *
       * @param accountFrom The account that will be used to send the transaction
       * for simulation.
       * @param rawTxn The raw transaction to be simulated, likely created by calling
       * the `generateTransaction` function.
       * @returns The BCS encoded signed transaction, which you should then pass into
       * the `submitBCSSimulation` function.
       */
      static generateBCSSimulation(accountFrom, rawTxn) {
        const txnBuilder = new TransactionBuilderEd25519((_signingMessage) => {
          const invalidSigBytes = new Uint8Array(64);
          return new aptos_types_exports.Ed25519Signature(invalidSigBytes);
        }, accountFrom.pubKey().toUint8Array());
        return txnBuilder.sign(rawTxn);
      }
      /** Generates an entry function transaction request that can be submitted to produce a raw transaction that
       * can be signed, which upon being signed can be submitted to the blockchain
       * This function fetches the remote ABI and uses it to serialized the data, therefore
       * users don't need to handle serialization by themselves.
       * @param sender Hex-encoded 32 byte Aptos account address of transaction sender
       * @param payload Entry function transaction payload type
       * @param options Options allow to overwrite default transaction options.
       * @returns A raw transaction object
       */
      async generateTransaction(sender, payload, options) {
        const config = { sender };
        if (options == null ? void 0 : options.sequence_number) {
          config.sequenceNumber = options.sequence_number;
        }
        if (options == null ? void 0 : options.gas_unit_price) {
          config.gasUnitPrice = options.gas_unit_price;
        }
        if (options == null ? void 0 : options.max_gas_amount) {
          config.maxGasAmount = options.max_gas_amount;
        }
        if (options == null ? void 0 : options.expiration_timestamp_secs) {
          const timestamp = Number.parseInt(options.expiration_timestamp_secs, 10);
          config.expSecFromNow = timestamp - Math.floor(Date.now() / 1e3);
        }
        const builder = new TransactionBuilderRemoteABI(this, config);
        return builder.build(payload.function, payload.type_arguments, payload.arguments);
      }
      /**
       * Generates a fee payer transaction that can be signed and submitted to chain
       *
       * @param sender the sender's account address
       * @param payload the transaction payload
       * @param fee_payer the fee payer account
       * @param secondarySignerAccounts an optional array of the secondary signers accounts
       * @returns a fee payer raw transaction that can be signed and submitted to chain
       */
      async generateFeePayerTransaction(sender, payload, feePayer, secondarySignerAccounts = [], options) {
        const rawTxn = await this.generateTransaction(sender, payload, options);
        const signers = secondarySignerAccounts.map((signer) => AccountAddress.fromHex(signer));
        const feePayerTxn = new aptos_types_exports.FeePayerRawTransaction(rawTxn, signers, AccountAddress.fromHex(feePayer));
        return feePayerTxn;
      }
      /**
       * Submits fee payer transaction to chain
       *
       * @param feePayerTransaction the raw transaction to be submitted, of type FeePayerRawTransaction
       * @param senderAuthenticator the sender account authenticator (can get from signMultiTransaction() method)
       * @param feePayerAuthenticator the feepayer account authenticator (can get from signMultiTransaction() method)
       * @param signersAuthenticators an optional array of the signer account authenticators
       * @returns The pending transaction
       */
      async submitFeePayerTransaction(feePayerTransaction, senderAuthenticator, feePayerAuthenticator, additionalSignersAuthenticators = []) {
        const txAuthenticatorFeePayer = new aptos_types_exports.TransactionAuthenticatorFeePayer(
          senderAuthenticator,
          feePayerTransaction.secondary_signer_addresses,
          additionalSignersAuthenticators,
          { address: feePayerTransaction.fee_payer_address, authenticator: feePayerAuthenticator }
        );
        const bcsTxn = bcsToBytes(
          new aptos_types_exports.SignedTransaction(feePayerTransaction.raw_txn, txAuthenticatorFeePayer)
        );
        const transactionRes = await this.submitSignedBCSTransaction(bcsTxn);
        return transactionRes;
      }
      /**
       * Signs a multi transaction type (multi agent / fee payer) and returns the
       * signer authenticator to be used to submit the transaction.
       *
       * @param signer the account to sign on the transaction
       * @param rawTxn a MultiAgentRawTransaction or FeePayerRawTransaction
       * @returns signer authenticator
       */
      // eslint-disable-next-line class-methods-use-this
      async signMultiTransaction(signer, rawTxn) {
        const signerSignature = new aptos_types_exports.Ed25519Signature(
          signer.signBuffer(TransactionBuilder.getSigningMessage(rawTxn)).toUint8Array()
        );
        const signerAuthenticator = new aptos_types_exports.AccountAuthenticatorEd25519(
          new aptos_types_exports.Ed25519PublicKey(signer.signingKey.publicKey),
          signerSignature
        );
        return Promise.resolve(signerAuthenticator);
      }
      /** Converts a transaction request produced by `generateTransaction` into a properly
       * signed transaction, which can then be submitted to the blockchain
       * @param accountFrom AptosAccount of transaction sender
       * @param rawTransaction A raw transaction generated by `generateTransaction` method
       * @returns A transaction, signed with sender account
       */
      // eslint-disable-next-line class-methods-use-this
      async signTransaction(accountFrom, rawTransaction) {
        return Promise.resolve(_AptosClient2.generateBCSTransaction(accountFrom, rawTransaction));
      }
      async getEventsByCreationNumber(address, creationNumber, query) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `accounts/${HexString.ensure(address).hex()}/events/${creationNumber}`,
          originMethod: "getEventsByCreationNumber",
          params: { start: query == null ? void 0 : query.start, limit: query == null ? void 0 : query.limit },
          overrides: { ...this.config }
        });
        return data;
      }
      async getEventsByEventHandle(address, eventHandleStruct, fieldName, query) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `accounts/${HexString.ensure(address).hex()}/events/${eventHandleStruct}/${fieldName}`,
          originMethod: "getEventsByEventHandle",
          params: { start: query == null ? void 0 : query.start, limit: query == null ? void 0 : query.limit },
          overrides: { ...this.config }
        });
        return data;
      }
      /**
       * Submits a signed transaction to the transaction endpoint.
       * @param signedTxn A transaction, signed by `signTransaction` method
       * @returns Transaction that is accepted and submitted to mempool
       */
      async submitTransaction(signedTxn) {
        return this.submitSignedBCSTransaction(signedTxn);
      }
      /**
       * Generates and submits a transaction to the transaction simulation
       * endpoint. For this we generate a transaction with a fake signature.
       *
       * @param accountOrPubkey The sender or sender's public key. When private key is available, `AptosAccount` instance
       * can be used to send the transaction for simulation. If private key is not available, sender's public key can be
       * used to send the transaction for simulation.
       * @param rawTransaction The raw transaction to be simulated, likely created
       * by calling the `generateTransaction` function.
       * @param query.estimateGasUnitPrice If set to true, the gas unit price in the
       * transaction will be ignored and the estimated value will be used.
       * @param query.estimateMaxGasAmount If set to true, the max gas value in the
       * transaction will be ignored and the maximum possible gas will be used.
       * @param query.estimatePrioritizedGasUnitPrice If set to true, the transaction will use a higher price than the
       * original estimate.
       * @returns The BCS encoded signed transaction, which you should then provide
       *
       */
      async simulateTransaction(accountOrPubkey, rawTransaction, query) {
        let signedTxn;
        if (accountOrPubkey instanceof AptosAccount) {
          signedTxn = _AptosClient2.generateBCSSimulation(accountOrPubkey, rawTransaction);
        } else if (accountOrPubkey instanceof MultiEd25519PublicKey) {
          const txnBuilder = new TransactionBuilderMultiEd25519(() => {
            const { threshold } = accountOrPubkey;
            const bits = [];
            const signatures = [];
            for (let i = 0; i < threshold; i += 1) {
              bits.push(i);
              signatures.push(new aptos_types_exports.Ed25519Signature(new Uint8Array(64)));
            }
            const bitmap = aptos_types_exports.MultiEd25519Signature.createBitmap(bits);
            return new aptos_types_exports.MultiEd25519Signature(signatures, bitmap);
          }, accountOrPubkey);
          signedTxn = txnBuilder.sign(rawTransaction);
        } else {
          const txnBuilder = new TransactionBuilderEd25519(() => {
            const invalidSigBytes = new Uint8Array(64);
            return new aptos_types_exports.Ed25519Signature(invalidSigBytes);
          }, accountOrPubkey.toBytes());
          signedTxn = txnBuilder.sign(rawTransaction);
        }
        return this.submitBCSSimulation(signedTxn, query);
      }
      async submitSignedBCSTransaction(signedTxn) {
        const { data } = await post({
          url: this.nodeUrl,
          body: signedTxn,
          endpoint: "transactions",
          originMethod: "submitSignedBCSTransaction",
          contentType: "application/x.aptos.signed_transaction+bcs",
          overrides: { ...this.config }
        });
        return data;
      }
      async submitBCSSimulation(bcsBody, query) {
        var _a, _b, _c;
        const queryParams = {
          estimate_gas_unit_price: (_a = query == null ? void 0 : query.estimateGasUnitPrice) != null ? _a : false,
          estimate_max_gas_amount: (_b = query == null ? void 0 : query.estimateMaxGasAmount) != null ? _b : false,
          estimate_prioritized_gas_unit_price: (_c = query == null ? void 0 : query.estimatePrioritizedGasUnitPrice) != null ? _c : false
        };
        const { data } = await post({
          url: this.nodeUrl,
          body: bcsBody,
          endpoint: "transactions/simulate",
          params: queryParams,
          originMethod: "submitBCSSimulation",
          contentType: "application/x.aptos.signed_transaction+bcs",
          overrides: { ...this.config }
        });
        return data;
      }
      async getTransactions(query) {
        var _a;
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: "transactions",
          originMethod: "getTransactions",
          params: { start: (_a = query == null ? void 0 : query.start) == null ? void 0 : _a.toString(), limit: query == null ? void 0 : query.limit },
          overrides: { ...this.config }
        });
        return data;
      }
      async getTransactionByHash(txnHash) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `transactions/by_hash/${txnHash}`,
          originMethod: "getTransactionByHash",
          overrides: { ...this.config }
        });
        return data;
      }
      async getTransactionByVersion(txnVersion) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `transactions/by_version/${txnVersion}`,
          originMethod: "getTransactionByVersion",
          overrides: { ...this.config }
        });
        return data;
      }
      /**
       * Defines if specified transaction is currently in pending state
       * @param txnHash A hash of transaction
       *
       * To create a transaction hash:
       *
       * 1. Create hash message bytes: "Aptos::Transaction" bytes + BCS bytes of Transaction.
       * 2. Apply hash algorithm SHA3-256 to the hash message bytes.
       * 3. Hex-encode the hash bytes with 0x prefix.
       *
       * @returns `true` if transaction is in pending state and `false` otherwise
       */
      async transactionPending(txnHash) {
        try {
          const response = await this.getTransactionByHash(txnHash);
          return response.type === "pending_transaction";
        } catch (e) {
          if ((e == null ? void 0 : e.status) === 404) {
            return true;
          }
          throw e;
        }
      }
      /**
       * Wait for a transaction to move past pending state.
       *
       * There are 4 possible outcomes:
       * 1. Transaction is processed and successfully committed to the blockchain.
       * 2. Transaction is rejected for some reason, and is therefore not committed
       *    to the blockchain.
       * 3. Transaction is committed but execution failed, meaning no changes were
       *    written to the blockchain state.
       * 4. Transaction is not processed within the specified timeout.
       *
       * In case 1, this function resolves with the transaction response returned
       * by the API.
       *
       * In case 2, the function will throw an ApiError, likely with an HTTP status
       * code indicating some problem with the request (e.g. 400).
       *
       * In case 3, if `checkSuccess` is false (the default), this function returns
       * the transaction response just like in case 1, in which the `success` field
       * will be false. If `checkSuccess` is true, it will instead throw a
       * FailedTransactionError.
       *
       * In case 4, this function throws a WaitForTransactionError.
       *
       * @param txnHash The hash of a transaction previously submitted to the blockchain.
       * @param extraArgs.timeoutSecs Timeout in seconds. Defaults to 20 seconds.
       * @param extraArgs.checkSuccess See above. Defaults to false.
       * @returns See above.
       *
       * @example
       * ```
       * const rawTransaction = await this.generateRawTransaction(sender.address(), payload, extraArgs);
       * const bcsTxn = AptosClient.generateBCSTransaction(sender, rawTransaction);
       * const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
       * const transasction = await this.aptosClient.waitForTransactionWithResult(pendingTransaction.hash);
       * ```
       */
      async waitForTransactionWithResult(txnHash, extraArgs) {
        var _a, _b;
        const timeoutSecs = (_a = extraArgs == null ? void 0 : extraArgs.timeoutSecs) != null ? _a : DEFAULT_TXN_TIMEOUT_SEC;
        const checkSuccess = (_b = extraArgs == null ? void 0 : extraArgs.checkSuccess) != null ? _b : false;
        let isPending = true;
        let count = 0;
        let lastTxn;
        while (isPending) {
          if (count >= timeoutSecs) {
            break;
          }
          try {
            lastTxn = await this.getTransactionByHash(txnHash);
            isPending = lastTxn.type === "pending_transaction";
            if (!isPending) {
              break;
            }
          } catch (e) {
            const isApiError = e instanceof ApiError;
            const isRequestError = isApiError && e.status !== 404 && e.status >= 400 && e.status < 500;
            if (!isApiError || isRequestError) {
              throw e;
            }
          }
          await sleep(1e3);
          count += 1;
        }
        if (lastTxn === void 0) {
          throw new Error(`Waiting for transaction ${txnHash} failed`);
        }
        if (isPending) {
          throw new WaitForTransactionError(
            `Waiting for transaction ${txnHash} timed out after ${timeoutSecs} seconds`,
            lastTxn
          );
        }
        if (!checkSuccess) {
          return lastTxn;
        }
        if (!(lastTxn == null ? void 0 : lastTxn.success)) {
          throw new FailedTransactionError(
            `Transaction ${txnHash} failed with an error: ${lastTxn.vm_status}`,
            lastTxn
          );
        }
        return lastTxn;
      }
      /**
       * This function works the same as `waitForTransactionWithResult` except it
       * doesn't return the transaction in those cases, it returns nothing. For
       * more information, see the documentation for `waitForTransactionWithResult`.
       */
      async waitForTransaction(txnHash, extraArgs) {
        await this.waitForTransactionWithResult(txnHash, extraArgs);
      }
      async getLedgerInfo() {
        const { data } = await get({
          url: this.nodeUrl,
          originMethod: "getLedgerInfo",
          overrides: { ...this.config }
        });
        return data;
      }
      async getChainId() {
        const result = await this.getLedgerInfo();
        return result.chain_id;
      }
      async getTableItem(handle, data, query) {
        var _a;
        const response = await post({
          url: this.nodeUrl,
          body: data,
          endpoint: `tables/${handle}/item`,
          originMethod: "getTableItem",
          params: { ledger_version: (_a = query == null ? void 0 : query.ledgerVersion) == null ? void 0 : _a.toString() },
          overrides: { ...this.config }
        });
        return response.data;
      }
      /**
       * Generates a raw transaction out of a transaction payload
       * @param accountFrom
       * @param payload
       * @param extraArgs
       * @returns A raw transaction object
       */
      async generateRawTransaction(accountFrom, payload, extraArgs) {
        const [{ sequence_number: sequenceNumber }, chainId, { gas_estimate: gasEstimate }] = await Promise.all([
          (extraArgs == null ? void 0 : extraArgs.providedSequenceNumber) ? Promise.resolve({ sequence_number: extraArgs.providedSequenceNumber }) : this.getAccount(accountFrom),
          this.getChainId(),
          (extraArgs == null ? void 0 : extraArgs.gasUnitPrice) ? Promise.resolve({ gas_estimate: extraArgs.gasUnitPrice }) : this.estimateGasPrice()
        ]);
        const { maxGasAmount, gasUnitPrice, expireTimestamp } = {
          maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),
          gasUnitPrice: BigInt(gasEstimate),
          expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + DEFAULT_TXN_EXP_SEC_FROM_NOW),
          ...extraArgs
        };
        return new aptos_types_exports.RawTransaction(
          aptos_types_exports.AccountAddress.fromHex(accountFrom),
          BigInt(sequenceNumber),
          payload,
          maxGasAmount,
          gasUnitPrice,
          expireTimestamp,
          new aptos_types_exports.ChainId(chainId)
        );
      }
      /**
       * Helper for generating, signing, and submitting a transaction.
       *
       * @param sender AptosAccount of transaction sender.
       * @param payload Transaction payload.
       * @param extraArgs Extra args for building the transaction payload.
       * @returns The transaction response from the API.
       */
      async generateSignSubmitTransaction(sender, payload, extraArgs) {
        const rawTransaction = await this.generateRawTransaction(sender.address(), payload, extraArgs);
        const bcsTxn = _AptosClient2.generateBCSTransaction(sender, rawTransaction);
        const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Helper for signing and submitting a transaction.
       *
       * @param sender AptosAccount of transaction sender.
       * @param transaction A generated Raw transaction payload.
       * @returns The transaction response from the API.
       */
      async signAndSubmitTransaction(sender, transaction) {
        const bcsTxn = _AptosClient2.generateBCSTransaction(sender, transaction);
        const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Publishes a move package. `packageMetadata` and `modules` can be generated with command
       * `aptos move compile --save-metadata [ --included-artifacts=<...> ]`.
       * @param sender
       * @param packageMetadata package metadata bytes
       * @param modules bytecodes of modules
       * @param extraArgs
       * @returns Transaction hash
       */
      async publishPackage(sender, packageMetadata, modules, extraArgs) {
        const codeSerializer = new Serializer();
        serializeVector(modules, codeSerializer);
        const payload = new aptos_types_exports.TransactionPayloadEntryFunction(
          aptos_types_exports.EntryFunction.natural(
            "0x1::code",
            "publish_package_txn",
            [],
            [bcsSerializeBytes(packageMetadata), codeSerializer.getBytes()]
          )
        );
        return this.generateSignSubmitTransaction(sender, payload, extraArgs);
      }
      /**
       * Publishes a move packages by creating a resource account.
       * The package cannot be upgraded since it is deployed by resource account
       * `packageMetadata` and `modules` can be generated with command
       * `aptos move compile --save-metadata [ --included-artifacts=<...> ]`.
       * @param sender
       * @param seed seeds for creation of resource address
       * @param packageMetadata package metadata bytes
       * @param modules bytecodes of modules
       * @param extraArgs
       * @returns Transaction hash
       */
      async createResourceAccountAndPublishPackage(sender, seed, packageMetadata, modules, extraArgs) {
        const codeSerializer = new Serializer();
        serializeVector(modules, codeSerializer);
        const payload = new aptos_types_exports.TransactionPayloadEntryFunction(
          aptos_types_exports.EntryFunction.natural(
            "0x1::resource_account",
            "create_resource_account_and_publish_package",
            [],
            [bcsSerializeBytes(seed), bcsSerializeBytes(packageMetadata), codeSerializer.getBytes()]
          )
        );
        return this.generateSignSubmitTransaction(sender, payload, extraArgs);
      }
      /**
       * Helper for generating, submitting, and waiting for a transaction, and then
       * checking whether it was committed successfully. Under the hood this is just
       * `generateSignSubmitTransaction` and then `waitForTransactionWithResult`, see
       * those for information about the return / error semantics of this function.
       */
      async generateSignSubmitWaitForTransaction(sender, payload, extraArgs) {
        const txnHash = await this.generateSignSubmitTransaction(sender, payload, extraArgs);
        return this.waitForTransactionWithResult(txnHash, extraArgs);
      }
      async estimateGasPrice() {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: "estimate_gas_price",
          originMethod: "estimateGasPrice",
          overrides: { ...this.config }
        });
        return data;
      }
      async estimateMaxGasAmount(forAccount) {
        const typeTag = `0x1::coin::CoinStore<${APTOS_COIN}>`;
        const [{ gas_estimate: gasUnitPrice }, resources] = await Promise.all([
          this.estimateGasPrice(),
          this.getAccountResources(forAccount)
        ]);
        const accountResource = resources.find((r) => r.type === typeTag);
        const balance = BigInt(accountResource.data.coin.value);
        return balance / BigInt(gasUnitPrice);
      }
      /**
       * Rotate an account's auth key. After rotation, only the new private key can be used to sign txns for
       * the account.
       * WARNING: You must create a new instance of AptosAccount after using this function.
       * @param forAccount Account of which the auth key will be rotated
       * @param toPrivateKeyBytes New private key
       * @param extraArgs Extra args for building the transaction payload.
       * @returns PendingTransaction
       */
      async rotateAuthKeyEd25519(forAccount, toPrivateKeyBytes, extraArgs) {
        const { sequence_number: sequenceNumber, authentication_key: authKey } = await this.getAccount(
          forAccount.address()
        );
        const helperAccount = new AptosAccount(toPrivateKeyBytes);
        const challenge = new aptos_types_exports.RotationProofChallenge(
          aptos_types_exports.AccountAddress.CORE_CODE_ADDRESS,
          "account",
          "RotationProofChallenge",
          BigInt(sequenceNumber),
          aptos_types_exports.AccountAddress.fromHex(forAccount.address()),
          new aptos_types_exports.AccountAddress(new HexString(authKey).toUint8Array()),
          helperAccount.pubKey().toUint8Array()
        );
        const challengeHex = HexString.fromUint8Array(bcsToBytes(challenge));
        const proofSignedByCurrentPrivateKey = forAccount.signHexString(challengeHex);
        const proofSignedByNewPrivateKey = helperAccount.signHexString(challengeHex);
        const payload = new aptos_types_exports.TransactionPayloadEntryFunction(
          aptos_types_exports.EntryFunction.natural(
            "0x1::account",
            "rotate_authentication_key",
            [],
            [
              bcsSerializeU8(0),
              // ed25519 scheme
              bcsSerializeBytes(forAccount.pubKey().toUint8Array()),
              bcsSerializeU8(0),
              // ed25519 scheme
              bcsSerializeBytes(helperAccount.pubKey().toUint8Array()),
              bcsSerializeBytes(proofSignedByCurrentPrivateKey.toUint8Array()),
              bcsSerializeBytes(proofSignedByNewPrivateKey.toUint8Array())
            ]
          )
        );
        const rawTransaction = await this.generateRawTransaction(forAccount.address(), payload, extraArgs);
        const bcsTxn = _AptosClient2.generateBCSTransaction(forAccount, rawTransaction);
        return this.submitSignedBCSTransaction(bcsTxn);
      }
      /**
       * Lookup the original address by the current derived address
       * @param addressOrAuthKey
       * @returns original address
       */
      async lookupOriginalAddress(addressOrAuthKey) {
        const resource = await this.getAccountResource("0x1", "0x1::account::OriginatingAddress");
        const {
          address_map: { handle }
        } = resource.data;
        const origAddress = await this.getTableItem(handle, {
          key_type: "address",
          value_type: "address",
          key: HexString.ensure(addressOrAuthKey).hex()
        });
        return new HexString(origAddress);
      }
      async getBlockByHeight(blockHeight, withTransactions) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `blocks/by_height/${blockHeight}`,
          originMethod: "getBlockByHeight",
          params: { with_transactions: withTransactions },
          overrides: { ...this.config }
        });
        return data;
      }
      async getBlockByVersion(version, withTransactions) {
        const { data } = await get({
          url: this.nodeUrl,
          endpoint: `blocks/by_version/${version}`,
          originMethod: "getBlockByVersion",
          params: { with_transactions: withTransactions },
          overrides: { ...this.config }
        });
        return data;
      }
      async view(payload, ledger_version) {
        const { data } = await post({
          url: this.nodeUrl,
          body: payload,
          endpoint: "view",
          originMethod: "getTableItem",
          params: { ledger_version },
          overrides: { ...this.config }
        });
        return data;
      }
      // eslint-disable-next-line class-methods-use-this
      clearCache(tags) {
        clear(tags);
      }
    };
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getAccount", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getAccountTransactions", 1);
    __decorateClass([
      parseApiError,
      MemoizeExpiring(10 * 60 * 1e3)
    ], _AptosClient.prototype, "getAccountModules", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getAccountModule", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getAccountResources", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getAccountResource", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getEventsByCreationNumber", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getEventsByEventHandle", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "submitSignedBCSTransaction", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "submitBCSSimulation", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getTransactions", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getTransactionByHash", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getTransactionByVersion", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getLedgerInfo", 1);
    __decorateClass([
      Memoize()
    ], _AptosClient.prototype, "getChainId", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getTableItem", 1);
    __decorateClass([
      parseApiError,
      Memoize({
        ttlMs: 5 * 60 * 1e3,
        // cache result for 5min
        tags: ["gas_estimates"]
      })
    ], _AptosClient.prototype, "estimateGasPrice", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "estimateMaxGasAmount", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getBlockByHeight", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "getBlockByVersion", 1);
    __decorateClass([
      parseApiError
    ], _AptosClient.prototype, "view", 1);
    var AptosClient = _AptosClient;
    var WaitForTransactionError = class extends Error {
      constructor(message, lastSubmittedTransaction) {
        super(message);
        this.lastSubmittedTransaction = lastSubmittedTransaction;
      }
    };
    var FailedTransactionError = class extends Error {
      constructor(message, transaction) {
        super(message);
        this.transaction = transaction;
      }
    };
    var ApiError = class extends Error {
      constructor(status, message, errorCode, vmErrorCode) {
        super(message);
        this.status = status;
        this.message = message;
        this.errorCode = errorCode;
        this.vmErrorCode = vmErrorCode;
      }
    };
    function parseApiError(target, propertyKey, descriptor) {
      const childFunction = descriptor.value;
      descriptor.value = async function wrapper(...args) {
        var _a, _b;
        try {
          const res = await childFunction.apply(this, [...args]);
          return res;
        } catch (e) {
          if (e instanceof AptosApiError) {
            throw new ApiError(
              e.status,
              JSON.stringify({ message: e.message, ...e.data }),
              (_a = e.data) == null ? void 0 : _a.error_code,
              (_b = e.data) == null ? void 0 : _b.vm_error_code
            );
          }
          throw e;
        }
      };
      return descriptor;
    }
    var IndexerClient = class _IndexerClient {
      /**
       * @param endpoint URL of the Aptos Indexer API endpoint.
       */
      constructor(endpoint, config) {
        this.endpoint = endpoint;
        this.config = config;
      }
      /**
       * Indexer only accepts address in the long format, i.e a 66 chars long -> 0x<64 chars>
       * This method makes sure address is 66 chars long.
       * @param address
       */
      static validateAddress(address) {
        if (address.length < 66) {
          throw new Error(`${address} is less than 66 chars long.`);
        }
      }
      /**
       * Makes axios client call to fetch data from Aptos Indexer.
       *
       * @param graphqlQuery A GraphQL query to pass in the `data` axios call.
       */
      async queryIndexer(graphqlQuery) {
        const response = await post({
          url: this.endpoint,
          body: graphqlQuery,
          overrides: { WITH_CREDENTIALS: false, ...this.config }
        });
        if (response.data.errors) {
          throw new ApiError(
            response.data.errors[0].extensions.code,
            JSON.stringify({
              message: response.data.errors[0].message,
              error_code: response.data.errors[0].extensions.code
            })
          );
        }
        return response.data.data;
      }
      /**
       * Queries Indexer Ledger Info
       *
       * @returns GetLedgerInfoQuery response type
       */
      async getIndexerLedgerInfo() {
        const graphqlQuery = {
          query: GetIndexerLedgerInfo
        };
        return this.queryIndexer(graphqlQuery);
      }
      // TOKENS //
      /**
       * @deprecated please use `getOwnedTokens` query
       *
       * Queries an Aptos account's NFTs by owner address
       *
       * @param ownerAddress Hex-encoded 32 byte Aptos account address
       * @returns GetAccountCurrentTokensQuery response type
       */
      async getAccountNFTs(ownerAddress, options) {
        const address = HexString.ensure(ownerAddress).hex();
        _IndexerClient.validateAddress(address);
        const graphqlQuery = {
          query: GetAccountCurrentTokens,
          variables: { address, offset: options == null ? void 0 : options.offset, limit: options == null ? void 0 : options.limit }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries a token activities by token address (v2) or token data id (v1)
       *
       * @param idHash token address (v2) or token data id (v1)
       * @returns GetTokenActivitiesQuery response type
       */
      async getTokenActivities(token, extraArgs) {
        var _a, _b;
        const tokenAddress = HexString.ensure(token).hex();
        _IndexerClient.validateAddress(tokenAddress);
        const whereCondition = {
          token_data_id: { _eq: tokenAddress }
        };
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
        }
        const graphqlQuery = {
          query: GetTokenActivities,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Gets the count of token's activities by token address (v2) or token data id (v1)
       *
       * @param token token address (v2) or token data id (v1)
       * @returns GetTokenActivitiesCountQuery response type
       */
      async getTokenActivitiesCount(token) {
        const graphqlQuery = {
          query: GetTokenActivitiesCount,
          variables: { token_id: token }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Gets the count of tokens owned by an account
       *
       * @param ownerAddress Owner address
       * @returns AccountTokensCountQuery response type
       */
      async getAccountTokensCount(ownerAddress, extraArgs) {
        var _a, _b;
        const whereCondition = {
          owner_address: { _eq: ownerAddress },
          amount: { _gt: "0" }
        };
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
        }
        const address = HexString.ensure(ownerAddress).hex();
        _IndexerClient.validateAddress(address);
        const graphqlQuery = {
          query: GetAccountTokensCount,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries token data by token address (v2) or token data id (v1)
       *
       * @param token token address (v2) or token data id (v1)
       * @returns GetTokenDataQuery response type
       */
      // :!:>getTokenData
      async getTokenData(token, extraArgs) {
        var _a, _b;
        const tokenAddress = HexString.ensure(token).hex();
        _IndexerClient.validateAddress(tokenAddress);
        const whereCondition = {
          token_data_id: { _eq: tokenAddress }
        };
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
        }
        const graphqlQuery = {
          query: GetTokenData,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      // <:!:getTokenData
      /**
       * Queries token owners data by token address (v2) or token data id (v1).
       * This query returns historical owners data.
       *
       * To fetch token v2 standard, pass in the optional `tokenStandard` parameter and
       * dont pass `propertyVersion` parameter (as propertyVersion only compatible with v1 standard)
       *
       * @param token token address (v2) or token data id (v1)
       * @param propertyVersion Property version (optional) - only compatible with token v1 standard
       * @returns GetTokenOwnersDataQuery response type
       */
      async getTokenOwnersData(token, propertyVersion, extraArgs) {
        var _a, _b;
        const tokenAddress = HexString.ensure(token).hex();
        _IndexerClient.validateAddress(tokenAddress);
        const whereCondition = {
          token_data_id: { _eq: tokenAddress },
          amount: { _gt: "0" }
        };
        if (propertyVersion) {
          whereCondition.property_version_v1 = { _eq: propertyVersion };
        }
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
        }
        const graphqlQuery = {
          query: GetTokenOwnersData,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries current token owner data by token address (v2) or token data id (v1).
       * This query returns the current token owner data.
       *
       * To fetch token v2 standard, pass in the optional `tokenStandard` parameter and
       * dont pass `propertyVersion` parameter (as propertyVersion only compatible with v1 standard)
       *
       * @param token token address (v2) or token data id (v1)
       * @param propertyVersion Property version (optional) - only compatible with token v1 standard
       * @returns GetTokenCurrentOwnerDataQuery response type
       */
      async getTokenCurrentOwnerData(token, propertyVersion, extraArgs) {
        var _a, _b;
        const tokenAddress = HexString.ensure(token).hex();
        _IndexerClient.validateAddress(tokenAddress);
        const whereCondition = {
          token_data_id: { _eq: tokenAddress },
          amount: { _gt: "0" }
        };
        if (propertyVersion) {
          whereCondition.property_version_v1 = { _eq: propertyVersion };
        }
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
        }
        const graphqlQuery = {
          query: GetTokenCurrentOwnerData,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries account's current owned tokens.
       * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.
       * If you want to get only the token from a specific standrd, you can pass an optional tokenStandard param
       *
       * @param ownerAddress The token owner address we want to get the tokens for
       * @returns GetOwnedTokensQuery response type
       */
      async getOwnedTokens(ownerAddress, extraArgs) {
        var _a, _b;
        const address = HexString.ensure(ownerAddress).hex();
        _IndexerClient.validateAddress(address);
        const whereCondition = {
          owner_address: { _eq: address },
          amount: { _gt: 0 }
        };
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
        }
        const graphqlQuery = {
          query: GetOwnedTokens,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries account's current owned tokens by token address (v2) or token data id (v1).
       *
       * @param token token address (v2) or token data id (v1)
       * @returns GetOwnedTokensByTokenDataQuery response type
       */
      async getOwnedTokensByTokenData(token, extraArgs) {
        var _a, _b;
        const address = HexString.ensure(token).hex();
        _IndexerClient.validateAddress(address);
        const whereCondition = {
          token_data_id: { _eq: address },
          amount: { _gt: 0 }
        };
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
        }
        const graphqlQuery = {
          query: GetOwnedTokensByTokenData,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries all tokens of a specific collection that an account owns by the collection address
       *
       * @param ownerAddress owner address that owns the tokens
       * @param collectionAddress the collection address
       * @returns GetTokenOwnedFromCollectionQuery response type
       */
      async getTokenOwnedFromCollectionAddress(ownerAddress, collectionAddress, extraArgs) {
        var _a, _b;
        const ownerHexAddress = HexString.ensure(ownerAddress).hex();
        _IndexerClient.validateAddress(ownerHexAddress);
        const collectionHexAddress = HexString.ensure(collectionAddress).hex();
        _IndexerClient.validateAddress(collectionHexAddress);
        const whereCondition = {
          owner_address: { _eq: ownerHexAddress },
          current_token_data: { collection_id: { _eq: collectionHexAddress } },
          amount: { _gt: 0 }
        };
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
        }
        const graphqlQuery = {
          query: GetTokenOwnedFromCollection,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries all tokens of a specific collection that an account owns by the collection name and collection
       * creator address
       *
       * @param ownerAddress owner address that owns the tokens
       * @param collectionName the collection name
       * @param creatorAddress the collection creator address
       * @returns GetTokenOwnedFromCollectionQuery response type
       */
      async getTokenOwnedFromCollectionNameAndCreatorAddress(ownerAddress, collectionName, creatorAddress, extraArgs) {
        const collectionAddress = await this.getCollectionAddress(creatorAddress, collectionName, extraArgs);
        const tokens = await this.getTokenOwnedFromCollectionAddress(ownerAddress, collectionAddress, extraArgs);
        return tokens;
      }
      /**
       * Queries data of a specific collection by the collection creator address and the collection name.
       *
       * if, for some reason, a creator account has 2 collections with the same name in v1 and v2,
       * can pass an optional `tokenStandard` parameter to query a specific standard
       *
       * @param creatorAddress the collection creator address
       * @param collectionName the collection name
       * @returns GetCollectionDataQuery response type
       */
      async getCollectionData(creatorAddress, collectionName, extraArgs) {
        var _a, _b;
        const address = HexString.ensure(creatorAddress).hex();
        _IndexerClient.validateAddress(address);
        const whereCondition = {
          collection_name: { _eq: collectionName },
          creator_address: { _eq: address }
        };
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
        }
        const graphqlQuery = {
          query: GetCollectionData,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries a collection address.
       *
       * @param creatorAddress the collection creator address
       * @param collectionName the collection name
       * @returns the collection address
       */
      async getCollectionAddress(creatorAddress, collectionName, extraArgs) {
        return (await this.getCollectionData(creatorAddress, collectionName, extraArgs)).current_collections_v2[0].collection_id;
      }
      /**
       * Queries for all collections that an account has tokens for.
       *
       * @param ownerAddress the account address that owns the tokens
       * @returns GetCollectionsWithOwnedTokensQuery response type
       */
      async getCollectionsWithOwnedTokens(ownerAddress, extraArgs) {
        var _a, _b;
        const ownerHexAddress = HexString.ensure(ownerAddress).hex();
        _IndexerClient.validateAddress(ownerHexAddress);
        const whereCondition = {
          owner_address: { _eq: ownerHexAddress }
        };
        if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
          whereCondition.current_collection = { token_standard: { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard } };
        }
        const graphqlQuery = {
          query: GetCollectionsWithOwnedTokens,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      // TRANSACTIONS //
      /**
       * Gets the count of transactions submitted by an account
       *
       * @param address Account address
       * @returns GetAccountTransactionsCountQuery response type
       */
      async getAccountTransactionsCount(accountAddress) {
        const address = HexString.ensure(accountAddress).hex();
        _IndexerClient.validateAddress(address);
        const graphqlQuery = {
          query: GetAccountTransactionsCount,
          variables: { address }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries an account transactions data
       *
       * @param address Account address
       * @returns GetAccountTransactionsDataQuery response type
       */
      async getAccountTransactionsData(accountAddress, extraArgs) {
        var _a, _b;
        const address = HexString.ensure(accountAddress).hex();
        _IndexerClient.validateAddress(address);
        const whereCondition = {
          account_address: { _eq: address }
        };
        const graphqlQuery = {
          query: GetAccountTransactionsData,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries top user transactions
       *
       * @param limit
       * @returns GetTopUserTransactionsQuery response type
       */
      async getTopUserTransactions(limit) {
        const graphqlQuery = {
          query: GetTopUserTransactions,
          variables: { limit }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries top user transactions
       *
       * @param startVersion optional - can be set to tell indexer what version to start from
       * @returns GetUserTransactionsQuery response type
       */
      async getUserTransactions(extraArgs) {
        var _a, _b;
        const whereCondition = {
          version: { _lte: extraArgs == null ? void 0 : extraArgs.startVersion }
        };
        const graphqlQuery = {
          query: GetUserTransactions,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      // STAKING //
      /**
       * Queries delegated staking activities
       *
       * @param delegatorAddress Delegator address
       * @param poolAddress Pool address
       * @returns GetDelegatedStakingActivitiesQuery response type
       */
      async getDelegatedStakingActivities(delegatorAddress, poolAddress) {
        const delegator = HexString.ensure(delegatorAddress).hex();
        const pool = HexString.ensure(poolAddress).hex();
        _IndexerClient.validateAddress(delegator);
        _IndexerClient.validateAddress(pool);
        const graphqlQuery = {
          query: GetDelegatedStakingActivities,
          variables: {
            delegatorAddress: delegator,
            poolAddress: pool
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries current number of delegators in a pool
       *
       * @returns GetNumberOfDelegatorsQuery response type
       */
      async getNumberOfDelegators(poolAddress) {
        const address = HexString.ensure(poolAddress).hex();
        _IndexerClient.validateAddress(address);
        const graphqlQuery = {
          query: GetNumberOfDelegators,
          variables: { poolAddress: address }
        };
        return this.queryIndexer(graphqlQuery);
      }
      // ACCOUNT //
      /**
       * Queries an account coin data
       *
       * @param ownerAddress Owner address
       * @returns GetAccountCoinsDataQuery response type
       */
      async getAccountCoinsData(ownerAddress, extraArgs) {
        var _a, _b;
        const address = HexString.ensure(ownerAddress).hex();
        _IndexerClient.validateAddress(address);
        const whereCondition = {
          owner_address: { _eq: address }
        };
        const graphqlQuery = {
          query: GetAccountCoinsData,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries an account coin data count
       *
       * @param ownerAddress Owner address
       * @returns GetAccountCoinsDataCountQuery response type
       */
      async getAccountCoinsDataCount(ownerAddress) {
        const address = HexString.ensure(ownerAddress).hex();
        _IndexerClient.validateAddress(address);
        const graphqlQuery = {
          query: GetAccountCoinsDataCount,
          variables: {
            address
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
      /**
       * Queries an account owned objects
       *
       * @param ownerAddress Owner address
       * @returns GetCurrentObjectsQuery response type
       */
      async getAccountOwnedObjects(ownerAddress, extraArgs) {
        var _a, _b;
        const address = HexString.ensure(ownerAddress).hex();
        _IndexerClient.validateAddress(address);
        const whereCondition = {
          owner_address: { _eq: address }
        };
        const graphqlQuery = {
          query: GetCurrentObjects,
          variables: {
            where_condition: whereCondition,
            offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
            limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
            order_by: extraArgs == null ? void 0 : extraArgs.orderBy
          }
        };
        return this.queryIndexer(graphqlQuery);
      }
    };
    var Provider = class {
      constructor(network, config, doNotFixNodeUrl = false) {
        let fullNodeUrl = null;
        let indexerUrl = null;
        if (typeof network === "object" && isCustomEndpoints(network)) {
          fullNodeUrl = network.fullnodeUrl;
          indexerUrl = network.indexerUrl;
          this.network = "CUSTOM";
        } else {
          fullNodeUrl = NetworkToNodeAPI[network];
          indexerUrl = NetworkToIndexerAPI[network];
          this.network = network;
        }
        if (this.network === "CUSTOM" && !fullNodeUrl) {
          throw new Error("fullnode url is not provided");
        }
        if (indexerUrl) {
          this.indexerClient = new IndexerClient(indexerUrl, config);
        }
        this.aptosClient = new AptosClient(fullNodeUrl, config, doNotFixNodeUrl);
      }
    };
    function applyMixin(targetClass, baseClass, baseClassProp) {
      Object.getOwnPropertyNames(baseClass.prototype).forEach((propertyName) => {
        const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass.prototype, propertyName);
        if (!propertyDescriptor)
          return;
        propertyDescriptor.value = function(...args) {
          return this[baseClassProp][propertyName](...args);
        };
        Object.defineProperty(targetClass.prototype, propertyName, propertyDescriptor);
      });
      Object.getOwnPropertyNames(baseClass).forEach((propertyName) => {
        const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass, propertyName);
        if (!propertyDescriptor)
          return;
        propertyDescriptor.value = function(...args) {
          return this[baseClassProp][propertyName](...args);
        };
        if (targetClass.hasOwnProperty.call(targetClass, propertyName)) {
          return;
        }
        Object.defineProperty(targetClass, propertyName, propertyDescriptor);
      });
    }
    applyMixin(Provider, AptosClient, "aptosClient");
    applyMixin(Provider, IndexerClient, "indexerClient");
    function isCustomEndpoints(network) {
      return network.fullnodeUrl !== void 0 && typeof network.fullnodeUrl === "string";
    }
    var PropertyValue = class {
      constructor(type, value) {
        this.type = type;
        this.value = value;
      }
    };
    var PropertyMap = class {
      constructor() {
        this.data = {};
      }
      setProperty(key, value) {
        this.data[key] = value;
      }
    };
    function getPropertyType(typ) {
      let typeTag;
      if (typ === "string" || typ === "String") {
        typeTag = new TypeTagStruct(stringStructTag);
      } else {
        typeTag = new TypeTagParser(typ).parseTypeTag();
      }
      return typeTag;
    }
    function getPropertyValueRaw(values, types) {
      if (values.length !== types.length) {
        throw new Error("Length of property values and types not match");
      }
      const results = new Array();
      types.forEach((typ, index) => {
        try {
          const typeTag = getPropertyType(typ);
          const serializer = new Serializer();
          serializeArg(values[index], typeTag, serializer);
          results.push(serializer.getBytes());
        } catch (error) {
          results.push(new TextEncoder().encode(values[index]));
        }
      });
      return results;
    }
    function getSinglePropertyValueRaw(value, type) {
      if (!value || !type) {
        throw new Error("value or type can not be empty");
      }
      try {
        const typeTag = getPropertyType(type);
        const serializer = new Serializer();
        serializeArg(value, typeTag, serializer);
        return serializer.getBytes();
      } catch (error) {
        return new TextEncoder().encode(value);
      }
    }
    function deserializePropertyMap(rawPropertyMap) {
      const entries = rawPropertyMap.map.data;
      const pm = new PropertyMap();
      entries.forEach((prop) => {
        const { key } = prop;
        const val = prop.value.value;
        const typ = prop.value.type;
        const typeTag = getPropertyType(typ);
        const newValue = deserializeValueBasedOnTypeTag(typeTag, val);
        const pv = new PropertyValue(typ, newValue);
        pm.setProperty(key, pv);
      });
      return pm;
    }
    function deserializeValueBasedOnTypeTag(tag, val) {
      const de = new Deserializer(new HexString(val).toUint8Array());
      let res = "";
      if (tag instanceof TypeTagU8) {
        res = de.deserializeU8().toString();
      } else if (tag instanceof TypeTagU64) {
        res = de.deserializeU64().toString();
      } else if (tag instanceof TypeTagU128) {
        res = de.deserializeU128().toString();
      } else if (tag instanceof TypeTagBool) {
        res = de.deserializeBool() ? "true" : "false";
      } else if (tag instanceof TypeTagAddress) {
        res = HexString.fromUint8Array(de.deserializeFixedBytes(32)).hex();
      } else if (tag instanceof TypeTagStruct && tag.isStringTypeTag()) {
        res = de.deserializeStr();
      } else {
        res = val;
      }
      return res;
    }
    var token_types_exports = {};
    __export2(token_types_exports, {
      PropertyMap: () => PropertyMap,
      PropertyValue: () => PropertyValue,
      Token: () => Token,
      TokenData: () => TokenData
    });
    var TokenData = class {
      constructor(collection, description, name, maximum, supply, uri, default_properties, mutability_config) {
        this.collection = collection;
        this.description = description;
        this.name = name;
        this.maximum = maximum;
        this.supply = supply;
        this.uri = uri;
        this.default_properties = deserializePropertyMap(default_properties);
        this.mutability_config = mutability_config;
      }
    };
    var Token = class {
      constructor(id, amount, token_properties) {
        this.id = id;
        this.amount = amount;
        this.token_properties = deserializePropertyMap(token_properties);
      }
    };
    var TokenClient = class {
      /**
       * Creates new TokenClient instance
       *
       * @param aptosClient AptosClient instance
       */
      constructor(aptosClient2) {
        this.aptosClient = aptosClient2;
      }
      /**
       * Creates a new NFT collection within the specified account
       *
       * @param account AptosAccount where collection will be created
       * @param name Collection name
       * @param description Collection description
       * @param uri URL to additional info about collection
       * @param maxAmount Maximum number of `token_data` allowed within this collection
       * @returns The hash of the transaction submitted to the API
       */
      // :!:>createCollection
      async createCollection(account, name, description, uri, maxAmount = MAX_U64_BIG_INT, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: account.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token::create_collection_script",
          [],
          [name, description, uri, maxAmount, [false, false, false]]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Creates a new NFT within the specified account
       *
       * @param account AptosAccount where token will be created
       * @param collectionName Name of collection, that token belongs to
       * @param name Token name
       * @param description Token description
       * @param supply Token supply
       * @param uri URL to additional info about token
       * @param max The maxium of tokens can be minted from this token
       * @param royalty_payee_address the address to receive the royalty, the address can be a shared account address.
       * @param royalty_points_denominator the denominator for calculating royalty
       * @param royalty_points_numerator the numerator for calculating royalty
       * @param property_keys the property keys for storing on-chain properties
       * @param property_values the property values to be stored on-chain
       * @param property_types the type of property values
       * @returns The hash of the transaction submitted to the API
       */
      // :!:>createToken
      async createToken(account, collectionName, name, description, supply, uri, max = MAX_U64_BIG_INT, royalty_payee_address = account.address(), royalty_points_denominator = 0, royalty_points_numerator = 0, property_keys = [], property_values = [], property_types = [], extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: account.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token::create_token_script",
          [],
          [
            collectionName,
            name,
            description,
            supply,
            max,
            uri,
            royalty_payee_address,
            royalty_points_denominator,
            royalty_points_numerator,
            [false, false, false, false, false],
            property_keys,
            getPropertyValueRaw(property_values, property_types),
            property_types
          ]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Creates a new NFT within the specified account
       *
       * @param account AptosAccount where token will be created
       * @param collectionName Name of collection, that token belongs to
       * @param name Token name
       * @param description Token description
       * @param supply Token supply
       * @param uri URL to additional info about token
       * @param max The maxium of tokens can be minted from this token
       * @param royalty_payee_address the address to receive the royalty, the address can be a shared account address.
       * @param royalty_points_denominator the denominator for calculating royalty
       * @param royalty_points_numerator the numerator for calculating royalty
       * @param property_keys the property keys for storing on-chain properties
       * @param property_values the property values to be stored on-chain
       * @param property_types the type of property values
       * @param mutability_config configs which field is mutable
       * @returns The hash of the transaction submitted to the API
       */
      // :!:>createToken
      async createTokenWithMutabilityConfig(account, collectionName, name, description, supply, uri, max = MAX_U64_BIG_INT, royalty_payee_address = account.address(), royalty_points_denominator = 0, royalty_points_numerator = 0, property_keys = [], property_values = [], property_types = [], mutability_config = [false, false, false, false, false], extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: account.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token::create_token_script",
          [],
          [
            collectionName,
            name,
            description,
            supply,
            max,
            uri,
            royalty_payee_address,
            royalty_points_denominator,
            royalty_points_numerator,
            mutability_config,
            property_keys,
            property_values,
            property_types
          ]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Transfers specified amount of tokens from account to receiver
       *
       * @param account AptosAccount where token from which tokens will be transfered
       * @param receiver  Hex-encoded 32 byte Aptos account address to which tokens will be transfered
       * @param creator Hex-encoded 32 byte Aptos account address to which created tokens
       * @param collectionName Name of collection where token is stored
       * @param name Token name
       * @param amount Amount of tokens which will be transfered
       * @param property_version the version of token PropertyMap with a default value 0.
       * @returns The hash of the transaction submitted to the API
       */
      async offerToken(account, receiver, creator, collectionName, name, amount, property_version = 0, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: account.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token_transfers::offer_script",
          [],
          [receiver, creator, collectionName, name, property_version, amount]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Claims a token on specified account
       *
       * @param account AptosAccount which will claim token
       * @param sender Hex-encoded 32 byte Aptos account address which holds a token
       * @param creator Hex-encoded 32 byte Aptos account address which created a token
       * @param collectionName Name of collection where token is stored
       * @param name Token name
       * @param property_version the version of token PropertyMap with a default value 0.
       * @returns The hash of the transaction submitted to the API
       */
      async claimToken(account, sender, creator, collectionName, name, property_version = 0, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: account.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token_transfers::claim_script",
          [],
          [sender, creator, collectionName, name, property_version]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Removes a token from pending claims list
       *
       * @param account AptosAccount which will remove token from pending list
       * @param receiver Hex-encoded 32 byte Aptos account address which had to claim token
       * @param creator Hex-encoded 32 byte Aptos account address which created a token
       * @param collectionName Name of collection where token is strored
       * @param name Token name
       * @param property_version the version of token PropertyMap with a default value 0.
       * @returns The hash of the transaction submitted to the API
       */
      async cancelTokenOffer(account, receiver, creator, collectionName, name, property_version = 0, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: account.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token_transfers::cancel_offer_script",
          [],
          [receiver, creator, collectionName, name, property_version]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Directly transfer the specified amount of tokens from account to receiver
       * using a single multi signature transaction.
       *
       * @param sender AptosAccount where token from which tokens will be transferred
       * @param receiver Hex-encoded 32 byte Aptos account address to which tokens will be transferred
       * @param creator Hex-encoded 32 byte Aptos account address to which created tokens
       * @param collectionName Name of collection where token is stored
       * @param name Token name
       * @param amount Amount of tokens which will be transferred
       * @param property_version the version of token PropertyMap with a default value 0.
       * @returns The hash of the transaction submitted to the API
       */
      async directTransferToken(sender, receiver, creator, collectionName, name, amount, propertyVersion = 0, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: sender.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token::direct_transfer_script",
          [],
          [creator, collectionName, name, propertyVersion, amount]
        );
        const multiAgentTxn = new aptos_types_exports.MultiAgentRawTransaction(rawTxn, [
          aptos_types_exports.AccountAddress.fromHex(receiver.address())
        ]);
        const senderSignature = new aptos_types_exports.Ed25519Signature(
          sender.signBuffer(TransactionBuilder.getSigningMessage(multiAgentTxn)).toUint8Array()
        );
        const senderAuthenticator = new aptos_types_exports.AccountAuthenticatorEd25519(
          new aptos_types_exports.Ed25519PublicKey(sender.signingKey.publicKey),
          senderSignature
        );
        const receiverSignature = new aptos_types_exports.Ed25519Signature(
          receiver.signBuffer(TransactionBuilder.getSigningMessage(multiAgentTxn)).toUint8Array()
        );
        const receiverAuthenticator = new aptos_types_exports.AccountAuthenticatorEd25519(
          new aptos_types_exports.Ed25519PublicKey(receiver.signingKey.publicKey),
          receiverSignature
        );
        const multiAgentAuthenticator = new aptos_types_exports.TransactionAuthenticatorMultiAgent(
          senderAuthenticator,
          [aptos_types_exports.AccountAddress.fromHex(receiver.address())],
          // Secondary signer addresses
          [receiverAuthenticator]
          // Secondary signer authenticators
        );
        const bcsTxn = bcsToBytes(new aptos_types_exports.SignedTransaction(rawTxn, multiAgentAuthenticator));
        const transactionRes = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return transactionRes.hash;
      }
      /**
       * Directly transfer the specified amount of tokens from account to receiver
       * using a single multi signature transaction.
       *
       * @param sender AptosAccount where token from which tokens will be transferred
       * @param receiver Hex-encoded 32 byte Aptos account address to which tokens will be transferred
       * @param creator Hex-encoded 32 byte Aptos account address to which created tokens
       * @param collectionName Name of collection where token is stored
       * @param name Token name
       * @param amount Amount of tokens which will be transferred
       * @param fee_payer AptosAccount which will pay fee for transaction
       * @param property_version the version of token PropertyMap with a default value 0.
       * @returns The hash of the transaction submitted to the API
       */
      async directTransferTokenWithFeePayer(sender, receiver, creator, collectionName, name, amount, fee_payer, propertyVersion = 0, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: sender.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token::direct_transfer_script",
          [],
          [creator, collectionName, name, propertyVersion, amount]
        );
        const feePayerTxn = new aptos_types_exports.FeePayerRawTransaction(
          rawTxn,
          [aptos_types_exports.AccountAddress.fromHex(receiver.address())],
          aptos_types_exports.AccountAddress.fromHex(fee_payer.address())
        );
        const senderSignature = new aptos_types_exports.Ed25519Signature(
          sender.signBuffer(TransactionBuilder.getSigningMessage(feePayerTxn)).toUint8Array()
        );
        const senderAuthenticator = new aptos_types_exports.AccountAuthenticatorEd25519(
          new aptos_types_exports.Ed25519PublicKey(sender.signingKey.publicKey),
          senderSignature
        );
        const receiverSignature = new aptos_types_exports.Ed25519Signature(
          receiver.signBuffer(TransactionBuilder.getSigningMessage(feePayerTxn)).toUint8Array()
        );
        const receiverAuthenticator = new aptos_types_exports.AccountAuthenticatorEd25519(
          new aptos_types_exports.Ed25519PublicKey(receiver.signingKey.publicKey),
          receiverSignature
        );
        const feePayerSignature = new aptos_types_exports.Ed25519Signature(
          fee_payer.signBuffer(TransactionBuilder.getSigningMessage(feePayerTxn)).toUint8Array()
        );
        const feePayerAuthenticator = new aptos_types_exports.AccountAuthenticatorEd25519(
          new aptos_types_exports.Ed25519PublicKey(fee_payer.signingKey.publicKey),
          feePayerSignature
        );
        const txAuthenticatorFeePayer = new aptos_types_exports.TransactionAuthenticatorFeePayer(
          senderAuthenticator,
          [aptos_types_exports.AccountAddress.fromHex(receiver.address())],
          [receiverAuthenticator],
          { address: aptos_types_exports.AccountAddress.fromHex(fee_payer.address()), authenticator: feePayerAuthenticator }
        );
        const bcsTxn = bcsToBytes(new aptos_types_exports.SignedTransaction(rawTxn, txAuthenticatorFeePayer));
        const transactionRes = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return transactionRes.hash;
      }
      /**
       * User opt-in or out direct transfer through a boolean flag
       *
       * @param sender AptosAccount where the token will be transferred
       * @param optIn boolean value indicates user want to opt-in or out of direct transfer
       * @returns The hash of the transaction submitted to the API
       */
      async optInTokenTransfer(sender, optIn, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: sender.address(), ...extraArgs });
        const rawTxn = await builder.build("0x3::token::opt_in_direct_transfer", [], [optIn]);
        const bcsTxn = AptosClient.generateBCSTransaction(sender, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Directly transfer token to a receiver. The receiver should have opted in to direct transfer
       *
       * @param sender AptosAccount where the token will be transferred
       * @param creator  address of the token creator
       * @param collectionName Name of collection where token is stored
       * @param name Token name
       * @param property_version the version of token PropertyMap
       * @param amount Amount of tokens which will be transfered
       * @returns The hash of the transaction submitted to the API
       */
      async transferWithOptIn(sender, creator, collectionName, tokenName, propertyVersion, receiver, amount, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: sender.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token::transfer_with_opt_in",
          [],
          [creator, collectionName, tokenName, propertyVersion, receiver, amount]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(sender, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * BurnToken by Creator
       *
       * @param creator creator of the token
       * @param ownerAddress address of the token owner
       * @param collectionName Name of collection where token is stored
       * @param name Token name
       * @param amount Amount of tokens which will be transfered
       * @param property_version the version of token PropertyMap
       * @returns The hash of the transaction submitted to the API
       */
      async burnByCreator(creator, ownerAddress, collection, name, PropertyVersion, amount, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: creator.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token::burn_by_creator",
          [],
          [ownerAddress, collection, name, PropertyVersion, amount]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(creator, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * BurnToken by Owner
       *
       * @param owner creator of the token
       * @param creatorAddress address of the token creator
       * @param collectionName Name of collection where token is stored
       * @param name Token name
       * @param amount Amount of tokens which will be transfered
       * @param property_version the version of token PropertyMap
       * @returns The hash of the transaction submitted to the API
       */
      async burnByOwner(owner, creatorAddress, collection, name, PropertyVersion, amount, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: owner.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token::burn",
          [],
          [creatorAddress, collection, name, PropertyVersion, amount]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(owner, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * creator mutates the properties of the tokens
       *
       * @param account AptosAccount who modifies the token properties
       * @param tokenOwner the address of account owning the token
       * @param creator the creator of the token
       * @param collection_name the name of the token collection
       * @param tokenName the name of created token
       * @param propertyVersion the property_version of the token to be modified
       * @param amount the number of tokens to be modified
       *
       * @returns The hash of the transaction submitted to the API
       */
      async mutateTokenProperties(account, tokenOwner, creator, collection_name, tokenName, propertyVersion, amount, keys, values, types, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: account.address(), ...extraArgs });
        const rawTxn = await builder.build(
          "0x3::token::mutate_token_properties",
          [],
          [tokenOwner, creator, collection_name, tokenName, propertyVersion, amount, keys, values, types]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Queries collection data
       * @param creator Hex-encoded 32 byte Aptos account address which created a collection
       * @param collectionName Collection name
       * @returns Collection data in below format
       * ```
       *  Collection {
       *    // Describes the collection
       *    description: string,
       *    // Unique name within this creators account for this collection
       *    name: string,
       *    // URL for additional information/media
       *    uri: string,
       *    // Total number of distinct Tokens tracked by the collection
       *    count: number,
       *    // Optional maximum number of tokens allowed within this collections
       *    maximum: number
       *  }
       * ```
       */
      async getCollectionData(creator, collectionName) {
        const resources = await this.aptosClient.getAccountResources(creator);
        const accountResource = resources.find(
          (r) => r.type === "0x3::token::Collections"
        );
        const { handle } = accountResource.data.collection_data;
        const getCollectionTableItemRequest = {
          key_type: "0x1::string::String",
          value_type: "0x3::token::CollectionData",
          key: collectionName
        };
        const collectionTable = await this.aptosClient.getTableItem(handle, getCollectionTableItemRequest);
        return collectionTable;
      }
      /**
       * Queries token data from collection
       *
       * @param creator Hex-encoded 32 byte Aptos account address which created a token
       * @param collectionName Name of collection, which holds a token
       * @param tokenName Token name
       * @returns Token data in below format
       * ```
       * TokenData {
       *     // Unique name within this creators account for this Token's collection
       *     collection: string;
       *     // Describes this Token
       *     description: string;
       *     // The name of this Token
       *     name: string;
       *     // Optional maximum number of this type of Token.
       *     maximum: number;
       *     // Total number of this type of Token
       *     supply: number;
       *     /// URL for additional information / media
       *     uri: string;
       *   }
       * ```
       */
      // :!:>getTokenData
      async getTokenData(creator, collectionName, tokenName) {
        const creatorHex = creator instanceof HexString ? creator.hex() : creator;
        const collection = await this.aptosClient.getAccountResource(
          creatorHex,
          "0x3::token::Collections"
        );
        const { handle } = collection.data.token_data;
        const tokenDataId = {
          creator: creatorHex,
          collection: collectionName,
          name: tokenName
        };
        const getTokenTableItemRequest = {
          key_type: "0x3::token::TokenDataId",
          value_type: "0x3::token::TokenData",
          key: tokenDataId
        };
        const rawTokenData = await this.aptosClient.getTableItem(handle, getTokenTableItemRequest);
        return new TokenData(
          rawTokenData.collection,
          rawTokenData.description,
          rawTokenData.name,
          rawTokenData.maximum,
          rawTokenData.supply,
          rawTokenData.uri,
          rawTokenData.default_properties,
          rawTokenData.mutability_config
        );
      }
      // <:!:getTokenData
      /**
       * Queries token balance for the token creator
       */
      async getToken(creator, collectionName, tokenName, property_version = "0") {
        const tokenDataId = {
          creator: creator instanceof HexString ? creator.hex() : creator,
          collection: collectionName,
          name: tokenName
        };
        return this.getTokenForAccount(creator, {
          token_data_id: tokenDataId,
          property_version
        });
      }
      /**
       * Queries token balance for a token account
       * @param account Hex-encoded 32 byte Aptos account address which created a token
       * @param tokenId token id
       *
       * TODO: Update this:
       * @example
       * ```
       * {
       *   creator: '0x1',
       *   collection: 'Some collection',
       *   name: 'Awesome token'
       * }
       * ```
       * @returns Token object in below format
       * ```
       * Token {
       *   id: TokenId;
       *   value: number;
       * }
       * ```
       */
      async getTokenForAccount(account, tokenId) {
        const tokenStore = await this.aptosClient.getAccountResource(
          account instanceof HexString ? account.hex() : account,
          "0x3::token::TokenStore"
        );
        const { handle } = tokenStore.data.tokens;
        const getTokenTableItemRequest = {
          key_type: "0x3::token::TokenId",
          value_type: "0x3::token::Token",
          key: tokenId
        };
        try {
          const rawToken = await this.aptosClient.getTableItem(handle, getTokenTableItemRequest);
          return new Token(rawToken.id, rawToken.amount, rawToken.token_properties);
        } catch (error) {
          if ((error == null ? void 0 : error.status) === 404) {
            return {
              id: tokenId,
              amount: "0",
              token_properties: new PropertyMap()
            };
          }
          return error;
        }
      }
    };
    var FungibleAssetClient = class {
      /**
       * Creates new FungibleAssetClient instance
       *
       * @param provider Provider instance
       */
      constructor(provider) {
        this.assetType = "0x1::fungible_asset::Metadata";
        this.provider = provider;
      }
      /**
       *  Transfer `amount` of fungible asset from sender's primary store to recipient's primary store.
       *
       * Use this method to transfer any fungible asset including fungible token.
       *
       * @param sender The sender account
       * @param fungibleAssetMetadataAddress The fungible asset address.
       * For example if you’re transferring USDT this would be the USDT address
       * @param recipient Recipient address
       * @param amount Number of assets to transfer
       * @returns The hash of the transaction submitted to the API
       */
      async transfer(sender, fungibleAssetMetadataAddress, recipient, amount, extraArgs) {
        const rawTransaction = await this.generateTransfer(
          sender,
          fungibleAssetMetadataAddress,
          recipient,
          amount,
          extraArgs
        );
        const txnHash = await this.provider.signAndSubmitTransaction(sender, rawTransaction);
        return txnHash;
      }
      /**
       * Get the balance of a fungible asset from the account's primary fungible store.
       *
       * @param account Account that you want to get the balance of.
       * @param fungibleAssetMetadataAddress The fungible asset address you want to check the balance of
       * @returns Promise that resolves to the balance
       */
      async getPrimaryBalance(account, fungibleAssetMetadataAddress) {
        const payload = {
          function: "0x1::primary_fungible_store::balance",
          type_arguments: [this.assetType],
          arguments: [HexString.ensure(account).hex(), HexString.ensure(fungibleAssetMetadataAddress).hex()]
        };
        const response = await this.provider.view(payload);
        return BigInt(response[0]);
      }
      /**
       *
       * Generate a transfer transaction that can be used to sign and submit to transfer an asset amount
       * from the sender primary fungible store to the recipient primary fungible store.
       *
       * This method can be used if you want/need to get the raw transaction so you can
       * first simulate the transaction and then sign and submit it.
       *
       * @param sender The sender account
       * @param fungibleAssetMetadataAddress The fungible asset address.
       * For example if you’re transferring USDT this would be the USDT address
       * @param recipient Recipient address
       * @param amount Number of assets to transfer
       * @returns Raw Transaction
       */
      async generateTransfer(sender, fungibleAssetMetadataAddress, recipient, amount, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.provider, {
          sender: sender.address(),
          ...extraArgs
        });
        const rawTxn = await builder.build(
          "0x1::primary_fungible_store::transfer",
          [this.assetType],
          [HexString.ensure(fungibleAssetMetadataAddress).hex(), HexString.ensure(recipient).hex(), amount]
        );
        return rawTxn;
      }
    };
    var PropertyTypeMap = {
      BOOLEAN: "bool",
      U8: "u8",
      U16: "u16",
      U32: "u32",
      U64: "u64",
      U128: "u128",
      U256: "u256",
      ADDRESS: "address",
      VECTOR: "vector<u8>",
      STRING: "string"
    };
    var AptosToken = class {
      /**
       * Creates new AptosToken instance
       *
       * @param provider Provider instance
       */
      constructor(provider) {
        this.tokenType = "0x4::token::Token";
        this.provider = provider;
      }
      async submitTransaction(account, funcName, typeArgs, args, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.provider, {
          sender: account.address(),
          ...extraArgs
        });
        const rawTxn = await builder.build(`0x4::aptos_token::${funcName}`, typeArgs, args);
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.provider.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Creates a new collection within the specified account
       *
       * @param creator AptosAccount where collection will be created
       * @param description Collection description
       * @param name Collection name
       * @param uri URL to additional info about collection
       * @param options CreateCollectionOptions type. By default all values set to `true` or `0`
       * @returns The hash of the transaction submitted to the API
       */
      // :!:>createCollection
      async createCollection(creator, description, name, uri, maxSupply = MAX_U64_BIG_INT, options, extraArgs) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;
        return this.submitTransaction(
          creator,
          "create_collection",
          [],
          [
            description,
            maxSupply,
            name,
            uri,
            (_a = options == null ? void 0 : options.mutableDescription) != null ? _a : true,
            (_b = options == null ? void 0 : options.mutableRoyalty) != null ? _b : true,
            (_c = options == null ? void 0 : options.mutableURI) != null ? _c : true,
            (_d = options == null ? void 0 : options.mutableTokenDescription) != null ? _d : true,
            (_e = options == null ? void 0 : options.mutableTokenName) != null ? _e : true,
            (_f = options == null ? void 0 : options.mutableTokenProperties) != null ? _f : true,
            (_g = options == null ? void 0 : options.mutableTokenURI) != null ? _g : true,
            (_h = options == null ? void 0 : options.tokensBurnableByCreator) != null ? _h : true,
            (_i = options == null ? void 0 : options.tokensFreezableByCreator) != null ? _i : true,
            (_j = options == null ? void 0 : options.royaltyNumerator) != null ? _j : 0,
            (_k = options == null ? void 0 : options.royaltyDenominator) != null ? _k : 1
          ],
          extraArgs
        );
      }
      /**
       * Mint a new token within the specified account
       *
       * @param account AptosAccount where token will be created
       * @param collection Name of collection, that token belongs to
       * @param description Token description
       * @param name Token name
       * @param uri URL to additional info about token
       * @param propertyKeys the property keys for storing on-chain properties
       * @param propertyTypes the type of property values
       * @param propertyValues the property values to be stored on-chain
       * @returns The hash of the transaction submitted to the API
       */
      // :!:>mint
      async mint(account, collection, description, name, uri, propertyKeys = [], propertyTypes = [], propertyValues = [], extraArgs) {
        return this.submitTransaction(
          account,
          "mint",
          [],
          [
            collection,
            description,
            name,
            uri,
            propertyKeys,
            propertyTypes,
            getPropertyValueRaw(propertyValues, propertyTypes)
          ],
          extraArgs
        );
      }
      /**
       * Mint a soul bound token into a recipient's account
       *
       * @param account AptosAccount that mints the token
       * @param collection Name of collection, that token belongs to
       * @param description Token description
       * @param name Token name
       * @param uri URL to additional info about token
       * @param recipient AptosAccount where token will be created
       * @param propertyKeys the property keys for storing on-chain properties
       * @param propertyTypes the type of property values
       * @param propertyValues the property values to be stored on-chain
       * @returns The hash of the transaction submitted to the API
       */
      async mintSoulBound(account, collection, description, name, uri, recipient, propertyKeys = [], propertyTypes = [], propertyValues = [], extraArgs) {
        return this.submitTransaction(
          account,
          "mint_soul_bound",
          [],
          [
            collection,
            description,
            name,
            uri,
            propertyKeys,
            propertyTypes,
            getPropertyValueRaw(propertyValues, propertyTypes),
            recipient.address().hex()
          ],
          extraArgs
        );
      }
      /**
       * Burn a token by its creator
       * @param creator Creator account
       * @param token Token address
       * @returns The hash of the transaction submitted to the API
       */
      async burnToken(creator, token, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "burn",
          [tokenType || this.tokenType],
          [HexString.ensure(token).hex()],
          extraArgs
        );
      }
      /**
       * Freeze token transfer ability
       * @param creator Creator account
       * @param token Token address
       * @returns The hash of the transaction submitted to the API
       */
      async freezeTokenTransafer(creator, token, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "freeze_transfer",
          [tokenType || this.tokenType],
          [HexString.ensure(token).hex()],
          extraArgs
        );
      }
      /**
       * Unfreeze token transfer ability
       * @param creator Creator account
       * @param token Token address
       * @returns The hash of the transaction submitted to the API
       */
      async unfreezeTokenTransafer(creator, token, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "unfreeze_transfer",
          [tokenType || this.tokenType],
          [HexString.ensure(token).hex()],
          extraArgs
        );
      }
      /**
       * Set token description
       * @param creator Creator account
       * @param token Token address
       * @param description Token description
       * @returns The hash of the transaction submitted to the API
       */
      async setTokenDescription(creator, token, description, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "set_description",
          [tokenType || this.tokenType],
          [HexString.ensure(token).hex(), description],
          extraArgs
        );
      }
      /**
       * Set token name
       * @param creator Creator account
       * @param token Token address
       * @param name Token name
       * @returns The hash of the transaction submitted to the API
       */
      async setTokenName(creator, token, name, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "set_name",
          [tokenType || this.tokenType],
          [HexString.ensure(token).hex(), name],
          extraArgs
        );
      }
      /**
       * Set token URI
       * @param creator Creator account
       * @param token Token address
       * @param uri Token uri
       * @returns The hash of the transaction submitted to the API
       */
      async setTokenURI(creator, token, uri, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "set_uri",
          [tokenType || this.tokenType],
          [HexString.ensure(token).hex(), uri],
          extraArgs
        );
      }
      /**
       * Add token property
       * @param creator Creator account
       * @param token Token address
       * @param key the property key for storing on-chain property
       * @param type the type of property value
       * @param value the property value to be stored on-chain
       * @returns The hash of the transaction submitted to the API
       */
      async addTokenProperty(creator, token, propertyKey, propertyType, propertyValue, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "add_property",
          [tokenType || this.tokenType],
          [
            HexString.ensure(token).hex(),
            propertyKey,
            PropertyTypeMap[propertyType],
            getSinglePropertyValueRaw(propertyValue, PropertyTypeMap[propertyType])
          ],
          extraArgs
        );
      }
      /**
       * Remove token property
       * @param creator Creator account
       * @param token Token address
       * @param key the property key stored on-chain
       * @returns The hash of the transaction submitted to the API
       */
      async removeTokenProperty(creator, token, propertyKey, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "remove_property",
          [tokenType || this.tokenType],
          [HexString.ensure(token).hex(), propertyKey],
          extraArgs
        );
      }
      /**
       * Update token property
       * @param creator Creator account
       * @param token Token address
       * @param key the property key stored on-chain
       * @param type the property typed stored on-chain
       * @param value the property value to be stored on-chain
       * @returns The hash of the transaction submitted to the API
       */
      async updateTokenProperty(creator, token, propertyKey, propertyType, propertyValue, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "update_property",
          [tokenType || this.tokenType],
          [
            HexString.ensure(token).hex(),
            propertyKey,
            PropertyTypeMap[propertyType],
            getSinglePropertyValueRaw(propertyValue, PropertyTypeMap[propertyType])
          ],
          extraArgs
        );
      }
      async addTypedProperty(creator, token, propertyKey, propertyType, propertyValue, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "add_typed_property",
          [tokenType || this.tokenType, PropertyTypeMap[propertyType]],
          [HexString.ensure(token).hex(), propertyKey, propertyValue],
          extraArgs
        );
      }
      async updateTypedProperty(creator, token, propertyKey, propertyType, propertyValue, tokenType, extraArgs) {
        return this.submitTransaction(
          creator,
          "update_typed_property",
          [tokenType || this.tokenType, PropertyTypeMap[propertyType]],
          [HexString.ensure(token).hex(), propertyKey, propertyValue],
          extraArgs
        );
      }
      /**
       * Transfer a non fungible token ownership.
       * We can transfer a token only when the token is not frozen (i.e. owner transfer is not disabled such as for soul bound tokens)
       * @param owner The account of the current token owner
       * @param token Token address
       * @param recipient Recipient address
       * @returns The hash of the transaction submitted to the API
       */
      async transferTokenOwnership(owner, token, recipient, tokenType, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.provider, {
          sender: owner.address(),
          ...extraArgs
        });
        const rawTxn = await builder.build(
          "0x1::object::transfer",
          [tokenType || this.tokenType],
          [HexString.ensure(token).hex(), HexString.ensure(recipient).hex()]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(owner, rawTxn);
        const pendingTransaction = await this.provider.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Transfer a token. This function supports transfer non-fungible token and fungible token.
       *
       * To set the token type, set isFungibleToken param to true or false.
       * If isFungibleToken param is not set, the function would query Indexer
       * for the token data and check whether it is a non-fungible or a fungible token.
       *
       * Note: this function supports only token v2 standard (it does not support the token v1 standard)
       *
       * @param data NonFungibleTokenParameters | FungibleTokenParameters type
       * @param isFungibleToken (optional) The token type, non-fungible or fungible token.
       * @returns The hash of the transaction submitted to the API
       */
      async transfer(data, isFungibleToken) {
        let isFungible = isFungibleToken;
        if (isFungible === void 0 || isFungible === null) {
          const tokenData = await this.provider.getTokenData(HexString.ensure(data.tokenAddress).hex());
          isFungible = tokenData.current_token_datas_v2[0].is_fungible_v2;
        }
        if (isFungible) {
          const token2 = data;
          const fungibleAsset = new FungibleAssetClient(this.provider);
          const txnHash2 = await fungibleAsset.transfer(
            token2.owner,
            token2.tokenAddress,
            token2.recipient,
            token2.amount,
            token2.extraArgs
          );
          return txnHash2;
        }
        const token = data;
        const txnHash = await this.transferTokenOwnership(
          token.owner,
          token.tokenAddress,
          token.recipient,
          token.tokenType,
          token.extraArgs
        );
        return txnHash;
      }
      /**
       * Burn an object by the object owner
       * @param owner The object owner account
       * @param objectId The object address
       * @optional objectType. The object type, default to "0x1::object::ObjectCore"
       * @returns The hash of the transaction submitted to the API
       */
      async burnObject(owner, objectId, objectType, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.provider, {
          sender: owner.address(),
          ...extraArgs
        });
        const rawTxn = await builder.build(
          "0x1::object::burn",
          [objectType || "0x1::object::ObjectCore"],
          [HexString.ensure(objectId).hex()]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(owner, rawTxn);
        const pendingTransaction = await this.provider.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
    };
    var TRANSFER_COINS = "0x1::aptos_account::transfer_coins";
    var COIN_TRANSFER = "0x1::coin::transfer";
    var CoinClient = class {
      /**
       * Creates new CoinClient instance
       * @param aptosClient AptosClient instance
       */
      constructor(aptosClient2) {
        this.aptosClient = aptosClient2;
      }
      /**
       * Generate, sign, and submit a transaction to the Aptos blockchain API to
       * transfer coins from one account to another. By default it transfers
       * 0x1::aptos_coin::AptosCoin, but you can specify a different coin type
       * with the `coinType` argument.
       *
       * You may set `createReceiverIfMissing` to true if you want to create the
       * receiver account if it does not exist on chain yet. If you do not set
       * this to true, the transaction will fail if the receiver account does not
       * exist on-chain.
       *
       * The TS SDK supports fungible assets operations. If you want to use CoinClient
       * with this feature, set the `coinType` to be the fungible asset metadata address.
       * This option uses the `FungibleAssetClient` class and queries the
       * fungible asset primary store.
       *
       * @param from Account sending the coins
       * @param to Account to receive the coins
       * @param amount Number of coins to transfer
       * @param extraArgs Extra args for building the transaction or configuring how
       * the client should submit and wait for the transaction
       * @returns The hash of the transaction submitted to the API
       */
      // :!:>transfer
      async transfer(from, to, amount, extraArgs) {
        var _a, _b, _c;
        const isTypeTag = ((_a = extraArgs == null ? void 0 : extraArgs.coinType) != null ? _a : "").toString().includes("::");
        if ((extraArgs == null ? void 0 : extraArgs.coinType) && !isTypeTag && AccountAddress.isValid(extraArgs.coinType)) {
          console.warn("to transfer a fungible asset, use `FungibleAssetClient()` class for better support");
          const provider = new Provider({
            fullnodeUrl: this.aptosClient.nodeUrl,
            indexerUrl: (_b = NetworkToIndexerAPI[NodeAPIToNetwork[this.aptosClient.nodeUrl]]) != null ? _b : this.aptosClient.nodeUrl
          });
          const fungibleAsset = new FungibleAssetClient(provider);
          const txnHash = await fungibleAsset.transfer(
            from,
            extraArgs == null ? void 0 : extraArgs.coinType,
            getAddressFromAccountOrAddress(to),
            amount
          );
          return txnHash;
        }
        const coinTypeToTransfer = (_c = extraArgs == null ? void 0 : extraArgs.coinType) != null ? _c : APTOS_COIN;
        let func;
        if ((extraArgs == null ? void 0 : extraArgs.createReceiverIfMissing) === void 0) {
          func = TRANSFER_COINS;
        } else {
          func = (extraArgs == null ? void 0 : extraArgs.createReceiverIfMissing) ? TRANSFER_COINS : COIN_TRANSFER;
        }
        const toAddress = getAddressFromAccountOrAddress(to);
        const builder = new TransactionBuilderRemoteABI(this.aptosClient, { sender: from.address(), ...extraArgs });
        const rawTxn = await builder.build(func, [coinTypeToTransfer], [toAddress, amount]);
        const bcsTxn = AptosClient.generateBCSTransaction(from, rawTxn);
        const pendingTransaction = await this.aptosClient.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      // <:!:transfer
      /**
       * Get the balance of the account. By default it checks the balance of
       * 0x1::aptos_coin::AptosCoin, but you can specify a different coin type.
       *
       * to use a different type, set the `coinType` to be the fungible asset type.
       *
       * The TS SDK supports fungible assets operations. If you want to use CoinClient
       * with this feature, set the `coinType` to be the fungible asset metadata address.
       * This option uses the FungibleAssetClient class and queries the
       * fungible asset primary store.
       *
       * @param account Account that you want to get the balance of.
       * @param extraArgs Extra args for checking the balance.
       * @returns Promise that resolves to the balance as a bigint.
       */
      // :!:>checkBalance
      async checkBalance(account, extraArgs) {
        var _a, _b, _c;
        const isTypeTag = ((_a = extraArgs == null ? void 0 : extraArgs.coinType) != null ? _a : "").toString().includes("::");
        if ((extraArgs == null ? void 0 : extraArgs.coinType) && !isTypeTag && AccountAddress.isValid(extraArgs.coinType)) {
          console.warn("to check balance of a fungible asset, use `FungibleAssetClient()` class for better support");
          const provider = new Provider({
            fullnodeUrl: this.aptosClient.nodeUrl,
            indexerUrl: (_b = NetworkToIndexerAPI[NodeAPIToNetwork[this.aptosClient.nodeUrl]]) != null ? _b : this.aptosClient.nodeUrl
          });
          const fungibleAsset = new FungibleAssetClient(provider);
          const balance = await fungibleAsset.getPrimaryBalance(
            getAddressFromAccountOrAddress(account),
            extraArgs == null ? void 0 : extraArgs.coinType
          );
          return balance;
        }
        const coinType = (_c = extraArgs == null ? void 0 : extraArgs.coinType) != null ? _c : APTOS_COIN;
        const typeTag = `0x1::coin::CoinStore<${coinType}>`;
        const address = getAddressFromAccountOrAddress(account);
        const accountResource = await this.aptosClient.getAccountResource(address, typeTag);
        return BigInt(accountResource.data.coin.value);
      }
      // <:!:checkBalance
    };
    var FaucetClient = class extends AptosClient {
      /**
       * Establishes a connection to Aptos node
       * @param nodeUrl A url of the Aptos Node API endpoint
       * @param faucetUrl A faucet url
       * @param config An optional config for inner axios instance
       * Detailed config description: {@link https://github.com/axios/axios#request-config}
       */
      constructor(nodeUrl, faucetUrl, config) {
        super(nodeUrl, config);
        if (!faucetUrl) {
          throw new Error("Faucet URL cannot be empty.");
        }
        this.faucetUrl = faucetUrl;
        this.config = config;
      }
      /**
       * This creates an account if it does not exist and mints the specified amount of
       * coins into that account
       * @param address Hex-encoded 16 bytes Aptos account address wich mints tokens
       * @param amount Amount of tokens to mint
       * @param timeoutSecs
       * @returns Hashes of submitted transactions
       */
      async fundAccount(address, amount, timeoutSecs = DEFAULT_TXN_TIMEOUT_SEC) {
        const { data } = await post({
          url: this.faucetUrl,
          endpoint: "mint",
          body: null,
          params: {
            address: HexString.ensure(address).noPrefix(),
            amount
          },
          overrides: { ...this.config },
          originMethod: "fundAccount"
        });
        const promises = [];
        for (let i = 0; i < data.length; i += 1) {
          const tnxHash = data[i];
          promises.push(this.waitForTransaction(tnxHash, { timeoutSecs }));
        }
        await Promise.all(promises);
        return data;
      }
    };
    var ansContractsMap = {
      testnet: "0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c",
      mainnet: "0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c"
    };
    var nameComponentPattern = /^[a-z\d][a-z\d-]{1,61}[a-z\d]$/;
    var namePattern = new RegExp(
      "^(?:(?<subdomain>[^.]+)\\.(?!apt$))?(?<domain>[^.]+)(?:\\.apt)?$"
    );
    var AnsClient = class {
      /**
       * Creates new AnsClient instance
       * @param provider Provider instance
       * @param contractAddress An optional contract address.
       * If there is no contract address matching to the provided network
       * then the AnsClient class expects a contract address -
       * this is to support both mainnet/testnet networks and local development.
       */
      constructor(provider, contractAddress) {
        var _a;
        this.provider = provider;
        if (!ansContractsMap[this.provider.network] && !contractAddress) {
          throw new Error("Error: For custom providers, you must pass in a contract address");
        }
        this.contractAddress = (_a = ansContractsMap[this.provider.network]) != null ? _a : contractAddress;
      }
      /**
       * Returns the primary name for the given account address
       * @param address An account address
       * @returns Account's primary name | null if there is no primary name defined
       */
      async getPrimaryNameByAddress(address) {
        const ansResource = await this.provider.getAccountResource(
          this.contractAddress,
          `${this.contractAddress}::domains::ReverseLookupRegistryV1`
        );
        const data = ansResource.data;
        const { handle } = data.registry;
        const domainsTableItemRequest = {
          key_type: "address",
          value_type: `${this.contractAddress}::domains::NameRecordKeyV1`,
          key: address
        };
        try {
          const item = await this.provider.getTableItem(handle, domainsTableItemRequest);
          return item.subdomain_name.vec[0] ? `${item.subdomain_name.vec[0]}.${item.domain_name}` : item.domain_name;
        } catch (error) {
          if (error.status === 404) {
            return null;
          }
          throw new Error(error);
        }
      }
      /**
       * Returns the target account address for the given name
       * @param name ANS name
       * @returns Account address | null
       */
      async getAddressByName(name) {
        var _a, _b;
        const { domain, subdomain } = (_b = (_a = name.match(namePattern)) == null ? void 0 : _a.groups) != null ? _b : {};
        if (!domain)
          return null;
        const registration = subdomain ? await this.getRegistrationForSubdomainName(domain, subdomain) : await this.getRegistrationForDomainName(domain);
        return registration === null ? null : registration.target;
      }
      /**
       * Mint a new Aptos name
       *
       * @param account AptosAccount where collection will be created
       * @param domainName Aptos domain name to mint
       * @param years year duration of the domain name
       * @returns The hash of the pending transaction submitted to the API
       */
      async mintAptosName(account, domainName, years = 1, extraArgs) {
        if (domainName.match(nameComponentPattern) === null) {
          throw new ApiError(400, `Name ${domainName} is not valid`);
        }
        const registration = await this.getRegistrationForDomainName(domainName);
        if (registration) {
          const now2 = Math.ceil(Date.now() / 1e3);
          if (now2 < registration.expirationTimestampSeconds) {
            throw new ApiError(400, `Name ${domainName} is not available`);
          }
        }
        const builder = new TransactionBuilderRemoteABI(this.provider.aptosClient, {
          sender: account.address(),
          ...extraArgs
        });
        const rawTxn = await builder.build(`${this.contractAddress}::domains::register_domain`, [], [domainName, years]);
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.provider.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Mint a new Aptos Subdomain
       *
       * @param account AptosAccount the owner of the domain name
       * @param subdomainName subdomain name to mint
       * @param domainName Aptos domain name to mint under
       * @param expirationTimestampSeconds must be set between the domains expiration and the current time
       * @returns The hash of the pending transaction submitted to the API
       */
      async mintAptosSubdomain(account, subdomainName, domainName, expirationTimestampSeconds, extraArgs) {
        if (domainName.match(nameComponentPattern) === null) {
          throw new ApiError(400, `Domain name ${domainName} is not valid`);
        }
        if (subdomainName.match(nameComponentPattern) === null) {
          throw new ApiError(400, `Subdomain name ${subdomainName} is not valid`);
        }
        const subdomainRegistration = await this.getRegistrationForSubdomainName(domainName, subdomainName);
        if (subdomainRegistration) {
          const now3 = Math.ceil(Date.now() / 1e3);
          if (now3 < subdomainRegistration.expirationTimestampSeconds) {
            throw new ApiError(400, `Name ${subdomainName}.${domainName} is not available`);
          }
        }
        const domainRegistration = await this.getRegistrationForDomainName(domainName);
        if (domainRegistration === null) {
          throw new ApiError(400, `Domain name ${domainName} does not exist`);
        }
        const now2 = Math.ceil(Date.now() / 1e3);
        if (domainRegistration.expirationTimestampSeconds < now2) {
          throw new ApiError(400, `Domain name ${domainName} expired`);
        }
        const actualExpirationTimestampSeconds = expirationTimestampSeconds || domainRegistration.expirationTimestampSeconds;
        if (actualExpirationTimestampSeconds < now2) {
          throw new ApiError(400, `Expiration for ${subdomainName}.${domainName} is before now`);
        }
        const builder = new TransactionBuilderRemoteABI(this.provider.aptosClient, {
          sender: account.address(),
          ...extraArgs
        });
        const rawTxn = await builder.build(
          `${this.contractAddress}::domains::register_subdomain`,
          [],
          [subdomainName, domainName, actualExpirationTimestampSeconds]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.provider.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * @param account AptosAccount the owner of the domain name
       * @param subdomainName subdomain name to mint
       * @param domainName Aptos domain name to mint
       * @param target the target address for the subdomain
       * @returns The hash of the pending transaction submitted to the API
       */
      async setSubdomainAddress(account, subdomainName, domainName, target, extraArgs) {
        const standardizeAddress = AccountAddress.standardizeAddress(target);
        if (domainName.match(nameComponentPattern) === null) {
          throw new ApiError(400, `Name ${domainName} is not valid`);
        }
        if (subdomainName.match(nameComponentPattern) === null) {
          throw new ApiError(400, `Name ${subdomainName} is not valid`);
        }
        const builder = new TransactionBuilderRemoteABI(this.provider.aptosClient, {
          sender: account.address(),
          ...extraArgs
        });
        const rawTxn = await builder.build(
          `${this.contractAddress}::domains::set_subdomain_address`,
          [],
          [subdomainName, domainName, standardizeAddress]
        );
        const bcsTxn = AptosClient.generateBCSTransaction(account, rawTxn);
        const pendingTransaction = await this.provider.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Initialize reverse lookup for contract owner
       *
       * @param owner the `aptos_names` AptosAccount
       * @returns The hash of the pending transaction submitted to the API
       */
      async initReverseLookupRegistry(owner, extraArgs) {
        const builder = new TransactionBuilderRemoteABI(this.provider.aptosClient, {
          sender: owner.address(),
          ...extraArgs
        });
        const rawTxn = await builder.build(`${this.contractAddress}::domains::init_reverse_lookup_registry_v1`, [], []);
        const bcsTxn = AptosClient.generateBCSTransaction(owner, rawTxn);
        const pendingTransaction = await this.provider.submitSignedBCSTransaction(bcsTxn);
        return pendingTransaction.hash;
      }
      /**
       * Returns the AnsRegistry for the given domain name
       * @param domain domain name
       * @example
       * if name is `aptos.apt`
       * domain = aptos
       *
       * @returns AnsRegistry | null
       */
      async getRegistrationForDomainName(domain) {
        if (domain.match(nameComponentPattern) === null)
          return null;
        const ansResource = await this.provider.getAccountResource(
          this.contractAddress,
          `${this.contractAddress}::domains::NameRegistryV1`
        );
        const data = ansResource.data;
        const { handle } = data.registry;
        const domainsTableItemRequest = {
          key_type: `${this.contractAddress}::domains::NameRecordKeyV1`,
          value_type: `${this.contractAddress}::domains::NameRecordV1`,
          key: {
            subdomain_name: { vec: [] },
            domain_name: domain
          }
        };
        try {
          const item = await this.provider.getTableItem(handle, domainsTableItemRequest);
          return {
            target: item.target_address.vec.length === 1 ? item.target_address.vec[0] : null,
            expirationTimestampSeconds: item.expiration_time_sec
          };
        } catch (error) {
          if (error.status === 404) {
            return null;
          }
          throw new Error(error);
        }
      }
      /**
       * Returns the AnsRegistry for the given subdomain_name
       * @param domain domain name
       * @param subdomain subdomain name
       * @example
       * if name is `dev.aptos.apt`
       * domain = aptos
       * subdomain = dev
       *
       * @returns AnsRegistry | null
       */
      async getRegistrationForSubdomainName(domain, subdomain) {
        if (domain.match(nameComponentPattern) === null)
          return null;
        if (subdomain.match(nameComponentPattern) === null)
          return null;
        const ansResource = await this.provider.getAccountResource(
          this.contractAddress,
          `${this.contractAddress}::domains::NameRegistryV1`
        );
        const data = ansResource.data;
        const { handle } = data.registry;
        const domainsTableItemRequest = {
          key_type: `${this.contractAddress}::domains::NameRecordKeyV1`,
          value_type: `${this.contractAddress}::domains::NameRecordV1`,
          key: {
            subdomain_name: { vec: [subdomain] },
            domain_name: domain
          }
        };
        try {
          const item = await this.provider.getTableItem(handle, domainsTableItemRequest);
          return {
            target: item.target_address.vec.length === 1 ? item.target_address.vec[0] : null,
            expirationTimestampSeconds: item.expiration_time_sec
          };
        } catch (error) {
          if (error.status === 404) {
            return null;
          }
          throw new Error(error);
        }
      }
    };
    var now = () => Math.floor(Date.now() / 1e3);
    var AccountSequenceNumber = class {
      constructor(provider, account, maxWaitTime, maximumInFlight, sleepTime) {
        this.lastUncommintedNumber = null;
        this.currentNumber = null;
        this.lock = false;
        this.provider = provider;
        this.account = account;
        this.maxWaitTime = maxWaitTime;
        this.maximumInFlight = maximumInFlight;
        this.sleepTime = sleepTime;
      }
      /**
       * Returns the next available sequence number for this account
       *
       * @returns next available sequence number
       */
      async nextSequenceNumber() {
        while (this.lock) {
          await sleep(this.sleepTime);
        }
        this.lock = true;
        let nextNumber = BigInt(0);
        try {
          if (this.lastUncommintedNumber === null || this.currentNumber === null) {
            await this.initialize();
          }
          if (this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight) {
            await this.update();
            const startTime = now();
            while (this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight) {
              await sleep(this.sleepTime);
              if (now() - startTime > this.maxWaitTime) {
                console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.address()}`);
                await this.initialize();
              } else {
                await this.update();
              }
            }
          }
          nextNumber = this.currentNumber;
          this.currentNumber += BigInt(1);
        } catch (e) {
          console.error("error in getting next sequence number for this account", e);
        } finally {
          this.lock = false;
        }
        return nextNumber;
      }
      /**
       * Initializes this account with the sequence number on chain
       */
      async initialize() {
        const { sequence_number: sequenceNumber } = await this.provider.getAccount(this.account.address());
        this.currentNumber = BigInt(sequenceNumber);
        this.lastUncommintedNumber = BigInt(sequenceNumber);
      }
      /**
       * Updates this account sequence number with the one on-chain
       *
       * @returns on-chain sequence number for this account
       */
      async update() {
        const { sequence_number: sequenceNumber } = await this.provider.getAccount(this.account.address());
        this.lastUncommintedNumber = BigInt(sequenceNumber);
        return this.lastUncommintedNumber;
      }
      /**
       * Synchronizes local sequence number with the seqeunce number on chain for this account.
       *
       * Poll the network until all submitted transactions have either been committed or until
       * the maximum wait time has elapsed
       */
      async synchronize() {
        if (this.lastUncommintedNumber === this.currentNumber)
          return;
        while (this.lock) {
          await sleep(this.sleepTime);
        }
        this.lock = true;
        try {
          await this.update();
          const startTime = now();
          while (this.lastUncommintedNumber !== this.currentNumber) {
            if (now() - startTime > this.maxWaitTime) {
              console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.address()}`);
              await this.initialize();
            } else {
              await sleep(this.sleepTime);
              await this.update();
            }
          }
        } catch (e) {
          console.error("error in synchronizing this account sequence number with the one on chain", e);
        } finally {
          this.lock = false;
        }
      }
    };
    var import_eventemitter3 = __toESM(require_eventemitter3());
    var AsyncQueue = class {
      constructor() {
        this.queue = [];
        this.pendingDequeue = [];
        this.cancelled = false;
      }
      /**
       * The enqueue method adds an item to the queue. If there are pending dequeued promises,
       * in the pendingDequeue, it resolves the oldest promise with the enqueued item immediately.
       * Otherwise, it adds the item to the queue.
       *
       * @param item T
       */
      enqueue(item) {
        this.cancelled = false;
        if (this.pendingDequeue.length > 0) {
          const promise = this.pendingDequeue.shift();
          promise == null ? void 0 : promise.resolve(item);
          return;
        }
        this.queue.push(item);
      }
      /**
       * The dequeue method returns a promise that resolves to the next item in the queue.
       * If the queue is not empty, it resolves the promise immediately with the next item.
       * Otherwise, it creates a new promise. The promise's resolve function is stored
       * in the pendingDequeue with a unique counter value as the key.
       * The newly created promise is then returned, and it will be resolved later when an item is enqueued.
       *
       * @returns Promise<T>
       */
      async dequeue() {
        if (this.queue.length > 0) {
          return Promise.resolve(this.queue.shift());
        }
        return new Promise((resolve, reject) => {
          this.pendingDequeue.push({ resolve, reject });
        });
      }
      /**
       * The isEmpty method returns whether the queue is empty or not.
       *
       * @returns boolean
       */
      isEmpty() {
        return this.queue.length === 0;
      }
      /**
       * The cancel method cancels all pending promises in the queue.
       * It rejects the promises with a AsyncQueueCancelledError error,
       * ensuring that any awaiting code can handle the cancellation appropriately.
       */
      cancel() {
        this.cancelled = true;
        this.pendingDequeue.forEach(async ({ reject }) => {
          reject(new AsyncQueueCancelledError("Task cancelled"));
        });
        this.pendingDequeue = [];
        this.queue.length = 0;
      }
      /**
       * The isCancelled method returns whether the queue is cancelled or not.
       *
       * @returns boolean
       */
      isCancelled() {
        return this.cancelled;
      }
      /**
       * The pendingDequeueLength method returns the length of the pendingDequeue.
       *
       * @returns number
       */
      pendingDequeueLength() {
        return this.pendingDequeue.length;
      }
    };
    var AsyncQueueCancelledError = class extends Error {
    };
    var promiseFulfilledStatus = "fulfilled";
    var TransactionWorkerEvents = ((TransactionWorkerEvents2) => {
      TransactionWorkerEvents2["TransactionSent"] = "transactionSent";
      TransactionWorkerEvents2["TransactionSendFailed"] = "transactionsendFailed";
      TransactionWorkerEvents2["TransactionExecuted"] = "transactionExecuted";
      TransactionWorkerEvents2["TransactionExecutionFailed"] = "transactionexecutionFailed";
      return TransactionWorkerEvents2;
    })(TransactionWorkerEvents || {});
    var TransactionWorker = class extends import_eventemitter3.default {
      /**
       * Provides a simple framework for receiving payloads to be processed.
       *
       * @param provider - a client provider
       * @param sender - a sender as AptosAccount
       * @param maxWaitTime - the max wait time to wait before resyncing the sequence number
       * to the current on-chain state, default to 30
       * @param maximumInFlight - submit up to `maximumInFlight` transactions per account.
       * Mempool limits the number of transactions per account to 100, hence why we default to 100.
       * @param sleepTime - If `maximumInFlight` are in flight, wait `sleepTime` seconds before re-evaluating, default to 10
       */
      constructor(provider, account, maxWaitTime = 30, maximumInFlight = 100, sleepTime = 10) {
        super();
        this.taskQueue = new AsyncQueue();
        this.transactionsQueue = new AsyncQueue();
        this.outstandingTransactions = new AsyncQueue();
        this.sentTransactions = [];
        this.executedTransactions = [];
        this.provider = provider;
        this.account = account;
        this.started = false;
        this.accountSequnceNumber = new AccountSequenceNumber(provider, account, maxWaitTime, maximumInFlight, sleepTime);
      }
      /**
       * Gets the current account sequence number,
       * generates the transaction with the account sequence number,
       * adds the transaction to the outstanding transaction queue
       * to be processed later.
       */
      async submitNextTransaction() {
        try {
          while (true) {
            if (this.transactionsQueue.isEmpty())
              return;
            const sequenceNumber = await this.accountSequnceNumber.nextSequenceNumber();
            if (sequenceNumber === null)
              return;
            const transaction = await this.generateNextTransaction(this.account, sequenceNumber);
            if (!transaction)
              return;
            const pendingTransaction = this.provider.submitSignedBCSTransaction(transaction);
            await this.outstandingTransactions.enqueue([pendingTransaction, sequenceNumber]);
          }
        } catch (error) {
          if (error instanceof AsyncQueueCancelledError) {
            return;
          }
          console.log(error);
        }
      }
      /**
       * Reads the outstanding transaction queue and submits the transaction to chain.
       *
       * If the transaction has fulfilled, it pushes the transaction to the processed
       * transactions queue and fires a transactionsFulfilled event.
       *
       * If the transaction has failed, it pushes the transaction to the processed
       * transactions queue with the failure reason and fires a transactionsFailed event.
       */
      async processTransactions() {
        try {
          while (true) {
            const awaitingTransactions = [];
            const sequenceNumbers = [];
            let [pendingTransaction, sequenceNumber] = await this.outstandingTransactions.dequeue();
            awaitingTransactions.push(pendingTransaction);
            sequenceNumbers.push(sequenceNumber);
            while (!this.outstandingTransactions.isEmpty()) {
              [pendingTransaction, sequenceNumber] = await this.outstandingTransactions.dequeue();
              awaitingTransactions.push(pendingTransaction);
              sequenceNumbers.push(sequenceNumber);
            }
            const sentTransactions = await Promise.allSettled(awaitingTransactions);
            for (let i = 0; i < sentTransactions.length && i < sequenceNumbers.length; i += 1) {
              const sentTransaction = sentTransactions[i];
              sequenceNumber = sequenceNumbers[i];
              if (sentTransaction.status === promiseFulfilledStatus) {
                this.sentTransactions.push([sentTransaction.value.hash, sequenceNumber, null]);
                this.emit("transactionSent", [
                  this.sentTransactions.length,
                  sentTransaction.value.hash
                ]);
                await this.checkTransaction(sentTransaction, sequenceNumber);
              } else {
                this.sentTransactions.push([sentTransaction.status, sequenceNumber, sentTransaction.reason]);
                this.emit("transactionsendFailed", [
                  this.sentTransactions.length,
                  sentTransaction.reason
                ]);
              }
            }
          }
        } catch (error) {
          if (error instanceof AsyncQueueCancelledError) {
            return;
          }
          console.log(error);
        }
      }
      /**
       * Once transaction has been sent to chain, we check for its execution status.
       * @param sentTransaction transactions that were sent to chain and are now waiting to be executed
       * @param sequenceNumber the account's sequence number that was sent with the transaction
       */
      async checkTransaction(sentTransaction, sequenceNumber) {
        const waitFor = [];
        waitFor.push(this.provider.waitForTransactionWithResult(sentTransaction.value.hash, { checkSuccess: true }));
        const sentTransactions = await Promise.allSettled(waitFor);
        for (let i = 0; i < sentTransactions.length; i += 1) {
          const executedTransaction = sentTransactions[i];
          if (executedTransaction.status === promiseFulfilledStatus) {
            this.executedTransactions.push([executedTransaction.value.hash, sequenceNumber, null]);
            this.emit("transactionExecuted", [
              this.executedTransactions.length,
              executedTransaction.value.hash
            ]);
          } else {
            this.executedTransactions.push([executedTransaction.status, sequenceNumber, executedTransaction.reason]);
            this.emit("transactionexecutionFailed", [
              this.executedTransactions.length,
              executedTransaction.reason
            ]);
          }
        }
      }
      /**
       * Push transaction to the transactions queue
       * @param payload Transaction payload
       */
      async push(payload) {
        await this.transactionsQueue.enqueue(payload);
      }
      /**
       * Generates a signed transaction that can be submitted to chain
       * @param account an Aptos account
       * @param sequenceNumber a sequence number the transaction will be generated with
       * @returns
       */
      async generateNextTransaction(account, sequenceNumber) {
        if (this.transactionsQueue.isEmpty())
          return void 0;
        const payload = await this.transactionsQueue.dequeue();
        const rawTransaction = await this.provider.generateRawTransaction(account.address(), payload, {
          providedSequenceNumber: sequenceNumber
        });
        const signedTransaction = AptosClient.generateBCSTransaction(account, rawTransaction);
        return signedTransaction;
      }
      /**
       * Starts transaction submission and transaction processing.
       */
      async run() {
        try {
          while (!this.taskQueue.isCancelled()) {
            const task = await this.taskQueue.dequeue();
            await task();
          }
        } catch (error) {
          throw new Error(error);
        }
      }
      /**
       * Starts the transaction management process.
       */
      start() {
        if (this.started) {
          throw new Error("worker has already started");
        }
        this.started = true;
        this.taskQueue.enqueue(() => this.submitNextTransaction());
        this.taskQueue.enqueue(() => this.processTransactions());
        this.run();
      }
      /**
       * Stops the the transaction management process.
       */
      stop() {
        if (this.taskQueue.isCancelled()) {
          throw new Error("worker has already stopped");
        }
        this.started = false;
        this.taskQueue.cancel();
      }
    };
    var generated_exports = {};
    __export2(generated_exports, {
      AptosErrorCode: () => AptosErrorCode,
      MoveFunctionVisibility: () => MoveFunctionVisibility,
      RoleType: () => RoleType
    });
    var AptosErrorCode = ((AptosErrorCode2) => {
      AptosErrorCode2["ACCOUNT_NOT_FOUND"] = "account_not_found";
      AptosErrorCode2["RESOURCE_NOT_FOUND"] = "resource_not_found";
      AptosErrorCode2["MODULE_NOT_FOUND"] = "module_not_found";
      AptosErrorCode2["STRUCT_FIELD_NOT_FOUND"] = "struct_field_not_found";
      AptosErrorCode2["VERSION_NOT_FOUND"] = "version_not_found";
      AptosErrorCode2["TRANSACTION_NOT_FOUND"] = "transaction_not_found";
      AptosErrorCode2["TABLE_ITEM_NOT_FOUND"] = "table_item_not_found";
      AptosErrorCode2["BLOCK_NOT_FOUND"] = "block_not_found";
      AptosErrorCode2["STATE_VALUE_NOT_FOUND"] = "state_value_not_found";
      AptosErrorCode2["VERSION_PRUNED"] = "version_pruned";
      AptosErrorCode2["BLOCK_PRUNED"] = "block_pruned";
      AptosErrorCode2["INVALID_INPUT"] = "invalid_input";
      AptosErrorCode2["INVALID_TRANSACTION_UPDATE"] = "invalid_transaction_update";
      AptosErrorCode2["SEQUENCE_NUMBER_TOO_OLD"] = "sequence_number_too_old";
      AptosErrorCode2["VM_ERROR"] = "vm_error";
      AptosErrorCode2["HEALTH_CHECK_FAILED"] = "health_check_failed";
      AptosErrorCode2["MEMPOOL_IS_FULL"] = "mempool_is_full";
      AptosErrorCode2["INTERNAL_ERROR"] = "internal_error";
      AptosErrorCode2["WEB_FRAMEWORK_ERROR"] = "web_framework_error";
      AptosErrorCode2["BCS_NOT_SUPPORTED"] = "bcs_not_supported";
      AptosErrorCode2["API_DISABLED"] = "api_disabled";
      return AptosErrorCode2;
    })(AptosErrorCode || {});
    var MoveFunctionVisibility = ((MoveFunctionVisibility2) => {
      MoveFunctionVisibility2["PRIVATE"] = "private";
      MoveFunctionVisibility2["PUBLIC"] = "public";
      MoveFunctionVisibility2["FRIEND"] = "friend";
      return MoveFunctionVisibility2;
    })(MoveFunctionVisibility || {});
    var RoleType = ((RoleType2) => {
      RoleType2["VALIDATOR"] = "validator";
      RoleType2["FULL_NODE"] = "full_node";
      return RoleType2;
    })(RoleType || {});
    var Account_Transactions_Select_Column = ((Account_Transactions_Select_Column2) => {
      Account_Transactions_Select_Column2["AccountAddress"] = "account_address";
      Account_Transactions_Select_Column2["TransactionVersion"] = "transaction_version";
      return Account_Transactions_Select_Column2;
    })(Account_Transactions_Select_Column || {});
    var Address_Events_Summary_Select_Column = ((Address_Events_Summary_Select_Column2) => {
      Address_Events_Summary_Select_Column2["AccountAddress"] = "account_address";
      Address_Events_Summary_Select_Column2["MinBlockHeight"] = "min_block_height";
      Address_Events_Summary_Select_Column2["NumDistinctVersions"] = "num_distinct_versions";
      return Address_Events_Summary_Select_Column2;
    })(Address_Events_Summary_Select_Column || {});
    var Address_Version_From_Events_Select_Column = ((Address_Version_From_Events_Select_Column2) => {
      Address_Version_From_Events_Select_Column2["AccountAddress"] = "account_address";
      Address_Version_From_Events_Select_Column2["TransactionVersion"] = "transaction_version";
      return Address_Version_From_Events_Select_Column2;
    })(Address_Version_From_Events_Select_Column || {});
    var Address_Version_From_Move_Resources_Select_Column = ((Address_Version_From_Move_Resources_Select_Column2) => {
      Address_Version_From_Move_Resources_Select_Column2["Address"] = "address";
      Address_Version_From_Move_Resources_Select_Column2["TransactionVersion"] = "transaction_version";
      return Address_Version_From_Move_Resources_Select_Column2;
    })(Address_Version_From_Move_Resources_Select_Column || {});
    var Block_Metadata_Transactions_Select_Column = ((Block_Metadata_Transactions_Select_Column2) => {
      Block_Metadata_Transactions_Select_Column2["BlockHeight"] = "block_height";
      Block_Metadata_Transactions_Select_Column2["Epoch"] = "epoch";
      Block_Metadata_Transactions_Select_Column2["FailedProposerIndices"] = "failed_proposer_indices";
      Block_Metadata_Transactions_Select_Column2["Id"] = "id";
      Block_Metadata_Transactions_Select_Column2["PreviousBlockVotesBitvec"] = "previous_block_votes_bitvec";
      Block_Metadata_Transactions_Select_Column2["Proposer"] = "proposer";
      Block_Metadata_Transactions_Select_Column2["Round"] = "round";
      Block_Metadata_Transactions_Select_Column2["Timestamp"] = "timestamp";
      Block_Metadata_Transactions_Select_Column2["Version"] = "version";
      return Block_Metadata_Transactions_Select_Column2;
    })(Block_Metadata_Transactions_Select_Column || {});
    var Coin_Activities_Select_Column = ((Coin_Activities_Select_Column2) => {
      Coin_Activities_Select_Column2["ActivityType"] = "activity_type";
      Coin_Activities_Select_Column2["Amount"] = "amount";
      Coin_Activities_Select_Column2["BlockHeight"] = "block_height";
      Coin_Activities_Select_Column2["CoinType"] = "coin_type";
      Coin_Activities_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
      Coin_Activities_Select_Column2["EventAccountAddress"] = "event_account_address";
      Coin_Activities_Select_Column2["EventCreationNumber"] = "event_creation_number";
      Coin_Activities_Select_Column2["EventIndex"] = "event_index";
      Coin_Activities_Select_Column2["EventSequenceNumber"] = "event_sequence_number";
      Coin_Activities_Select_Column2["IsGasFee"] = "is_gas_fee";
      Coin_Activities_Select_Column2["IsTransactionSuccess"] = "is_transaction_success";
      Coin_Activities_Select_Column2["OwnerAddress"] = "owner_address";
      Coin_Activities_Select_Column2["StorageRefundAmount"] = "storage_refund_amount";
      Coin_Activities_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Coin_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
      return Coin_Activities_Select_Column2;
    })(Coin_Activities_Select_Column || {});
    var Coin_Balances_Select_Column = ((Coin_Balances_Select_Column2) => {
      Coin_Balances_Select_Column2["Amount"] = "amount";
      Coin_Balances_Select_Column2["CoinType"] = "coin_type";
      Coin_Balances_Select_Column2["CoinTypeHash"] = "coin_type_hash";
      Coin_Balances_Select_Column2["OwnerAddress"] = "owner_address";
      Coin_Balances_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Coin_Balances_Select_Column2["TransactionVersion"] = "transaction_version";
      return Coin_Balances_Select_Column2;
    })(Coin_Balances_Select_Column || {});
    var Coin_Infos_Select_Column = ((Coin_Infos_Select_Column2) => {
      Coin_Infos_Select_Column2["CoinType"] = "coin_type";
      Coin_Infos_Select_Column2["CoinTypeHash"] = "coin_type_hash";
      Coin_Infos_Select_Column2["CreatorAddress"] = "creator_address";
      Coin_Infos_Select_Column2["Decimals"] = "decimals";
      Coin_Infos_Select_Column2["Name"] = "name";
      Coin_Infos_Select_Column2["SupplyAggregatorTableHandle"] = "supply_aggregator_table_handle";
      Coin_Infos_Select_Column2["SupplyAggregatorTableKey"] = "supply_aggregator_table_key";
      Coin_Infos_Select_Column2["Symbol"] = "symbol";
      Coin_Infos_Select_Column2["TransactionCreatedTimestamp"] = "transaction_created_timestamp";
      Coin_Infos_Select_Column2["TransactionVersionCreated"] = "transaction_version_created";
      return Coin_Infos_Select_Column2;
    })(Coin_Infos_Select_Column || {});
    var Coin_Supply_Select_Column = ((Coin_Supply_Select_Column2) => {
      Coin_Supply_Select_Column2["CoinType"] = "coin_type";
      Coin_Supply_Select_Column2["CoinTypeHash"] = "coin_type_hash";
      Coin_Supply_Select_Column2["Supply"] = "supply";
      Coin_Supply_Select_Column2["TransactionEpoch"] = "transaction_epoch";
      Coin_Supply_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Coin_Supply_Select_Column2["TransactionVersion"] = "transaction_version";
      return Coin_Supply_Select_Column2;
    })(Coin_Supply_Select_Column || {});
    var Collection_Datas_Select_Column = ((Collection_Datas_Select_Column2) => {
      Collection_Datas_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
      Collection_Datas_Select_Column2["CollectionName"] = "collection_name";
      Collection_Datas_Select_Column2["CreatorAddress"] = "creator_address";
      Collection_Datas_Select_Column2["Description"] = "description";
      Collection_Datas_Select_Column2["DescriptionMutable"] = "description_mutable";
      Collection_Datas_Select_Column2["Maximum"] = "maximum";
      Collection_Datas_Select_Column2["MaximumMutable"] = "maximum_mutable";
      Collection_Datas_Select_Column2["MetadataUri"] = "metadata_uri";
      Collection_Datas_Select_Column2["Supply"] = "supply";
      Collection_Datas_Select_Column2["TableHandle"] = "table_handle";
      Collection_Datas_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Collection_Datas_Select_Column2["TransactionVersion"] = "transaction_version";
      Collection_Datas_Select_Column2["UriMutable"] = "uri_mutable";
      return Collection_Datas_Select_Column2;
    })(Collection_Datas_Select_Column || {});
    var Current_Ans_Lookup_Select_Column = ((Current_Ans_Lookup_Select_Column2) => {
      Current_Ans_Lookup_Select_Column2["Domain"] = "domain";
      Current_Ans_Lookup_Select_Column2["ExpirationTimestamp"] = "expiration_timestamp";
      Current_Ans_Lookup_Select_Column2["IsDeleted"] = "is_deleted";
      Current_Ans_Lookup_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Ans_Lookup_Select_Column2["RegisteredAddress"] = "registered_address";
      Current_Ans_Lookup_Select_Column2["Subdomain"] = "subdomain";
      Current_Ans_Lookup_Select_Column2["TokenName"] = "token_name";
      return Current_Ans_Lookup_Select_Column2;
    })(Current_Ans_Lookup_Select_Column || {});
    var Current_Ans_Lookup_V2_Select_Column = ((Current_Ans_Lookup_V2_Select_Column2) => {
      Current_Ans_Lookup_V2_Select_Column2["Domain"] = "domain";
      Current_Ans_Lookup_V2_Select_Column2["ExpirationTimestamp"] = "expiration_timestamp";
      Current_Ans_Lookup_V2_Select_Column2["IsDeleted"] = "is_deleted";
      Current_Ans_Lookup_V2_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Ans_Lookup_V2_Select_Column2["RegisteredAddress"] = "registered_address";
      Current_Ans_Lookup_V2_Select_Column2["Subdomain"] = "subdomain";
      Current_Ans_Lookup_V2_Select_Column2["TokenName"] = "token_name";
      Current_Ans_Lookup_V2_Select_Column2["TokenStandard"] = "token_standard";
      return Current_Ans_Lookup_V2_Select_Column2;
    })(Current_Ans_Lookup_V2_Select_Column || {});
    var Current_Aptos_Names_Select_Column = ((Current_Aptos_Names_Select_Column2) => {
      Current_Aptos_Names_Select_Column2["Domain"] = "domain";
      Current_Aptos_Names_Select_Column2["DomainWithSuffix"] = "domain_with_suffix";
      Current_Aptos_Names_Select_Column2["ExpirationTimestamp"] = "expiration_timestamp";
      Current_Aptos_Names_Select_Column2["IsActive"] = "is_active";
      Current_Aptos_Names_Select_Column2["IsPrimary"] = "is_primary";
      Current_Aptos_Names_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Aptos_Names_Select_Column2["OwnerAddress"] = "owner_address";
      Current_Aptos_Names_Select_Column2["RegisteredAddress"] = "registered_address";
      Current_Aptos_Names_Select_Column2["Subdomain"] = "subdomain";
      Current_Aptos_Names_Select_Column2["TokenName"] = "token_name";
      Current_Aptos_Names_Select_Column2["TokenStandard"] = "token_standard";
      return Current_Aptos_Names_Select_Column2;
    })(Current_Aptos_Names_Select_Column || {});
    var Current_Coin_Balances_Select_Column = ((Current_Coin_Balances_Select_Column2) => {
      Current_Coin_Balances_Select_Column2["Amount"] = "amount";
      Current_Coin_Balances_Select_Column2["CoinType"] = "coin_type";
      Current_Coin_Balances_Select_Column2["CoinTypeHash"] = "coin_type_hash";
      Current_Coin_Balances_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Coin_Balances_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Coin_Balances_Select_Column2["OwnerAddress"] = "owner_address";
      return Current_Coin_Balances_Select_Column2;
    })(Current_Coin_Balances_Select_Column || {});
    var Current_Collection_Datas_Select_Column = ((Current_Collection_Datas_Select_Column2) => {
      Current_Collection_Datas_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
      Current_Collection_Datas_Select_Column2["CollectionName"] = "collection_name";
      Current_Collection_Datas_Select_Column2["CreatorAddress"] = "creator_address";
      Current_Collection_Datas_Select_Column2["Description"] = "description";
      Current_Collection_Datas_Select_Column2["DescriptionMutable"] = "description_mutable";
      Current_Collection_Datas_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Collection_Datas_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Collection_Datas_Select_Column2["Maximum"] = "maximum";
      Current_Collection_Datas_Select_Column2["MaximumMutable"] = "maximum_mutable";
      Current_Collection_Datas_Select_Column2["MetadataUri"] = "metadata_uri";
      Current_Collection_Datas_Select_Column2["Supply"] = "supply";
      Current_Collection_Datas_Select_Column2["TableHandle"] = "table_handle";
      Current_Collection_Datas_Select_Column2["UriMutable"] = "uri_mutable";
      return Current_Collection_Datas_Select_Column2;
    })(Current_Collection_Datas_Select_Column || {});
    var Current_Collection_Ownership_V2_View_Select_Column = ((Current_Collection_Ownership_V2_View_Select_Column2) => {
      Current_Collection_Ownership_V2_View_Select_Column2["CollectionId"] = "collection_id";
      Current_Collection_Ownership_V2_View_Select_Column2["CollectionName"] = "collection_name";
      Current_Collection_Ownership_V2_View_Select_Column2["CollectionUri"] = "collection_uri";
      Current_Collection_Ownership_V2_View_Select_Column2["CreatorAddress"] = "creator_address";
      Current_Collection_Ownership_V2_View_Select_Column2["DistinctTokens"] = "distinct_tokens";
      Current_Collection_Ownership_V2_View_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Collection_Ownership_V2_View_Select_Column2["OwnerAddress"] = "owner_address";
      Current_Collection_Ownership_V2_View_Select_Column2["SingleTokenUri"] = "single_token_uri";
      return Current_Collection_Ownership_V2_View_Select_Column2;
    })(Current_Collection_Ownership_V2_View_Select_Column || {});
    var Current_Collections_V2_Select_Column = ((Current_Collections_V2_Select_Column2) => {
      Current_Collections_V2_Select_Column2["CollectionId"] = "collection_id";
      Current_Collections_V2_Select_Column2["CollectionName"] = "collection_name";
      Current_Collections_V2_Select_Column2["CreatorAddress"] = "creator_address";
      Current_Collections_V2_Select_Column2["CurrentSupply"] = "current_supply";
      Current_Collections_V2_Select_Column2["Description"] = "description";
      Current_Collections_V2_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Collections_V2_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Collections_V2_Select_Column2["MaxSupply"] = "max_supply";
      Current_Collections_V2_Select_Column2["MutableDescription"] = "mutable_description";
      Current_Collections_V2_Select_Column2["MutableUri"] = "mutable_uri";
      Current_Collections_V2_Select_Column2["TableHandleV1"] = "table_handle_v1";
      Current_Collections_V2_Select_Column2["TokenStandard"] = "token_standard";
      Current_Collections_V2_Select_Column2["TotalMintedV2"] = "total_minted_v2";
      Current_Collections_V2_Select_Column2["Uri"] = "uri";
      return Current_Collections_V2_Select_Column2;
    })(Current_Collections_V2_Select_Column || {});
    var Current_Delegated_Staking_Pool_Balances_Select_Column = ((Current_Delegated_Staking_Pool_Balances_Select_Column2) => {
      Current_Delegated_Staking_Pool_Balances_Select_Column2["ActiveTableHandle"] = "active_table_handle";
      Current_Delegated_Staking_Pool_Balances_Select_Column2["InactiveTableHandle"] = "inactive_table_handle";
      Current_Delegated_Staking_Pool_Balances_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Delegated_Staking_Pool_Balances_Select_Column2["OperatorCommissionPercentage"] = "operator_commission_percentage";
      Current_Delegated_Staking_Pool_Balances_Select_Column2["StakingPoolAddress"] = "staking_pool_address";
      Current_Delegated_Staking_Pool_Balances_Select_Column2["TotalCoins"] = "total_coins";
      Current_Delegated_Staking_Pool_Balances_Select_Column2["TotalShares"] = "total_shares";
      return Current_Delegated_Staking_Pool_Balances_Select_Column2;
    })(Current_Delegated_Staking_Pool_Balances_Select_Column || {});
    var Current_Delegated_Voter_Select_Column = ((Current_Delegated_Voter_Select_Column2) => {
      Current_Delegated_Voter_Select_Column2["DelegationPoolAddress"] = "delegation_pool_address";
      Current_Delegated_Voter_Select_Column2["DelegatorAddress"] = "delegator_address";
      Current_Delegated_Voter_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Delegated_Voter_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Delegated_Voter_Select_Column2["PendingVoter"] = "pending_voter";
      Current_Delegated_Voter_Select_Column2["TableHandle"] = "table_handle";
      Current_Delegated_Voter_Select_Column2["Voter"] = "voter";
      return Current_Delegated_Voter_Select_Column2;
    })(Current_Delegated_Voter_Select_Column || {});
    var Current_Delegator_Balances_Select_Column = ((Current_Delegator_Balances_Select_Column2) => {
      Current_Delegator_Balances_Select_Column2["DelegatorAddress"] = "delegator_address";
      Current_Delegator_Balances_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Delegator_Balances_Select_Column2["ParentTableHandle"] = "parent_table_handle";
      Current_Delegator_Balances_Select_Column2["PoolAddress"] = "pool_address";
      Current_Delegator_Balances_Select_Column2["PoolType"] = "pool_type";
      Current_Delegator_Balances_Select_Column2["Shares"] = "shares";
      Current_Delegator_Balances_Select_Column2["TableHandle"] = "table_handle";
      return Current_Delegator_Balances_Select_Column2;
    })(Current_Delegator_Balances_Select_Column || {});
    var Current_Fungible_Asset_Balances_Select_Column = ((Current_Fungible_Asset_Balances_Select_Column2) => {
      Current_Fungible_Asset_Balances_Select_Column2["Amount"] = "amount";
      Current_Fungible_Asset_Balances_Select_Column2["AssetType"] = "asset_type";
      Current_Fungible_Asset_Balances_Select_Column2["IsFrozen"] = "is_frozen";
      Current_Fungible_Asset_Balances_Select_Column2["IsPrimary"] = "is_primary";
      Current_Fungible_Asset_Balances_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Fungible_Asset_Balances_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Fungible_Asset_Balances_Select_Column2["OwnerAddress"] = "owner_address";
      Current_Fungible_Asset_Balances_Select_Column2["StorageId"] = "storage_id";
      Current_Fungible_Asset_Balances_Select_Column2["TokenStandard"] = "token_standard";
      return Current_Fungible_Asset_Balances_Select_Column2;
    })(Current_Fungible_Asset_Balances_Select_Column || {});
    var Current_Objects_Select_Column = ((Current_Objects_Select_Column2) => {
      Current_Objects_Select_Column2["AllowUngatedTransfer"] = "allow_ungated_transfer";
      Current_Objects_Select_Column2["IsDeleted"] = "is_deleted";
      Current_Objects_Select_Column2["LastGuidCreationNum"] = "last_guid_creation_num";
      Current_Objects_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Objects_Select_Column2["ObjectAddress"] = "object_address";
      Current_Objects_Select_Column2["OwnerAddress"] = "owner_address";
      Current_Objects_Select_Column2["StateKeyHash"] = "state_key_hash";
      return Current_Objects_Select_Column2;
    })(Current_Objects_Select_Column || {});
    var Current_Staking_Pool_Voter_Select_Column = ((Current_Staking_Pool_Voter_Select_Column2) => {
      Current_Staking_Pool_Voter_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Staking_Pool_Voter_Select_Column2["OperatorAddress"] = "operator_address";
      Current_Staking_Pool_Voter_Select_Column2["StakingPoolAddress"] = "staking_pool_address";
      Current_Staking_Pool_Voter_Select_Column2["VoterAddress"] = "voter_address";
      return Current_Staking_Pool_Voter_Select_Column2;
    })(Current_Staking_Pool_Voter_Select_Column || {});
    var Current_Table_Items_Select_Column = ((Current_Table_Items_Select_Column2) => {
      Current_Table_Items_Select_Column2["DecodedKey"] = "decoded_key";
      Current_Table_Items_Select_Column2["DecodedValue"] = "decoded_value";
      Current_Table_Items_Select_Column2["IsDeleted"] = "is_deleted";
      Current_Table_Items_Select_Column2["Key"] = "key";
      Current_Table_Items_Select_Column2["KeyHash"] = "key_hash";
      Current_Table_Items_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Table_Items_Select_Column2["TableHandle"] = "table_handle";
      return Current_Table_Items_Select_Column2;
    })(Current_Table_Items_Select_Column || {});
    var Current_Token_Datas_Select_Column = ((Current_Token_Datas_Select_Column2) => {
      Current_Token_Datas_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
      Current_Token_Datas_Select_Column2["CollectionName"] = "collection_name";
      Current_Token_Datas_Select_Column2["CreatorAddress"] = "creator_address";
      Current_Token_Datas_Select_Column2["DefaultProperties"] = "default_properties";
      Current_Token_Datas_Select_Column2["Description"] = "description";
      Current_Token_Datas_Select_Column2["DescriptionMutable"] = "description_mutable";
      Current_Token_Datas_Select_Column2["LargestPropertyVersion"] = "largest_property_version";
      Current_Token_Datas_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Token_Datas_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Token_Datas_Select_Column2["Maximum"] = "maximum";
      Current_Token_Datas_Select_Column2["MaximumMutable"] = "maximum_mutable";
      Current_Token_Datas_Select_Column2["MetadataUri"] = "metadata_uri";
      Current_Token_Datas_Select_Column2["Name"] = "name";
      Current_Token_Datas_Select_Column2["PayeeAddress"] = "payee_address";
      Current_Token_Datas_Select_Column2["PropertiesMutable"] = "properties_mutable";
      Current_Token_Datas_Select_Column2["RoyaltyMutable"] = "royalty_mutable";
      Current_Token_Datas_Select_Column2["RoyaltyPointsDenominator"] = "royalty_points_denominator";
      Current_Token_Datas_Select_Column2["RoyaltyPointsNumerator"] = "royalty_points_numerator";
      Current_Token_Datas_Select_Column2["Supply"] = "supply";
      Current_Token_Datas_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
      Current_Token_Datas_Select_Column2["UriMutable"] = "uri_mutable";
      return Current_Token_Datas_Select_Column2;
    })(Current_Token_Datas_Select_Column || {});
    var Current_Token_Datas_V2_Select_Column = ((Current_Token_Datas_V2_Select_Column2) => {
      Current_Token_Datas_V2_Select_Column2["CollectionId"] = "collection_id";
      Current_Token_Datas_V2_Select_Column2["Description"] = "description";
      Current_Token_Datas_V2_Select_Column2["IsFungibleV2"] = "is_fungible_v2";
      Current_Token_Datas_V2_Select_Column2["LargestPropertyVersionV1"] = "largest_property_version_v1";
      Current_Token_Datas_V2_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Token_Datas_V2_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Token_Datas_V2_Select_Column2["Maximum"] = "maximum";
      Current_Token_Datas_V2_Select_Column2["Supply"] = "supply";
      Current_Token_Datas_V2_Select_Column2["TokenDataId"] = "token_data_id";
      Current_Token_Datas_V2_Select_Column2["TokenName"] = "token_name";
      Current_Token_Datas_V2_Select_Column2["TokenProperties"] = "token_properties";
      Current_Token_Datas_V2_Select_Column2["TokenStandard"] = "token_standard";
      Current_Token_Datas_V2_Select_Column2["TokenUri"] = "token_uri";
      return Current_Token_Datas_V2_Select_Column2;
    })(Current_Token_Datas_V2_Select_Column || {});
    var Current_Token_Ownerships_Select_Column = ((Current_Token_Ownerships_Select_Column2) => {
      Current_Token_Ownerships_Select_Column2["Amount"] = "amount";
      Current_Token_Ownerships_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
      Current_Token_Ownerships_Select_Column2["CollectionName"] = "collection_name";
      Current_Token_Ownerships_Select_Column2["CreatorAddress"] = "creator_address";
      Current_Token_Ownerships_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Token_Ownerships_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Token_Ownerships_Select_Column2["Name"] = "name";
      Current_Token_Ownerships_Select_Column2["OwnerAddress"] = "owner_address";
      Current_Token_Ownerships_Select_Column2["PropertyVersion"] = "property_version";
      Current_Token_Ownerships_Select_Column2["TableType"] = "table_type";
      Current_Token_Ownerships_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
      Current_Token_Ownerships_Select_Column2["TokenProperties"] = "token_properties";
      return Current_Token_Ownerships_Select_Column2;
    })(Current_Token_Ownerships_Select_Column || {});
    var Current_Token_Ownerships_V2_Select_Column = ((Current_Token_Ownerships_V2_Select_Column2) => {
      Current_Token_Ownerships_V2_Select_Column2["Amount"] = "amount";
      Current_Token_Ownerships_V2_Select_Column2["IsFungibleV2"] = "is_fungible_v2";
      Current_Token_Ownerships_V2_Select_Column2["IsSoulboundV2"] = "is_soulbound_v2";
      Current_Token_Ownerships_V2_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Token_Ownerships_V2_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Token_Ownerships_V2_Select_Column2["OwnerAddress"] = "owner_address";
      Current_Token_Ownerships_V2_Select_Column2["PropertyVersionV1"] = "property_version_v1";
      Current_Token_Ownerships_V2_Select_Column2["StorageId"] = "storage_id";
      Current_Token_Ownerships_V2_Select_Column2["TableTypeV1"] = "table_type_v1";
      Current_Token_Ownerships_V2_Select_Column2["TokenDataId"] = "token_data_id";
      Current_Token_Ownerships_V2_Select_Column2["TokenPropertiesMutatedV1"] = "token_properties_mutated_v1";
      Current_Token_Ownerships_V2_Select_Column2["TokenStandard"] = "token_standard";
      return Current_Token_Ownerships_V2_Select_Column2;
    })(Current_Token_Ownerships_V2_Select_Column || {});
    var Current_Token_Pending_Claims_Select_Column = ((Current_Token_Pending_Claims_Select_Column2) => {
      Current_Token_Pending_Claims_Select_Column2["Amount"] = "amount";
      Current_Token_Pending_Claims_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
      Current_Token_Pending_Claims_Select_Column2["CollectionId"] = "collection_id";
      Current_Token_Pending_Claims_Select_Column2["CollectionName"] = "collection_name";
      Current_Token_Pending_Claims_Select_Column2["CreatorAddress"] = "creator_address";
      Current_Token_Pending_Claims_Select_Column2["FromAddress"] = "from_address";
      Current_Token_Pending_Claims_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Current_Token_Pending_Claims_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Current_Token_Pending_Claims_Select_Column2["Name"] = "name";
      Current_Token_Pending_Claims_Select_Column2["PropertyVersion"] = "property_version";
      Current_Token_Pending_Claims_Select_Column2["TableHandle"] = "table_handle";
      Current_Token_Pending_Claims_Select_Column2["ToAddress"] = "to_address";
      Current_Token_Pending_Claims_Select_Column2["TokenDataId"] = "token_data_id";
      Current_Token_Pending_Claims_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
      return Current_Token_Pending_Claims_Select_Column2;
    })(Current_Token_Pending_Claims_Select_Column || {});
    var Cursor_Ordering = ((Cursor_Ordering2) => {
      Cursor_Ordering2["Asc"] = "ASC";
      Cursor_Ordering2["Desc"] = "DESC";
      return Cursor_Ordering2;
    })(Cursor_Ordering || {});
    var Delegated_Staking_Activities_Select_Column = ((Delegated_Staking_Activities_Select_Column2) => {
      Delegated_Staking_Activities_Select_Column2["Amount"] = "amount";
      Delegated_Staking_Activities_Select_Column2["DelegatorAddress"] = "delegator_address";
      Delegated_Staking_Activities_Select_Column2["EventIndex"] = "event_index";
      Delegated_Staking_Activities_Select_Column2["EventType"] = "event_type";
      Delegated_Staking_Activities_Select_Column2["PoolAddress"] = "pool_address";
      Delegated_Staking_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
      return Delegated_Staking_Activities_Select_Column2;
    })(Delegated_Staking_Activities_Select_Column || {});
    var Delegated_Staking_Pools_Select_Column = ((Delegated_Staking_Pools_Select_Column2) => {
      Delegated_Staking_Pools_Select_Column2["FirstTransactionVersion"] = "first_transaction_version";
      Delegated_Staking_Pools_Select_Column2["StakingPoolAddress"] = "staking_pool_address";
      return Delegated_Staking_Pools_Select_Column2;
    })(Delegated_Staking_Pools_Select_Column || {});
    var Delegator_Distinct_Pool_Select_Column = ((Delegator_Distinct_Pool_Select_Column2) => {
      Delegator_Distinct_Pool_Select_Column2["DelegatorAddress"] = "delegator_address";
      Delegator_Distinct_Pool_Select_Column2["PoolAddress"] = "pool_address";
      return Delegator_Distinct_Pool_Select_Column2;
    })(Delegator_Distinct_Pool_Select_Column || {});
    var Events_Select_Column = ((Events_Select_Column2) => {
      Events_Select_Column2["AccountAddress"] = "account_address";
      Events_Select_Column2["CreationNumber"] = "creation_number";
      Events_Select_Column2["Data"] = "data";
      Events_Select_Column2["EventIndex"] = "event_index";
      Events_Select_Column2["IndexedType"] = "indexed_type";
      Events_Select_Column2["SequenceNumber"] = "sequence_number";
      Events_Select_Column2["TransactionBlockHeight"] = "transaction_block_height";
      Events_Select_Column2["TransactionVersion"] = "transaction_version";
      Events_Select_Column2["Type"] = "type";
      return Events_Select_Column2;
    })(Events_Select_Column || {});
    var Fungible_Asset_Activities_Select_Column = ((Fungible_Asset_Activities_Select_Column2) => {
      Fungible_Asset_Activities_Select_Column2["Amount"] = "amount";
      Fungible_Asset_Activities_Select_Column2["AssetType"] = "asset_type";
      Fungible_Asset_Activities_Select_Column2["BlockHeight"] = "block_height";
      Fungible_Asset_Activities_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
      Fungible_Asset_Activities_Select_Column2["EventIndex"] = "event_index";
      Fungible_Asset_Activities_Select_Column2["GasFeePayerAddress"] = "gas_fee_payer_address";
      Fungible_Asset_Activities_Select_Column2["IsFrozen"] = "is_frozen";
      Fungible_Asset_Activities_Select_Column2["IsGasFee"] = "is_gas_fee";
      Fungible_Asset_Activities_Select_Column2["IsTransactionSuccess"] = "is_transaction_success";
      Fungible_Asset_Activities_Select_Column2["OwnerAddress"] = "owner_address";
      Fungible_Asset_Activities_Select_Column2["StorageId"] = "storage_id";
      Fungible_Asset_Activities_Select_Column2["StorageRefundAmount"] = "storage_refund_amount";
      Fungible_Asset_Activities_Select_Column2["TokenStandard"] = "token_standard";
      Fungible_Asset_Activities_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Fungible_Asset_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
      Fungible_Asset_Activities_Select_Column2["Type"] = "type";
      return Fungible_Asset_Activities_Select_Column2;
    })(Fungible_Asset_Activities_Select_Column || {});
    var Fungible_Asset_Metadata_Select_Column = ((Fungible_Asset_Metadata_Select_Column2) => {
      Fungible_Asset_Metadata_Select_Column2["AssetType"] = "asset_type";
      Fungible_Asset_Metadata_Select_Column2["CreatorAddress"] = "creator_address";
      Fungible_Asset_Metadata_Select_Column2["Decimals"] = "decimals";
      Fungible_Asset_Metadata_Select_Column2["IconUri"] = "icon_uri";
      Fungible_Asset_Metadata_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Fungible_Asset_Metadata_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Fungible_Asset_Metadata_Select_Column2["Name"] = "name";
      Fungible_Asset_Metadata_Select_Column2["ProjectUri"] = "project_uri";
      Fungible_Asset_Metadata_Select_Column2["SupplyAggregatorTableHandleV1"] = "supply_aggregator_table_handle_v1";
      Fungible_Asset_Metadata_Select_Column2["SupplyAggregatorTableKeyV1"] = "supply_aggregator_table_key_v1";
      Fungible_Asset_Metadata_Select_Column2["Symbol"] = "symbol";
      Fungible_Asset_Metadata_Select_Column2["TokenStandard"] = "token_standard";
      return Fungible_Asset_Metadata_Select_Column2;
    })(Fungible_Asset_Metadata_Select_Column || {});
    var Indexer_Status_Select_Column = ((Indexer_Status_Select_Column2) => {
      Indexer_Status_Select_Column2["Db"] = "db";
      Indexer_Status_Select_Column2["IsIndexerUp"] = "is_indexer_up";
      return Indexer_Status_Select_Column2;
    })(Indexer_Status_Select_Column || {});
    var Ledger_Infos_Select_Column = ((Ledger_Infos_Select_Column2) => {
      Ledger_Infos_Select_Column2["ChainId"] = "chain_id";
      return Ledger_Infos_Select_Column2;
    })(Ledger_Infos_Select_Column || {});
    var Move_Resources_Select_Column = ((Move_Resources_Select_Column2) => {
      Move_Resources_Select_Column2["Address"] = "address";
      Move_Resources_Select_Column2["TransactionVersion"] = "transaction_version";
      return Move_Resources_Select_Column2;
    })(Move_Resources_Select_Column || {});
    var Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column = ((Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2) => {
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["BuyItNowPrice"] = "buy_it_now_price";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["CoinType"] = "coin_type";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["CollectionId"] = "collection_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["ContractAddress"] = "contract_address";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["CurrentBidPrice"] = "current_bid_price";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["CurrentBidder"] = "current_bidder";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["ExpirationTime"] = "expiration_time";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["IsDeleted"] = "is_deleted";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["ListingId"] = "listing_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["Marketplace"] = "marketplace";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["Seller"] = "seller";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["StartingBidPrice"] = "starting_bid_price";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["TokenAmount"] = "token_amount";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["TokenDataId"] = "token_data_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["TokenStandard"] = "token_standard";
      return Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2;
    })(Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column || {});
    var Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column = ((Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2) => {
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["Buyer"] = "buyer";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["CoinType"] = "coin_type";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["CollectionId"] = "collection_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["CollectionOfferId"] = "collection_offer_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["ContractAddress"] = "contract_address";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["ExpirationTime"] = "expiration_time";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["IsDeleted"] = "is_deleted";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["ItemPrice"] = "item_price";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["Marketplace"] = "marketplace";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["RemainingTokenAmount"] = "remaining_token_amount";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["TokenStandard"] = "token_standard";
      return Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2;
    })(Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column || {});
    var Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column = ((Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2) => {
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["CoinType"] = "coin_type";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["CollectionId"] = "collection_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["ContractAddress"] = "contract_address";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["IsDeleted"] = "is_deleted";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["ListingId"] = "listing_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["Marketplace"] = "marketplace";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["Price"] = "price";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["Seller"] = "seller";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["TokenAmount"] = "token_amount";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["TokenDataId"] = "token_data_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["TokenStandard"] = "token_standard";
      return Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2;
    })(Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column || {});
    var Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column = ((Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2) => {
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["Buyer"] = "buyer";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["CoinType"] = "coin_type";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["CollectionId"] = "collection_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["ContractAddress"] = "contract_address";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["ExpirationTime"] = "expiration_time";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["IsDeleted"] = "is_deleted";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["Marketplace"] = "marketplace";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["OfferId"] = "offer_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["Price"] = "price";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["TokenAmount"] = "token_amount";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["TokenDataId"] = "token_data_id";
      Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["TokenStandard"] = "token_standard";
      return Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2;
    })(Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column || {});
    var Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column = ((Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2) => {
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["Buyer"] = "buyer";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["CoinType"] = "coin_type";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["CollectionId"] = "collection_id";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["CollectionName"] = "collection_name";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["ContractAddress"] = "contract_address";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["CreatorAddress"] = "creator_address";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["EventIndex"] = "event_index";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["EventType"] = "event_type";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["Marketplace"] = "marketplace";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["OfferOrListingId"] = "offer_or_listing_id";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["Price"] = "price";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["PropertyVersion"] = "property_version";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["Seller"] = "seller";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TokenAmount"] = "token_amount";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TokenDataId"] = "token_data_id";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TokenName"] = "token_name";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TokenStandard"] = "token_standard";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
      return Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2;
    })(Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column || {});
    var Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column = ((Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2) => {
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["AnimationOptimizerRetryCount"] = "animation_optimizer_retry_count";
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["AssetUri"] = "asset_uri";
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["CdnAnimationUri"] = "cdn_animation_uri";
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["CdnImageUri"] = "cdn_image_uri";
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["CdnJsonUri"] = "cdn_json_uri";
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["ImageOptimizerRetryCount"] = "image_optimizer_retry_count";
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["JsonParserRetryCount"] = "json_parser_retry_count";
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["RawAnimationUri"] = "raw_animation_uri";
      Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["RawImageUri"] = "raw_image_uri";
      return Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2;
    })(Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column || {});
    var Num_Active_Delegator_Per_Pool_Select_Column = ((Num_Active_Delegator_Per_Pool_Select_Column2) => {
      Num_Active_Delegator_Per_Pool_Select_Column2["NumActiveDelegator"] = "num_active_delegator";
      Num_Active_Delegator_Per_Pool_Select_Column2["PoolAddress"] = "pool_address";
      return Num_Active_Delegator_Per_Pool_Select_Column2;
    })(Num_Active_Delegator_Per_Pool_Select_Column || {});
    var Order_By = ((Order_By2) => {
      Order_By2["Asc"] = "asc";
      Order_By2["AscNullsFirst"] = "asc_nulls_first";
      Order_By2["AscNullsLast"] = "asc_nulls_last";
      Order_By2["Desc"] = "desc";
      Order_By2["DescNullsFirst"] = "desc_nulls_first";
      Order_By2["DescNullsLast"] = "desc_nulls_last";
      return Order_By2;
    })(Order_By || {});
    var Processor_Status_Select_Column = ((Processor_Status_Select_Column2) => {
      Processor_Status_Select_Column2["LastSuccessVersion"] = "last_success_version";
      Processor_Status_Select_Column2["LastUpdated"] = "last_updated";
      Processor_Status_Select_Column2["Processor"] = "processor";
      return Processor_Status_Select_Column2;
    })(Processor_Status_Select_Column || {});
    var Proposal_Votes_Select_Column = ((Proposal_Votes_Select_Column2) => {
      Proposal_Votes_Select_Column2["NumVotes"] = "num_votes";
      Proposal_Votes_Select_Column2["ProposalId"] = "proposal_id";
      Proposal_Votes_Select_Column2["ShouldPass"] = "should_pass";
      Proposal_Votes_Select_Column2["StakingPoolAddress"] = "staking_pool_address";
      Proposal_Votes_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Proposal_Votes_Select_Column2["TransactionVersion"] = "transaction_version";
      Proposal_Votes_Select_Column2["VoterAddress"] = "voter_address";
      return Proposal_Votes_Select_Column2;
    })(Proposal_Votes_Select_Column || {});
    var Table_Items_Select_Column = ((Table_Items_Select_Column2) => {
      Table_Items_Select_Column2["DecodedKey"] = "decoded_key";
      Table_Items_Select_Column2["DecodedValue"] = "decoded_value";
      Table_Items_Select_Column2["Key"] = "key";
      Table_Items_Select_Column2["TableHandle"] = "table_handle";
      Table_Items_Select_Column2["TransactionVersion"] = "transaction_version";
      Table_Items_Select_Column2["WriteSetChangeIndex"] = "write_set_change_index";
      return Table_Items_Select_Column2;
    })(Table_Items_Select_Column || {});
    var Table_Metadatas_Select_Column = ((Table_Metadatas_Select_Column2) => {
      Table_Metadatas_Select_Column2["Handle"] = "handle";
      Table_Metadatas_Select_Column2["KeyType"] = "key_type";
      Table_Metadatas_Select_Column2["ValueType"] = "value_type";
      return Table_Metadatas_Select_Column2;
    })(Table_Metadatas_Select_Column || {});
    var Token_Activities_Select_Column = ((Token_Activities_Select_Column2) => {
      Token_Activities_Select_Column2["CoinAmount"] = "coin_amount";
      Token_Activities_Select_Column2["CoinType"] = "coin_type";
      Token_Activities_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
      Token_Activities_Select_Column2["CollectionName"] = "collection_name";
      Token_Activities_Select_Column2["CreatorAddress"] = "creator_address";
      Token_Activities_Select_Column2["EventAccountAddress"] = "event_account_address";
      Token_Activities_Select_Column2["EventCreationNumber"] = "event_creation_number";
      Token_Activities_Select_Column2["EventIndex"] = "event_index";
      Token_Activities_Select_Column2["EventSequenceNumber"] = "event_sequence_number";
      Token_Activities_Select_Column2["FromAddress"] = "from_address";
      Token_Activities_Select_Column2["Name"] = "name";
      Token_Activities_Select_Column2["PropertyVersion"] = "property_version";
      Token_Activities_Select_Column2["ToAddress"] = "to_address";
      Token_Activities_Select_Column2["TokenAmount"] = "token_amount";
      Token_Activities_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
      Token_Activities_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Token_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
      Token_Activities_Select_Column2["TransferType"] = "transfer_type";
      return Token_Activities_Select_Column2;
    })(Token_Activities_Select_Column || {});
    var Token_Activities_V2_Select_Column = ((Token_Activities_V2_Select_Column2) => {
      Token_Activities_V2_Select_Column2["AfterValue"] = "after_value";
      Token_Activities_V2_Select_Column2["BeforeValue"] = "before_value";
      Token_Activities_V2_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
      Token_Activities_V2_Select_Column2["EventAccountAddress"] = "event_account_address";
      Token_Activities_V2_Select_Column2["EventIndex"] = "event_index";
      Token_Activities_V2_Select_Column2["FromAddress"] = "from_address";
      Token_Activities_V2_Select_Column2["IsFungibleV2"] = "is_fungible_v2";
      Token_Activities_V2_Select_Column2["PropertyVersionV1"] = "property_version_v1";
      Token_Activities_V2_Select_Column2["ToAddress"] = "to_address";
      Token_Activities_V2_Select_Column2["TokenAmount"] = "token_amount";
      Token_Activities_V2_Select_Column2["TokenDataId"] = "token_data_id";
      Token_Activities_V2_Select_Column2["TokenStandard"] = "token_standard";
      Token_Activities_V2_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Token_Activities_V2_Select_Column2["TransactionVersion"] = "transaction_version";
      Token_Activities_V2_Select_Column2["Type"] = "type";
      return Token_Activities_V2_Select_Column2;
    })(Token_Activities_V2_Select_Column || {});
    var Token_Datas_Select_Column = ((Token_Datas_Select_Column2) => {
      Token_Datas_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
      Token_Datas_Select_Column2["CollectionName"] = "collection_name";
      Token_Datas_Select_Column2["CreatorAddress"] = "creator_address";
      Token_Datas_Select_Column2["DefaultProperties"] = "default_properties";
      Token_Datas_Select_Column2["Description"] = "description";
      Token_Datas_Select_Column2["DescriptionMutable"] = "description_mutable";
      Token_Datas_Select_Column2["LargestPropertyVersion"] = "largest_property_version";
      Token_Datas_Select_Column2["Maximum"] = "maximum";
      Token_Datas_Select_Column2["MaximumMutable"] = "maximum_mutable";
      Token_Datas_Select_Column2["MetadataUri"] = "metadata_uri";
      Token_Datas_Select_Column2["Name"] = "name";
      Token_Datas_Select_Column2["PayeeAddress"] = "payee_address";
      Token_Datas_Select_Column2["PropertiesMutable"] = "properties_mutable";
      Token_Datas_Select_Column2["RoyaltyMutable"] = "royalty_mutable";
      Token_Datas_Select_Column2["RoyaltyPointsDenominator"] = "royalty_points_denominator";
      Token_Datas_Select_Column2["RoyaltyPointsNumerator"] = "royalty_points_numerator";
      Token_Datas_Select_Column2["Supply"] = "supply";
      Token_Datas_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
      Token_Datas_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Token_Datas_Select_Column2["TransactionVersion"] = "transaction_version";
      Token_Datas_Select_Column2["UriMutable"] = "uri_mutable";
      return Token_Datas_Select_Column2;
    })(Token_Datas_Select_Column || {});
    var Token_Ownerships_Select_Column = ((Token_Ownerships_Select_Column2) => {
      Token_Ownerships_Select_Column2["Amount"] = "amount";
      Token_Ownerships_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
      Token_Ownerships_Select_Column2["CollectionName"] = "collection_name";
      Token_Ownerships_Select_Column2["CreatorAddress"] = "creator_address";
      Token_Ownerships_Select_Column2["Name"] = "name";
      Token_Ownerships_Select_Column2["OwnerAddress"] = "owner_address";
      Token_Ownerships_Select_Column2["PropertyVersion"] = "property_version";
      Token_Ownerships_Select_Column2["TableHandle"] = "table_handle";
      Token_Ownerships_Select_Column2["TableType"] = "table_type";
      Token_Ownerships_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
      Token_Ownerships_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Token_Ownerships_Select_Column2["TransactionVersion"] = "transaction_version";
      return Token_Ownerships_Select_Column2;
    })(Token_Ownerships_Select_Column || {});
    var Tokens_Select_Column = ((Tokens_Select_Column2) => {
      Tokens_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
      Tokens_Select_Column2["CollectionName"] = "collection_name";
      Tokens_Select_Column2["CreatorAddress"] = "creator_address";
      Tokens_Select_Column2["Name"] = "name";
      Tokens_Select_Column2["PropertyVersion"] = "property_version";
      Tokens_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
      Tokens_Select_Column2["TokenProperties"] = "token_properties";
      Tokens_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
      Tokens_Select_Column2["TransactionVersion"] = "transaction_version";
      return Tokens_Select_Column2;
    })(Tokens_Select_Column || {});
    var User_Transactions_Select_Column = ((User_Transactions_Select_Column2) => {
      User_Transactions_Select_Column2["BlockHeight"] = "block_height";
      User_Transactions_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
      User_Transactions_Select_Column2["Epoch"] = "epoch";
      User_Transactions_Select_Column2["ExpirationTimestampSecs"] = "expiration_timestamp_secs";
      User_Transactions_Select_Column2["GasUnitPrice"] = "gas_unit_price";
      User_Transactions_Select_Column2["MaxGasAmount"] = "max_gas_amount";
      User_Transactions_Select_Column2["ParentSignatureType"] = "parent_signature_type";
      User_Transactions_Select_Column2["Sender"] = "sender";
      User_Transactions_Select_Column2["SequenceNumber"] = "sequence_number";
      User_Transactions_Select_Column2["Timestamp"] = "timestamp";
      User_Transactions_Select_Column2["Version"] = "version";
      return User_Transactions_Select_Column2;
    })(User_Transactions_Select_Column || {});
  }
});

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// node_modules/decimal.js/decimal.js
var require_decimal = __commonJS({
  "node_modules/decimal.js/decimal.js"(exports, module) {
    (function(globalScope) {
      "use strict";
      var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.
        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,
        // 1 to MAX_DIGITS
        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,
        // 0 to 8
        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,
        // 0 to 9
        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,
        // 0 to -EXP_LIMIT
        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,
        // 0 to EXP_LIMIT
        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT,
        // -1 to -EXP_LIMIT
        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT,
        // 1 to EXP_LIMIT
        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false
        // true/false
      }, Decimal, inexact, noConflict, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = { toStringTag: tag };
      P.absoluteValue = P.abs = function() {
        var x = new this.constructor(this);
        if (x.s < 0) x.s = 1;
        return finalise(x);
      };
      P.ceil = function() {
        return finalise(new this.constructor(this), this.e + 1, 2);
      };
      P.clampedTo = P.clamp = function(min2, max2) {
        var k, x = this, Ctor = x.constructor;
        min2 = new Ctor(min2);
        max2 = new Ctor(max2);
        if (!min2.s || !max2.s) return new Ctor(NaN);
        if (min2.gt(max2)) throw Error(invalidArgument + max2);
        k = x.cmp(min2);
        return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
      };
      P.comparedTo = P.cmp = function(y) {
        var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }
        if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
        if (xs !== ys) return xs;
        if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length;
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      P.cosine = P.cos = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.d) return new Ctor(NaN);
        if (!x.d[0]) return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
      };
      P.cubeRoot = P.cbrt = function() {
        var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        external = false;
        s = x.s * mathpow(x.s * x, 1 / 3);
        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString(x.d);
          e = x.e;
          if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
          s = mathpow(n, 1 / 3);
          e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e + 1, 0);
                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      P.decimalPlaces = P.dp = function() {
        var w, d = this.d, n = NaN;
        if (d) {
          w = d.length - 1;
          n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
          w = d[w];
          if (w) for (; w % 10 == 0; w /= 10) n--;
          if (n < 0) n = 0;
        }
        return n;
      };
      P.dividedBy = P.div = function(y) {
        return divide(this, new this.constructor(y));
      };
      P.dividedToIntegerBy = P.divToInt = function(y) {
        var x = this, Ctor = x.constructor;
        return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      P.equals = P.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P.floor = function() {
        return finalise(new this.constructor(this), this.e + 1, 3);
      };
      P.greaterThan = P.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P.greaterThanOrEqualTo = P.gte = function(y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };
      P.hyperbolicCosine = P.cosh = function() {
        var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
        if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero()) return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          n = "2.3283064365386962890625e-10";
        }
        x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
        var cosh2_x, i = k, d8 = new Ctor(8);
        for (; i--; ) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }
        return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P.hyperbolicSine = P.sinh = function() {
        var k, pr, rm, len, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 3) {
          x = taylorSeries(Ctor, 2, x, x, true);
        } else {
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow(5, k));
          x = taylorSeries(Ctor, 2, x, x, true);
          var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k--; ) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(x, pr, rm, true);
      };
      P.hyperbolicTangent = P.tanh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(x.s);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      P.inverseCosine = P.acos = function() {
        var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
        if (k !== -1) {
          return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
        }
        if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.asin();
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return halfPi.minus(x);
      };
      P.inverseHyperbolicCosine = P.acosh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).minus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P.inverseHyperbolicSine = P.asinh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).plus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P.inverseHyperbolicTangent = P.atanh = function() {
        var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();
        if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
        Ctor.precision = wpr = xsd - x.e;
        x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x = x.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(0.5);
      };
      P.inverseSine = P.asin = function() {
        var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
        if (x.isZero()) return new Ctor(x);
        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (k !== -1) {
          if (k === 0) {
            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          }
          return new Ctor(NaN);
        }
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P.inverseTangent = P.atan = function() {
        var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
        if (!x.isFinite()) {
          if (!x.s) return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION) {
            r = getPi(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }
        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;
        k = Math.min(28, wpr / LOG_BASE + 2 | 0);
        for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
        external = false;
        j = Math.ceil(wpr / LOG_BASE);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x;
        for (; i !== -1; ) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));
          px = px.times(x2);
          r = t.plus(px.div(n += 2));
          if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
        }
        if (k) r = r.times(2 << k - 1);
        external = true;
        return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P.isFinite = function() {
        return !!this.d;
      };
      P.isInteger = P.isInt = function() {
        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = P.isNeg = function() {
        return this.s < 0;
      };
      P.isPositive = P.isPos = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      P.lessThan = P.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P.lessThanOrEqualTo = P.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P.logarithm = P.log = function(base) {
        var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d;
          if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
          isBase10 = base.eq(10);
        }
        d = arg.d;
        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
        }
        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0; ) k /= 10;
            inf = k !== 1;
          }
        }
        external = false;
        sd = pr + guard;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (checkRoundingDigits(r.d, k = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm(arg, sd);
            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
            r = divide(num, denominator, sd, 1);
            if (!inf) {
              if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise(r, pr + 1, 0);
              }
              break;
            }
          } while (checkRoundingDigits(r.d, k += 10, rm));
        }
        external = true;
        return finalise(r, pr, rm);
      };
      P.minus = P.sub = function(y) {
        var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s) y = new Ctor(NaN);
          else if (x.d) y.s = -y.s;
          else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (yd[0]) y.s = -y.s;
          else if (xd[0]) y = new Ctor(x);
          else return new Ctor(rm === 3 ? -0 : 0);
          return external ? finalise(y, pr, rm) : y;
        }
        e = mathfloor(y.e / LOG_BASE);
        xe = mathfloor(x.e / LOG_BASE);
        xd = xd.slice();
        k = xe - e;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          }
          i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
          if (k > i) {
            k = i;
            d.length = 1;
          }
          d.reverse();
          for (i = k; i--; ) d.push(0);
          d.reverse();
        } else {
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy) len = i;
          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
        for (i = yd.length; i > k; ) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
            --xd[j];
            xd[i] += BASE;
          }
          xd[i] -= yd[i];
        }
        for (; xd[--len] === 0; ) xd.pop();
        for (; xd[0] === 0; xd.shift()) --e;
        if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      P.modulo = P.mod = function(y) {
        var q, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
        if (!y.d || x.d && !x.d[0]) {
          return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
        }
        external = false;
        if (Ctor.modulo == 9) {
          q = divide(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide(x, y, 0, Ctor.modulo, 1);
        }
        q = q.times(y);
        external = true;
        return x.minus(q);
      };
      P.naturalExponential = P.exp = function() {
        return naturalExponential(this);
      };
      P.naturalLogarithm = P.ln = function() {
        return naturalLogarithm(this);
      };
      P.negated = P.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise(x);
      };
      P.plus = P.add = function(y) {
        var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s) y = new Ctor(NaN);
          else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (!yd[0]) y = new Ctor(x);
          return external ? finalise(y, pr, rm) : y;
        }
        k = mathfloor(x.e / LOG_BASE);
        e = mathfloor(y.e / LOG_BASE);
        xd = xd.slice();
        i = k - e;
        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE);
          len = k > len ? k + 1 : len + 1;
          if (i > len) {
            i = len;
            d.length = 1;
          }
          d.reverse();
          for (; i--; ) d.push(0);
          d.reverse();
        }
        len = xd.length;
        i = yd.length;
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i; ) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
          xd[i] %= BASE;
        }
        if (carry) {
          xd.unshift(carry);
          ++e;
        }
        for (len = xd.length; xd[--len] == 0; ) xd.pop();
        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      P.precision = P.sd = function(z) {
        var k, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
        if (x.d) {
          k = getPrecision(x.d);
          if (z && x.e + 1 > k) k = x.e + 1;
        } else {
          k = NaN;
        }
        return k;
      };
      P.round = function() {
        var x = this, Ctor = x.constructor;
        return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
      };
      P.sine = P.sin = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = sine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }
        external = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString(d);
          if ((n.length + e) % 2 == 0) n += "0";
          s = Math.sqrt(n);
          e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e + 1, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e + 1, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      P.tangent = P.tan = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x = x.sin();
        x.s = 1;
        x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
      };
      P.times = P.mul = function(y) {
        var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        y.s *= x.s;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
        }
        e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--; ) r.push(0);
        for (i = ydL; --i >= 0; ) {
          carry = 0;
          for (k = xdL + i; k > i; ) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
          }
          r[k] = (r[k] + carry) % BASE | 0;
        }
        for (; !r[--rL]; ) r.pop();
        if (carry) ++e;
        else r.shift();
        y.d = r;
        y.e = getBase10Exponent(r, e);
        return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
      };
      P.toBinary = function(sd, rm) {
        return toStringBinary(this, 2, sd, rm);
      };
      P.toDecimalPlaces = P.toDP = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0) return x;
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        return finalise(x, dp + x.e + 1, rm);
      };
      P.toExponential = function(dp, rm) {
        var str, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), dp + 1, rm);
          str = finiteToString(x, true, dp + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toFixed = function(dp, rm) {
        var str, y, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          y = finalise(new Ctor(x), dp + x.e + 1, rm);
          str = finiteToString(y, false, dp + y.e + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toFraction = function(maxD) {
        var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
        if (!xd) return new Ctor(x);
        n1 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d = new Ctor(d1);
        e = d.e = getPrecision(xd) - x.e - 1;
        k = e % LOG_BASE;
        d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
        if (maxD == null) {
          maxD = e > 0 ? d : n1;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
          maxD = n.gt(d) ? e > 0 ? d : n1 : n;
        }
        external = false;
        n = new Ctor(digitsToString(xd));
        pr = Ctor.precision;
        Ctor.precision = e = xd.length * LOG_BASE * 2;
        for (; ; ) {
          q = divide(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1) break;
          d0 = d1;
          d1 = d2;
          d2 = n1;
          n1 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }
        d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        Ctor.precision = pr;
        external = true;
        return r;
      };
      P.toHexadecimal = P.toHex = function(sd, rm) {
        return toStringBinary(this, 16, sd, rm);
      };
      P.toNearest = function(y, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (y == null) {
          if (!x.d) return x;
          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt32(rm, 0, 8);
          }
          if (!x.d) return y.s ? x : y;
          if (!y.d) {
            if (y.s) y.s = x.s;
            return y;
          }
        }
        if (y.d[0]) {
          external = false;
          x = divide(x, y, 0, rm, 1).times(y);
          external = true;
          finalise(x);
        } else {
          y.s = x.s;
          x = y;
        }
        return x;
      };
      P.toNumber = function() {
        return +this;
      };
      P.toOctal = function(sd, rm) {
        return toStringBinary(this, 8, sd, rm);
      };
      P.toPower = P.pow = function(y) {
        var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
        if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
        x = new Ctor(x);
        if (x.eq(1)) return x;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y.eq(1)) return finalise(x, pr, rm);
        e = mathfloor(y.e / LOG_BASE);
        if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
          r = intPow(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
        }
        s = x.s;
        if (s < 0) {
          if (e < y.d.length - 1) return new Ctor(NaN);
          if ((y.d[e] & 1) == 0) s = 1;
          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        }
        k = mathpow(+x, yn);
        e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
        if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
        external = false;
        Ctor.rounding = x.s = 1;
        k = Math.min(12, (e + "").length);
        r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
        if (r.d) {
          r = finalise(r, pr + 5, 1);
          if (checkRoundingDigits(r.d, pr, rm)) {
            e = pr + 10;
            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
          }
        }
        r.s = s;
        external = true;
        Ctor.rounding = rm;
        return finalise(r, pr, rm);
      };
      P.toPrecision = function(sd, rm) {
        var str, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), sd, rm);
          str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toSignificantDigits = P.toSD = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        }
        return finalise(new Ctor(x), sd, rm);
      };
      P.toString = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.truncated = P.trunc = function() {
        return finalise(new this.constructor(this), this.e + 1, 1);
      };
      P.valueOf = P.toJSON = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() ? "-" + str : str;
      };
      function digitsToString(d) {
        var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
        if (indexOfLastWord > 0) {
          str += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + "";
            k = LOG_BASE - ws.length;
            if (k) str += getZeroString(k);
            str += ws;
          }
          w = d[i];
          ws = w + "";
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; ) w /= 10;
        return str + w;
      }
      function checkInt32(i, min2, max2) {
        if (i !== ~~i || i < min2 || i > max2) {
          throw Error(invalidArgument + i);
        }
      }
      function checkRoundingDigits(d, i, rm, repeating) {
        var di, k, r, rd;
        for (k = d[0]; k >= 10; k /= 10) --i;
        if (--i < 0) {
          i += LOG_BASE;
          di = 0;
        } else {
          di = Math.ceil((i + 1) / LOG_BASE);
          i %= LOG_BASE;
        }
        k = mathpow(10, LOG_BASE - i);
        rd = d[di] % k | 0;
        if (repeating == null) {
          if (i < 3) {
            if (i == 0) rd = rd / 100 | 0;
            else if (i == 1) rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i < 4) {
            if (i == 0) rd = rd / 1e3 | 0;
            else if (i == 1) rd = rd / 100 | 0;
            else if (i == 2) rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
          }
        }
        return r;
      }
      function convertBase(str, baseIn, baseOut) {
        var j, arr = [0], arrL, i = 0, strL = str.length;
        for (; i < strL; ) {
          for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
          arr[0] += NUMERALS.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      function cosine(Ctor, x) {
        var k, len, y;
        if (x.isZero()) return x;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          y = "2.3283064365386962890625e-10";
        }
        Ctor.precision += k;
        x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
        for (var i = k; i--; ) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }
        Ctor.precision -= k;
        return x;
      }
      var divide = /* @__PURE__ */ function() {
        function multiplyInteger(x, k, base) {
          var temp, carry = 0, i = x.length;
          for (x = x.slice(); i--; ) {
            temp = x[i] * k + carry;
            x[i] = temp % base | 0;
            carry = temp / base | 0;
          }
          if (carry) x.unshift(carry);
          return x;
        }
        function compare(a, b, aL, bL) {
          var i, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; ) a.shift();
        }
        return function(x, y, pr, rm, dp, base) {
          var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
                // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.
                xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
              )
            );
          }
          if (base) {
            logBase = 1;
            e = x.e - y.e;
          } else {
            base = BASE;
            logBase = LOG_BASE;
            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
          }
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign2);
          qd = q.d = [];
          for (i = 0; yd[i] == (xd[i] || 0); i++) ;
          if (yd[i] > (xd[i] || 0)) e--;
          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            sd = sd / logBase + 2 | 0;
            i = 0;
            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++;
              for (; (i < xL || k) && sd--; i++) {
                t = k * base + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
              }
              more = k || i < xL;
            } else {
              k = base / (yd[0] + 1) | 0;
              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }
              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; ) rem[remL++] = 0;
              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2) ++yd0;
              do {
                k = 0;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  k = rem0 / yd0 | 0;
                  if (k > 1) {
                    if (k >= base) k = base - 1;
                    prod = multiplyInteger(yd, k, base);
                    prodL = prod.length;
                    remL = rem.length;
                    cmp = compare(prod, rem, prodL, remL);
                    if (cmp == 1) {
                      k--;
                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    if (k == 0) cmp = k = 1;
                    prod = yd.slice();
                  }
                  prodL = prod.length;
                  if (prodL < remL) prod.unshift(0);
                  subtract(rem, prod, remL, base);
                  if (cmp == -1) {
                    remL = rem.length;
                    cmp = compare(yd, rem, yL, remL);
                    if (cmp < 1) {
                      k++;
                      subtract(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }
                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                }
                qd[i++] = k;
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);
              more = rem[0] !== void 0;
            }
            if (!qd[0]) qd.shift();
          }
          if (logBase == 1) {
            q.e = e;
            inexact = more;
          } else {
            for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
            q.e = i + e * logBase - 1;
            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
          }
          return q;
        };
      }();
      function finalise(x, sd, rm, isTruncated) {
        var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
        out: if (sd != null) {
          xd = x.d;
          if (!xd) return x;
          for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
          i = sd - digits;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            w = xd[xdi = 0];
            rd = w / mathpow(10, digits - j - 1) % 10 | 0;
          } else {
            xdi = Math.ceil((i + 1) / LOG_BASE);
            k = xd.length;
            if (xdi >= k) {
              if (isTruncated) {
                for (; k++ <= xdi; ) xd.push(0);
                w = rd = 0;
                digits = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              w = k = xd[xdi];
              for (digits = 1; k >= 10; k /= 10) digits++;
              i %= LOG_BASE;
              j = i - LOG_BASE + digits;
              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
            }
          }
          isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
          roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xd[0]) {
            xd.length = 0;
            if (roundUp) {
              sd -= x.e + 1;
              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
              x.e = -sd || 0;
            } else {
              xd[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xd.length = xdi;
            k = 1;
            xdi--;
          } else {
            xd.length = xdi + 1;
            k = mathpow(10, LOG_BASE - i);
            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
          }
          if (roundUp) {
            for (; ; ) {
              if (xdi == 0) {
                for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
                j = xd[0] += k;
                for (k = 1; j >= 10; j /= 10) k++;
                if (i != k) {
                  x.e++;
                  if (xd[0] == BASE) xd[0] = 1;
                }
                break;
              } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE) break;
                xd[xdi--] = 0;
                k = 1;
              }
            }
          }
          for (i = xd.length; xd[--i] === 0; ) xd.pop();
        }
        if (external) {
          if (x.e > Ctor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < Ctor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
        return x;
      }
      function finiteToString(x, isExp, sd) {
        if (!x.isFinite()) return nonFiniteToString(x);
        var k, e = x.e, str = digitsToString(x.d), len = str.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
          } else if (len > 1) {
            str = str.charAt(0) + "." + str.slice(1);
          }
          str = str + (x.e < 0 ? "e" : "e+") + x.e;
        } else if (e < 0) {
          str = "0." + getZeroString(-e - 1) + str;
          if (sd && (k = sd - len) > 0) str += getZeroString(k);
        } else if (e >= len) {
          str += getZeroString(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
        } else {
          if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len) str += ".";
            str += getZeroString(k);
          }
        }
        return str;
      }
      function getBase10Exponent(digits, e) {
        var w = digits[0];
        for (e *= LOG_BASE; w >= 10; w /= 10) e++;
        return e;
      }
      function getLn10(Ctor, sd, pr) {
        if (sd > LN10_PRECISION) {
          external = true;
          if (pr) Ctor.precision = pr;
          throw Error(precisionLimitExceeded);
        }
        return finalise(new Ctor(LN10), sd, 1, true);
      }
      function getPi(Ctor, sd, rm) {
        if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
        return finalise(new Ctor(PI), sd, rm, true);
      }
      function getPrecision(digits) {
        var w = digits.length - 1, len = w * LOG_BASE + 1;
        w = digits[w];
        if (w) {
          for (; w % 10 == 0; w /= 10) len--;
          for (w = digits[0]; w >= 10; w /= 10) len++;
        }
        return len;
      }
      function getZeroString(k) {
        var zs = "";
        for (; k--; ) zs += "0";
        return zs;
      }
      function intPow(Ctor, x, n, pr) {
        var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
        external = false;
        for (; ; ) {
          if (n % 2) {
            r = r.times(x);
            if (truncate(r.d, k)) isTruncated = true;
          }
          n = mathfloor(n / 2);
          if (n === 0) {
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0) ++r.d[n];
            break;
          }
          x = x.times(x);
          truncate(x.d, k);
        }
        external = true;
        return r;
      }
      function isOdd(n) {
        return n.d[n.d.length - 1] & 1;
      }
      function maxOrMin(Ctor, args, ltgt) {
        var y, x = new Ctor(args[0]), i = 0;
        for (; ++i < args.length; ) {
          y = new Ctor(args[i]);
          if (!y.s) {
            x = y;
            break;
          } else if (x[ltgt](y)) {
            x = y;
          }
        }
        return x;
      }
      function naturalExponential(x, sd) {
        var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (!x.d || !x.d[0] || x.e > 17) {
          return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.e > -2) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow2 = sum2 = new Ctor(1);
        Ctor.precision = wpr;
        for (; ; ) {
          pow2 = finalise(pow2.times(x), wpr, 1);
          denominator = denominator.times(++i);
          t = sum2.plus(divide(pow2, denominator, wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
            j = k;
            while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
            if (sd == null) {
              if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow2 = t = new Ctor(1);
                i = 0;
                rep++;
              } else {
                return finalise(sum2, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum2;
            }
          }
          sum2 = t;
        }
      }
      function naturalLogarithm(y, sd) {
        var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        Ctor.precision = wpr += guard;
        c = digitsToString(xd);
        c0 = c.charAt(0);
        if (Math.abs(e = x.e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e = x.e;
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn10(Ctor, wpr + 2, pr).times(e + "");
          x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? finalise(x, pr, rm, external = true) : x;
        }
        x1 = x;
        sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise(x.times(x), wpr, 1);
        denominator = 3;
        for (; ; ) {
          numerator = finalise(numerator.times(x2), wpr, 1);
          t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
            sum2 = sum2.times(2);
            if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
            sum2 = divide(sum2, new Ctor(n), wpr, 1);
            if (sd == null) {
              if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise(sum2, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum2;
            }
          }
          sum2 = t;
          denominator += 2;
        }
      }
      function nonFiniteToString(x) {
        return String(x.s * x.s / 0);
      }
      function parseDecimal(x, str) {
        var e, i, len;
        if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++) ;
        for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
        str = str.slice(i, len);
        if (str) {
          len -= i;
          x.e = e = e - i - 1;
          x.d = [];
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;
          if (i < len) {
            if (i) x.d.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
            str = str.slice(i);
            i = LOG_BASE - str.length;
          } else {
            i -= len;
          }
          for (; i--; ) str += "0";
          x.d.push(+str);
          if (external) {
            if (x.e > x.constructor.maxE) {
              x.d = null;
              x.e = NaN;
            } else if (x.e < x.constructor.minE) {
              x.e = 0;
              x.d = [0];
            }
          }
        } else {
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function parseOther(x, str) {
        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
        if (str.indexOf("_") > -1) {
          str = str.replace(/(\d)_(?=\d)/g, "$1");
          if (isDecimal.test(str)) return parseDecimal(x, str);
        } else if (str === "Infinity" || str === "NaN") {
          if (!+str) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }
        if (isHex.test(str)) {
          base = 16;
          str = str.toLowerCase();
        } else if (isBinary.test(str)) {
          base = 2;
        } else if (isOctal.test(str)) {
          base = 8;
        } else {
          throw Error(invalidArgument + str);
        }
        i = str.search(/p/i);
        if (i > 0) {
          p = +str.slice(i + 1);
          str = str.substring(2, i);
        } else {
          str = str.slice(2);
        }
        i = str.indexOf(".");
        isFloat = i >= 0;
        Ctor = x.constructor;
        if (isFloat) {
          str = str.replace(".", "");
          len = str.length;
          i = len - i;
          divisor = intPow(Ctor, new Ctor(base), i, i * 2);
        }
        xd = convertBase(str, base, BASE);
        xe = xd.length - 1;
        for (i = xe; xd[i] === 0; --i) xd.pop();
        if (i < 0) return new Ctor(x.s * 0);
        x.e = getBase10Exponent(xd, xe);
        x.d = xd;
        external = false;
        if (isFloat) x = divide(x, divisor, len * 4);
        if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
        external = true;
        return x;
      }
      function sine(Ctor, x) {
        var k, len = x.d.length;
        if (len < 3) {
          return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
        }
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x);
        var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }
        return x;
      }
      function taylorSeries(Ctor, n, x, y, isHyperbolic) {
        var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
        external = false;
        x2 = x.times(x);
        u = new Ctor(y);
        for (; ; ) {
          t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);
          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--; ) ;
            if (j == -1) break;
          }
          j = u;
          u = y;
          y = t;
          t = j;
          i++;
        }
        external = true;
        t.d.length = k + 1;
        return t;
      }
      function tinyPow(b, e) {
        var n = b;
        while (--e) n *= b;
        return n;
      }
      function toLessThanHalfPi(Ctor, x) {
        var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
        x = x.abs();
        if (x.lte(halfPi)) {
          quadrant = isNeg ? 4 : 1;
          return x;
        }
        t = x.divToInt(pi);
        if (t.isZero()) {
          quadrant = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi));
          if (x.lte(halfPi)) {
            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
            return x;
          }
          quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
        }
        return x.minus(pi).abs();
      }
      function toStringBinary(x, baseOut, sd, rm) {
        var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
        if (isExp) {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }
        if (!x.isFinite()) {
          str = nonFiniteToString(x);
        } else {
          str = finiteToString(x);
          i = str.indexOf(".");
          if (isExp) {
            base = 2;
            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          }
          if (i >= 0) {
            str = str.replace(".", "");
            y = new Ctor(1);
            y.e = str.length - i;
            y.d = convertBase(finiteToString(y), 10, base);
            y.e = y.d.length;
          }
          xd = convertBase(str, 10, base);
          e = len = xd.length;
          for (; xd[--len] == 0; ) xd.pop();
          if (!xd[0]) {
            str = isExp ? "0p+0" : "0";
          } else {
            if (i < 0) {
              e--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e;
              x = divide(x, y, sd, rm, 0, base);
              xd = x.d;
              e = x.e;
              roundUp = inexact;
            }
            i = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;
            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
            xd.length = sd;
            if (roundUp) {
              for (; ++xd[--sd] > base - 1; ) {
                xd[sd] = 0;
                if (!sd) {
                  ++e;
                  xd.unshift(1);
                }
              }
            }
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i = baseOut == 16 ? 4 : 3;
                  for (--len; len % i; len++) str += "0";
                  xd = convertBase(str, base, baseOut);
                  for (len = xd.length; !xd[len - 1]; --len) ;
                  for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
                } else {
                  str = str.charAt(0) + "." + str.slice(1);
                }
              }
              str = str + (e < 0 ? "p" : "p+") + e;
            } else if (e < 0) {
              for (; ++e; ) str = "0" + str;
              str = "0." + str;
            } else {
              if (++e > len) for (e -= len; e--; ) str += "0";
              else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
            }
          }
          str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
        }
        return x.s < 0 ? "-" + str : str;
      }
      function truncate(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function abs(x) {
        return new this(x).abs();
      }
      function acos(x) {
        return new this(x).acos();
      }
      function acosh(x) {
        return new this(x).acosh();
      }
      function add(x, y) {
        return new this(x).plus(y);
      }
      function asin(x) {
        return new this(x).asin();
      }
      function asinh(x) {
        return new this(x).asinh();
      }
      function atan(x) {
        return new this(x).atan();
      }
      function atanh(x) {
        return new this(x).atanh();
      }
      function atan2(y, x) {
        y = new this(y);
        x = new this(x);
        var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
        if (!y.s || !x.s) {
          r = new this(NaN);
        } else if (!y.d && !x.d) {
          r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s;
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
          r.s = y.s;
        } else if (!y.d || x.isZero()) {
          r = getPi(this, wpr, 1).times(0.5);
          r.s = y.s;
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide(y, x, wpr, 1));
          x = getPi(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide(y, x, wpr, 1));
        }
        return r;
      }
      function cbrt(x) {
        return new this(x).cbrt();
      }
      function ceil(x) {
        return finalise(x = new this(x), x.e + 1, 2);
      }
      function clamp(x, min2, max2) {
        return new this(x).clamp(min2, max2);
      }
      function config(obj) {
        if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
        var i, p, v, useDefaults = obj.defaults === true, ps = [
          "precision",
          1,
          MAX_DIGITS,
          "rounding",
          0,
          8,
          "toExpNeg",
          -EXP_LIMIT,
          0,
          "toExpPos",
          0,
          EXP_LIMIT,
          "maxE",
          0,
          EXP_LIMIT,
          "minE",
          -EXP_LIMIT,
          0,
          "modulo",
          0,
          9
        ];
        for (i = 0; i < ps.length; i += 3) {
          if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
          if ((v = obj[p]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
            else throw Error(invalidArgument + p + ": " + v);
          }
        }
        if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument + p + ": " + v);
          }
        }
        return this;
      }
      function cos(x) {
        return new this(x).cos();
      }
      function cosh(x) {
        return new this(x).cosh();
      }
      function clone(obj) {
        var i, p, ps;
        function Decimal2(v) {
          var e, i2, t, x = this;
          if (!(x instanceof Decimal2)) return new Decimal2(v);
          x.constructor = Decimal2;
          if (isDecimalInstance(v)) {
            x.s = v.s;
            if (external) {
              if (!v.d || v.e > Decimal2.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal2.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }
            return;
          }
          t = typeof v;
          if (t === "number") {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            if (v === ~~v && v < 1e7) {
              for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
              if (external) {
                if (e > Decimal2.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e < Decimal2.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e;
                  x.d = [v];
                }
              } else {
                x.e = e;
                x.d = [v];
              }
              return;
            } else if (v * 0 !== 0) {
              if (!v) x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }
            return parseDecimal(x, v.toString());
          } else if (t !== "string") {
            throw Error(invalidArgument + v);
          }
          if ((i2 = v.charCodeAt(0)) === 45) {
            v = v.slice(1);
            x.s = -1;
          } else {
            if (i2 === 43) v = v.slice(1);
            x.s = 1;
          }
          return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
        }
        Decimal2.prototype = P;
        Decimal2.ROUND_UP = 0;
        Decimal2.ROUND_DOWN = 1;
        Decimal2.ROUND_CEIL = 2;
        Decimal2.ROUND_FLOOR = 3;
        Decimal2.ROUND_HALF_UP = 4;
        Decimal2.ROUND_HALF_DOWN = 5;
        Decimal2.ROUND_HALF_EVEN = 6;
        Decimal2.ROUND_HALF_CEIL = 7;
        Decimal2.ROUND_HALF_FLOOR = 8;
        Decimal2.EUCLID = 9;
        Decimal2.config = Decimal2.set = config;
        Decimal2.clone = clone;
        Decimal2.isDecimal = isDecimalInstance;
        Decimal2.abs = abs;
        Decimal2.acos = acos;
        Decimal2.acosh = acosh;
        Decimal2.add = add;
        Decimal2.asin = asin;
        Decimal2.asinh = asinh;
        Decimal2.atan = atan;
        Decimal2.atanh = atanh;
        Decimal2.atan2 = atan2;
        Decimal2.cbrt = cbrt;
        Decimal2.ceil = ceil;
        Decimal2.clamp = clamp;
        Decimal2.cos = cos;
        Decimal2.cosh = cosh;
        Decimal2.div = div;
        Decimal2.exp = exp;
        Decimal2.floor = floor;
        Decimal2.hypot = hypot;
        Decimal2.ln = ln;
        Decimal2.log = log;
        Decimal2.log10 = log10;
        Decimal2.log2 = log2;
        Decimal2.max = max;
        Decimal2.min = min;
        Decimal2.mod = mod;
        Decimal2.mul = mul;
        Decimal2.pow = pow;
        Decimal2.random = random;
        Decimal2.round = round;
        Decimal2.sign = sign;
        Decimal2.sin = sin;
        Decimal2.sinh = sinh;
        Decimal2.sqrt = sqrt;
        Decimal2.sub = sub;
        Decimal2.sum = sum;
        Decimal2.tan = tan;
        Decimal2.tanh = tanh;
        Decimal2.trunc = trunc;
        if (obj === void 0) obj = {};
        if (obj) {
          if (obj.defaults !== true) {
            ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
            for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
          }
        }
        Decimal2.config(obj);
        return Decimal2;
      }
      function div(x, y) {
        return new this(x).div(y);
      }
      function exp(x) {
        return new this(x).exp();
      }
      function floor(x) {
        return finalise(x = new this(x), x.e + 1, 3);
      }
      function hypot() {
        var i, n, t = new this(0);
        external = false;
        for (i = 0; i < arguments.length; ) {
          n = new this(arguments[i++]);
          if (!n.d) {
            if (n.s) {
              external = true;
              return new this(1 / 0);
            }
            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }
        external = true;
        return t.sqrt();
      }
      function isDecimalInstance(obj) {
        return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
      }
      function ln(x) {
        return new this(x).ln();
      }
      function log(x, y) {
        return new this(x).log(y);
      }
      function log2(x) {
        return new this(x).log(2);
      }
      function log10(x) {
        return new this(x).log(10);
      }
      function max() {
        return maxOrMin(this, arguments, "lt");
      }
      function min() {
        return maxOrMin(this, arguments, "gt");
      }
      function mod(x, y) {
        return new this(x).mod(y);
      }
      function mul(x, y) {
        return new this(x).mul(y);
      }
      function pow(x, y) {
        return new this(x).pow(y);
      }
      function random(sd) {
        var d, e, k, n, i = 0, r = new this(1), rd = [];
        if (sd === void 0) sd = this.precision;
        else checkInt32(sd, 1, MAX_DIGITS);
        k = Math.ceil(sd / LOG_BASE);
        if (!this.crypto) {
          for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));
          for (; i < k; ) {
            n = d[i];
            if (n >= 429e7) {
              d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {
              rd[i++] = n % 1e7;
            }
          }
        } else if (crypto.randomBytes) {
          d = crypto.randomBytes(k *= 4);
          for (; i < k; ) {
            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
            if (n >= 214e7) {
              crypto.randomBytes(4).copy(d, i);
            } else {
              rd.push(n % 1e7);
              i += 4;
            }
          }
          i = k / 4;
        } else {
          throw Error(cryptoUnavailable);
        }
        k = rd[--i];
        sd %= LOG_BASE;
        if (k && sd) {
          n = mathpow(10, LOG_BASE - sd);
          rd[i] = (k / n | 0) * n;
        }
        for (; rd[i] === 0; i--) rd.pop();
        if (i < 0) {
          e = 0;
          rd = [0];
        } else {
          e = -1;
          for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
          for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
          if (k < LOG_BASE) e -= LOG_BASE - k;
        }
        r.e = e;
        r.d = rd;
        return r;
      }
      function round(x) {
        return finalise(x = new this(x), x.e + 1, this.rounding);
      }
      function sign(x) {
        x = new this(x);
        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
      }
      function sin(x) {
        return new this(x).sin();
      }
      function sinh(x) {
        return new this(x).sinh();
      }
      function sqrt(x) {
        return new this(x).sqrt();
      }
      function sub(x, y) {
        return new this(x).sub(y);
      }
      function sum() {
        var i = 0, args = arguments, x = new this(args[i]);
        external = false;
        for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
        external = true;
        return finalise(x, this.precision, this.rounding);
      }
      function tan(x) {
        return new this(x).tan();
      }
      function tanh(x) {
        return new this(x).tanh();
      }
      function trunc(x) {
        return finalise(x = new this(x), x.e + 1, 1);
      }
      Decimal = clone(DEFAULTS);
      Decimal.prototype.constructor = Decimal;
      Decimal["default"] = Decimal.Decimal = Decimal;
      LN10 = new Decimal(LN10);
      PI = new Decimal(PI);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal;
        });
      } else if (typeof module != "undefined" && module.exports) {
        if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
          P[Symbol["for"]("nodejs.util.inspect.custom")] = P.toString;
          P[Symbol.toStringTag] = "Decimal";
        }
        module.exports = Decimal;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
        }
        noConflict = globalScope.Decimal;
        Decimal.noConflict = function() {
          globalScope.Decimal = noConflict;
          return Decimal;
        };
        globalScope.Decimal = Decimal;
      }
    })(exports);
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/swap-math.js
var require_swap_math = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/swap-math.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dStable = exports.lp_value = exports.f = exports.get_y = exports.coin_out = exports.getCoinsOutWithFeesStable = exports.coin_in = exports.getCoinsInWithFeesStable = exports.getCoinInWithFees = exports.getCoinOutWithFees = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var decimal_js_1 = tslib_1.__importDefault(require_decimal());
    var utils_1 = require_utils2();
    var e8 = new decimal_js_1.default("100000000");
    var DENOMINATOR = new decimal_js_1.default(1e4);
    function getCoinOutWithFees(coinInVal, reserveInSize, reserveOutSize, fee) {
      const { feePct, feeScale } = { feePct: fee, feeScale: (0, utils_1.d)(DENOMINATOR) };
      const feeMultiplier = feeScale.minus(feePct);
      const coinInAfterFees = coinInVal.mul(feeMultiplier);
      const newReservesInSize = reserveInSize.mul(feeScale).plus(coinInAfterFees);
      return coinInAfterFees.mul(reserveOutSize).div(newReservesInSize);
    }
    exports.getCoinOutWithFees = getCoinOutWithFees;
    function getCoinInWithFees(coinOutVal, reserveOutSize, reserveInSize, fee) {
      const feeMultiplier = DENOMINATOR.minus(fee);
      const newReservesOutSize = reserveOutSize.minus(coinOutVal).mul(feeMultiplier);
      return coinOutVal.mul(DENOMINATOR).mul(reserveInSize).div(newReservesOutSize).plus(1);
    }
    exports.getCoinInWithFees = getCoinInWithFees;
    function getCoinsInWithFeesStable(coinOut, reserveOut, reserveIn, scaleOut, scaleIn, fee) {
      const r = coin_in(coinOut, scaleOut, scaleIn, reserveOut, reserveIn);
      return r.plus(1).mul(DENOMINATOR).div(DENOMINATOR.minus(fee)).plus(1);
    }
    exports.getCoinsInWithFeesStable = getCoinsInWithFeesStable;
    function coin_in(coinOut, scaleOut, scaleIn, reserveOut, reserveIn) {
      const xy = lp_value(reserveIn, scaleIn, reserveOut, scaleOut);
      const reserve_in = reserveIn.mul(e8).div(scaleIn);
      const reserve_out = reserveOut.mul(e8).div(scaleOut);
      const amount_out = coinOut.mul(e8).div(scaleOut);
      const total_reserve = reserve_out.minus(amount_out);
      const x = get_y(total_reserve, xy, reserve_in).minus(reserve_in);
      return x.mul(scaleIn).div(e8);
    }
    exports.coin_in = coin_in;
    function getCoinsOutWithFeesStable(coinIn, reserveIn, reserveOut, scaleIn, scaleOut, fee) {
      let coin_in_val_after_fees = new decimal_js_1.default(0);
      const coin_in_val_scaled = coinIn.mul(DENOMINATOR.minus(fee));
      if (!coin_in_val_scaled.mod(DENOMINATOR).eq(0)) {
        coin_in_val_after_fees = coin_in_val_scaled.div(DENOMINATOR).plus(1);
      } else {
        coin_in_val_after_fees = coin_in_val_scaled.div(DENOMINATOR);
      }
      return coin_out(coin_in_val_after_fees, scaleIn, scaleOut, reserveIn, reserveOut);
    }
    exports.getCoinsOutWithFeesStable = getCoinsOutWithFeesStable;
    function coin_out(coinIn, scaleIn, scaleOut, reserveIn, reserveOut) {
      const xy = lp_value(reserveIn, scaleIn, reserveOut, scaleOut);
      const reserve_in = reserveIn.mul(e8).div(scaleIn);
      const reserve_out = reserveOut.mul(e8).dividedBy(scaleOut);
      const amount_in = coinIn.mul(e8).div(scaleIn);
      const total_reserve = amount_in.plus(reserve_in);
      const y = reserve_out.minus(get_y(total_reserve, xy, reserve_out));
      return y.mul(scaleOut).div(e8);
    }
    exports.coin_out = coin_out;
    function get_y(x0, xy, y) {
      let i = 0;
      while (i < 255) {
        const k = f(x0, y);
        let dy = new decimal_js_1.default(0);
        if (k.lt(xy)) {
          dy = xy.minus(k).div(dStable(x0, y)).plus(1);
          y = y.plus(dy);
        } else {
          dy = k.minus(xy).dividedBy(dStable(x0, y));
          y = y.minus(dy);
        }
        if (dy.lte(1)) {
          return y;
        }
        i++;
      }
      return y;
    }
    exports.get_y = get_y;
    function f(x0, y) {
      const yyy = y.mul(y).mul(y);
      const a = x0.mul(yyy);
      const xxx = x0.mul(x0).mul(x0);
      const b = xxx.mul(y);
      return a.plus(b);
    }
    exports.f = f;
    function lp_value(x_coin, x_scale, y_coin, y_scale) {
      const x = x_coin.mul(e8).div(x_scale);
      const y = y_coin.mul(e8).div(y_scale);
      const a = x.mul(y);
      const b = x.mul(x).plus(y.mul(y));
      return a.mul(b);
    }
    exports.lp_value = lp_value;
    function dStable(x0, y) {
      const x3 = x0.mul(3);
      const yy = y.mul(y);
      const xyy3 = x3.mul(yy);
      const xxx = x0.mul(x0).mul(x0);
      return xyy3.plus(xxx);
    }
    exports.dStable = dStable;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/constants/index.js
var require_constants = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TOKENS_MAPPING = exports.NETWORKS_MODULES = exports.VERSION_0_5 = exports.VERSION_0 = exports.SCRIPTS_V2 = exports.SCRIPTS_V1 = exports.COIN_STORE = exports.COIN_INFO = exports.RESOURCES_V05_ACCOUNT = exports.MODULES_V05_ACCOUNT = exports.COINS_ACCOUNT = exports.RESOURCES_ACCOUNT = exports.MODULES_ACCOUNT = void 0;
    exports.MODULES_ACCOUNT = "0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12";
    exports.RESOURCES_ACCOUNT = "0x05a97986a9d031c4567e15b797be516910cfcb4156312482efc6a19c0a30c948";
    exports.COINS_ACCOUNT = "0x43417434fd869edee76cca2a4d2301e528a1551b1d719b75c350c3c97d15b8b9";
    exports.MODULES_V05_ACCOUNT = "0x163df34fccbf003ce219d3f1d9e70d140b60622cb9dd47599c25fb2f797ba6e";
    exports.RESOURCES_V05_ACCOUNT = "0x61d2c22a6cb7831bee0f48363b0eec92369357aece0d1142062f7d5d85c7bef8";
    exports.COIN_INFO = "0x1::coin::CoinInfo";
    exports.COIN_STORE = "0x1::coin::CoinStore";
    exports.SCRIPTS_V1 = "scripts";
    exports.SCRIPTS_V2 = "scripts_v2";
    exports.VERSION_0 = 0;
    exports.VERSION_0_5 = 0.5;
    exports.NETWORKS_MODULES = {
      Scripts: `${exports.MODULES_ACCOUNT}::scripts_v2`,
      Faucet: `${exports.COINS_ACCOUNT}::faucet`,
      CoinInfo: `${exports.COIN_INFO}`,
      CoinStore: `${exports.COIN_STORE}`
    };
    exports.TOKENS_MAPPING = {
      APTOS: "0x1::aptos_coin::AptosCoin",
      USDT: "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT",
      BTC: "0xae478ff7d83ed072dbc5e264250e67ef58f57c99d89b447efd8a0a2e8b2be76e::coin::T",
      WETH: "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::WETH",
      USDC: "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDC",
      amAPT: "0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::amapt_token::AmnisApt"
      // Amnis APT
    };
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/hex.js
var require_hex = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/hex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkAptosType = exports.toBuffer = exports.checkAddress = exports.shortAddress = exports.shortString = exports.addHexPrefix = void 0;
    var HEX_REGEXP = /^[-+]?[0-9A-Fa-f]+\.?[0-9A-Fa-f]*?$/;
    function addHexPrefix(hex) {
      return !hex.startsWith("0x") ? "0x" + hex : hex;
    }
    exports.addHexPrefix = addHexPrefix;
    function shortString(str, start = 4, end = 4) {
      const slen = Math.max(start, 1);
      const elen = Math.max(end, 1);
      return str.slice(0, slen + 2) + " ... " + str.slice(-elen);
    }
    exports.shortString = shortString;
    function shortAddress(address, start = 4, end = 4) {
      return shortString(addHexPrefix(address), start, end);
    }
    exports.shortAddress = shortAddress;
    function checkAddress(address, options = { leadingZero: true }) {
      if (typeof address !== "string") {
        return false;
      }
      let str = address;
      if (options.leadingZero) {
        if (!address.startsWith("0x")) {
          return false;
        } else {
          str = str.substring(2);
        }
      }
      return HEX_REGEXP.test(str);
    }
    exports.checkAddress = checkAddress;
    function toBuffer(v) {
      if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
          v = Buffer.from(v);
        } else if (typeof v === "string") {
          if (exports.isHexString(v)) {
            v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), "hex");
          } else {
            v = Buffer.from(v);
          }
        } else if (typeof v === "number") {
          v = exports.intToBuffer(v);
        } else if (v === null || v === void 0) {
          v = Buffer.allocUnsafe(0);
        } else if (v.toArray) {
          v = Buffer.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    }
    exports.toBuffer = toBuffer;
    function checkAptosType(type, options = { leadingZero: true }) {
      var _a, _b, _c, _d, _e;
      if (typeof type !== "string") {
        return false;
      }
      let _type = type.replace(/\s/g, "");
      const openBracketsCount = (_b = (_a = _type.match(/</g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      const closeBracketsCount = (_d = (_c = _type.match(/>/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
      if (openBracketsCount !== closeBracketsCount) {
        return false;
      }
      const genericsString = _type.match(/(<.+>)$/);
      const generics = (_e = genericsString === null || genericsString === void 0 ? void 0 : genericsString[1]) === null || _e === void 0 ? void 0 : _e.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
      if (generics) {
        _type = _type.slice(0, _type.indexOf("<"));
        const validGenerics = generics.every((g) => {
          var _a2, _b2, _c2, _d2;
          const gOpenCount = (_b2 = (_a2 = g.match(/</g)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0;
          const gCloseCount = (_d2 = (_c2 = g.match(/>/g)) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
          let t = g;
          if (gOpenCount !== gCloseCount) {
            t = t.slice(0, -(gCloseCount - gOpenCount));
          }
          return checkAptosType(t, options);
        });
        if (!validGenerics) {
          return false;
        }
      }
      const parts = _type.split("::");
      if (parts.length !== 3) {
        return false;
      }
      return checkAddress(parts[0], options) && parts[1].length >= 1 && parts[2].length >= 1;
    }
    exports.checkAptosType = checkAptosType;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/contracts.js
var require_contracts = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/contracts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCurve = exports.getScriptsFor = exports.checkAptosType = exports.extractAddressFromType = exports.withSlippage = exports.composeType = exports.is_sorted = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var buffer_1 = require_buffer();
    var decimal_js_1 = tslib_1.__importDefault(require_decimal());
    var constants_1 = require_constants();
    var hex_1 = require_hex();
    var EQUAL = 0;
    var LESS_THAN = 1;
    var GREATER_THAN = 2;
    function cmp(a, b) {
      if (a === b) {
        return EQUAL;
      } else if (a < b) {
        return LESS_THAN;
      } else {
        return GREATER_THAN;
      }
    }
    function compare(symbolX, symbolY) {
      const lenCmp = cmp(symbolX.length, symbolY.length);
      if (lenCmp != EQUAL) {
        return lenCmp;
      }
      let i = 0;
      while (i < symbolX.length && i < symbolY.length) {
        const elem_cmp = cmp(symbolX.charCodeAt(i), symbolY.charCodeAt(i));
        if (elem_cmp != EQUAL)
          return elem_cmp;
        i++;
      }
      return EQUAL;
    }
    function cmp_addresses(a, b) {
      if (a.startsWith("0x")) {
        a = a.substring(2);
      }
      if (a.length != 64) {
        while (a.length < 64) {
          a = "0" + a;
        }
      }
      if (b.startsWith("0x")) {
        b = b.substring(2);
      }
      if (b.length != 64) {
        while (b.length < 64) {
          b = "0" + b;
        }
      }
      const a_buf = buffer_1.Buffer.from(a, "hex");
      const b_buf = buffer_1.Buffer.from(b, "hex");
      for (let i = 0; i < 32; i++) {
        if (a_buf[i] < b_buf[i]) {
          return LESS_THAN;
        } else if (a_buf[i] > b_buf[i]) {
          return GREATER_THAN;
        }
      }
      return EQUAL;
    }
    function compare_types(coin_x, coin_y) {
      const coin_x_parts = coin_x.split("::").reverse();
      const coin_y_parts = coin_y.split("::").reverse();
      const coin_x_address = coin_x_parts.pop();
      const coin_y_address = coin_y_parts.pop();
      for (let i = 0; i < 2; i++) {
        const c = compare(coin_x_parts[i], coin_y_parts[i]);
        if (c != EQUAL) {
          return c;
        }
      }
      return cmp_addresses(coin_x_address, coin_y_address);
    }
    function is_sorted(coin_x, coin_y) {
      return compare_types(coin_x, coin_y) == LESS_THAN;
    }
    exports.is_sorted = is_sorted;
    function composeType(address, ...args) {
      const generics = Array.isArray(args[args.length - 1]) ? args.pop() : [];
      const chains = [address, ...args].filter(Boolean);
      let result = chains.join("::");
      if (generics && generics.length) {
        result += `<${generics.join(",")}>`;
      }
      return result;
    }
    exports.composeType = composeType;
    function withSlippage(slippage, value, isPlussed) {
      const multiply = new decimal_js_1.default(1e4);
      const slippagePercent = slippage.mul(multiply);
      return isPlussed ? value.plus(value.mul(slippagePercent).div(multiply)).toNumber() : value.minus(value.mul(slippagePercent).div(multiply)).toNumber();
    }
    exports.withSlippage = withSlippage;
    function extractAddressFromType(type) {
      return type.split("::")[0];
    }
    exports.extractAddressFromType = extractAddressFromType;
    function checkAptosType(type, options = { leadingZero: true }) {
      var _a, _b, _c, _d, _e;
      if (typeof type !== "string") {
        return false;
      }
      let _type = type.replace(/\s/g, "");
      const openBracketsCount = (_b = (_a = _type.match(/</g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      const closeBracketsCount = (_d = (_c = _type.match(/>/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
      if (openBracketsCount !== closeBracketsCount) {
        return false;
      }
      const genericsString = _type.match(/(<.+>)$/);
      const generics = (_e = genericsString === null || genericsString === void 0 ? void 0 : genericsString[1]) === null || _e === void 0 ? void 0 : _e.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
      if (generics) {
        _type = _type.slice(0, _type.indexOf("<"));
        const validGenerics = generics.every((g) => {
          var _a2, _b2, _c2, _d2;
          const gOpenCount = (_b2 = (_a2 = g.match(/</g)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0;
          const gCloseCount = (_d2 = (_c2 = g.match(/>/g)) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
          let t = g;
          if (gOpenCount !== gCloseCount) {
            t = t.slice(0, -(gCloseCount - gOpenCount));
          }
          return checkAptosType(t, options);
        });
        if (!validGenerics) {
          return false;
        }
      }
      const parts = _type.split("::");
      if (parts.length !== 3) {
        return false;
      }
      return (0, hex_1.checkAddress)(parts[0], options) && parts[1].length >= 1 && parts[2].length >= 1;
    }
    exports.checkAptosType = checkAptosType;
    function getScriptsFor(version) {
      if (version === constants_1.VERSION_0_5)
        return constants_1.SCRIPTS_V1;
      switch (version) {
        case constants_1.VERSION_0:
          return constants_1.SCRIPTS_V2;
        case constants_1.VERSION_0_5:
          return constants_1.SCRIPTS_V1;
      }
      throw new Error("Unknown contract version requested");
    }
    exports.getScriptsFor = getScriptsFor;
    function getCurve(type, curves, contract) {
      if (contract === constants_1.VERSION_0_5) {
        if (type === "stable") {
          return curves.stableV05;
        }
        return curves.uncorrelatedV05;
      }
      if (type === "stable") {
        return curves.stable;
      }
      return curves.uncorrelated;
    }
    exports.getCurve = getCurve;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/numbers.js
var require_numbers = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/numbers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertDecimalToFixedString = exports.convertValueToDecimal = exports.decimalsMultiplier = exports.d = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var decimal_js_1 = tslib_1.__importDefault(require_decimal());
    function d(value) {
      if (decimal_js_1.default.isDecimal(value)) {
        return value;
      }
      return new decimal_js_1.default(value === void 0 ? 0 : value);
    }
    exports.d = d;
    function decimalsMultiplier(decimals) {
      return d(10).pow(d(decimals).abs());
    }
    exports.decimalsMultiplier = decimalsMultiplier;
    function convertValueToDecimal(value, decimals = 0) {
      const mul = decimalsMultiplier(decimals);
      return d(value).mul(mul);
    }
    exports.convertValueToDecimal = convertValueToDecimal;
    function convertDecimalToFixedString(value, decimals) {
      const mul = decimalsMultiplier(decimals);
      return value.div(mul).toFixed(decimals);
    }
    exports.convertDecimalToFixedString = convertDecimalToFixedString;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/liquidity.js
var require_liquidity = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/liquidity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPoolStr = exports.getOptimalLiquidityAmount = exports.calcOutputBurnLiquidity = exports.calcReceivedLP = void 0;
    var decimal_js_1 = require_decimal();
    var numbers_1 = require_numbers();
    var contracts_1 = require_contracts();
    var MINIMAL_LIQUIDITY = 1e4;
    function calcReceivedLP({ x, y, xReserve, yReserve, lpSupply }) {
      const dxReserve = (0, numbers_1.d)(xReserve);
      const dyReserve = (0, numbers_1.d)(yReserve);
      const dx = (0, numbers_1.d)(x);
      const dy = (0, numbers_1.d)(y);
      const dSupply = (0, numbers_1.d)(lpSupply);
      if (dxReserve.eq(0) || dyReserve.eq(0)) {
        return decimal_js_1.Decimal.sqrt(dx.mul(dy)).minus(MINIMAL_LIQUIDITY).toFixed(0);
      }
      const xLp = dx.mul(dSupply).div(dxReserve);
      const yLp = dy.mul(dSupply).div(dyReserve);
      return decimal_js_1.Decimal.min(xLp, yLp).toFixed(0);
    }
    exports.calcReceivedLP = calcReceivedLP;
    function calcOutputBurnLiquidity({ xReserve, yReserve, lpSupply, toBurn }) {
      const xReturn = toBurn.mul(xReserve).div(lpSupply);
      const yReturn = toBurn.mul(yReserve).div(lpSupply);
      if (xReturn.eq(0) || yReturn.eq(0)) {
        return void 0;
      }
      return {
        x: xReturn,
        y: yReturn
      };
    }
    exports.calcOutputBurnLiquidity = calcOutputBurnLiquidity;
    function getOptimalLiquidityAmount(xDesired, xReserve, yReserve) {
      return xDesired.mul(yReserve).div(xReserve);
    }
    exports.getOptimalLiquidityAmount = getOptimalLiquidityAmount;
    function getPoolStr(coinX, coinY, curve, modulesLiquidityPool) {
      const [sortedX, sortedY] = (0, contracts_1.is_sorted)(coinX, coinY) ? [coinX, coinY] : [coinY, coinX];
      return (0, contracts_1.composeType)(modulesLiquidityPool, [sortedX, sortedY, curve]);
    }
    exports.getPoolStr = getPoolStr;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/index.js
var require_utils2 = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertDecimalToFixedString = exports.convertValueToDecimal = exports.decimalsMultiplier = exports.d = exports.getPoolStr = exports.getOptimalLiquidityAmount = exports.calcOutputBurnLiquidity = exports.calcReceivedLP = exports.extractAddressFromType = exports.composeType = exports.withSlippage = exports.is_sorted = exports.getCoinsInWithFeesStable = exports.getCoinsOutWithFeesStable = exports.getCoinOutWithFees = exports.getCoinInWithFees = void 0;
    var swap_math_1 = require_swap_math();
    Object.defineProperty(exports, "getCoinInWithFees", { enumerable: true, get: function() {
      return swap_math_1.getCoinInWithFees;
    } });
    Object.defineProperty(exports, "getCoinOutWithFees", { enumerable: true, get: function() {
      return swap_math_1.getCoinOutWithFees;
    } });
    Object.defineProperty(exports, "getCoinsOutWithFeesStable", { enumerable: true, get: function() {
      return swap_math_1.getCoinsOutWithFeesStable;
    } });
    Object.defineProperty(exports, "getCoinsInWithFeesStable", { enumerable: true, get: function() {
      return swap_math_1.getCoinsInWithFeesStable;
    } });
    var contracts_1 = require_contracts();
    Object.defineProperty(exports, "is_sorted", { enumerable: true, get: function() {
      return contracts_1.is_sorted;
    } });
    Object.defineProperty(exports, "withSlippage", { enumerable: true, get: function() {
      return contracts_1.withSlippage;
    } });
    Object.defineProperty(exports, "composeType", { enumerable: true, get: function() {
      return contracts_1.composeType;
    } });
    Object.defineProperty(exports, "extractAddressFromType", { enumerable: true, get: function() {
      return contracts_1.extractAddressFromType;
    } });
    var liquidity_1 = require_liquidity();
    Object.defineProperty(exports, "calcReceivedLP", { enumerable: true, get: function() {
      return liquidity_1.calcReceivedLP;
    } });
    Object.defineProperty(exports, "calcOutputBurnLiquidity", { enumerable: true, get: function() {
      return liquidity_1.calcOutputBurnLiquidity;
    } });
    Object.defineProperty(exports, "getOptimalLiquidityAmount", { enumerable: true, get: function() {
      return liquidity_1.getOptimalLiquidityAmount;
    } });
    Object.defineProperty(exports, "getPoolStr", { enumerable: true, get: function() {
      return liquidity_1.getPoolStr;
    } });
    var numbers_1 = require_numbers();
    Object.defineProperty(exports, "d", { enumerable: true, get: function() {
      return numbers_1.d;
    } });
    Object.defineProperty(exports, "decimalsMultiplier", { enumerable: true, get: function() {
      return numbers_1.decimalsMultiplier;
    } });
    Object.defineProperty(exports, "convertValueToDecimal", { enumerable: true, get: function() {
      return numbers_1.convertValueToDecimal;
    } });
    Object.defineProperty(exports, "convertDecimalToFixedString", { enumerable: true, get: function() {
      return numbers_1.convertDecimalToFixedString;
    } });
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/modules/SwapModule.js
var require_SwapModule = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/modules/SwapModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SwapModule = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var utils_1 = require_utils2();
    var constants_1 = require_constants();
    var contracts_1 = require_contracts();
    var SwapModule = class {
      constructor(sdk) {
        this._sdk = sdk;
      }
      get sdk() {
        return this._sdk;
      }
      getAmountIn(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return yield this.calculateRates(Object.assign(Object.assign({}, params), { interactiveToken: "from" }));
        });
      }
      getAmountOut(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          return yield this.calculateRates(Object.assign(Object.assign({}, params), { interactiveToken: "to" }));
        });
      }
      calculateRates(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { modules } = this.sdk.networkOptions;
          let fromCoinInfo;
          try {
            fromCoinInfo = yield this.sdk.Resources.fetchAccountResource((0, utils_1.extractAddressFromType)(params.fromToken), (0, utils_1.composeType)(modules.CoinInfo, [params.fromToken]));
          } catch (e) {
            console.log(e);
          }
          let toCoinInfo;
          try {
            toCoinInfo = yield this.sdk.Resources.fetchAccountResource((0, utils_1.extractAddressFromType)(params.toToken), (0, utils_1.composeType)(modules.CoinInfo, [params.toToken]));
          } catch (e) {
            console.log(e);
          }
          if (!fromCoinInfo) {
            throw new Error("From Coin not exists");
          }
          if (!toCoinInfo) {
            throw new Error("To Coin not exists");
          }
          const { liquidityPoolType, liquidityPoolResource } = yield this.getLiquidityPoolResource(params);
          if (!liquidityPoolResource) {
            throw new Error(`LiquidityPool (${liquidityPoolType}) not found`);
          }
          const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
          const [sortedFromCoinInfo, sortedToCoinInfo] = isSorted ? [fromCoinInfo, toCoinInfo] : [toCoinInfo, fromCoinInfo];
          const fromReserve = isSorted ? (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value) : (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value);
          const toReserve = isSorted ? (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value) : (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value);
          let fee = (0, utils_1.d)(liquidityPoolResource.data.fee);
          if (params.additionalFee) {
            fee = fee.plus(params.additionalFee);
          }
          const coinFromDecimals = +sortedFromCoinInfo.data.decimals;
          const coinToDecimals = +sortedToCoinInfo.data.decimals;
          const amount = (0, utils_1.d)(params.amount);
          if (amount.comparedTo(0) === 0) {
            throw new Error(`Amount equals zero or undefined`);
          }
          if (params.interactiveToken === "to" && toReserve.lessThan(amount)) {
            throw new Error(`Insufficient funds in Liquidity Pool`);
          }
          let rate;
          if (params.curveType === "uncorrelated") {
            rate = params.interactiveToken === "from" ? (0, utils_1.getCoinOutWithFees)(amount, fromReserve, toReserve, fee) : (0, utils_1.getCoinInWithFees)(amount, toReserve, fromReserve, fee);
          } else {
            rate = params.interactiveToken === "from" ? (0, utils_1.getCoinsOutWithFeesStable)(amount, fromReserve, toReserve, (0, utils_1.d)(Math.pow(10, coinFromDecimals)), (0, utils_1.d)(Math.pow(10, coinToDecimals)), fee) : (0, utils_1.getCoinsInWithFeesStable)(amount, toReserve, fromReserve, (0, utils_1.d)(Math.pow(10, coinToDecimals)), (0, utils_1.d)(Math.pow(10, coinFromDecimals)), fee);
          }
          return rate.toFixed(0);
        });
      }
      createSwapTransactionPayload(params) {
        const curves = this.sdk.curves;
        const slippage = (0, utils_1.d)(params.slippage);
        if (slippage.gte(1) || slippage.lte(0)) {
          throw new Error(`Invalid slippage (${params.slippage}) value, it should be from 0 to 1`);
        }
        const { moduleAccountV05, moduleAccount } = this.sdk.networkOptions;
        const { version = constants_1.VERSION_0 } = params;
        const isUnchecked = version === constants_1.VERSION_0 && params.curveType === "stable" && params.stableSwapType === "normal";
        const scriptsVersion = (0, contracts_1.getScriptsFor)(version);
        const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
        const functionName = (0, utils_1.composeType)(moduleAcc, scriptsVersion, isUnchecked ? "swap_unchecked" : params.interactiveToken === "from" ? "swap" : "swap_into");
        const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
        const typeArguments = [params.fromToken, params.toToken, curve];
        const fromAmount = params.interactiveToken === "from" ? params.fromAmount : params.curveType === "stable" ? params.fromAmount : (0, utils_1.withSlippage)(slippage, (0, utils_1.d)(params.fromAmount), true).toFixed(0);
        const toAmount = params.interactiveToken === "to" ? params.toAmount : params.curveType === "stable" ? (0, utils_1.d)(params.toAmount).minus(1).toNumber().toString() : (0, utils_1.withSlippage)(slippage, (0, utils_1.d)(params.toAmount), false).toFixed(0);
        const args = [fromAmount.toString(), toAmount.toString()];
        return {
          type: "entry_function_payload",
          function: functionName,
          type_arguments: typeArguments,
          arguments: args
        };
      }
      getLiquidityPoolResource(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { resourceAccount, moduleAccount, resourceAccountV05, moduleAccountV05 } = this.sdk.networkOptions;
          const curves = this.sdk.curves;
          const version = params.version;
          const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
          const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
          const resourceAcc = version === constants_1.VERSION_0_5 ? resourceAccountV05 : resourceAccount;
          const modulesLiquidityPool = (0, utils_1.composeType)(moduleAcc, "liquidity_pool", "LiquidityPool");
          function getPoolStr(coinX, coinY, curve2) {
            const [sortedX, sortedY] = (0, utils_1.is_sorted)(coinX, coinY) ? [coinX, coinY] : [coinY, coinX];
            return (0, utils_1.composeType)(modulesLiquidityPool, [sortedX, sortedY, curve2]);
          }
          const liquidityPoolType = getPoolStr(params.fromToken, params.toToken, curve);
          let liquidityPoolResource;
          try {
            liquidityPoolResource = yield this.sdk.Resources.fetchAccountResource(resourceAcc, liquidityPoolType);
          } catch (e) {
            console.log(e);
          }
          return { liquidityPoolType, liquidityPoolResource };
        });
      }
    };
    exports.SwapModule = SwapModule;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/is.js
var require_is = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/is.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isAxiosError = void 0;
    function isAxiosError(e) {
      if (e.isAxiosError) {
        return e;
      }
      return e;
    }
    exports.isAxiosError = isAxiosError;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/modules/ResourcesModule.js
var require_ResourcesModule = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/modules/ResourcesModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ResourcesModule = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var is_1 = require_is();
    var ResourcesModule = class {
      constructor(sdk) {
        this._sdk = sdk;
      }
      get sdk() {
        return this._sdk;
      }
      fetchAccountResource(accountAddress, resourceType) {
        var _a;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          try {
            const response = yield this._sdk.client.getAccountResource(accountAddress, resourceType);
            return response;
          } catch (e) {
            if ((0, is_1.isAxiosError)(e)) {
              if (((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === 404) {
                return void 0;
              }
            }
            throw e;
          }
        });
      }
    };
    exports.ResourcesModule = ResourcesModule;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/modules/LiquidityModule.js
var require_LiquidityModule = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/modules/LiquidityModule.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LiquidityModule = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var utils_1 = require_utils2();
    var constants_1 = require_constants();
    var contracts_1 = require_contracts();
    var LiquidityModule = class {
      constructor(sdk) {
        this._sdk = sdk;
      }
      get sdk() {
        return this._sdk;
      }
      checkPoolExistence(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { moduleAccount, resourceAccount, moduleAccountV05, resourceAccountV05 } = this.sdk.networkOptions;
          const curves = this.sdk.curves;
          const { version = constants_1.VERSION_0 } = params;
          const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
          const resourceAcc = version === constants_1.VERSION_0_5 ? resourceAccountV05 : resourceAccount;
          const modulesLiquidityPool = (0, utils_1.composeType)(moduleAcc, "liquidity_pool", "LiquidityPool");
          const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
          const liquidityPoolType = (0, utils_1.getPoolStr)(params.fromToken, params.toToken, curve, modulesLiquidityPool);
          try {
            const liquidityPoolResource = yield this.sdk.Resources.fetchAccountResource(resourceAcc, liquidityPoolType);
            return Boolean(liquidityPoolResource === null || liquidityPoolResource === void 0 ? void 0 : liquidityPoolResource.type);
          } catch (_e) {
            return false;
          }
        });
      }
      getLiquidityPoolResource(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { moduleAccount, resourceAccount, moduleAccountV05, resourceAccountV05 } = this.sdk.networkOptions;
          const curves = this.sdk.curves;
          const { version = constants_1.VERSION_0 } = params;
          const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
          const resourceAcc = version === constants_1.VERSION_0_5 ? resourceAccountV05 : resourceAccount;
          const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
          const modulesLiquidityPool = (0, utils_1.composeType)(moduleAcc, "liquidity_pool", "LiquidityPool");
          const liquidityPoolType = (0, utils_1.getPoolStr)(params.fromToken, params.toToken, curve, modulesLiquidityPool);
          let liquidityPoolResource;
          try {
            liquidityPoolResource = yield this.sdk.Resources.fetchAccountResource(resourceAcc, liquidityPoolType);
          } catch (e) {
            console.log(e);
          }
          return { liquidityPoolResource };
        });
      }
      getLiquiditySupplyResource(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const curves = this.sdk.curves;
          const { modules, resourceAccount, resourceAccountV05 } = this.sdk.networkOptions;
          const { version = constants_1.VERSION_0 } = params;
          const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
          const resourceAcc = version === constants_1.VERSION_0_5 ? resourceAccountV05 : resourceAccount;
          function getPoolLpStr(coinX, coinY, curve2) {
            const [sortedX, sortedY] = (0, utils_1.is_sorted)(coinX, coinY) ? [coinX, coinY] : [coinY, coinX];
            return (0, utils_1.composeType)(resourceAcc, "lp_coin", "LP", [sortedX, sortedY, curve2]);
          }
          const lpString = getPoolLpStr(params.fromToken, params.toToken, curve);
          let liquidityPoolResource;
          try {
            liquidityPoolResource = yield this.sdk.Resources.fetchAccountResource(resourceAcc, (0, utils_1.composeType)(modules.CoinInfo, [lpString]));
          } catch (e) {
            console.log(e);
          }
          return { liquidityPoolResource };
        });
      }
      calculateSupply(params) {
        const value = (0, utils_1.calcReceivedLP)({
          x: (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), params.isSorted ? (0, utils_1.d)(params.fromAmount) : (0, utils_1.d)(params.toAmount), false),
          y: (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), params.isSorted ? (0, utils_1.d)(params.toAmount) : (0, utils_1.d)(params.fromAmount), false),
          xReserve: params.isSorted ? (0, utils_1.d)(params.fromReserve) : (0, utils_1.d)(params.toReserve),
          yReserve: params.isSorted ? (0, utils_1.d)(params.toReserve) : (0, utils_1.d)(params.fromReserve),
          lpSupply: params.lpSupply
        });
        return value;
      }
      getAmountIn(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { rate } = yield this.calculateRateAndMinReceivedLP(Object.assign(Object.assign({}, params), { interactiveToken: "from" }));
          return rate;
        });
      }
      getAmountOut(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { rate } = yield this.calculateRateAndMinReceivedLP(Object.assign(Object.assign({}, params), { interactiveToken: "to" }));
          return rate;
        });
      }
      calculateRateAndMinReceivedLP(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { modules } = this.sdk.networkOptions;
          let fromCoinInfo;
          try {
            fromCoinInfo = yield this.sdk.Resources.fetchAccountResource((0, utils_1.extractAddressFromType)(params.fromToken), (0, utils_1.composeType)(modules.CoinInfo, [params.fromToken]));
          } catch (e) {
            console.log(e);
          }
          let toCoinInfo;
          try {
            toCoinInfo = yield this.sdk.Resources.fetchAccountResource((0, utils_1.extractAddressFromType)(params.toToken), (0, utils_1.composeType)(modules.CoinInfo, [params.toToken]));
          } catch (e) {
            console.log(e);
          }
          if (!fromCoinInfo) {
            throw new Error("From Coin not exists");
          }
          if (!toCoinInfo) {
            throw new Error("To Coin not exists");
          }
          const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
          const { liquidityPoolResource } = yield this.getLiquidityPoolResource(params);
          if (!liquidityPoolResource) {
            throw new Error(`LiquidityPool not existed`);
          }
          const fromReserve = isSorted ? (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value) : (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value);
          const toReserve = isSorted ? (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value) : (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value);
          const optimalAmount = params.interactiveToken === "from" ? (0, utils_1.getOptimalLiquidityAmount)((0, utils_1.d)(params.amount), fromReserve, toReserve) : (0, utils_1.getOptimalLiquidityAmount)((0, utils_1.d)(params.amount), toReserve, fromReserve);
          const { liquidityPoolResource: lpSupplyResponse } = yield this.getLiquiditySupplyResource(params);
          if (!lpSupplyResponse) {
            throw new Error(`lpSupplyResponse not existed`);
          }
          let lpSupply;
          try {
            lpSupply = lpSupplyResponse.data.supply.vec[0].integer.vec[0].value;
          } catch (e) {
            console.log(e);
          }
          const receiveLp = this.calculateSupply({
            slippage: params.slippage,
            fromReserve,
            toReserve,
            fromAmount: params.interactiveToken === "from" ? params.amount : optimalAmount,
            toAmount: params.interactiveToken === "to" ? params.amount : optimalAmount,
            lpSupply,
            isSorted
          });
          return { rate: optimalAmount.toFixed(0), receiveLp };
        });
      }
      createAddLiquidityPayload(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const slippage = (0, utils_1.d)(params.slippage);
          if (slippage.gte(1) || slippage.lte(0)) {
            throw new Error(`Invalid slippage (${params.slippage}) value, it should be from 0 to 1`);
          }
          const isPoolExisted = yield this.checkPoolExistence(params);
          const { version = constants_1.VERSION_0 } = params;
          const { moduleAccountV05, moduleAccount } = this.sdk.networkOptions;
          const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
          const curves = this.sdk.curves;
          const scriptsVersion = (0, contracts_1.getScriptsFor)(version);
          const functionName = (0, utils_1.composeType)(moduleAcc, scriptsVersion, isPoolExisted ? "add_liquidity" : "register_pool_and_add_liquidity");
          const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
          const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
          const typeArguments = isSorted ? [params.fromToken, params.toToken, curve] : [params.toToken, params.fromToken, curve];
          const fromAmountWithSlippage = (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), (0, utils_1.d)(params.fromAmount), false).toFixed(0);
          const toAmountWithSlippage = (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), (0, utils_1.d)(params.toAmount), false).toFixed(0);
          const args = isSorted ? [
            params.fromAmount.toString(),
            fromAmountWithSlippage,
            params.toAmount.toString(),
            toAmountWithSlippage
          ] : [
            params.toAmount.toString(),
            toAmountWithSlippage,
            params.fromAmount.toString(),
            fromAmountWithSlippage
          ];
          return {
            type: "entry_function_payload",
            function: functionName,
            type_arguments: typeArguments,
            arguments: args
          };
        });
      }
      createBurnLiquidityPayload(params) {
        var _a, _b;
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const slippage = (0, utils_1.d)(params.slippage);
          if (slippage.gte(1) || slippage.lte(0)) {
            throw new Error(`Invalid slippage (${params.slippage}) value, it should be from 0 to 1`);
          }
          const { version = constants_1.VERSION_0 } = params;
          const curves = this.sdk.curves;
          const curve = (0, contracts_1.getCurve)(params.curveType, curves, version);
          const { moduleAccountV05, moduleAccount } = this.sdk.networkOptions;
          const moduleAcc = version === constants_1.VERSION_0_5 ? moduleAccountV05 : moduleAccount;
          const output = yield this.calculateOutputBurn(params);
          const xOutput = (_a = output === null || output === void 0 ? void 0 : output.x) !== null && _a !== void 0 ? _a : "0";
          const yOutput = (_b = output === null || output === void 0 ? void 0 : output.y) !== null && _b !== void 0 ? _b : "0";
          const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
          const args = isSorted ? [params.burnAmount.toString(), xOutput, yOutput] : [params.burnAmount.toString(), yOutput, xOutput];
          const scriptsVersion = (0, contracts_1.getScriptsFor)(version);
          const functionName = (0, utils_1.composeType)(moduleAcc, scriptsVersion, "remove_liquidity");
          const typeArguments = isSorted ? [params.fromToken, params.toToken, curve] : [params.toToken, params.fromToken, curve];
          return {
            type: "entry_function_payload",
            function: functionName,
            type_arguments: typeArguments,
            arguments: args
          };
        });
      }
      calculateOutputBurn(params) {
        return tslib_1.__awaiter(this, void 0, void 0, function* () {
          const { liquidityPoolResource } = yield this.getLiquidityPoolResource(params);
          const { liquidityPoolResource: lpSupplyResponse } = yield this.getLiquiditySupplyResource(params);
          if (!lpSupplyResponse) {
            throw new Error(`lpSupplyResponse not existed`);
          }
          let lpSupply;
          try {
            lpSupply = lpSupplyResponse.data.supply.vec[0].integer.vec[0].value;
          } catch (e) {
            console.log(e);
          }
          if (!liquidityPoolResource) {
            throw new Error(`LiquidityPool not existed`);
          }
          const isSorted = (0, utils_1.is_sorted)(params.fromToken, params.toToken);
          const fromReserve = isSorted ? (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value) : (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value);
          const toReserve = isSorted ? (0, utils_1.d)(liquidityPoolResource.data.coin_y_reserve.value) : (0, utils_1.d)(liquidityPoolResource.data.coin_x_reserve.value);
          const outputVal = (0, utils_1.calcOutputBurnLiquidity)({
            xReserve: fromReserve,
            yReserve: toReserve,
            lpSupply: (0, utils_1.d)(lpSupply),
            toBurn: (0, utils_1.d)(params.burnAmount)
          });
          if (!outputVal) {
            return;
          }
          return {
            x: (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), outputVal["x"], false).toFixed(0),
            y: (0, utils_1.withSlippage)((0, utils_1.d)(params.slippage), outputVal["y"], false).toFixed(0),
            withoutSlippage: {
              x: outputVal["x"].toFixed(0),
              y: outputVal["y"].toFixed(0)
            }
          };
        });
      }
    };
    exports.LiquidityModule = LiquidityModule;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/sdk.js
var require_sdk = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/sdk.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SDK = void 0;
    var aptos_1 = require_dist();
    var SwapModule_1 = require_SwapModule();
    var ResourcesModule_1 = require_ResourcesModule();
    var LiquidityModule_1 = require_LiquidityModule();
    var constants_1 = require_constants();
    var initialNetworkOptions = {
      nativeToken: "0x1::aptos_coin::AptosCoin",
      modules: {
        Scripts: constants_1.NETWORKS_MODULES.Scripts,
        CoinInfo: constants_1.NETWORKS_MODULES.CoinInfo,
        CoinStore: constants_1.NETWORKS_MODULES.CoinStore
      },
      resourceAccount: constants_1.RESOURCES_ACCOUNT,
      moduleAccount: constants_1.MODULES_ACCOUNT,
      moduleAccountV05: constants_1.MODULES_V05_ACCOUNT,
      resourceAccountV05: constants_1.RESOURCES_V05_ACCOUNT
    };
    var SDK = class {
      constructor(options) {
        var _a, _b, _c, _d, _e, _f;
        this._networkOptions = initialNetworkOptions;
        if (options.networkOptions) {
          if ((_a = options.networkOptions) === null || _a === void 0 ? void 0 : _a.nativeToken) {
            this._networkOptions.nativeToken = options.networkOptions.nativeToken;
          }
          if ((_b = options.networkOptions) === null || _b === void 0 ? void 0 : _b.modules) {
            this._networkOptions.modules = options.networkOptions.modules;
          }
          if ((_c = options.networkOptions) === null || _c === void 0 ? void 0 : _c.moduleAccount) {
            this._networkOptions.moduleAccount = options.networkOptions.moduleAccount;
          }
          if ((_d = options.networkOptions) === null || _d === void 0 ? void 0 : _d.resourceAccount) {
            this._networkOptions.resourceAccount = options.networkOptions.resourceAccount;
          }
          if ((_e = options.networkOptions) === null || _e === void 0 ? void 0 : _e.moduleAccountV05) {
            this._networkOptions.moduleAccountV05 = options.networkOptions.moduleAccountV05;
          }
          if ((_f = options.networkOptions) === null || _f === void 0 ? void 0 : _f.resourceAccountV05) {
            this._networkOptions.resourceAccountV05 = options.networkOptions.resourceAccountV05;
          }
        }
        this._client = new aptos_1.AptosClient(options.nodeUrl, options.nodeOptions);
        this._swap = new SwapModule_1.SwapModule(this);
        this._resources = new ResourcesModule_1.ResourcesModule(this);
        this._liquidity = new LiquidityModule_1.LiquidityModule(this);
        this._curves = {
          uncorrelated: `${this._networkOptions.moduleAccount}::curves::Uncorrelated`,
          stable: `${this._networkOptions.moduleAccount}::curves::Stable`,
          uncorrelatedV05: `${this._networkOptions.moduleAccountV05}::curves::Uncorrelated`,
          stableV05: `${this._networkOptions.moduleAccountV05}::curves::Stable`
        };
      }
      get Swap() {
        return this._swap;
      }
      get Resources() {
        return this._resources;
      }
      get Liquidity() {
        return this._liquidity;
      }
      get client() {
        return this._client;
      }
      get networkOptions() {
        return this._networkOptions;
      }
      get curves() {
        return this._curves;
      }
    };
    exports.SDK = SDK;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/main.js
var require_main = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/main.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertDecimalToFixedString = exports.convertValueToDecimal = exports.getCoinsInWithFeesStable = exports.getCoinsOutWithFeesStable = exports.getCoinOutWithFees = exports.getCoinInWithFees = exports.ResourcesModule = exports.LiquidityModule = exports.SwapModule = exports.SDK = void 0;
    var sdk_1 = require_sdk();
    Object.defineProperty(exports, "SDK", { enumerable: true, get: function() {
      return sdk_1.SDK;
    } });
    var SwapModule_1 = require_SwapModule();
    Object.defineProperty(exports, "SwapModule", { enumerable: true, get: function() {
      return SwapModule_1.SwapModule;
    } });
    var ResourcesModule_1 = require_ResourcesModule();
    Object.defineProperty(exports, "ResourcesModule", { enumerable: true, get: function() {
      return ResourcesModule_1.ResourcesModule;
    } });
    var LiquidityModule_1 = require_LiquidityModule();
    Object.defineProperty(exports, "LiquidityModule", { enumerable: true, get: function() {
      return LiquidityModule_1.LiquidityModule;
    } });
    var utils_1 = require_utils2();
    Object.defineProperty(exports, "getCoinsInWithFeesStable", { enumerable: true, get: function() {
      return utils_1.getCoinsInWithFeesStable;
    } });
    Object.defineProperty(exports, "getCoinsOutWithFeesStable", { enumerable: true, get: function() {
      return utils_1.getCoinsOutWithFeesStable;
    } });
    Object.defineProperty(exports, "getCoinOutWithFees", { enumerable: true, get: function() {
      return utils_1.getCoinOutWithFees;
    } });
    Object.defineProperty(exports, "getCoinInWithFees", { enumerable: true, get: function() {
      return utils_1.getCoinInWithFees;
    } });
    Object.defineProperty(exports, "convertValueToDecimal", { enumerable: true, get: function() {
      return utils_1.convertValueToDecimal;
    } });
    Object.defineProperty(exports, "convertDecimalToFixedString", { enumerable: true, get: function() {
      return utils_1.convertDecimalToFixedString;
    } });
    exports.default = sdk_1.SDK;
  }
});
export default require_main();
/*! Bundled license information:

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

decimal.js/decimal.js:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
//# sourceMappingURL=@pontem_liquidswap-sdk.js.map
