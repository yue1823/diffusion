import {
  Slot
} from "./chunk-UIDY2BM6.js";
import {
  require_buffer,
  require_nacl_fast
} from "./chunk-4MO5LSUJ.js";
import {
  A8 as A,
  AxiosError,
  B,
  C2 as C,
  D2 as D,
  a3 as a,
  aptosClient,
  axios_default,
  d,
  d7 as d2,
  e,
  f4 as f,
  f5 as f2,
  fn2 as fn,
  h5 as h,
  i,
  isAxiosError,
  j2 as j,
  jwtDecode,
  l4 as l,
  l8 as l2,
  m5 as m,
  m6 as m2,
  mn,
  n,
  n5 as n2,
  n6 as n3,
  n8 as n4,
  o10 as o2,
  o11 as o3,
  o9 as o,
  p3 as p,
  r4 as r,
  r5 as r2,
  sha3_256,
  t,
  t10 as t4,
  t3 as t2,
  t6 as t3,
  u4 as u,
  u5 as u2,
  vn,
  x3 as x,
  y6 as y
} from "./chunk-PWZIAAD4.js";
import {
  require_jsx_runtime
} from "./chunk-7BUGFXDR.js";
import {
  require_react
} from "./chunk-CMM6OKGN.js";
import {
  __commonJS,
  __publicField,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@aptos-labs/wallet-adapter-core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn3, context, once) {
      this.fn = fn3;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn3, context, once) {
      if (typeof fn3 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn3, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter3() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter3.prototype.eventNames = function eventNames() {
      var names = [], events, name;
      if (this._eventsCount === 0) return names;
      for (name in events = this._events) {
        if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names.concat(Object.getOwnPropertySymbols(events));
      }
      return names;
    };
    EventEmitter3.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i4 = 0, l3 = handlers.length, ee2 = new Array(l3); i4 < l3; i4++) {
        ee2[i4] = handlers[i4].fn;
      }
      return ee2;
    };
    EventEmitter3.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2) return 0;
      if (listeners2.fn) return 1;
      return listeners2.length;
    };
    EventEmitter3.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners2 = this._events[evt], len = arguments.length, args, i4;
      if (listeners2.fn) {
        if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a2), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a2, a3), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a2, a3, a4), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a2, a3, a4, a5), true;
        }
        for (i4 = 1, args = new Array(len - 1); i4 < len; i4++) {
          args[i4 - 1] = arguments[i4];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length = listeners2.length, j2;
        for (i4 = 0; i4 < length; i4++) {
          if (listeners2[i4].once) this.removeListener(event, listeners2[i4].fn, void 0, true);
          switch (len) {
            case 1:
              listeners2[i4].fn.call(listeners2[i4].context);
              break;
            case 2:
              listeners2[i4].fn.call(listeners2[i4].context, a1);
              break;
            case 3:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a2);
              break;
            case 4:
              listeners2[i4].fn.call(listeners2[i4].context, a1, a2, a3);
              break;
            default:
              if (!args) for (j2 = 1, args = new Array(len - 1); j2 < len; j2++) {
                args[j2 - 1] = arguments[j2];
              }
              listeners2[i4].fn.apply(listeners2[i4].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter3.prototype.on = function on3(event, fn3, context) {
      return addListener(this, event, fn3, context, false);
    };
    EventEmitter3.prototype.once = function once(event, fn3, context) {
      return addListener(this, event, fn3, context, true);
    };
    EventEmitter3.prototype.removeListener = function removeListener(event, fn3, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn3) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn3 && (!once || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i4 = 0, events = [], length = listeners2.length; i4 < length; i4++) {
          if (listeners2[i4].fn !== fn3 || once && !listeners2[i4].once || context && listeners2[i4].context !== context) {
            events.push(listeners2[i4]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter3.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter3.prototype.off = EventEmitter3.prototype.removeListener;
    EventEmitter3.prototype.addListener = EventEmitter3.prototype.on;
    EventEmitter3.prefixed = prefix;
    EventEmitter3.EventEmitter = EventEmitter3;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter3;
    }
  }
});

// node_modules/ed2curve/ed2curve.js
var require_ed2curve = __commonJS({
  "node_modules/ed2curve/ed2curve.js"(exports, module) {
    (function(root, f5) {
      "use strict";
      if (typeof module !== "undefined" && module.exports) module.exports = f5(require_nacl_fast());
      else root.ed2curve = f5(root.nacl);
    })(exports, function(nacl5) {
      "use strict";
      if (!nacl5) throw new Error("tweetnacl not loaded");
      var gf = function(init) {
        var i4, r7 = new Float64Array(16);
        if (init) for (i4 = 0; i4 < init.length; i4++) r7[i4] = init[i4];
        return r7;
      };
      var gf0 = gf(), gf1 = gf([1]), D3 = gf([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), I2 = gf([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
      function car25519(o12) {
        var c;
        var i4;
        for (i4 = 0; i4 < 16; i4++) {
          o12[i4] += 65536;
          c = Math.floor(o12[i4] / 65536);
          o12[(i4 + 1) * (i4 < 15 ? 1 : 0)] += c - 1 + 37 * (c - 1) * (i4 === 15 ? 1 : 0);
          o12[i4] -= c * 65536;
        }
      }
      function sel25519(p4, q2, b2) {
        var t14, c = ~(b2 - 1);
        for (var i4 = 0; i4 < 16; i4++) {
          t14 = c & (p4[i4] ^ q2[i4]);
          p4[i4] ^= t14;
          q2[i4] ^= t14;
        }
      }
      function unpack25519(o12, n14) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o12[i4] = n14[2 * i4] + (n14[2 * i4 + 1] << 8);
        o12[15] &= 32767;
      }
      function A5(o12, a2, b2) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o12[i4] = a2[i4] + b2[i4] | 0;
      }
      function Z(o12, a2, b2) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) o12[i4] = a2[i4] - b2[i4] | 0;
      }
      function M(o12, a2, b2) {
        var i4, j2, t14 = new Float64Array(31);
        for (i4 = 0; i4 < 31; i4++) t14[i4] = 0;
        for (i4 = 0; i4 < 16; i4++) {
          for (j2 = 0; j2 < 16; j2++) {
            t14[i4 + j2] += a2[i4] * b2[j2];
          }
        }
        for (i4 = 0; i4 < 15; i4++) {
          t14[i4] += 38 * t14[i4 + 16];
        }
        for (i4 = 0; i4 < 16; i4++) o12[i4] = t14[i4];
        car25519(o12);
        car25519(o12);
      }
      function S2(o12, a2) {
        M(o12, a2, a2);
      }
      function inv25519(o12, i4) {
        var c = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c[a2] = i4[a2];
        for (a2 = 253; a2 >= 0; a2--) {
          S2(c, c);
          if (a2 !== 2 && a2 !== 4) M(c, c, i4);
        }
        for (a2 = 0; a2 < 16; a2++) o12[a2] = c[a2];
      }
      function pack25519(o12, n14) {
        var i4, j2, b2;
        var m3 = gf(), t14 = gf();
        for (i4 = 0; i4 < 16; i4++) t14[i4] = n14[i4];
        car25519(t14);
        car25519(t14);
        car25519(t14);
        for (j2 = 0; j2 < 2; j2++) {
          m3[0] = t14[0] - 65517;
          for (i4 = 1; i4 < 15; i4++) {
            m3[i4] = t14[i4] - 65535 - (m3[i4 - 1] >> 16 & 1);
            m3[i4 - 1] &= 65535;
          }
          m3[15] = t14[15] - 32767 - (m3[14] >> 16 & 1);
          b2 = m3[15] >> 16 & 1;
          m3[14] &= 65535;
          sel25519(t14, m3, 1 - b2);
        }
        for (i4 = 0; i4 < 16; i4++) {
          o12[2 * i4] = t14[i4] & 255;
          o12[2 * i4 + 1] = t14[i4] >> 8;
        }
      }
      function par25519(a2) {
        var d8 = new Uint8Array(32);
        pack25519(d8, a2);
        return d8[0] & 1;
      }
      function vn3(x2, xi, y3, yi, n14) {
        var i4, d8 = 0;
        for (i4 = 0; i4 < n14; i4++) d8 |= x2[xi + i4] ^ y3[yi + i4];
        return (1 & d8 - 1 >>> 8) - 1;
      }
      function crypto_verify_32(x2, xi, y3, yi) {
        return vn3(x2, xi, y3, yi, 32);
      }
      function neq25519(a2, b2) {
        var c = new Uint8Array(32), d8 = new Uint8Array(32);
        pack25519(c, a2);
        pack25519(d8, b2);
        return crypto_verify_32(c, 0, d8, 0);
      }
      function pow2523(o12, i4) {
        var c = gf();
        var a2;
        for (a2 = 0; a2 < 16; a2++) c[a2] = i4[a2];
        for (a2 = 250; a2 >= 0; a2--) {
          S2(c, c);
          if (a2 !== 1) M(c, c, i4);
        }
        for (a2 = 0; a2 < 16; a2++) o12[a2] = c[a2];
      }
      function set25519(r7, a2) {
        var i4;
        for (i4 = 0; i4 < 16; i4++) r7[i4] = a2[i4] | 0;
      }
      function unpackneg(r7, p4) {
        var t14 = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r7[2], gf1);
        unpack25519(r7[1], p4);
        S2(num, r7[1]);
        M(den, num, D3);
        Z(num, num, r7[2]);
        A5(den, r7[2], den);
        S2(den2, den);
        S2(den4, den2);
        M(den6, den4, den2);
        M(t14, den6, num);
        M(t14, t14, den);
        pow2523(t14, t14);
        M(t14, t14, num);
        M(t14, t14, den);
        M(t14, t14, den);
        M(r7[0], t14, den);
        S2(chk, r7[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r7[0], r7[0], I2);
        S2(chk, r7[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r7[0]) === p4[31] >> 7) Z(r7[0], gf0, r7[0]);
        M(r7[3], r7[0], r7[1]);
        return 0;
      }
      function convertPublicKey(pk) {
        var z2 = new Uint8Array(32), q2 = [gf(), gf(), gf(), gf()], a2 = gf(), b2 = gf();
        if (unpackneg(q2, pk)) return null;
        var y3 = q2[1];
        A5(a2, gf1, y3);
        Z(b2, gf1, y3);
        inv25519(b2, b2);
        M(a2, a2, b2);
        pack25519(z2, a2);
        return z2;
      }
      function convertSecretKey(sk) {
        var d8 = new Uint8Array(64), o12 = new Uint8Array(32), i4;
        nacl5.lowlevel.crypto_hash(d8, sk, 32);
        d8[0] &= 248;
        d8[31] &= 127;
        d8[31] |= 64;
        for (i4 = 0; i4 < 32; i4++) o12[i4] = d8[i4];
        for (i4 = 0; i4 < 64; i4++) d8[i4] = 0;
        return o12;
      }
      function convertKeyPair(edKeyPair) {
        var publicKey = convertPublicKey(edKeyPair.publicKey);
        if (!publicKey) return null;
        return {
          publicKey,
          secretKey: convertSecretKey(edKeyPair.secretKey)
        };
      }
      return {
        convertPublicKey,
        convertSecretKey,
        convertKeyPair
      };
    });
  }
});

// node_modules/aptos/dist/index.mjs
var import_tweetnacl = __toESM(require_nacl_fast(), 1);

// node_modules/aptos/node_modules/@noble/hashes/esm/_assert.js
function number(n14) {
  if (!Number.isSafeInteger(n14) || n14 < 0)
    throw new Error(`Wrong positive integer: ${n14}`);
}
function isBytes(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
function bytes(b2, ...lengths) {
  if (!isBytes(b2))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b2.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b2.length}`);
}
function hash(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/aptos/node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/aptos/node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
function isBytes2(a2) {
  return a2 instanceof Uint8Array || a2 != null && typeof a2 === "object" && a2.constructor.name === "Uint8Array";
}
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
var hexes = Array.from({ length: 256 }, (_, i4) => i4.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  if (!isBytes2(bytes2))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i4 = 0; i4 < bytes2.length; i4++) {
    hex += hexes[bytes2[i4]];
  }
  return hex;
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n22 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n22;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!isBytes2(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function checkOpts(defaults, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}

// node_modules/aptos/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i4 = 0; i4 < pad.length; i4++)
      pad[i4] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i4 = 0; i4 < pad.length; i4++)
      pad[i4] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/aptos/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash2, _password, _salt, _opts) {
  hash(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt2 = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt2);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u4) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u4.fill(0);
  return DK;
}
function pbkdf2(hash2, password, salt2, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt2, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u4 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u4);
    Ti.set(u4.subarray(0, Ti.length));
    for (let ui = 1; ui < c; ui++) {
      PRF._cloneInto(prfW).update(u4).digestInto(u4);
      for (let i4 = 0; i4 < Ti.length; i4++)
        Ti[i4] ^= u4[i4];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u4);
}

// node_modules/aptos/node_modules/@noble/hashes/esm/_sha2.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h4 = isLE2 ? 4 : 0;
  const l3 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h4, wh, isLE2);
  view.setUint32(byteOffset + l3, wl, isLE2);
}
var SHA2 = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i4 = pos; i4 < blockLen; i4++)
      buffer[i4] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i4 = 0; i4 < outLen; i4++)
      oview.setUint32(4 * i4, state[i4], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/aptos/node_modules/@noble/hashes/esm/sha256.js
var Chi = (a2, b2, c) => a2 & b2 ^ ~a2 & c;
var Maj = (a2, b2, c) => a2 & b2 ^ a2 & c ^ b2 & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A: A5, B: B2, C: C3, D: D3, E: E2, F, G, H } = this;
    return [A5, B2, C3, D3, E2, F, G, H];
  }
  // prettier-ignore
  set(A5, B2, C3, D3, E2, F, G, H) {
    this.A = A5 | 0;
    this.B = B2 | 0;
    this.C = C3 | 0;
    this.D = D3 | 0;
    this.E = E2 | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i4 = 0; i4 < 16; i4++, offset += 4)
      SHA256_W[i4] = view.getUint32(offset, false);
    for (let i4 = 16; i4 < 64; i4++) {
      const W15 = SHA256_W[i4 - 15];
      const W22 = SHA256_W[i4 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i4] = s1 + SHA256_W[i4 - 7] + s0 + SHA256_W[i4 - 16] | 0;
    }
    let { A: A5, B: B2, C: C3, D: D3, E: E2, F, G, H } = this;
    for (let i4 = 0; i4 < 64; i4++) {
      const sigma1 = rotr(E2, 6) ^ rotr(E2, 11) ^ rotr(E2, 25);
      const T1 = H + sigma1 + Chi(E2, F, G) + SHA256_K[i4] + SHA256_W[i4] | 0;
      const sigma0 = rotr(A5, 2) ^ rotr(A5, 13) ^ rotr(A5, 22);
      const T22 = sigma0 + Maj(A5, B2, C3) | 0;
      H = G;
      G = F;
      F = E2;
      E2 = D3 + T1 | 0;
      D3 = C3;
      C3 = B2;
      B2 = A5;
      A5 = T1 + T22 | 0;
    }
    A5 = A5 + this.A | 0;
    B2 = B2 + this.B | 0;
    C3 = C3 + this.C | 0;
    D3 = D3 + this.D | 0;
    E2 = E2 + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A5, B2, C3, D3, E2, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/aptos/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n14, le2 = false) {
  if (le2)
    return { h: Number(n14 & U32_MASK64), l: Number(n14 >> _32n & U32_MASK64) };
  return { h: Number(n14 >> _32n & U32_MASK64) | 0, l: Number(n14 & U32_MASK64) | 0 };
}
function split(lst, le2 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i4 = 0; i4 < lst.length; i4++) {
    const { h: h4, l: l3 } = fromBig(lst[i4], le2);
    [Ah[i4], Al[i4]] = [h4, l3];
  }
  return [Ah, Al];
}
var toBig = (h4, l3) => BigInt(h4 >>> 0) << _32n | BigInt(l3 >>> 0);
var shrSH = (h4, _l, s3) => h4 >>> s3;
var shrSL = (h4, l3, s3) => h4 << 32 - s3 | l3 >>> s3;
var rotrSH = (h4, l3, s3) => h4 >>> s3 | l3 << 32 - s3;
var rotrSL = (h4, l3, s3) => h4 << 32 - s3 | l3 >>> s3;
var rotrBH = (h4, l3, s3) => h4 << 64 - s3 | l3 >>> s3 - 32;
var rotrBL = (h4, l3, s3) => h4 >>> s3 - 32 | l3 << 64 - s3;
var rotr32H = (_h, l3) => l3;
var rotr32L = (h4, _l) => h4;
var rotlSH = (h4, l3, s3) => h4 << s3 | l3 >>> 32 - s3;
var rotlSL = (h4, l3, s3) => l3 << s3 | h4 >>> 32 - s3;
var rotlBH = (h4, l3, s3) => l3 << s3 - 32 | h4 >>> 64 - s3;
var rotlBL = (h4, l3, s3) => h4 << s3 - 32 | l3 >>> 64 - s3;
function add(Ah, Al, Bh, Bl) {
  const l3 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l3 / 2 ** 32 | 0) | 0, l: l3 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/aptos/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n14) => BigInt(n14))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i4 = 0; i4 < 16; i4++, offset += 4) {
      SHA512_W_H[i4] = view.getUint32(offset);
      SHA512_W_L[i4] = view.getUint32(offset += 4);
    }
    for (let i4 = 16; i4 < 80; i4++) {
      const W15h = SHA512_W_H[i4 - 15] | 0;
      const W15l = SHA512_W_L[i4 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i4 - 2] | 0;
      const W2l = SHA512_W_L[i4 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i4 - 7], SHA512_W_L[i4 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i4 - 7], SHA512_W_H[i4 - 16]);
      SHA512_W_H[i4] = SUMh | 0;
      SHA512_W_L[i4] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i4 = 0; i4 < 80; i4++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i4], SHA512_W_L[i4]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i4], SHA512_W_H[i4]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/aptos/node_modules/@scure/bip39/esm/index.js
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
  return str.normalize("NFKD");
}
function normalize(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}

// node_modules/aptos/node_modules/@noble/hashes/esm/sha3.js
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n, x2 = 1, y3 = 0; round < 24; round++) {
  [x2, y3] = [y3, (2 * x2 + 3 * y3) % 5];
  SHA3_PI.push(2 * (5 * y3 + x2));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t14 = _0n;
  for (let j2 = 0; j2 < 7; j2++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t14 ^= _1n << (_1n << BigInt(j2)) - _1n;
  }
  _SHA3_IOTA.push(t14);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h4, l3, s3) => s3 > 32 ? rotlBH(h4, l3, s3) : rotlSH(h4, l3, s3);
var rotlL = (h4, l3, s3) => s3 > 32 ? rotlBL(h4, l3, s3) : rotlSL(h4, l3, s3);
function keccakP(s3, rounds = 24) {
  const B2 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x2 = 0; x2 < 10; x2++)
      B2[x2] = s3[x2] ^ s3[x2 + 10] ^ s3[x2 + 20] ^ s3[x2 + 30] ^ s3[x2 + 40];
    for (let x2 = 0; x2 < 10; x2 += 2) {
      const idx1 = (x2 + 8) % 10;
      const idx0 = (x2 + 2) % 10;
      const B0 = B2[idx0];
      const B1 = B2[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B2[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
      for (let y3 = 0; y3 < 50; y3 += 10) {
        s3[x2 + y3] ^= Th;
        s3[x2 + y3 + 1] ^= Tl;
      }
    }
    let curH = s3[2];
    let curL = s3[3];
    for (let t14 = 0; t14 < 24; t14++) {
      const shift = SHA3_ROTL[t14];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t14];
      curH = s3[PI];
      curL = s3[PI + 1];
      s3[PI] = Th;
      s3[PI + 1] = Tl;
    }
    for (let y3 = 0; y3 < 50; y3 += 10) {
      for (let x2 = 0; x2 < 10; x2++)
        B2[x2] = s3[y3 + x2];
      for (let x2 = 0; x2 < 10; x2++)
        s3[y3 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
    }
    s3[0] ^= SHA3_IOTA_H[round];
    s3[1] ^= SHA3_IOTA_L[round];
  }
  B2.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i4 = 0; i4 < take; i4++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_2562 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/aptos/dist/index.mjs
var import_tweetnacl2 = __toESM(require_nacl_fast(), 1);
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __decorateClass = (decorators, target, key, kind) => {
  var result = kind > 1 ? void 0 : kind ? __getOwnPropDesc(target, key) : target;
  for (var i4 = decorators.length - 1, decorator; i4 >= 0; i4--)
    if (decorator = decorators[i4])
      result = (kind ? decorator(target, key, result) : decorator(result)) || result;
  if (kind && result)
    __defProp(target, key, result);
  return result;
};
var pathRegex = /^m(\/[0-9]+')+$/;
var replaceDerive = (val) => val.replace("'", "");
var HMAC_KEY = "ed25519 seed";
var HARDENED_OFFSET = 2147483648;
var getMasterKeyFromSeed = (seed) => {
  const h4 = hmac.create(sha512, HMAC_KEY);
  const I2 = h4.update(hexToBytes(seed)).digest();
  const IL = I2.slice(0, 32);
  const IR = I2.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var CKDPriv = ({ key, chainCode }, index) => {
  const buffer = new ArrayBuffer(4);
  new DataView(buffer).setUint32(0, index);
  const indexBytes = new Uint8Array(buffer);
  const zero = new Uint8Array([0]);
  const data = new Uint8Array([...zero, ...key, ...indexBytes]);
  const I2 = hmac.create(sha512, chainCode).update(data).digest();
  const IL = I2.slice(0, 32);
  const IR = I2.slice(32);
  return {
    key: IL,
    chainCode: IR
  };
};
var isValidPath = (path) => {
  if (!pathRegex.test(path)) {
    return false;
  }
  return !path.split("/").slice(1).map(replaceDerive).some(Number.isNaN);
};
var derivePath = (path, seed, offset = HARDENED_OFFSET) => {
  if (!isValidPath(path)) {
    throw new Error("Invalid derivation path");
  }
  const { key, chainCode } = getMasterKeyFromSeed(seed);
  const segments = path.split("/").slice(1).map(replaceDerive).map((el) => parseInt(el, 10));
  return segments.reduce((parentKeys, segment) => CKDPriv(parentKeys, segment + offset), { key, chainCode });
};
var VERSION = "1.21.0";
async function sleep(timeMs) {
  return new Promise((resolve) => {
    setTimeout(resolve, timeMs);
  });
}
var DEFAULT_VERSION_PATH_BASE = "/v1";
function fixNodeUrl(nodeUrl) {
  let out = `${nodeUrl}`;
  if (out.endsWith("/")) {
    out = out.substring(0, out.length - 1);
  }
  if (!out.endsWith(DEFAULT_VERSION_PATH_BASE)) {
    out = `${out}${DEFAULT_VERSION_PATH_BASE}`;
  }
  return out;
}
var DEFAULT_MAX_GAS_AMOUNT = 2e5;
var DEFAULT_TXN_EXP_SEC_FROM_NOW = 20;
var DEFAULT_TXN_TIMEOUT_SEC = 20;
var APTOS_COIN = "0x1::aptos_coin::AptosCoin";
var CUSTOM_REQUEST_HEADER = { "x-aptos-client": `aptos-ts-sdk/${VERSION}` };
function Memoize(args) {
  let hashFunction;
  let ttlMs;
  let tags;
  if (typeof args === "object") {
    hashFunction = args.hashFunction;
    ttlMs = args.ttlMs;
    tags = args.tags;
  } else {
    hashFunction = args;
  }
  return (target, propertyKey, descriptor) => {
    if (descriptor.value != null) {
      descriptor.value = getNewFunction(descriptor.value, hashFunction, ttlMs, tags);
    } else if (descriptor.get != null) {
      descriptor.get = getNewFunction(descriptor.get, hashFunction, ttlMs, tags);
    } else {
      throw new Error("Only put a Memoize() decorator on a method or get accessor.");
    }
  };
}
function MemoizeExpiring(ttlMs, hashFunction) {
  return Memoize({
    ttlMs,
    hashFunction
  });
}
var clearCacheTagsMap = /* @__PURE__ */ new Map();
function clear(tags) {
  const cleared = /* @__PURE__ */ new Set();
  for (const tag of tags) {
    const maps = clearCacheTagsMap.get(tag);
    if (maps) {
      for (const mp of maps) {
        if (!cleared.has(mp)) {
          mp.clear();
          cleared.add(mp);
        }
      }
    }
  }
  return cleared.size;
}
function getNewFunction(originalMethod, hashFunction, ttlMs = 0, tags) {
  const propMapName = Symbol("__memoized_map__");
  return function(...args) {
    let returnedValue;
    const that = this;
    if (!that.hasOwnProperty(propMapName)) {
      Object.defineProperty(that, propMapName, {
        configurable: false,
        enumerable: false,
        writable: false,
        value: /* @__PURE__ */ new Map()
      });
    }
    const myMap = that[propMapName];
    if (Array.isArray(tags)) {
      for (const tag of tags) {
        if (clearCacheTagsMap.has(tag)) {
          clearCacheTagsMap.get(tag).push(myMap);
        } else {
          clearCacheTagsMap.set(tag, [myMap]);
        }
      }
    }
    if (hashFunction || args.length > 0 || ttlMs > 0) {
      let hashKey;
      if (hashFunction === true) {
        hashKey = args.map((a2) => a2.toString()).join("!");
      } else if (hashFunction) {
        hashKey = hashFunction.apply(that, args);
      } else {
        hashKey = args[0];
      }
      const timestampKey = `${hashKey}__timestamp`;
      let isExpired = false;
      if (ttlMs > 0) {
        if (!myMap.has(timestampKey)) {
          isExpired = true;
        } else {
          const timestamp = myMap.get(timestampKey);
          isExpired = Date.now() - timestamp > ttlMs;
        }
      }
      if (myMap.has(hashKey) && !isExpired) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(that, args);
        myMap.set(hashKey, returnedValue);
        if (ttlMs > 0) {
          myMap.set(timestampKey, Date.now());
        }
      }
    } else {
      const hashKey = that;
      if (myMap.has(hashKey)) {
        returnedValue = myMap.get(hashKey);
      } else {
        returnedValue = originalMethod.apply(that, args);
        myMap.set(hashKey, returnedValue);
      }
    }
    return returnedValue;
  };
}
var AptosApiError = class extends Error {
  constructor(request22, response, message) {
    super(message);
    this.name = "AptosApiError";
    this.url = response.url;
    this.status = response.status;
    this.statusText = response.statusText;
    this.data = response.data;
    this.request = request22;
  }
};
var errors = {
  400: "Bad Request",
  401: "Unauthorized",
  403: "Forbidden",
  404: "Not Found",
  429: "Too Many Requests",
  500: "Internal Server Error",
  502: "Bad Gateway",
  503: "Service Unavailable"
};
async function request(url, method, body, contentType, params, overrides) {
  const headers = {
    ...overrides == null ? void 0 : overrides.HEADERS,
    "x-aptos-client": `aptos-ts-sdk/${VERSION}`,
    "content-type": contentType != null ? contentType : "application/json"
  };
  if (overrides == null ? void 0 : overrides.TOKEN) {
    headers.Authorization = `Bearer ${overrides == null ? void 0 : overrides.TOKEN}`;
  }
  const response = await aptosClient({ url, method, body, params, headers, overrides });
  return response;
}
async function aptosRequest(options) {
  const { url, endpoint, method, body, contentType, params, overrides } = options;
  const fullEndpoint = `${url}/${endpoint != null ? endpoint : ""}`;
  const response = await request(fullEndpoint, method, body, contentType, params, overrides);
  const result = {
    status: response.status,
    statusText: response.statusText,
    data: response.data,
    headers: response.headers,
    config: response.config,
    url: fullEndpoint
  };
  if (result.status >= 200 && result.status < 300) {
    return result;
  }
  const errorMessage = errors[result.status];
  throw new AptosApiError(options, result, errorMessage != null ? errorMessage : "Generic Error");
}
async function get(options) {
  const response = await aptosRequest({ ...options, method: "GET" });
  return response;
}
async function post(options) {
  const response = await aptosRequest({ ...options, method: "POST" });
  return response;
}
async function paginateWithCursor(options) {
  const out = [];
  let cursor;
  const requestParams = options.params;
  while (true) {
    requestParams.start = cursor;
    const response = await get({
      url: options.url,
      endpoint: options.endpoint,
      params: requestParams,
      originMethod: options.originMethod,
      overrides: options.overrides
    });
    cursor = response.headers["x-aptos-cursor"];
    delete response.headers;
    out.push(...response.data);
    if (cursor === null || cursor === void 0) {
      break;
    }
  }
  return out;
}
var NetworkToIndexerAPI = {
  mainnet: "https://indexer.mainnet.aptoslabs.com/v1/graphql",
  testnet: "https://indexer-testnet.staging.gcp.aptosdev.com/v1/graphql",
  devnet: "https://indexer-devnet.staging.gcp.aptosdev.com/v1/graphql",
  local: "http://127.0.0.1:8090/v1/graphql"
};
var NetworkToNodeAPI = {
  mainnet: "https://fullnode.mainnet.aptoslabs.com/v1",
  testnet: "https://fullnode.testnet.aptoslabs.com/v1",
  devnet: "https://fullnode.devnet.aptoslabs.com/v1",
  local: "http://127.0.0.1:8080/v1"
};
var Network = ((Network3) => {
  Network3["MAINNET"] = "mainnet";
  Network3["TESTNET"] = "testnet";
  Network3["DEVNET"] = "devnet";
  Network3["LOCAL"] = "local";
  return Network3;
})(Network || {});
var HexString = class _HexString {
  /**
   * Creates new hex string from Buffer
   * @param buffer A buffer to convert
   * @returns New HexString
   */
  static fromBuffer(buffer) {
    return _HexString.fromUint8Array(buffer);
  }
  /**
   * Creates new hex string from Uint8Array
   * @param arr Uint8Array to convert
   * @returns New HexString
   */
  static fromUint8Array(arr) {
    return new _HexString(bytesToHex(arr));
  }
  /**
   * Ensures `hexString` is instance of `HexString` class
   * @param hexString String to check
   * @returns New HexString if `hexString` is regular string or `hexString` if it is HexString instance
   * @example
   * ```
   *  const regularString = "string";
   *  const hexString = new HexString("string"); // "0xstring"
   *  HexString.ensure(regularString); // "0xstring"
   *  HexString.ensure(hexString); // "0xstring"
   * ```
   */
  static ensure(hexString) {
    if (typeof hexString === "string") {
      return new _HexString(hexString);
    }
    return hexString;
  }
  /**
   * Creates new HexString instance from regular string. If specified string already starts with "0x" prefix,
   * it will not add another one
   * @param hexString String to convert
   * @example
   * ```
   *  const string = "string";
   *  new HexString(string); // "0xstring"
   * ```
   */
  constructor(hexString) {
    if (hexString.startsWith("0x")) {
      this.hexString = hexString;
    } else {
      this.hexString = `0x${hexString}`;
    }
  }
  /**
   * Getter for inner hexString
   * @returns Inner hex string
   */
  hex() {
    return this.hexString;
  }
  /**
   * Getter for inner hexString without prefix
   * @returns Inner hex string without prefix
   * @example
   * ```
   *  const hexString = new HexString("string"); // "0xstring"
   *  hexString.noPrefix(); // "string"
   * ```
   */
  noPrefix() {
    return this.hexString.slice(2);
  }
  /**
   * Overrides default `toString` method
   * @returns Inner hex string
   */
  toString() {
    return this.hex();
  }
  /**
   * Trimmes extra zeroes in the begining of a string
   * @returns Inner hexString without leading zeroes
   * @example
   * ```
   *  new HexString("0x000000string").toShortString(); // result = "0xstring"
   * ```
   */
  toShortString() {
    const trimmed = this.hexString.replace(/^0x0*/, "");
    return `0x${trimmed}`;
  }
  /**
   * Converts hex string to a Uint8Array
   * @returns Uint8Array from inner hexString without prefix
   */
  toUint8Array() {
    return Uint8Array.from(hexToBytes(this.noPrefix()));
  }
};
var aptos_types_exports = {};
__export(aptos_types_exports, {
  AccountAddress: () => AccountAddress,
  AccountAuthenticator: () => AccountAuthenticator,
  AccountAuthenticatorEd25519: () => AccountAuthenticatorEd25519,
  AccountAuthenticatorMultiEd25519: () => AccountAuthenticatorMultiEd25519,
  ArgumentABI: () => ArgumentABI,
  AuthenticationKey: () => AuthenticationKey,
  ChainId: () => ChainId,
  ChangeSet: () => ChangeSet,
  Ed25519PublicKey: () => Ed25519PublicKey,
  Ed25519Signature: () => Ed25519Signature,
  EntryFunction: () => EntryFunction,
  EntryFunctionABI: () => EntryFunctionABI,
  FeePayerRawTransaction: () => FeePayerRawTransaction,
  Identifier: () => Identifier,
  Module: () => Module,
  ModuleId: () => ModuleId,
  MultiAgentRawTransaction: () => MultiAgentRawTransaction,
  MultiEd25519PublicKey: () => MultiEd25519PublicKey,
  MultiEd25519Signature: () => MultiEd25519Signature,
  MultiSig: () => MultiSig,
  MultiSigTransactionPayload: () => MultiSigTransactionPayload,
  RawTransaction: () => RawTransaction,
  RawTransactionWithData: () => RawTransactionWithData,
  RotationProofChallenge: () => RotationProofChallenge,
  Script: () => Script,
  ScriptABI: () => ScriptABI,
  SignedTransaction: () => SignedTransaction,
  StructTag: () => StructTag,
  Transaction: () => Transaction,
  TransactionArgument: () => TransactionArgument,
  TransactionArgumentAddress: () => TransactionArgumentAddress,
  TransactionArgumentBool: () => TransactionArgumentBool,
  TransactionArgumentU128: () => TransactionArgumentU128,
  TransactionArgumentU16: () => TransactionArgumentU16,
  TransactionArgumentU256: () => TransactionArgumentU256,
  TransactionArgumentU32: () => TransactionArgumentU32,
  TransactionArgumentU64: () => TransactionArgumentU64,
  TransactionArgumentU8: () => TransactionArgumentU8,
  TransactionArgumentU8Vector: () => TransactionArgumentU8Vector,
  TransactionAuthenticator: () => TransactionAuthenticator,
  TransactionAuthenticatorEd25519: () => TransactionAuthenticatorEd25519,
  TransactionAuthenticatorFeePayer: () => TransactionAuthenticatorFeePayer,
  TransactionAuthenticatorMultiAgent: () => TransactionAuthenticatorMultiAgent,
  TransactionAuthenticatorMultiEd25519: () => TransactionAuthenticatorMultiEd25519,
  TransactionPayload: () => TransactionPayload,
  TransactionPayloadEntryFunction: () => TransactionPayloadEntryFunction,
  TransactionPayloadMultisig: () => TransactionPayloadMultisig,
  TransactionPayloadScript: () => TransactionPayloadScript,
  TransactionScriptABI: () => TransactionScriptABI,
  TypeArgumentABI: () => TypeArgumentABI,
  TypeTag: () => TypeTag,
  TypeTagAddress: () => TypeTagAddress,
  TypeTagBool: () => TypeTagBool,
  TypeTagParser: () => TypeTagParser,
  TypeTagParserError: () => TypeTagParserError,
  TypeTagSigner: () => TypeTagSigner,
  TypeTagStruct: () => TypeTagStruct,
  TypeTagU128: () => TypeTagU128,
  TypeTagU16: () => TypeTagU16,
  TypeTagU256: () => TypeTagU256,
  TypeTagU32: () => TypeTagU32,
  TypeTagU64: () => TypeTagU64,
  TypeTagU8: () => TypeTagU8,
  TypeTagVector: () => TypeTagVector,
  UserTransaction: () => UserTransaction,
  WriteSet: () => WriteSet,
  objectStructTag: () => objectStructTag,
  optionStructTag: () => optionStructTag,
  stringStructTag: () => stringStructTag
});
var bcs_exports = {};
__export(bcs_exports, {
  Deserializer: () => Deserializer,
  Serializer: () => Serializer,
  bcsSerializeBool: () => bcsSerializeBool,
  bcsSerializeBytes: () => bcsSerializeBytes,
  bcsSerializeFixedBytes: () => bcsSerializeFixedBytes,
  bcsSerializeStr: () => bcsSerializeStr,
  bcsSerializeU128: () => bcsSerializeU128,
  bcsSerializeU16: () => bcsSerializeU16,
  bcsSerializeU256: () => bcsSerializeU256,
  bcsSerializeU32: () => bcsSerializeU32,
  bcsSerializeU8: () => bcsSerializeU8,
  bcsSerializeUint64: () => bcsSerializeUint64,
  bcsToBytes: () => bcsToBytes,
  deserializeVector: () => deserializeVector,
  serializeVector: () => serializeVector,
  serializeVectorWithFunc: () => serializeVectorWithFunc
});
var MAX_U8_NUMBER = 2 ** 8 - 1;
var MAX_U16_NUMBER = 2 ** 16 - 1;
var MAX_U32_NUMBER = 2 ** 32 - 1;
var MAX_U64_BIG_INT = BigInt(2 ** 64) - BigInt(1);
var MAX_U128_BIG_INT = BigInt(2 ** 128) - BigInt(1);
var MAX_U256_BIG_INT = BigInt(2 ** 256) - BigInt(1);
var Serializer = class {
  constructor() {
    this.buffer = new ArrayBuffer(64);
    this.offset = 0;
  }
  ensureBufferWillHandleSize(bytes2) {
    while (this.buffer.byteLength < this.offset + bytes2) {
      const newBuffer = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(newBuffer).set(new Uint8Array(this.buffer));
      this.buffer = newBuffer;
    }
  }
  serialize(values) {
    this.ensureBufferWillHandleSize(values.length);
    new Uint8Array(this.buffer, this.offset).set(values);
    this.offset += values.length;
  }
  serializeWithFunction(fn3, bytesLength, value) {
    this.ensureBufferWillHandleSize(bytesLength);
    const dv = new DataView(this.buffer, this.offset);
    fn3.apply(dv, [0, value, true]);
    this.offset += bytesLength;
  }
  /**
   * Serializes a string. UTF8 string is supported. Serializes the string's bytes length "l" first,
   * and then serializes "l" bytes of the string content.
   *
   * BCS layout for "string": string_length | string_content. string_length is the bytes length of
   * the string that is uleb128 encoded. string_length is a u32 integer.
   *
   * @example
   * ```ts
   * const serializer = new Serializer();
   * serializer.serializeStr("");
   * assert(serializer.getBytes() === new Uint8Array([24, 0xc3, 0xa7, 0xc3, 0xa5, 0xe2, 0x88, 0x9e,
   * 0xe2, 0x89, 0xa0, 0xc2, 0xa2, 0xc3, 0xb5, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xc6, 0x92, 0xe2, 0x88, 0xab]));
   * ```
   */
  serializeStr(value) {
    const textEncoder = new TextEncoder();
    this.serializeBytes(textEncoder.encode(value));
  }
  /**
   * Serializes an array of bytes.
   *
   * BCS layout for "bytes": bytes_length | bytes. bytes_length is the length of the bytes array that is
   * uleb128 encoded. bytes_length is a u32 integer.
   */
  serializeBytes(value) {
    this.serializeU32AsUleb128(value.length);
    this.serialize(value);
  }
  /**
   * Serializes an array of bytes with known length. Therefore length doesn't need to be
   * serialized to help deserialization.  When deserializing, the number of
   * bytes to deserialize needs to be passed in.
   */
  serializeFixedBytes(value) {
    this.serialize(value);
  }
  /**
   * Serializes a boolean value.
   *
   * BCS layout for "boolean": One byte. "0x01" for True and "0x00" for False.
   */
  serializeBool(value) {
    if (typeof value !== "boolean") {
      throw new Error("Value needs to be a boolean");
    }
    const byteValue = value ? 1 : 0;
    this.serialize(new Uint8Array([byteValue]));
  }
  serializeU8(value) {
    this.serialize(new Uint8Array([value]));
  }
  serializeU16(value) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, value);
  }
  serializeU32(value) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, value);
  }
  serializeU64(value) {
    const low = BigInt(value.toString()) & BigInt(MAX_U32_NUMBER);
    const high = BigInt(value.toString()) >> BigInt(32);
    this.serializeU32(Number(low));
    this.serializeU32(Number(high));
  }
  serializeU128(value) {
    const low = BigInt(value.toString()) & MAX_U64_BIG_INT;
    const high = BigInt(value.toString()) >> BigInt(64);
    this.serializeU64(low);
    this.serializeU64(high);
  }
  serializeU256(value) {
    const low = BigInt(value.toString()) & MAX_U128_BIG_INT;
    const high = BigInt(value.toString()) >> BigInt(128);
    this.serializeU128(low);
    this.serializeU128(high);
  }
  serializeU32AsUleb128(val) {
    let value = val;
    const valueArray = [];
    while (value >>> 7 !== 0) {
      valueArray.push(value & 127 | 128);
      value >>>= 7;
    }
    valueArray.push(value);
    this.serialize(new Uint8Array(valueArray));
  }
  /**
   * Returns the buffered bytes
   */
  getBytes() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
};
__decorateClass([
  checkNumberRange(0, MAX_U8_NUMBER)
], Serializer.prototype, "serializeU8", 1);
__decorateClass([
  checkNumberRange(0, MAX_U16_NUMBER)
], Serializer.prototype, "serializeU16", 1);
__decorateClass([
  checkNumberRange(0, MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U64_BIG_INT)
], Serializer.prototype, "serializeU64", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U128_BIG_INT)
], Serializer.prototype, "serializeU128", 1);
__decorateClass([
  checkNumberRange(BigInt(0), MAX_U256_BIG_INT)
], Serializer.prototype, "serializeU256", 1);
__decorateClass([
  checkNumberRange(0, MAX_U32_NUMBER)
], Serializer.prototype, "serializeU32AsUleb128", 1);
function checkNumberRange(minValue, maxValue, message) {
  return (target, propertyKey, descriptor) => {
    const childFunction = descriptor.value;
    descriptor.value = function deco(value) {
      const valueBigInt = BigInt(value.toString());
      if (valueBigInt > BigInt(maxValue.toString()) || valueBigInt < BigInt(minValue.toString())) {
        throw new Error(message || "Value is out of range");
      }
      childFunction.apply(this, [value]);
    };
    return descriptor;
  };
}
var Deserializer = class {
  constructor(data) {
    this.buffer = new ArrayBuffer(data.length);
    new Uint8Array(this.buffer).set(data, 0);
    this.offset = 0;
  }
  read(length) {
    if (this.offset + length > this.buffer.byteLength) {
      throw new Error("Reached to the end of buffer");
    }
    const bytes2 = this.buffer.slice(this.offset, this.offset + length);
    this.offset += length;
    return bytes2;
  }
  /**
   * Deserializes a string. UTF8 string is supported. Reads the string's bytes length "l" first,
   * and then reads "l" bytes of content. Decodes the byte array into a string.
   *
   * BCS layout for "string": string_length | string_content. string_length is the bytes length of
   * the string that is uleb128 encoded. string_length is a u32 integer.
   *
   * @example
   * ```ts
   * const deserializer = new Deserializer(new Uint8Array([24, 0xc3, 0xa7, 0xc3, 0xa5, 0xe2, 0x88, 0x9e,
   * 0xe2, 0x89, 0xa0, 0xc2, 0xa2, 0xc3, 0xb5, 0xc3, 0x9f, 0xe2, 0x88, 0x82, 0xc6, 0x92, 0xe2, 0x88, 0xab]));
   * assert(deserializer.deserializeStr() === "");
   * ```
   */
  deserializeStr() {
    const value = this.deserializeBytes();
    const textDecoder = new TextDecoder();
    return textDecoder.decode(value);
  }
  /**
   * Deserializes an array of bytes.
   *
   * BCS layout for "bytes": bytes_length | bytes. bytes_length is the length of the bytes array that is
   * uleb128 encoded. bytes_length is a u32 integer.
   */
  deserializeBytes() {
    const len = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(len));
  }
  /**
   * Deserializes an array of bytes. The number of bytes to read is already known.
   *
   */
  deserializeFixedBytes(len) {
    return new Uint8Array(this.read(len));
  }
  /**
   * Deserializes a boolean value.
   *
   * BCS layout for "boolean": One byte. "0x01" for True and "0x00" for False.
   */
  deserializeBool() {
    const bool = new Uint8Array(this.read(1))[0];
    if (bool !== 1 && bool !== 0) {
      throw new Error("Invalid boolean value");
    }
    return bool === 1;
  }
  /**
   * Deserializes a uint8 number.
   *
   * BCS layout for "uint8": One byte. Binary format in little-endian representation.
   */
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  /**
   * Deserializes a uint16 number.
   *
   * BCS layout for "uint16": Two bytes. Binary format in little-endian representation.
   * @example
   * ```ts
   * const deserializer = new Deserializer(new Uint8Array([0x34, 0x12]));
   * assert(deserializer.deserializeU16() === 4660);
   * ```
   */
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, true);
  }
  /**
   * Deserializes a uint32 number.
   *
   * BCS layout for "uint32": Four bytes. Binary format in little-endian representation.
   * @example
   * ```ts
   * const deserializer = new Deserializer(new Uint8Array([0x78, 0x56, 0x34, 0x12]));
   * assert(deserializer.deserializeU32() === 305419896);
   * ```
   */
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, true);
  }
  /**
   * Deserializes a uint64 number.
   *
   * BCS layout for "uint64": Eight bytes. Binary format in little-endian representation.
   * @example
   * ```ts
   * const deserializer = new Deserializer(new Uint8Array([0x00, 0xEF, 0xCD, 0xAB, 0x78, 0x56, 0x34, 0x12]));
   * assert(deserializer.deserializeU64() === 1311768467750121216);
   * ```
   */
  deserializeU64() {
    const low = this.deserializeU32();
    const high = this.deserializeU32();
    return BigInt(BigInt(high) << BigInt(32) | BigInt(low));
  }
  /**
   * Deserializes a uint128 number.
   *
   * BCS layout for "uint128": Sixteen bytes. Binary format in little-endian representation.
   */
  deserializeU128() {
    const low = this.deserializeU64();
    const high = this.deserializeU64();
    return BigInt(high << BigInt(64) | low);
  }
  /**
   * Deserializes a uint256 number.
   *
   * BCS layout for "uint256": Thirty-two bytes. Binary format in little-endian representation.
   */
  deserializeU256() {
    const low = this.deserializeU128();
    const high = this.deserializeU128();
    return BigInt(high << BigInt(128) | low);
  }
  /**
   * Deserializes a uleb128 encoded uint32 number.
   *
   * BCS use uleb128 encoding in two cases: (1) lengths of variable-length sequences and (2) tags of enum values
   */
  deserializeUleb128AsU32() {
    let value = BigInt(0);
    let shift = 0;
    while (value < MAX_U32_NUMBER) {
      const byte = this.deserializeU8();
      value |= BigInt(byte & 127) << BigInt(shift);
      if ((byte & 128) === 0) {
        break;
      }
      shift += 7;
    }
    if (value > MAX_U32_NUMBER) {
      throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    }
    return Number(value);
  }
};
function serializeVector(value, serializer) {
  serializer.serializeU32AsUleb128(value.length);
  value.forEach((item) => {
    item.serialize(serializer);
  });
}
function serializeVectorWithFunc(value, func) {
  const serializer = new Serializer();
  serializer.serializeU32AsUleb128(value.length);
  const f5 = serializer[func];
  value.forEach((item) => {
    f5.call(serializer, item);
  });
  return serializer.getBytes();
}
function deserializeVector(deserializer, cls) {
  const length = deserializer.deserializeUleb128AsU32();
  const list = [];
  for (let i4 = 0; i4 < length; i4 += 1) {
    list.push(cls.deserialize(deserializer));
  }
  return list;
}
function bcsToBytes(value) {
  const serializer = new Serializer();
  value.serialize(serializer);
  return serializer.getBytes();
}
function bcsSerializeUint64(value) {
  const serializer = new Serializer();
  serializer.serializeU64(value);
  return serializer.getBytes();
}
function bcsSerializeU8(value) {
  const serializer = new Serializer();
  serializer.serializeU8(value);
  return serializer.getBytes();
}
function bcsSerializeU16(value) {
  const serializer = new Serializer();
  serializer.serializeU16(value);
  return serializer.getBytes();
}
function bcsSerializeU32(value) {
  const serializer = new Serializer();
  serializer.serializeU32(value);
  return serializer.getBytes();
}
function bcsSerializeU128(value) {
  const serializer = new Serializer();
  serializer.serializeU128(value);
  return serializer.getBytes();
}
function bcsSerializeU256(value) {
  const serializer = new Serializer();
  serializer.serializeU256(value);
  return serializer.getBytes();
}
function bcsSerializeBool(value) {
  const serializer = new Serializer();
  serializer.serializeBool(value);
  return serializer.getBytes();
}
function bcsSerializeStr(value) {
  const serializer = new Serializer();
  serializer.serializeStr(value);
  return serializer.getBytes();
}
function bcsSerializeBytes(value) {
  const serializer = new Serializer();
  serializer.serializeBytes(value);
  return serializer.getBytes();
}
function bcsSerializeFixedBytes(value) {
  const serializer = new Serializer();
  serializer.serializeFixedBytes(value);
  return serializer.getBytes();
}
var _AccountAddress = class _AccountAddress2 {
  constructor(address) {
    if (address.length !== _AccountAddress2.LENGTH) {
      throw new Error("Expected address of length 32");
    }
    this.address = address;
  }
  /**
   * Creates AccountAddress from a hex string.
   * @param addr Hex string can be with a prefix or without a prefix,
   *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.
   */
  static fromHex(addr) {
    let address = HexString.ensure(addr);
    if (address.noPrefix().length % 2 !== 0) {
      address = new HexString(`0${address.noPrefix()}`);
    }
    const addressBytes = address.toUint8Array();
    if (addressBytes.length > _AccountAddress2.LENGTH) {
      throw new Error("Hex string is too long. Address's length is 32 bytes.");
    } else if (addressBytes.length === _AccountAddress2.LENGTH) {
      return new _AccountAddress2(addressBytes);
    }
    const res = new Uint8Array(_AccountAddress2.LENGTH);
    res.set(addressBytes, _AccountAddress2.LENGTH - addressBytes.length);
    return new _AccountAddress2(res);
  }
  /**
   * Checks if the string is a valid AccountAddress
   * @param addr Hex string can be with a prefix or without a prefix,
   *   e.g. '0x1aa' or '1aa'. Hex string will be left padded with 0s if too short.
   */
  static isValid(addr) {
    if (addr === "") {
      return false;
    }
    let address = HexString.ensure(addr);
    if (address.noPrefix().length % 2 !== 0) {
      address = new HexString(`0${address.noPrefix()}`);
    }
    const addressBytes = address.toUint8Array();
    return addressBytes.length <= _AccountAddress2.LENGTH;
  }
  /**
   * Return a hex string from account Address.
   */
  toHexString() {
    return HexString.fromUint8Array(this.address).hex();
  }
  serialize(serializer) {
    serializer.serializeFixedBytes(this.address);
  }
  static deserialize(deserializer) {
    return new _AccountAddress2(deserializer.deserializeFixedBytes(_AccountAddress2.LENGTH));
  }
  /**
   * Standardizes an address to the format "0x" followed by 64 lowercase hexadecimal digits.
   */
  static standardizeAddress(address) {
    const lowercaseAddress = address.toLowerCase();
    const addressWithoutPrefix = lowercaseAddress.startsWith("0x") ? lowercaseAddress.slice(2) : lowercaseAddress;
    const addressWithPadding = addressWithoutPrefix.padStart(64, "0");
    return `0x${addressWithPadding}`;
  }
};
_AccountAddress.LENGTH = 32;
_AccountAddress.CORE_CODE_ADDRESS = _AccountAddress.fromHex("0x1");
var AccountAddress = _AccountAddress;
var _Ed25519PublicKey = class _Ed25519PublicKey2 {
  constructor(value) {
    if (value.length !== _Ed25519PublicKey2.LENGTH) {
      throw new Error(`Ed25519PublicKey length should be ${_Ed25519PublicKey2.LENGTH}`);
    }
    this.value = value;
  }
  toBytes() {
    return this.value;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.value);
  }
  static deserialize(deserializer) {
    const value = deserializer.deserializeBytes();
    return new _Ed25519PublicKey2(value);
  }
};
_Ed25519PublicKey.LENGTH = 32;
var Ed25519PublicKey = _Ed25519PublicKey;
var _Ed25519Signature = class _Ed25519Signature2 {
  constructor(value) {
    this.value = value;
    if (value.length !== _Ed25519Signature2.LENGTH) {
      throw new Error(`Ed25519Signature length should be ${_Ed25519Signature2.LENGTH}`);
    }
  }
  serialize(serializer) {
    serializer.serializeBytes(this.value);
  }
  static deserialize(deserializer) {
    const value = deserializer.deserializeBytes();
    return new _Ed25519Signature2(value);
  }
};
_Ed25519Signature.LENGTH = 64;
var Ed25519Signature = _Ed25519Signature;
var MAX_SIGNATURES_SUPPORTED = 32;
var MultiEd25519PublicKey = class _MultiEd25519PublicKey {
  /**
   * Public key for a K-of-N multisig transaction. A K-of-N multisig transaction means that for such a
   * transaction to be executed, at least K out of the N authorized signers have signed the transaction
   * and passed the check conducted by the chain.
   *
   * @see {@link
   * https://aptos.dev/guides/creating-a-signed-transaction#multisignature-transactions | Creating a Signed Transaction}
   *
   * @param public_keys A list of public keys
   * @param threshold At least "threshold" signatures must be valid
   */
  constructor(public_keys, threshold) {
    this.public_keys = public_keys;
    this.threshold = threshold;
    if (threshold > MAX_SIGNATURES_SUPPORTED) {
      throw new Error(`"threshold" cannot be larger than ${MAX_SIGNATURES_SUPPORTED}`);
    }
  }
  /**
   * Converts a MultiEd25519PublicKey into bytes with: bytes = p1_bytes | ... | pn_bytes | threshold
   */
  toBytes() {
    const bytes2 = new Uint8Array(this.public_keys.length * Ed25519PublicKey.LENGTH + 1);
    this.public_keys.forEach((k2, i4) => {
      bytes2.set(k2.value, i4 * Ed25519PublicKey.LENGTH);
    });
    bytes2[this.public_keys.length * Ed25519PublicKey.LENGTH] = this.threshold;
    return bytes2;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toBytes());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    const threshold = bytes2[bytes2.length - 1];
    const keys = [];
    for (let i4 = 0; i4 < bytes2.length - 1; i4 += Ed25519PublicKey.LENGTH) {
      const begin = i4;
      keys.push(new Ed25519PublicKey(bytes2.subarray(begin, begin + Ed25519PublicKey.LENGTH)));
    }
    return new _MultiEd25519PublicKey(keys, threshold);
  }
};
var _MultiEd25519Signature = class _MultiEd25519Signature2 {
  /**
   * Signature for a K-of-N multisig transaction.
   *
   * @see {@link
   * https://aptos.dev/guides/creating-a-signed-transaction#multisignature-transactions | Creating a Signed Transaction}
   *
   * @param signatures A list of ed25519 signatures
   * @param bitmap 4 bytes, at most 32 signatures are supported. If Nth bit value is `1`, the Nth
   * signature should be provided in `signatures`. Bits are read from left to right
   */
  constructor(signatures, bitmap) {
    this.signatures = signatures;
    this.bitmap = bitmap;
    if (bitmap.length !== _MultiEd25519Signature2.BITMAP_LEN) {
      throw new Error(`"bitmap" length should be ${_MultiEd25519Signature2.BITMAP_LEN}`);
    }
  }
  /**
   * Converts a MultiEd25519Signature into bytes with `bytes = s1_bytes | ... | sn_bytes | bitmap`
   */
  toBytes() {
    const bytes2 = new Uint8Array(this.signatures.length * Ed25519Signature.LENGTH + _MultiEd25519Signature2.BITMAP_LEN);
    this.signatures.forEach((k2, i4) => {
      bytes2.set(k2.value, i4 * Ed25519Signature.LENGTH);
    });
    bytes2.set(this.bitmap, this.signatures.length * Ed25519Signature.LENGTH);
    return bytes2;
  }
  /**
   * Helper method to create a bitmap out of the specified bit positions
   * @param bits The bitmap positions that should be set. A position starts at index 0.
   * Valid position should range between 0 and 31.
   * @example
   * Here's an example of valid `bits`
   * ```
   * [0, 2, 31]
   * ```
   * `[0, 2, 31]` means the 1st, 3rd and 32nd bits should be set in the bitmap.
   * The result bitmap should be 0b1010000000000000000000000000001
   *
   * @returns bitmap that is 32bit long
   */
  static createBitmap(bits) {
    const firstBitInByte = 128;
    const bitmap = new Uint8Array([0, 0, 0, 0]);
    const dupCheckSet = /* @__PURE__ */ new Set();
    bits.forEach((bit) => {
      if (bit >= MAX_SIGNATURES_SUPPORTED) {
        throw new Error(`Invalid bit value ${bit}.`);
      }
      if (dupCheckSet.has(bit)) {
        throw new Error("Duplicated bits detected.");
      }
      dupCheckSet.add(bit);
      const byteOffset = Math.floor(bit / 8);
      let byte = bitmap[byteOffset];
      byte |= firstBitInByte >> bit % 8;
      bitmap[byteOffset] = byte;
    });
    return bitmap;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.toBytes());
  }
  static deserialize(deserializer) {
    const bytes2 = deserializer.deserializeBytes();
    const bitmap = bytes2.subarray(bytes2.length - 4);
    const sigs = [];
    for (let i4 = 0; i4 < bytes2.length - bitmap.length; i4 += Ed25519Signature.LENGTH) {
      const begin = i4;
      sigs.push(new Ed25519Signature(bytes2.subarray(begin, begin + Ed25519Signature.LENGTH)));
    }
    return new _MultiEd25519Signature2(sigs, bitmap);
  }
};
_MultiEd25519Signature.BITMAP_LEN = 4;
var MultiEd25519Signature = _MultiEd25519Signature;
var TransactionAuthenticator = class {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TransactionAuthenticatorEd25519.load(deserializer);
      case 1:
        return TransactionAuthenticatorMultiEd25519.load(deserializer);
      case 2:
        return TransactionAuthenticatorMultiAgent.load(deserializer);
      case 3:
        return TransactionAuthenticatorFeePayer.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${index}`);
    }
  }
};
var TransactionAuthenticatorEd25519 = class _TransactionAuthenticatorEd25519 extends TransactionAuthenticator {
  /**
   * An authenticator for single signature.
   *
   * @param public_key Client's public key.
   * @param signature Signature of a raw transaction.
   * @see {@link https://aptos.dev/guides/creating-a-signed-transaction/ | Creating a Signed Transaction}
   * for details about generating a signature.
   */
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = Ed25519PublicKey.deserialize(deserializer);
    const signature = Ed25519Signature.deserialize(deserializer);
    return new _TransactionAuthenticatorEd25519(public_key, signature);
  }
};
var TransactionAuthenticatorMultiEd25519 = class _TransactionAuthenticatorMultiEd25519 extends TransactionAuthenticator {
  /**
   * An authenticator for multiple signatures.
   *
   * @param public_key
   * @param signature
   *
   */
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = MultiEd25519PublicKey.deserialize(deserializer);
    const signature = MultiEd25519Signature.deserialize(deserializer);
    return new _TransactionAuthenticatorMultiEd25519(public_key, signature);
  }
};
var TransactionAuthenticatorMultiAgent = class _TransactionAuthenticatorMultiAgent extends TransactionAuthenticator {
  constructor(sender, secondary_signer_addresses, secondary_signers) {
    super();
    this.sender = sender;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.secondary_signers = secondary_signers;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(2);
    this.sender.serialize(serializer);
    serializeVector(this.secondary_signer_addresses, serializer);
    serializeVector(this.secondary_signers, serializer);
  }
  static load(deserializer) {
    const sender = AccountAuthenticator.deserialize(deserializer);
    const secondary_signer_addresses = deserializeVector(deserializer, AccountAddress);
    const secondary_signers = deserializeVector(deserializer, AccountAuthenticator);
    return new _TransactionAuthenticatorMultiAgent(sender, secondary_signer_addresses, secondary_signers);
  }
};
var TransactionAuthenticatorFeePayer = class _TransactionAuthenticatorFeePayer extends TransactionAuthenticator {
  constructor(sender, secondary_signer_addresses, secondary_signers, fee_payer) {
    super();
    this.sender = sender;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.secondary_signers = secondary_signers;
    this.fee_payer = fee_payer;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(3);
    this.sender.serialize(serializer);
    serializeVector(this.secondary_signer_addresses, serializer);
    serializeVector(this.secondary_signers, serializer);
    this.fee_payer.address.serialize(serializer);
    this.fee_payer.authenticator.serialize(serializer);
  }
  static load(deserializer) {
    const sender = AccountAuthenticator.deserialize(deserializer);
    const secondary_signer_addresses = deserializeVector(deserializer, AccountAddress);
    const secondary_signers = deserializeVector(deserializer, AccountAuthenticator);
    const address = AccountAddress.deserialize(deserializer);
    const authenticator = AccountAuthenticator.deserialize(deserializer);
    const fee_payer = { address, authenticator };
    return new _TransactionAuthenticatorFeePayer(sender, secondary_signer_addresses, secondary_signers, fee_payer);
  }
};
var AccountAuthenticator = class {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return AccountAuthenticatorEd25519.load(deserializer);
      case 1:
        return AccountAuthenticatorMultiEd25519.load(deserializer);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${index}`);
    }
  }
};
var AccountAuthenticatorEd25519 = class _AccountAuthenticatorEd25519 extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = Ed25519PublicKey.deserialize(deserializer);
    const signature = Ed25519Signature.deserialize(deserializer);
    return new _AccountAuthenticatorEd25519(public_key, signature);
  }
};
var AccountAuthenticatorMultiEd25519 = class _AccountAuthenticatorMultiEd25519 extends AccountAuthenticator {
  constructor(public_key, signature) {
    super();
    this.public_key = public_key;
    this.signature = signature;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
    this.public_key.serialize(serializer);
    this.signature.serialize(serializer);
  }
  static load(deserializer) {
    const public_key = MultiEd25519PublicKey.deserialize(deserializer);
    const signature = MultiEd25519Signature.deserialize(deserializer);
    return new _AccountAuthenticatorMultiEd25519(public_key, signature);
  }
};
var Identifier = class _Identifier {
  constructor(value) {
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeStr(this.value);
  }
  static deserialize(deserializer) {
    const value = deserializer.deserializeStr();
    return new _Identifier(value);
  }
};
var TypeTag = class {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TypeTagBool.load(deserializer);
      case 1:
        return TypeTagU8.load(deserializer);
      case 2:
        return TypeTagU64.load(deserializer);
      case 3:
        return TypeTagU128.load(deserializer);
      case 4:
        return TypeTagAddress.load(deserializer);
      case 5:
        return TypeTagSigner.load(deserializer);
      case 6:
        return TypeTagVector.load(deserializer);
      case 7:
        return TypeTagStruct.load(deserializer);
      case 8:
        return TypeTagU16.load(deserializer);
      case 9:
        return TypeTagU32.load(deserializer);
      case 10:
        return TypeTagU256.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${index}`);
    }
  }
};
var TypeTagBool = class _TypeTagBool extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
  }
  static load(_deserializer) {
    return new _TypeTagBool();
  }
};
var TypeTagU8 = class _TypeTagU8 extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
  }
  static load(_deserializer) {
    return new _TypeTagU8();
  }
};
var TypeTagU16 = class _TypeTagU16 extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(8);
  }
  static load(_deserializer) {
    return new _TypeTagU16();
  }
};
var TypeTagU32 = class _TypeTagU32 extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(9);
  }
  static load(_deserializer) {
    return new _TypeTagU32();
  }
};
var TypeTagU64 = class _TypeTagU64 extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(2);
  }
  static load(_deserializer) {
    return new _TypeTagU64();
  }
};
var TypeTagU128 = class _TypeTagU128 extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(3);
  }
  static load(_deserializer) {
    return new _TypeTagU128();
  }
};
var TypeTagU256 = class _TypeTagU256 extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(10);
  }
  static load(_deserializer) {
    return new _TypeTagU256();
  }
};
var TypeTagAddress = class _TypeTagAddress extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(4);
  }
  static load(_deserializer) {
    return new _TypeTagAddress();
  }
};
var TypeTagSigner = class _TypeTagSigner extends TypeTag {
  serialize(serializer) {
    serializer.serializeU32AsUleb128(5);
  }
  static load(_deserializer) {
    return new _TypeTagSigner();
  }
};
var TypeTagVector = class _TypeTagVector extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(6);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = TypeTag.deserialize(deserializer);
    return new _TypeTagVector(value);
  }
};
var TypeTagStruct = class _TypeTagStruct extends TypeTag {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(7);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = StructTag.deserialize(deserializer);
    return new _TypeTagStruct(value);
  }
  isStringTypeTag() {
    if (this.value.module_name.value === "string" && this.value.name.value === "String" && this.value.address.toHexString() === AccountAddress.CORE_CODE_ADDRESS.toHexString()) {
      return true;
    }
    return false;
  }
};
var StructTag = class _StructTag {
  constructor(address, module_name, name, type_args) {
    this.address = address;
    this.module_name = module_name;
    this.name = name;
    this.type_args = type_args;
  }
  /**
   * Converts a string literal to a StructTag
   * @param structTag String literal in format "AcountAddress::module_name::ResourceName",
   *   e.g. "0x1::aptos_coin::AptosCoin"
   * @returns
   */
  static fromString(structTag) {
    const typeTagStruct = new TypeTagParser(structTag).parseTypeTag();
    return new _StructTag(
      typeTagStruct.value.address,
      typeTagStruct.value.module_name,
      typeTagStruct.value.name,
      typeTagStruct.value.type_args
    );
  }
  serialize(serializer) {
    this.address.serialize(serializer);
    this.module_name.serialize(serializer);
    this.name.serialize(serializer);
    serializeVector(this.type_args, serializer);
  }
  static deserialize(deserializer) {
    const address = AccountAddress.deserialize(deserializer);
    const moduleName = Identifier.deserialize(deserializer);
    const name = Identifier.deserialize(deserializer);
    const typeArgs = deserializeVector(deserializer, TypeTag);
    return new _StructTag(address, moduleName, name, typeArgs);
  }
};
var stringStructTag = new StructTag(
  AccountAddress.fromHex("0x1"),
  new Identifier("string"),
  new Identifier("String"),
  []
);
function optionStructTag(typeArg) {
  return new StructTag(AccountAddress.fromHex("0x1"), new Identifier("option"), new Identifier("Option"), [typeArg]);
}
function objectStructTag(typeArg) {
  return new StructTag(AccountAddress.fromHex("0x1"), new Identifier("object"), new Identifier("Object"), [typeArg]);
}
function bail(message) {
  throw new TypeTagParserError(message);
}
function isWhiteSpace(c) {
  if (c.match(/\s/)) {
    return true;
  }
  return false;
}
function isValidAlphabetic(c) {
  if (c.match(/[_A-Za-z0-9]/g)) {
    return true;
  }
  return false;
}
function isGeneric(c) {
  if (c.match(/T\d+/g)) {
    return true;
  }
  return false;
}
function nextToken(tagStr, pos) {
  const c = tagStr[pos];
  if (c === ":") {
    if (tagStr.slice(pos, pos + 2) === "::") {
      return [["COLON", "::"], 2];
    }
    bail("Unrecognized token.");
  } else if (c === "<") {
    return [["LT", "<"], 1];
  } else if (c === ">") {
    return [["GT", ">"], 1];
  } else if (c === ",") {
    return [["COMMA", ","], 1];
  } else if (isWhiteSpace(c)) {
    let res = "";
    for (let i4 = pos; i4 < tagStr.length; i4 += 1) {
      const char = tagStr[i4];
      if (isWhiteSpace(char)) {
        res = `${res}${char}`;
      } else {
        break;
      }
    }
    return [["SPACE", res], res.length];
  } else if (isValidAlphabetic(c)) {
    let res = "";
    for (let i4 = pos; i4 < tagStr.length; i4 += 1) {
      const char = tagStr[i4];
      if (isValidAlphabetic(char)) {
        res = `${res}${char}`;
      } else {
        break;
      }
    }
    if (isGeneric(res)) {
      return [["GENERIC", res], res.length];
    }
    return [["IDENT", res], res.length];
  }
  throw new Error("Unrecognized token.");
}
function tokenize(tagStr) {
  let pos = 0;
  const tokens = [];
  while (pos < tagStr.length) {
    const [token, size] = nextToken(tagStr, pos);
    if (token[0] !== "SPACE") {
      tokens.push(token);
    }
    pos += size;
  }
  return tokens;
}
var TypeTagParser = class _TypeTagParser {
  constructor(tagStr, typeTags) {
    this.typeTags = [];
    this.tokens = tokenize(tagStr);
    this.typeTags = typeTags || [];
  }
  consume(targetToken) {
    const token = this.tokens.shift();
    if (!token || token[1] !== targetToken) {
      bail("Invalid type tag.");
    }
  }
  /**
   * Consumes all of an unused generic field, mostly applicable to object
   *
   * Note: This is recursive.  it can be problematic if there's bad input
   * @private
   */
  consumeWholeGeneric() {
    this.consume("<");
    while (this.tokens[0][1] !== ">") {
      if (this.tokens[0][1] === "<") {
        this.consumeWholeGeneric();
      } else {
        this.tokens.shift();
      }
    }
    this.consume(">");
  }
  parseCommaList(endToken, allowTraillingComma) {
    const res = [];
    if (this.tokens.length <= 0) {
      bail("Invalid type tag.");
    }
    while (this.tokens[0][1] !== endToken) {
      res.push(this.parseTypeTag());
      if (this.tokens.length > 0 && this.tokens[0][1] === endToken) {
        break;
      }
      this.consume(",");
      if (this.tokens.length > 0 && this.tokens[0][1] === endToken && allowTraillingComma) {
        break;
      }
      if (this.tokens.length <= 0) {
        bail("Invalid type tag.");
      }
    }
    return res;
  }
  parseTypeTag() {
    if (this.tokens.length === 0) {
      bail("Invalid type tag.");
    }
    const [tokenTy, tokenVal] = this.tokens.shift();
    if (tokenVal === "u8") {
      return new TypeTagU8();
    }
    if (tokenVal === "u16") {
      return new TypeTagU16();
    }
    if (tokenVal === "u32") {
      return new TypeTagU32();
    }
    if (tokenVal === "u64") {
      return new TypeTagU64();
    }
    if (tokenVal === "u128") {
      return new TypeTagU128();
    }
    if (tokenVal === "u256") {
      return new TypeTagU256();
    }
    if (tokenVal === "bool") {
      return new TypeTagBool();
    }
    if (tokenVal === "address") {
      return new TypeTagAddress();
    }
    if (tokenVal === "vector") {
      this.consume("<");
      const res = this.parseTypeTag();
      this.consume(">");
      return new TypeTagVector(res);
    }
    if (tokenVal === "string") {
      return new TypeTagStruct(stringStructTag);
    }
    if (tokenTy === "IDENT" && (tokenVal.startsWith("0x") || tokenVal.startsWith("0X"))) {
      const address = AccountAddress.fromHex(tokenVal);
      this.consume("::");
      const [moduleTokenTy, module] = this.tokens.shift();
      if (moduleTokenTy !== "IDENT") {
        bail("Invalid type tag.");
      }
      this.consume("::");
      const [nameTokenTy, name] = this.tokens.shift();
      if (nameTokenTy !== "IDENT") {
        bail("Invalid type tag.");
      }
      if (AccountAddress.CORE_CODE_ADDRESS.toHexString() === address.toHexString() && module === "object" && name === "Object") {
        this.consumeWholeGeneric();
        return new TypeTagAddress();
      }
      let tyTags = [];
      if (this.tokens.length > 0 && this.tokens[0][1] === "<") {
        this.consume("<");
        tyTags = this.parseCommaList(">", true);
        this.consume(">");
      }
      const structTag = new StructTag(address, new Identifier(module), new Identifier(name), tyTags);
      return new TypeTagStruct(structTag);
    }
    if (tokenTy === "GENERIC") {
      if (this.typeTags.length === 0) {
        bail("Can't convert generic type since no typeTags were specified.");
      }
      const idx = parseInt(tokenVal.substring(1), 10);
      return new _TypeTagParser(this.typeTags[idx]).parseTypeTag();
    }
    throw new Error("Invalid type tag.");
  }
};
var TypeTagParserError = class extends Error {
  constructor(message) {
    super(message);
    this.name = "TypeTagParserError";
  }
};
var RawTransaction = class _RawTransaction {
  /**
   * RawTransactions contain the metadata and payloads that can be submitted to Aptos chain for execution.
   * RawTransactions must be signed before Aptos chain can execute them.
   *
   * @param sender Account address of the sender.
   * @param sequence_number Sequence number of this transaction. This must match the sequence number stored in
   *   the sender's account at the time the transaction executes.
   * @param payload Instructions for the Aptos Blockchain, including publishing a module,
   *   execute a entry function or execute a script payload.
   * @param max_gas_amount Maximum total gas to spend for this transaction. The account must have more
   *   than this gas or the transaction will be discarded during validation.
   * @param gas_unit_price Price to be paid per gas unit.
   * @param expiration_timestamp_secs The blockchain timestamp at which the blockchain would discard this transaction.
   * @param chain_id The chain ID of the blockchain that this transaction is intended to be run on.
   */
  constructor(sender, sequence_number, payload, max_gas_amount, gas_unit_price, expiration_timestamp_secs, chain_id) {
    this.sender = sender;
    this.sequence_number = sequence_number;
    this.payload = payload;
    this.max_gas_amount = max_gas_amount;
    this.gas_unit_price = gas_unit_price;
    this.expiration_timestamp_secs = expiration_timestamp_secs;
    this.chain_id = chain_id;
  }
  serialize(serializer) {
    this.sender.serialize(serializer);
    serializer.serializeU64(this.sequence_number);
    this.payload.serialize(serializer);
    serializer.serializeU64(this.max_gas_amount);
    serializer.serializeU64(this.gas_unit_price);
    serializer.serializeU64(this.expiration_timestamp_secs);
    this.chain_id.serialize(serializer);
  }
  static deserialize(deserializer) {
    const sender = AccountAddress.deserialize(deserializer);
    const sequence_number = deserializer.deserializeU64();
    const payload = TransactionPayload.deserialize(deserializer);
    const max_gas_amount = deserializer.deserializeU64();
    const gas_unit_price = deserializer.deserializeU64();
    const expiration_timestamp_secs = deserializer.deserializeU64();
    const chain_id = ChainId.deserialize(deserializer);
    return new _RawTransaction(
      sender,
      sequence_number,
      payload,
      max_gas_amount,
      gas_unit_price,
      expiration_timestamp_secs,
      chain_id
    );
  }
};
var Script = class _Script {
  /**
   * Scripts contain the Move bytecodes payload that can be submitted to Aptos chain for execution.
   * @param code Move bytecode
   * @param ty_args Type arguments that bytecode requires.
   *
   * @example
   * A coin transfer function has one type argument "CoinType".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   * @param args Arugments to bytecode function.
   *
   * @example
   * A coin transfer function has three arugments "from", "to" and "amount".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   */
  constructor(code, ty_args, args) {
    this.code = code;
    this.ty_args = ty_args;
    this.args = args;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.code);
    serializeVector(this.ty_args, serializer);
    serializeVector(this.args, serializer);
  }
  static deserialize(deserializer) {
    const code = deserializer.deserializeBytes();
    const ty_args = deserializeVector(deserializer, TypeTag);
    const args = deserializeVector(deserializer, TransactionArgument);
    return new _Script(code, ty_args, args);
  }
};
var EntryFunction = class _EntryFunction {
  /**
   * Contains the payload to run a function within a module.
   * @param module_name Fully qualified module name. ModuleId consists of account address and module name.
   * @param function_name The function to run.
   * @param ty_args Type arguments that move function requires.
   *
   * @example
   * A coin transfer function has one type argument "CoinType".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   * @param args Arugments to the move function.
   *
   * @example
   * A coin transfer function has three arugments "from", "to" and "amount".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   */
  constructor(module_name, function_name, ty_args, args) {
    this.module_name = module_name;
    this.function_name = function_name;
    this.ty_args = ty_args;
    this.args = args;
  }
  /**
   *
   * @param module Fully qualified module name in format "AccountAddress::module_name" e.g. "0x1::coin"
   * @param func Function name
   * @param ty_args Type arguments that move function requires.
   *
   * @example
   * A coin transfer function has one type argument "CoinType".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   * @param args Arugments to the move function.
   *
   * @example
   * A coin transfer function has three arugments "from", "to" and "amount".
   * ```
   * public(script) fun transfer<CoinType>(from: &signer, to: address, amount: u64,)
   * ```
   * @returns
   */
  static natural(module, func, ty_args, args) {
    return new _EntryFunction(ModuleId.fromStr(module), new Identifier(func), ty_args, args);
  }
  /**
   * `natual` is deprecated, please use `natural`
   *
   * @deprecated.
   */
  static natual(module, func, ty_args, args) {
    return _EntryFunction.natural(module, func, ty_args, args);
  }
  serialize(serializer) {
    this.module_name.serialize(serializer);
    this.function_name.serialize(serializer);
    serializeVector(this.ty_args, serializer);
    serializer.serializeU32AsUleb128(this.args.length);
    this.args.forEach((item) => {
      serializer.serializeBytes(item);
    });
  }
  static deserialize(deserializer) {
    const module_name = ModuleId.deserialize(deserializer);
    const function_name = Identifier.deserialize(deserializer);
    const ty_args = deserializeVector(deserializer, TypeTag);
    const length = deserializer.deserializeUleb128AsU32();
    const list = [];
    for (let i4 = 0; i4 < length; i4 += 1) {
      list.push(deserializer.deserializeBytes());
    }
    const args = list;
    return new _EntryFunction(module_name, function_name, ty_args, args);
  }
};
var MultiSigTransactionPayload = class _MultiSigTransactionPayload {
  /**
   * Contains the payload to run a multisig account transaction.
   * @param transaction_payload The payload of the multisig transaction. This can only be EntryFunction for now but
   * Script might be supported in the future.
   */
  constructor(transaction_payload) {
    this.transaction_payload = transaction_payload;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.transaction_payload.serialize(serializer);
  }
  static deserialize(deserializer) {
    deserializer.deserializeUleb128AsU32();
    return new _MultiSigTransactionPayload(EntryFunction.deserialize(deserializer));
  }
};
var MultiSig = class _MultiSig {
  /**
   * Contains the payload to run a multisig account transaction.
   * @param multisig_address The multisig account address the transaction will be executed as.
   * @param transaction_payload The payload of the multisig transaction. This is optional when executing a multisig
   *  transaction whose payload is already stored on chain.
   */
  constructor(multisig_address, transaction_payload) {
    this.multisig_address = multisig_address;
    this.transaction_payload = transaction_payload;
  }
  serialize(serializer) {
    this.multisig_address.serialize(serializer);
    if (this.transaction_payload === void 0) {
      serializer.serializeBool(false);
    } else {
      serializer.serializeBool(true);
      this.transaction_payload.serialize(serializer);
    }
  }
  static deserialize(deserializer) {
    const multisig_address = AccountAddress.deserialize(deserializer);
    const payloadPresent = deserializer.deserializeBool();
    let transaction_payload;
    if (payloadPresent) {
      transaction_payload = MultiSigTransactionPayload.deserialize(deserializer);
    }
    return new _MultiSig(multisig_address, transaction_payload);
  }
};
var Module = class _Module {
  /**
   * Contains the bytecode of a Move module that can be published to the Aptos chain.
   * @param code Move bytecode of a module.
   */
  constructor(code) {
    this.code = code;
  }
  serialize(serializer) {
    serializer.serializeBytes(this.code);
  }
  static deserialize(deserializer) {
    const code = deserializer.deserializeBytes();
    return new _Module(code);
  }
};
var ModuleId = class _ModuleId {
  /**
   * Full name of a module.
   * @param address The account address.
   * @param name The name of the module under the account at "address".
   */
  constructor(address, name) {
    this.address = address;
    this.name = name;
  }
  /**
   * Converts a string literal to a ModuleId
   * @param moduleId String literal in format "AccountAddress::module_name", e.g. "0x1::coin"
   * @returns
   */
  static fromStr(moduleId) {
    const parts = moduleId.split("::");
    if (parts.length !== 2) {
      throw new Error("Invalid module id.");
    }
    return new _ModuleId(AccountAddress.fromHex(new HexString(parts[0])), new Identifier(parts[1]));
  }
  serialize(serializer) {
    this.address.serialize(serializer);
    this.name.serialize(serializer);
  }
  static deserialize(deserializer) {
    const address = AccountAddress.deserialize(deserializer);
    const name = Identifier.deserialize(deserializer);
    return new _ModuleId(address, name);
  }
};
var ChangeSet = class {
  serialize(serializer) {
    throw new Error("Not implemented.");
  }
  static deserialize(deserializer) {
    throw new Error("Not implemented.");
  }
};
var WriteSet = class {
  serialize(serializer) {
    throw new Error("Not implmented.");
  }
  static deserialize(deserializer) {
    throw new Error("Not implmented.");
  }
};
var SignedTransaction = class _SignedTransaction {
  /**
   * A SignedTransaction consists of a raw transaction and an authenticator. The authenticator
   * contains a client's public key and the signature of the raw transaction.
   *
   * @see {@link https://aptos.dev/guides/creating-a-signed-transaction/ | Creating a Signed Transaction}
   *
   * @param raw_txn
   * @param authenticator Contains a client's public key and the signature of the raw transaction.
   *   Authenticator has 3 flavors: single signature, multi-signature and multi-agent.
   *   @see authenticator.ts for details.
   */
  constructor(raw_txn, authenticator) {
    this.raw_txn = raw_txn;
    this.authenticator = authenticator;
  }
  serialize(serializer) {
    this.raw_txn.serialize(serializer);
    this.authenticator.serialize(serializer);
  }
  static deserialize(deserializer) {
    const raw_txn = RawTransaction.deserialize(deserializer);
    const authenticator = TransactionAuthenticator.deserialize(deserializer);
    return new _SignedTransaction(raw_txn, authenticator);
  }
};
var RawTransactionWithData = class {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return MultiAgentRawTransaction.load(deserializer);
      case 1:
        return FeePayerRawTransaction.load(deserializer);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${index}`);
    }
  }
};
var MultiAgentRawTransaction = class _MultiAgentRawTransaction extends RawTransactionWithData {
  constructor(raw_txn, secondary_signer_addresses) {
    super();
    this.raw_txn = raw_txn;
    this.secondary_signer_addresses = secondary_signer_addresses;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.raw_txn.serialize(serializer);
    serializeVector(this.secondary_signer_addresses, serializer);
  }
  static load(deserializer) {
    const rawTxn = RawTransaction.deserialize(deserializer);
    const secondarySignerAddresses = deserializeVector(deserializer, AccountAddress);
    return new _MultiAgentRawTransaction(rawTxn, secondarySignerAddresses);
  }
};
var FeePayerRawTransaction = class _FeePayerRawTransaction extends RawTransactionWithData {
  constructor(raw_txn, secondary_signer_addresses, fee_payer_address) {
    super();
    this.raw_txn = raw_txn;
    this.secondary_signer_addresses = secondary_signer_addresses;
    this.fee_payer_address = fee_payer_address;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
    this.raw_txn.serialize(serializer);
    serializeVector(this.secondary_signer_addresses, serializer);
    this.fee_payer_address.serialize(serializer);
  }
  static load(deserializer) {
    const rawTxn = RawTransaction.deserialize(deserializer);
    const secondarySignerAddresses = deserializeVector(deserializer, AccountAddress);
    const feePayerAddress = AccountAddress.deserialize(deserializer);
    return new _FeePayerRawTransaction(rawTxn, secondarySignerAddresses, feePayerAddress);
  }
};
var TransactionPayload = class {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TransactionPayloadScript.load(deserializer);
      case 2:
        return TransactionPayloadEntryFunction.load(deserializer);
      case 3:
        return TransactionPayloadMultisig.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);
    }
  }
};
var TransactionPayloadScript = class _TransactionPayloadScript extends TransactionPayload {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = Script.deserialize(deserializer);
    return new _TransactionPayloadScript(value);
  }
};
var TransactionPayloadEntryFunction = class _TransactionPayloadEntryFunction extends TransactionPayload {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(2);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = EntryFunction.deserialize(deserializer);
    return new _TransactionPayloadEntryFunction(value);
  }
};
var TransactionPayloadMultisig = class _TransactionPayloadMultisig extends TransactionPayload {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(3);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = MultiSig.deserialize(deserializer);
    return new _TransactionPayloadMultisig(value);
  }
};
var ChainId = class _ChainId {
  constructor(value) {
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU8(this.value);
  }
  static deserialize(deserializer) {
    const value = deserializer.deserializeU8();
    return new _ChainId(value);
  }
};
var TransactionArgument = class {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TransactionArgumentU8.load(deserializer);
      case 1:
        return TransactionArgumentU64.load(deserializer);
      case 2:
        return TransactionArgumentU128.load(deserializer);
      case 3:
        return TransactionArgumentAddress.load(deserializer);
      case 4:
        return TransactionArgumentU8Vector.load(deserializer);
      case 5:
        return TransactionArgumentBool.load(deserializer);
      case 6:
        return TransactionArgumentU16.load(deserializer);
      case 7:
        return TransactionArgumentU32.load(deserializer);
      case 8:
        return TransactionArgumentU256.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionArgument: ${index}`);
    }
  }
};
var TransactionArgumentU8 = class _TransactionArgumentU8 extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    serializer.serializeU8(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU8();
    return new _TransactionArgumentU8(value);
  }
};
var TransactionArgumentU16 = class _TransactionArgumentU16 extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(6);
    serializer.serializeU16(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU16();
    return new _TransactionArgumentU16(value);
  }
};
var TransactionArgumentU32 = class _TransactionArgumentU32 extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(7);
    serializer.serializeU32(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU32();
    return new _TransactionArgumentU32(value);
  }
};
var TransactionArgumentU64 = class _TransactionArgumentU64 extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
    serializer.serializeU64(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU64();
    return new _TransactionArgumentU64(value);
  }
};
var TransactionArgumentU128 = class _TransactionArgumentU128 extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(2);
    serializer.serializeU128(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU128();
    return new _TransactionArgumentU128(value);
  }
};
var TransactionArgumentU256 = class _TransactionArgumentU256 extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(8);
    serializer.serializeU256(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeU256();
    return new _TransactionArgumentU256(value);
  }
};
var TransactionArgumentAddress = class _TransactionArgumentAddress extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(3);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    const value = AccountAddress.deserialize(deserializer);
    return new _TransactionArgumentAddress(value);
  }
};
var TransactionArgumentU8Vector = class _TransactionArgumentU8Vector extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(4);
    serializer.serializeBytes(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeBytes();
    return new _TransactionArgumentU8Vector(value);
  }
};
var TransactionArgumentBool = class _TransactionArgumentBool extends TransactionArgument {
  constructor(value) {
    super();
    this.value = value;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(5);
    serializer.serializeBool(this.value);
  }
  static load(deserializer) {
    const value = deserializer.deserializeBool();
    return new _TransactionArgumentBool(value);
  }
};
var Transaction = class {
  getHashSalt() {
    const hash2 = sha3_2562.create();
    hash2.update("APTOS::Transaction");
    return hash2.digest();
  }
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return UserTransaction.load(deserializer);
      default:
        throw new Error(`Unknown variant index for Transaction: ${index}`);
    }
  }
};
var UserTransaction = class _UserTransaction extends Transaction {
  constructor(value) {
    super();
    this.value = value;
  }
  hash() {
    const hash2 = sha3_2562.create();
    hash2.update(this.getHashSalt());
    hash2.update(bcsToBytes(this));
    return hash2.digest();
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    this.value.serialize(serializer);
  }
  static load(deserializer) {
    return new _UserTransaction(SignedTransaction.deserialize(deserializer));
  }
};
var TypeArgumentABI = class _TypeArgumentABI {
  /**
   * Constructs a TypeArgumentABI instance.
   * @param name
   */
  constructor(name) {
    this.name = name;
  }
  serialize(serializer) {
    serializer.serializeStr(this.name);
  }
  static deserialize(deserializer) {
    const name = deserializer.deserializeStr();
    return new _TypeArgumentABI(name);
  }
};
var ArgumentABI = class _ArgumentABI {
  /**
   * Constructs an ArgumentABI instance.
   * @param name
   * @param type_tag
   */
  constructor(name, type_tag) {
    this.name = name;
    this.type_tag = type_tag;
  }
  serialize(serializer) {
    serializer.serializeStr(this.name);
    this.type_tag.serialize(serializer);
  }
  static deserialize(deserializer) {
    const name = deserializer.deserializeStr();
    const typeTag = TypeTag.deserialize(deserializer);
    return new _ArgumentABI(name, typeTag);
  }
};
var ScriptABI = class {
  static deserialize(deserializer) {
    const index = deserializer.deserializeUleb128AsU32();
    switch (index) {
      case 0:
        return TransactionScriptABI.load(deserializer);
      case 1:
        return EntryFunctionABI.load(deserializer);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${index}`);
    }
  }
};
var TransactionScriptABI = class _TransactionScriptABI extends ScriptABI {
  /**
   * Constructs a TransactionScriptABI instance.
   * @param name Entry function name
   * @param doc
   * @param code
   * @param ty_args
   * @param args
   */
  constructor(name, doc, code, ty_args, args) {
    super();
    this.name = name;
    this.doc = doc;
    this.code = code;
    this.ty_args = ty_args;
    this.args = args;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(0);
    serializer.serializeStr(this.name);
    serializer.serializeStr(this.doc);
    serializer.serializeBytes(this.code);
    serializeVector(this.ty_args, serializer);
    serializeVector(this.args, serializer);
  }
  static load(deserializer) {
    const name = deserializer.deserializeStr();
    const doc = deserializer.deserializeStr();
    const code = deserializer.deserializeBytes();
    const tyArgs = deserializeVector(deserializer, TypeArgumentABI);
    const args = deserializeVector(deserializer, ArgumentABI);
    return new _TransactionScriptABI(name, doc, code, tyArgs, args);
  }
};
var EntryFunctionABI = class _EntryFunctionABI extends ScriptABI {
  /**
   * Constructs a EntryFunctionABI instance
   * @param name
   * @param module_name Fully qualified module id
   * @param doc
   * @param ty_args
   * @param args
   */
  constructor(name, module_name, doc, ty_args, args) {
    super();
    this.name = name;
    this.module_name = module_name;
    this.doc = doc;
    this.ty_args = ty_args;
    this.args = args;
  }
  serialize(serializer) {
    serializer.serializeU32AsUleb128(1);
    serializer.serializeStr(this.name);
    this.module_name.serialize(serializer);
    serializer.serializeStr(this.doc);
    serializeVector(this.ty_args, serializer);
    serializeVector(this.args, serializer);
  }
  static load(deserializer) {
    const name = deserializer.deserializeStr();
    const moduleName = ModuleId.deserialize(deserializer);
    const doc = deserializer.deserializeStr();
    const tyArgs = deserializeVector(deserializer, TypeArgumentABI);
    const args = deserializeVector(deserializer, ArgumentABI);
    return new _EntryFunctionABI(name, moduleName, doc, tyArgs, args);
  }
};
var _AuthenticationKey = class _AuthenticationKey2 {
  constructor(bytes2) {
    if (bytes2.length !== _AuthenticationKey2.LENGTH) {
      throw new Error("Expected a byte array of length 32");
    }
    this.bytes = bytes2;
  }
  /**
   * Converts a K-of-N MultiEd25519PublicKey to AuthenticationKey with:
   * `auth_key = sha3-256(p_1 |  | p_n | K | 0x01)`. `K` represents the K-of-N required for
   * authenticating the transaction. `0x01` is the 1-byte scheme for multisig.
   */
  static fromMultiEd25519PublicKey(publicKey) {
    const pubKeyBytes = publicKey.toBytes();
    const bytes2 = new Uint8Array(pubKeyBytes.length + 1);
    bytes2.set(pubKeyBytes);
    bytes2.set([_AuthenticationKey2.MULTI_ED25519_SCHEME], pubKeyBytes.length);
    const hash2 = sha3_2562.create();
    hash2.update(bytes2);
    return new _AuthenticationKey2(hash2.digest());
  }
  static fromEd25519PublicKey(publicKey) {
    const pubKeyBytes = publicKey.value;
    const bytes2 = new Uint8Array(pubKeyBytes.length + 1);
    bytes2.set(pubKeyBytes);
    bytes2.set([_AuthenticationKey2.ED25519_SCHEME], pubKeyBytes.length);
    const hash2 = sha3_2562.create();
    hash2.update(bytes2);
    return new _AuthenticationKey2(hash2.digest());
  }
  /**
   * Derives an account address from AuthenticationKey. Since current AccountAddress is 32 bytes,
   * AuthenticationKey bytes are directly translated to AccountAddress.
   */
  derivedAddress() {
    return HexString.fromUint8Array(this.bytes);
  }
};
_AuthenticationKey.LENGTH = 32;
_AuthenticationKey.MULTI_ED25519_SCHEME = 1;
_AuthenticationKey.ED25519_SCHEME = 0;
_AuthenticationKey.DERIVE_RESOURCE_ACCOUNT_SCHEME = 255;
var AuthenticationKey = _AuthenticationKey;
var RotationProofChallenge = class {
  constructor(accountAddress, moduleName, structName, sequenceNumber, originator, currentAuthKey, newPublicKey) {
    this.accountAddress = accountAddress;
    this.moduleName = moduleName;
    this.structName = structName;
    this.sequenceNumber = sequenceNumber;
    this.originator = originator;
    this.currentAuthKey = currentAuthKey;
    this.newPublicKey = newPublicKey;
  }
  serialize(serializer) {
    this.accountAddress.serialize(serializer);
    serializer.serializeStr(this.moduleName);
    serializer.serializeStr(this.structName);
    serializer.serializeU64(this.sequenceNumber);
    this.originator.serialize(serializer);
    this.currentAuthKey.serialize(serializer);
    serializer.serializeBytes(this.newPublicKey);
  }
};
var _AptosAccount = class _AptosAccount2 {
  static fromAptosAccountObject(obj) {
    return new _AptosAccount2(HexString.ensure(obj.privateKeyHex).toUint8Array(), obj.address);
  }
  /**
   * Check's if the derive path is valid
   */
  static isValidPath(path) {
    return /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'+$/.test(path);
  }
  /**
   * Creates new account with bip44 path and mnemonics,
   * @param path. (e.g. m/44'/637'/0'/0'/0')
   * Detailed description: {@link https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki}
   * @param mnemonics.
   * @returns AptosAccount
   */
  static fromDerivePath(path, mnemonics) {
    if (!_AptosAccount2.isValidPath(path)) {
      throw new Error("Invalid derivation path");
    }
    const normalizeMnemonics = mnemonics.trim().split(/\s+/).map((part) => part.toLowerCase()).join(" ");
    const { key } = derivePath(path, bytesToHex(mnemonicToSeedSync(normalizeMnemonics)));
    return new _AptosAccount2(key);
  }
  /**
   * Creates new account instance. Constructor allows passing in an address,
   * to handle account key rotation, where auth_key != public_key
   * @param privateKeyBytes  Private key from which account key pair will be generated.
   * If not specified, new key pair is going to be created.
   * @param address Account address (e.g. 0xe8012714cd17606cee7188a2a365eef3fe760be598750678c8c5954eb548a591).
   * If not specified, a new one will be generated from public key
   */
  constructor(privateKeyBytes, address) {
    if (privateKeyBytes) {
      this.signingKey = import_tweetnacl.default.sign.keyPair.fromSeed(privateKeyBytes.slice(0, 32));
    } else {
      this.signingKey = import_tweetnacl.default.sign.keyPair();
    }
    this.accountAddress = HexString.ensure(address || this.authKey().hex());
  }
  /**
   * This is the key by which Aptos account is referenced.
   * It is the 32-byte of the SHA-3 256 cryptographic hash
   * of the public key(s) concatenated with a signature scheme identifier byte
   * @returns Address associated with the given account
   */
  address() {
    return this.accountAddress;
  }
  authKey() {
    const pubKey = new Ed25519PublicKey(this.signingKey.publicKey);
    const authKey = AuthenticationKey.fromEd25519PublicKey(pubKey);
    return authKey.derivedAddress();
  }
  /**
   * Takes source address and seeds and returns the resource account address
   * @param sourceAddress Address used to derive the resource account
   * @param seed The seed bytes
   * @returns The resource account address
   */
  static getResourceAccountAddress(sourceAddress, seed) {
    const source = bcsToBytes(AccountAddress.fromHex(sourceAddress));
    const bytes2 = new Uint8Array([...source, ...seed, AuthenticationKey.DERIVE_RESOURCE_ACCOUNT_SCHEME]);
    const hash2 = sha3_2562.create();
    hash2.update(bytes2);
    return HexString.fromUint8Array(hash2.digest());
  }
  /**
   * Takes creator address and collection name and returns the collection id hash.
   * Collection id hash are generated as sha256 hash of (`creator_address::collection_name`)
   *
   * @param creatorAddress Collection creator address
   * @param collectionName The collection name
   * @returns The collection id hash
   */
  static getCollectionID(creatorAddress, collectionName) {
    const seed = new TextEncoder().encode(`${creatorAddress}::${collectionName}`);
    const hash2 = sha256.create();
    hash2.update(seed);
    return HexString.fromUint8Array(hash2.digest());
  }
  /**
   * This key is generated with Ed25519 scheme.
   * Public key is used to check a signature of transaction, signed by given account
   * @returns The public key for the associated account
   */
  pubKey() {
    return HexString.fromUint8Array(this.signingKey.publicKey);
  }
  /**
   * Signs specified `buffer` with account's private key
   * @param buffer A buffer to sign
   * @returns A signature HexString
   */
  signBuffer(buffer) {
    const signature = import_tweetnacl.default.sign.detached(buffer, this.signingKey.secretKey);
    return HexString.fromUint8Array(signature);
  }
  /**
   * Signs specified `hexString` with account's private key
   * @param hexString A regular string or HexString to sign
   * @returns A signature HexString
   */
  signHexString(hexString) {
    const toSign = HexString.ensure(hexString).toUint8Array();
    return this.signBuffer(toSign);
  }
  /**
   * Verifies the signature of the message with the public key of the account
   * @param message a signed message
   * @param signature the signature of the message
   */
  verifySignature(message, signature) {
    const rawMessage = HexString.ensure(message).toUint8Array();
    const rawSignature = HexString.ensure(signature).toUint8Array();
    return import_tweetnacl.default.sign.detached.verify(rawMessage, rawSignature, this.signingKey.publicKey);
  }
  /**
   * Derives account address, public key and private key
   * @returns AptosAccountObject instance.
   * @example An example of the returned AptosAccountObject object
   * ```
   * {
   *    address: "0xe8012714cd17606cee7188a2a365eef3fe760be598750678c8c5954eb548a591",
   *    publicKeyHex: "0xf56d8524faf79fbc0f48c13aeed3b0ce5dd376b4db93b8130a107c0a5e04ba04",
   *    privateKeyHex: `0x009c9f7c992a06cfafe916f125d8adb7a395fca243e264a8e56a4b3e6accf940
   *      d2b11e9ece3049ce60e3c7b4a1c58aebfa9298e29a30a58a67f1998646135204`
   * }
   * ```
   */
  toPrivateKeyObject() {
    return {
      address: this.address().hex(),
      publicKeyHex: this.pubKey().hex(),
      privateKeyHex: HexString.fromUint8Array(this.signingKey.secretKey.slice(0, 32)).hex()
    };
  }
};
__decorateClass([
  Memoize()
], _AptosAccount.prototype, "authKey", 1);
var AptosAccount = _AptosAccount;
var CurrentTokenOwnershipFieldsFragmentDoc = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
var TokenDataFieldsFragmentDoc = `
    fragment TokenDataFields on current_token_datas {
  creator_address
  collection_name
  description
  metadata_uri
  name
  token_data_id_hash
  collection_data_id_hash
}
    `;
var CollectionDataFieldsFragmentDoc = `
    fragment CollectionDataFields on current_collection_datas {
  metadata_uri
  supply
  description
  collection_name
  collection_data_id_hash
  table_handle
  creator_address
}
    `;
var TokenActivitiesFieldsFragmentDoc = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
var GetAccountCoinsDataCount = `
    query getAccountCoinsDataCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
var GetAccountCoinsData = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
var GetAccountCurrentTokens = `
    query getAccountCurrentTokens($address: String!, $offset: Int, $limit: Int) {
  current_token_ownerships(
    where: {owner_address: {_eq: $address}, amount: {_gt: 0}}
    order_by: [{last_transaction_version: desc}, {creator_address: asc}, {collection_name: asc}, {name: asc}]
    offset: $offset
    limit: $limit
  ) {
    amount
    current_token_data {
      ...TokenDataFields
    }
    current_collection_data {
      ...CollectionDataFields
    }
    last_transaction_version
    property_version
  }
}
    ${TokenDataFieldsFragmentDoc}
${CollectionDataFieldsFragmentDoc}`;
var GetAccountTokensCount = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
var GetAccountTransactionsCount = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
var GetAccountTransactionsData = `
    query getAccountTransactionsData($where_condition: account_transactions_bool_exp!, $offset: Int, $limit: Int, $order_by: [account_transactions_order_by!]) {
  account_transactions(
    where: $where_condition
    order_by: $order_by
    limit: $limit
    offset: $offset
  ) {
    token_activities_v2 {
      ...TokenActivitiesFields
    }
    transaction_version
    account_address
  }
}
    ${TokenActivitiesFieldsFragmentDoc}`;
var GetCollectionData = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collections_v2_order_by!]) {
  current_collections_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    max_supply
    mutable_description
    mutable_uri
    table_handle_v1
    token_standard
    total_minted_v2
    uri
  }
}
    `;
var GetCollectionsWithOwnedTokens = `
    query getCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
var GetCurrentObjects = `
    query getCurrentObjects($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
var GetDelegatedStakingActivities = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
var GetIndexerLedgerInfo = `
    query getIndexerLedgerInfo {
  ledger_infos {
    chain_id
  }
}
    `;
var GetNumberOfDelegators = `
    query getNumberOfDelegators($poolAddress: String) {
  num_active_delegator_per_pool(
    where: {pool_address: {_eq: $poolAddress}, num_active_delegator: {_gt: "0"}}
    distinct_on: pool_address
  ) {
    num_active_delegator
    pool_address
  }
}
    `;
var GetOwnedTokens = `
    query getOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetOwnedTokensByTokenData = `
    query getOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetTokenActivities = `
    query getTokenActivities($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${TokenActivitiesFieldsFragmentDoc}`;
var GetTokenActivitiesCount = `
    query getTokenActivitiesCount($token_id: String) {
  token_activities_v2_aggregate(where: {token_data_id: {_eq: $token_id}}) {
    aggregate {
      count
    }
  }
}
    `;
var GetTokenCurrentOwnerData = `
    query getTokenCurrentOwnerData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetTokenData = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
var GetTokenOwnedFromCollection = `
    query getTokenOwnedFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetTokenOwnersData = `
    query getTokenOwnersData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${CurrentTokenOwnershipFieldsFragmentDoc}`;
var GetTopUserTransactions = `
    query getTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
var GetUserTransactions = `
    query getUserTransactions($where_condition: user_transactions_bool_exp!, $offset: Int, $limit: Int, $order_by: [user_transactions_order_by!]) {
  user_transactions(
    order_by: $order_by
    where: $where_condition
    limit: $limit
    offset: $offset
  ) {
    version
  }
}
    `;
function assertType(val, types, message) {
  if (!(types == null ? void 0 : types.includes(typeof val))) {
    throw new Error(
      message || `Invalid arg: ${val} type should be ${types instanceof Array ? types.join(" or ") : types}`
    );
  }
}
function ensureBoolean(val) {
  assertType(val, ["boolean", "string"]);
  if (typeof val === "boolean") {
    return val;
  }
  if (val === "true") {
    return true;
  }
  if (val === "false") {
    return false;
  }
  throw new Error("Invalid boolean string.");
}
function ensureNumber(val) {
  assertType(val, ["number", "string"]);
  if (typeof val === "number") {
    return val;
  }
  const res = Number.parseInt(val, 10);
  if (Number.isNaN(res)) {
    throw new Error("Invalid number string.");
  }
  return res;
}
function ensureBigInt(val) {
  assertType(val, ["number", "bigint", "string"]);
  return BigInt(val);
}
function serializeArg(argVal, argType, serializer) {
  serializeArgInner(argVal, argType, serializer, 0);
}
function serializeArgInner(argVal, argType, serializer, depth) {
  if (argType instanceof TypeTagBool) {
    serializer.serializeBool(ensureBoolean(argVal));
  } else if (argType instanceof TypeTagU8) {
    serializer.serializeU8(ensureNumber(argVal));
  } else if (argType instanceof TypeTagU16) {
    serializer.serializeU16(ensureNumber(argVal));
  } else if (argType instanceof TypeTagU32) {
    serializer.serializeU32(ensureNumber(argVal));
  } else if (argType instanceof TypeTagU64) {
    serializer.serializeU64(ensureBigInt(argVal));
  } else if (argType instanceof TypeTagU128) {
    serializer.serializeU128(ensureBigInt(argVal));
  } else if (argType instanceof TypeTagU256) {
    serializer.serializeU256(ensureBigInt(argVal));
  } else if (argType instanceof TypeTagAddress) {
    serializeAddress(argVal, serializer);
  } else if (argType instanceof TypeTagVector) {
    serializeVector2(argVal, argType, serializer, depth);
  } else if (argType instanceof TypeTagStruct) {
    serializeStruct(argVal, argType, serializer, depth);
  } else {
    throw new Error("Unsupported arg type.");
  }
}
function serializeAddress(argVal, serializer) {
  let addr;
  if (typeof argVal === "string" || argVal instanceof HexString) {
    addr = AccountAddress.fromHex(argVal);
  } else if (argVal instanceof AccountAddress) {
    addr = argVal;
  } else {
    throw new Error("Invalid account address.");
  }
  addr.serialize(serializer);
}
function serializeVector2(argVal, argType, serializer, depth) {
  if (argType.value instanceof TypeTagU8) {
    if (argVal instanceof Uint8Array) {
      serializer.serializeBytes(argVal);
      return;
    }
    if (argVal instanceof HexString) {
      serializer.serializeBytes(argVal.toUint8Array());
      return;
    }
    if (typeof argVal === "string") {
      serializer.serializeStr(argVal);
      return;
    }
  }
  if (!Array.isArray(argVal)) {
    throw new Error("Invalid vector args.");
  }
  serializer.serializeU32AsUleb128(argVal.length);
  argVal.forEach((arg) => serializeArgInner(arg, argType.value, serializer, depth + 1));
}
function serializeStruct(argVal, argType, serializer, depth) {
  const { address, module_name: moduleName, name, type_args: typeArgs } = argType.value;
  const structType = `${HexString.fromUint8Array(address.address).toShortString()}::${moduleName.value}::${name.value}`;
  if (structType === "0x1::string::String") {
    assertType(argVal, ["string"]);
    serializer.serializeStr(argVal);
  } else if (structType === "0x1::object::Object") {
    serializeAddress(argVal, serializer);
  } else if (structType === "0x1::option::Option") {
    if (typeArgs.length !== 1) {
      throw new Error(`Option has the wrong number of type arguments ${typeArgs.length}`);
    }
    serializeOption(argVal, typeArgs[0], serializer, depth);
  } else {
    throw new Error("Unsupported struct type in function argument");
  }
}
function serializeOption(argVal, argType, serializer, depth) {
  if (argVal === void 0 || argVal === null) {
    serializer.serializeU32AsUleb128(0);
  } else {
    serializer.serializeU32AsUleb128(1);
    serializeArgInner(argVal, argType, serializer, depth + 1);
  }
}
function argToTransactionArgument(argVal, argType) {
  if (argType instanceof TypeTagBool) {
    return new TransactionArgumentBool(ensureBoolean(argVal));
  }
  if (argType instanceof TypeTagU8) {
    return new TransactionArgumentU8(ensureNumber(argVal));
  }
  if (argType instanceof TypeTagU16) {
    return new TransactionArgumentU16(ensureNumber(argVal));
  }
  if (argType instanceof TypeTagU32) {
    return new TransactionArgumentU32(ensureNumber(argVal));
  }
  if (argType instanceof TypeTagU64) {
    return new TransactionArgumentU64(ensureBigInt(argVal));
  }
  if (argType instanceof TypeTagU128) {
    return new TransactionArgumentU128(ensureBigInt(argVal));
  }
  if (argType instanceof TypeTagU256) {
    return new TransactionArgumentU256(ensureBigInt(argVal));
  }
  if (argType instanceof TypeTagAddress) {
    let addr;
    if (typeof argVal === "string" || argVal instanceof HexString) {
      addr = AccountAddress.fromHex(argVal);
    } else if (argVal instanceof AccountAddress) {
      addr = argVal;
    } else {
      throw new Error("Invalid account address.");
    }
    return new TransactionArgumentAddress(addr);
  }
  if (argType instanceof TypeTagVector && argType.value instanceof TypeTagU8) {
    if (!(argVal instanceof Uint8Array)) {
      throw new Error(`${argVal} should be an instance of Uint8Array`);
    }
    return new TransactionArgumentU8Vector(argVal);
  }
  throw new Error("Unknown type for TransactionArgument.");
}
var RAW_TRANSACTION_SALT = "APTOS::RawTransaction";
var RAW_TRANSACTION_WITH_DATA_SALT = "APTOS::RawTransactionWithData";
var TransactionBuilder = class {
  constructor(signingFunction, rawTxnBuilder) {
    this.rawTxnBuilder = rawTxnBuilder;
    this.signingFunction = signingFunction;
  }
  /**
   * Builds a RawTransaction. Relays the call to TransactionBuilderABI.build
   * @param func
   * @param ty_tags
   * @param args
   */
  build(func, ty_tags, args) {
    if (!this.rawTxnBuilder) {
      throw new Error("this.rawTxnBuilder doesn't exist.");
    }
    return this.rawTxnBuilder.build(func, ty_tags, args);
  }
  /** Generates a Signing Message out of a raw transaction. */
  static getSigningMessage(rawTxn) {
    const hash2 = sha3_2562.create();
    if (rawTxn instanceof RawTransaction) {
      hash2.update(RAW_TRANSACTION_SALT);
    } else if (rawTxn instanceof MultiAgentRawTransaction) {
      hash2.update(RAW_TRANSACTION_WITH_DATA_SALT);
    } else if (rawTxn instanceof FeePayerRawTransaction) {
      hash2.update(RAW_TRANSACTION_WITH_DATA_SALT);
    } else {
      throw new Error("Unknown transaction type.");
    }
    const prefix = hash2.digest();
    const body = bcsToBytes(rawTxn);
    const mergedArray = new Uint8Array(prefix.length + body.length);
    mergedArray.set(prefix);
    mergedArray.set(body, prefix.length);
    return mergedArray;
  }
};
var TransactionBuilderEd25519 = class extends TransactionBuilder {
  constructor(signingFunction, publicKey, rawTxnBuilder) {
    super(signingFunction, rawTxnBuilder);
    this.publicKey = publicKey;
  }
  rawToSigned(rawTxn) {
    const signingMessage = TransactionBuilder.getSigningMessage(rawTxn);
    const signature = this.signingFunction(signingMessage);
    const authenticator = new TransactionAuthenticatorEd25519(
      new Ed25519PublicKey(this.publicKey),
      signature
    );
    return new SignedTransaction(rawTxn, authenticator);
  }
  /** Signs a raw transaction and returns a bcs serialized transaction. */
  sign(rawTxn) {
    return bcsToBytes(this.rawToSigned(rawTxn));
  }
};
var TransactionBuilderMultiEd25519 = class extends TransactionBuilder {
  constructor(signingFunction, publicKey) {
    super(signingFunction);
    this.publicKey = publicKey;
  }
  rawToSigned(rawTxn) {
    const signingMessage = TransactionBuilder.getSigningMessage(rawTxn);
    const signature = this.signingFunction(signingMessage);
    const authenticator = new TransactionAuthenticatorMultiEd25519(this.publicKey, signature);
    return new SignedTransaction(rawTxn, authenticator);
  }
  /** Signs a raw transaction and returns a bcs serialized transaction. */
  sign(rawTxn) {
    return bcsToBytes(this.rawToSigned(rawTxn));
  }
};
var TransactionBuilderABI = class _TransactionBuilderABI {
  /**
   * Constructs a TransactionBuilderABI instance
   * @param abis List of binary ABIs.
   * @param builderConfig Configs for creating a raw transaction.
   */
  constructor(abis, builderConfig) {
    this.abiMap = /* @__PURE__ */ new Map();
    abis.forEach((abi) => {
      const deserializer = new Deserializer(abi);
      const scriptABI = ScriptABI.deserialize(deserializer);
      let k2;
      if (scriptABI instanceof EntryFunctionABI) {
        const funcABI = scriptABI;
        const { address: addr, name: moduleName } = funcABI.module_name;
        k2 = `${HexString.fromUint8Array(addr.address).toShortString()}::${moduleName.value}::${funcABI.name}`;
      } else {
        const funcABI = scriptABI;
        k2 = funcABI.name;
      }
      if (this.abiMap.has(k2)) {
        throw new Error("Found conflicting ABI interfaces");
      }
      this.abiMap.set(k2, scriptABI);
    });
    this.builderConfig = {
      maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),
      expSecFromNow: DEFAULT_TXN_EXP_SEC_FROM_NOW,
      ...builderConfig
    };
  }
  static toBCSArgs(abiArgs, args) {
    if (abiArgs.length !== args.length) {
      throw new Error("Wrong number of args provided.");
    }
    return args.map((arg, i4) => {
      const serializer = new Serializer();
      serializeArg(arg, abiArgs[i4].type_tag, serializer);
      return serializer.getBytes();
    });
  }
  static toTransactionArguments(abiArgs, args) {
    if (abiArgs.length !== args.length) {
      throw new Error("Wrong number of args provided.");
    }
    return args.map((arg, i4) => argToTransactionArgument(arg, abiArgs[i4].type_tag));
  }
  setSequenceNumber(seqNumber) {
    this.builderConfig.sequenceNumber = BigInt(seqNumber);
  }
  /**
   * Builds a TransactionPayload. For dApps, chain ID and account sequence numbers are only known to the wallet.
   * Instead of building a RawTransaction (requires chainID and sequenceNumber), dApps can build a TransactionPayload
   * and pass the payload to the wallet for signing and sending.
   * @param func Fully qualified func names, e.g. 0x1::aptos_account::transfer
   * @param ty_tags TypeTag strings
   * @param args Function arguments
   * @returns TransactionPayload
   */
  buildTransactionPayload(func, ty_tags, args) {
    const typeTags = ty_tags.map((ty_arg) => new TypeTagParser(ty_arg).parseTypeTag());
    let payload;
    if (!this.abiMap.has(func)) {
      throw new Error(`Cannot find function: ${func}`);
    }
    const scriptABI = this.abiMap.get(func);
    if (scriptABI instanceof EntryFunctionABI) {
      const funcABI = scriptABI;
      const bcsArgs = _TransactionBuilderABI.toBCSArgs(funcABI.args, args);
      payload = new TransactionPayloadEntryFunction(
        new EntryFunction(funcABI.module_name, new Identifier(funcABI.name), typeTags, bcsArgs)
      );
    } else if (scriptABI instanceof TransactionScriptABI) {
      const funcABI = scriptABI;
      const scriptArgs = _TransactionBuilderABI.toTransactionArguments(funcABI.args, args);
      payload = new TransactionPayloadScript(new Script(funcABI.code, typeTags, scriptArgs));
    } else {
      throw new Error("Unknown ABI format.");
    }
    return payload;
  }
  /**
   * Builds a RawTransaction
   * @param func Fully qualified func names, e.g. 0x1::aptos_account::transfer
   * @param ty_tags TypeTag strings.
   * @example Below are valid value examples
   * ```
   * // Structs are in format `AccountAddress::ModuleName::StructName`
   * 0x1::aptos_coin::AptosCoin
   * // Vectors are in format `vector<other_tag_string>`
   * vector<0x1::aptos_coin::AptosCoin>
   * bool
   * u8
   * u16
   * u32
   * u64
   * u128
   * u256
   * address
   * ```
   * @param args Function arguments
   * @returns RawTransaction
   */
  build(func, ty_tags, args) {
    const { sender, sequenceNumber, gasUnitPrice, maxGasAmount, expSecFromNow, chainId } = this.builderConfig;
    if (!gasUnitPrice) {
      throw new Error("No gasUnitPrice provided.");
    }
    const senderAccount = sender instanceof AccountAddress ? sender : AccountAddress.fromHex(sender);
    const expTimestampSec = BigInt(Math.floor(Date.now() / 1e3) + Number(expSecFromNow));
    const payload = this.buildTransactionPayload(func, ty_tags, args);
    if (payload) {
      return new RawTransaction(
        senderAccount,
        BigInt(sequenceNumber),
        payload,
        BigInt(maxGasAmount),
        BigInt(gasUnitPrice),
        expTimestampSec,
        new ChainId(Number(chainId))
      );
    }
    throw new Error("Invalid ABI.");
  }
};
var TransactionBuilderRemoteABI = class {
  // We don't want the builder to depend on the actual AptosClient. There might be circular dependencies.
  constructor(aptosClient2, builderConfig) {
    this.aptosClient = aptosClient2;
    this.builderConfig = builderConfig;
  }
  async fetchABI(addr) {
    const modules = await this.aptosClient.getAccountModules(addr);
    const abis = modules.map((module) => module.abi).flatMap(
      (abi) => abi.exposed_functions.filter((ef) => ef.is_entry).map(
        (ef) => ({
          fullName: `${abi.address}::${abi.name}::${ef.name}`,
          ...ef
        })
      )
    );
    const abiMap = /* @__PURE__ */ new Map();
    abis.forEach((abi) => {
      abiMap.set(abi.fullName, abi);
    });
    return abiMap;
  }
  /**
   * Builds a raw transaction. Only support script function a.k.a entry function payloads
   *
   * @param func fully qualified function name in format <address>::<module>::<function>, e.g. 0x1::coin::transfer
   * @param ty_tags
   * @param args
   * @returns RawTransaction
   */
  async build(func, ty_tags, args) {
    const normlize = (s3) => s3.replace(/^0[xX]0*/g, "0x");
    func = normlize(func);
    const funcNameParts = func.split("::");
    if (funcNameParts.length !== 3) {
      throw new Error(
        // eslint-disable-next-line max-len
        "'func' needs to be a fully qualified function name in format <address>::<module>::<function>, e.g. 0x1::coin::transfer"
      );
    }
    const [addr, module] = func.split("::");
    const abiMap = await this.fetchABI(addr);
    if (!abiMap.has(func)) {
      throw new Error(`${func} doesn't exist.`);
    }
    const funcAbi = abiMap.get(func);
    const abiArgs = funcAbi.params.filter((param) => param !== "signer" && param !== "&signer");
    const typeArgABIs = abiArgs.map(
      (abiArg, i4) => new ArgumentABI(`var${i4}`, new TypeTagParser(abiArg, ty_tags).parseTypeTag())
    );
    const entryFunctionABI = new EntryFunctionABI(
      funcAbi.name,
      ModuleId.fromStr(`${addr}::${module}`),
      "",
      // Doc string
      funcAbi.generic_type_params.map((_, i4) => new TypeArgumentABI(`${i4}`)),
      typeArgABIs
    );
    const { sender, ...rest } = this.builderConfig;
    const senderAddress = sender instanceof AccountAddress ? HexString.fromUint8Array(sender.address) : sender;
    const [{ sequence_number: sequenceNumber }, chainId, { gas_estimate: gasUnitPrice }] = await Promise.all([
      (rest == null ? void 0 : rest.sequenceNumber) ? Promise.resolve({ sequence_number: rest == null ? void 0 : rest.sequenceNumber }) : this.aptosClient.getAccount(senderAddress),
      (rest == null ? void 0 : rest.chainId) ? Promise.resolve(rest == null ? void 0 : rest.chainId) : this.aptosClient.getChainId(),
      (rest == null ? void 0 : rest.gasUnitPrice) ? Promise.resolve({ gas_estimate: rest == null ? void 0 : rest.gasUnitPrice }) : this.aptosClient.estimateGasPrice()
    ]);
    const builderABI = new TransactionBuilderABI([bcsToBytes(entryFunctionABI)], {
      sender,
      sequenceNumber,
      chainId,
      gasUnitPrice: BigInt(gasUnitPrice),
      ...rest
    });
    return builderABI.build(func, ty_tags, args);
  }
};
__decorateClass([
  MemoizeExpiring(10 * 60 * 1e3)
], TransactionBuilderRemoteABI.prototype, "fetchABI", 1);
var _AptosClient = class _AptosClient2 {
  /**
   * Build a client configured to connect to an Aptos node at the given URL.
   *
   * Note: If you forget to append `/v1` to the URL, the client constructor
   * will automatically append it. If you don't want this URL processing to
   * take place, set doNotFixNodeUrl to true.
   *
   * @param nodeUrl URL of the Aptos Node API endpoint.
   * @param config Additional configuration options for the generated Axios client.
   */
  constructor(nodeUrl, config, doNotFixNodeUrl = false) {
    if (!nodeUrl) {
      throw new Error("Node URL cannot be empty.");
    }
    if (doNotFixNodeUrl) {
      this.nodeUrl = nodeUrl;
    } else {
      this.nodeUrl = fixNodeUrl(nodeUrl);
    }
    this.config = config === void 0 || config === null ? {} : { ...config };
  }
  async getAccount(accountAddress) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `accounts/${HexString.ensure(accountAddress).hex()}`,
      originMethod: "getAccount",
      overrides: { ...this.config }
    });
    return data;
  }
  async getAccountTransactions(accountAddress, query) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `accounts/${HexString.ensure(accountAddress).hex()}/transactions`,
      originMethod: "getAccountTransactions",
      params: { start: query == null ? void 0 : query.start, limit: query == null ? void 0 : query.limit },
      overrides: { ...this.config }
    });
    return data;
  }
  async getAccountModules(accountAddress, query) {
    const out = await paginateWithCursor({
      url: this.nodeUrl,
      endpoint: `accounts/${accountAddress}/modules`,
      params: { ledger_version: query == null ? void 0 : query.ledgerVersion, limit: 1e3 },
      originMethod: "getAccountModules",
      overrides: { ...this.config }
    });
    return out;
  }
  async getAccountModule(accountAddress, moduleName, query) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `accounts/${HexString.ensure(accountAddress).hex()}/module/${moduleName}`,
      originMethod: "getAccountModule",
      params: { ledger_version: query == null ? void 0 : query.ledgerVersion },
      overrides: { ...this.config }
    });
    return data;
  }
  async getAccountResources(accountAddress, query) {
    const out = await paginateWithCursor({
      url: this.nodeUrl,
      endpoint: `accounts/${accountAddress}/resources`,
      params: { ledger_version: query == null ? void 0 : query.ledgerVersion, limit: 9999 },
      originMethod: "getAccountResources",
      overrides: { ...this.config }
    });
    return out;
  }
  async getAccountResource(accountAddress, resourceType, query) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `accounts/${HexString.ensure(accountAddress).hex()}/resource/${resourceType}`,
      originMethod: "getAccountResource",
      params: { ledger_version: query == null ? void 0 : query.ledgerVersion },
      overrides: { ...this.config }
    });
    return data;
  }
  /** Generates a signed transaction that can be submitted to the chain for execution. */
  static generateBCSTransaction(accountFrom, rawTxn) {
    const txnBuilder = new TransactionBuilderEd25519((signingMessage) => {
      const sigHexStr = accountFrom.signBuffer(signingMessage);
      return new aptos_types_exports.Ed25519Signature(sigHexStr.toUint8Array());
    }, accountFrom.pubKey().toUint8Array());
    return txnBuilder.sign(rawTxn);
  }
  /**
   * Note: Unless you have a specific reason for using this, it'll probably be simpler
   * to use `simulateTransaction`.
   *
   * Generates a BCS transaction that can be submitted to the chain for simulation.
   *
   * @param accountFrom The account that will be used to send the transaction
   * for simulation.
   * @param rawTxn The raw transaction to be simulated, likely created by calling
   * the `generateTransaction` function.
   * @returns The BCS encoded signed transaction, which you should then pass into
   * the `submitBCSSimulation` function.
   */
  static generateBCSSimulation(accountFrom, rawTxn) {
    const txnBuilder = new TransactionBuilderEd25519((_signingMessage) => {
      const invalidSigBytes = new Uint8Array(64);
      return new aptos_types_exports.Ed25519Signature(invalidSigBytes);
    }, accountFrom.pubKey().toUint8Array());
    return txnBuilder.sign(rawTxn);
  }
  /** Generates an entry function transaction request that can be submitted to produce a raw transaction that
   * can be signed, which upon being signed can be submitted to the blockchain
   * This function fetches the remote ABI and uses it to serialized the data, therefore
   * users don't need to handle serialization by themselves.
   * @param sender Hex-encoded 32 byte Aptos account address of transaction sender
   * @param payload Entry function transaction payload type
   * @param options Options allow to overwrite default transaction options.
   * @returns A raw transaction object
   */
  async generateTransaction(sender, payload, options) {
    const config = { sender };
    if (options == null ? void 0 : options.sequence_number) {
      config.sequenceNumber = options.sequence_number;
    }
    if (options == null ? void 0 : options.gas_unit_price) {
      config.gasUnitPrice = options.gas_unit_price;
    }
    if (options == null ? void 0 : options.max_gas_amount) {
      config.maxGasAmount = options.max_gas_amount;
    }
    if (options == null ? void 0 : options.expiration_timestamp_secs) {
      const timestamp = Number.parseInt(options.expiration_timestamp_secs, 10);
      config.expSecFromNow = timestamp - Math.floor(Date.now() / 1e3);
    }
    const builder = new TransactionBuilderRemoteABI(this, config);
    return builder.build(payload.function, payload.type_arguments, payload.arguments);
  }
  /**
   * Generates a fee payer transaction that can be signed and submitted to chain
   *
   * @param sender the sender's account address
   * @param payload the transaction payload
   * @param fee_payer the fee payer account
   * @param secondarySignerAccounts an optional array of the secondary signers accounts
   * @returns a fee payer raw transaction that can be signed and submitted to chain
   */
  async generateFeePayerTransaction(sender, payload, feePayer, secondarySignerAccounts = [], options) {
    const rawTxn = await this.generateTransaction(sender, payload, options);
    const signers = secondarySignerAccounts.map((signer) => AccountAddress.fromHex(signer));
    const feePayerTxn = new aptos_types_exports.FeePayerRawTransaction(rawTxn, signers, AccountAddress.fromHex(feePayer));
    return feePayerTxn;
  }
  /**
   * Submits fee payer transaction to chain
   *
   * @param feePayerTransaction the raw transaction to be submitted, of type FeePayerRawTransaction
   * @param senderAuthenticator the sender account authenticator (can get from signMultiTransaction() method)
   * @param feePayerAuthenticator the feepayer account authenticator (can get from signMultiTransaction() method)
   * @param signersAuthenticators an optional array of the signer account authenticators
   * @returns The pending transaction
   */
  async submitFeePayerTransaction(feePayerTransaction, senderAuthenticator, feePayerAuthenticator, additionalSignersAuthenticators = []) {
    const txAuthenticatorFeePayer = new aptos_types_exports.TransactionAuthenticatorFeePayer(
      senderAuthenticator,
      feePayerTransaction.secondary_signer_addresses,
      additionalSignersAuthenticators,
      { address: feePayerTransaction.fee_payer_address, authenticator: feePayerAuthenticator }
    );
    const bcsTxn = bcsToBytes(
      new aptos_types_exports.SignedTransaction(feePayerTransaction.raw_txn, txAuthenticatorFeePayer)
    );
    const transactionRes = await this.submitSignedBCSTransaction(bcsTxn);
    return transactionRes;
  }
  /**
   * Signs a multi transaction type (multi agent / fee payer) and returns the
   * signer authenticator to be used to submit the transaction.
   *
   * @param signer the account to sign on the transaction
   * @param rawTxn a MultiAgentRawTransaction or FeePayerRawTransaction
   * @returns signer authenticator
   */
  // eslint-disable-next-line class-methods-use-this
  async signMultiTransaction(signer, rawTxn) {
    const signerSignature = new aptos_types_exports.Ed25519Signature(
      signer.signBuffer(TransactionBuilder.getSigningMessage(rawTxn)).toUint8Array()
    );
    const signerAuthenticator = new aptos_types_exports.AccountAuthenticatorEd25519(
      new aptos_types_exports.Ed25519PublicKey(signer.signingKey.publicKey),
      signerSignature
    );
    return Promise.resolve(signerAuthenticator);
  }
  /** Converts a transaction request produced by `generateTransaction` into a properly
   * signed transaction, which can then be submitted to the blockchain
   * @param accountFrom AptosAccount of transaction sender
   * @param rawTransaction A raw transaction generated by `generateTransaction` method
   * @returns A transaction, signed with sender account
   */
  // eslint-disable-next-line class-methods-use-this
  async signTransaction(accountFrom, rawTransaction) {
    return Promise.resolve(_AptosClient2.generateBCSTransaction(accountFrom, rawTransaction));
  }
  async getEventsByCreationNumber(address, creationNumber, query) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `accounts/${HexString.ensure(address).hex()}/events/${creationNumber}`,
      originMethod: "getEventsByCreationNumber",
      params: { start: query == null ? void 0 : query.start, limit: query == null ? void 0 : query.limit },
      overrides: { ...this.config }
    });
    return data;
  }
  async getEventsByEventHandle(address, eventHandleStruct, fieldName, query) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `accounts/${HexString.ensure(address).hex()}/events/${eventHandleStruct}/${fieldName}`,
      originMethod: "getEventsByEventHandle",
      params: { start: query == null ? void 0 : query.start, limit: query == null ? void 0 : query.limit },
      overrides: { ...this.config }
    });
    return data;
  }
  /**
   * Submits a signed transaction to the transaction endpoint.
   * @param signedTxn A transaction, signed by `signTransaction` method
   * @returns Transaction that is accepted and submitted to mempool
   */
  async submitTransaction(signedTxn) {
    return this.submitSignedBCSTransaction(signedTxn);
  }
  /**
   * Generates and submits a transaction to the transaction simulation
   * endpoint. For this we generate a transaction with a fake signature.
   *
   * @param accountOrPubkey The sender or sender's public key. When private key is available, `AptosAccount` instance
   * can be used to send the transaction for simulation. If private key is not available, sender's public key can be
   * used to send the transaction for simulation.
   * @param rawTransaction The raw transaction to be simulated, likely created
   * by calling the `generateTransaction` function.
   * @param query.estimateGasUnitPrice If set to true, the gas unit price in the
   * transaction will be ignored and the estimated value will be used.
   * @param query.estimateMaxGasAmount If set to true, the max gas value in the
   * transaction will be ignored and the maximum possible gas will be used.
   * @param query.estimatePrioritizedGasUnitPrice If set to true, the transaction will use a higher price than the
   * original estimate.
   * @returns The BCS encoded signed transaction, which you should then provide
   *
   */
  async simulateTransaction(accountOrPubkey, rawTransaction, query) {
    let signedTxn;
    if (accountOrPubkey instanceof AptosAccount) {
      signedTxn = _AptosClient2.generateBCSSimulation(accountOrPubkey, rawTransaction);
    } else if (accountOrPubkey instanceof MultiEd25519PublicKey) {
      const txnBuilder = new TransactionBuilderMultiEd25519(() => {
        const { threshold } = accountOrPubkey;
        const bits = [];
        const signatures = [];
        for (let i4 = 0; i4 < threshold; i4 += 1) {
          bits.push(i4);
          signatures.push(new aptos_types_exports.Ed25519Signature(new Uint8Array(64)));
        }
        const bitmap = aptos_types_exports.MultiEd25519Signature.createBitmap(bits);
        return new aptos_types_exports.MultiEd25519Signature(signatures, bitmap);
      }, accountOrPubkey);
      signedTxn = txnBuilder.sign(rawTransaction);
    } else {
      const txnBuilder = new TransactionBuilderEd25519(() => {
        const invalidSigBytes = new Uint8Array(64);
        return new aptos_types_exports.Ed25519Signature(invalidSigBytes);
      }, accountOrPubkey.toBytes());
      signedTxn = txnBuilder.sign(rawTransaction);
    }
    return this.submitBCSSimulation(signedTxn, query);
  }
  async submitSignedBCSTransaction(signedTxn) {
    const { data } = await post({
      url: this.nodeUrl,
      body: signedTxn,
      endpoint: "transactions",
      originMethod: "submitSignedBCSTransaction",
      contentType: "application/x.aptos.signed_transaction+bcs",
      overrides: { ...this.config }
    });
    return data;
  }
  async submitBCSSimulation(bcsBody, query) {
    var _a, _b, _c;
    const queryParams = {
      estimate_gas_unit_price: (_a = query == null ? void 0 : query.estimateGasUnitPrice) != null ? _a : false,
      estimate_max_gas_amount: (_b = query == null ? void 0 : query.estimateMaxGasAmount) != null ? _b : false,
      estimate_prioritized_gas_unit_price: (_c = query == null ? void 0 : query.estimatePrioritizedGasUnitPrice) != null ? _c : false
    };
    const { data } = await post({
      url: this.nodeUrl,
      body: bcsBody,
      endpoint: "transactions/simulate",
      params: queryParams,
      originMethod: "submitBCSSimulation",
      contentType: "application/x.aptos.signed_transaction+bcs",
      overrides: { ...this.config }
    });
    return data;
  }
  async getTransactions(query) {
    var _a;
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: "transactions",
      originMethod: "getTransactions",
      params: { start: (_a = query == null ? void 0 : query.start) == null ? void 0 : _a.toString(), limit: query == null ? void 0 : query.limit },
      overrides: { ...this.config }
    });
    return data;
  }
  async getTransactionByHash(txnHash) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `transactions/by_hash/${txnHash}`,
      originMethod: "getTransactionByHash",
      overrides: { ...this.config }
    });
    return data;
  }
  async getTransactionByVersion(txnVersion) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `transactions/by_version/${txnVersion}`,
      originMethod: "getTransactionByVersion",
      overrides: { ...this.config }
    });
    return data;
  }
  /**
   * Defines if specified transaction is currently in pending state
   * @param txnHash A hash of transaction
   *
   * To create a transaction hash:
   *
   * 1. Create hash message bytes: "Aptos::Transaction" bytes + BCS bytes of Transaction.
   * 2. Apply hash algorithm SHA3-256 to the hash message bytes.
   * 3. Hex-encode the hash bytes with 0x prefix.
   *
   * @returns `true` if transaction is in pending state and `false` otherwise
   */
  async transactionPending(txnHash) {
    try {
      const response = await this.getTransactionByHash(txnHash);
      return response.type === "pending_transaction";
    } catch (e10) {
      if ((e10 == null ? void 0 : e10.status) === 404) {
        return true;
      }
      throw e10;
    }
  }
  /**
   * Wait for a transaction to move past pending state.
   *
   * There are 4 possible outcomes:
   * 1. Transaction is processed and successfully committed to the blockchain.
   * 2. Transaction is rejected for some reason, and is therefore not committed
   *    to the blockchain.
   * 3. Transaction is committed but execution failed, meaning no changes were
   *    written to the blockchain state.
   * 4. Transaction is not processed within the specified timeout.
   *
   * In case 1, this function resolves with the transaction response returned
   * by the API.
   *
   * In case 2, the function will throw an ApiError, likely with an HTTP status
   * code indicating some problem with the request (e.g. 400).
   *
   * In case 3, if `checkSuccess` is false (the default), this function returns
   * the transaction response just like in case 1, in which the `success` field
   * will be false. If `checkSuccess` is true, it will instead throw a
   * FailedTransactionError.
   *
   * In case 4, this function throws a WaitForTransactionError.
   *
   * @param txnHash The hash of a transaction previously submitted to the blockchain.
   * @param extraArgs.timeoutSecs Timeout in seconds. Defaults to 20 seconds.
   * @param extraArgs.checkSuccess See above. Defaults to false.
   * @returns See above.
   *
   * @example
   * ```
   * const rawTransaction = await this.generateRawTransaction(sender.address(), payload, extraArgs);
   * const bcsTxn = AptosClient.generateBCSTransaction(sender, rawTransaction);
   * const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
   * const transasction = await this.aptosClient.waitForTransactionWithResult(pendingTransaction.hash);
   * ```
   */
  async waitForTransactionWithResult(txnHash, extraArgs) {
    var _a, _b;
    const timeoutSecs = (_a = extraArgs == null ? void 0 : extraArgs.timeoutSecs) != null ? _a : DEFAULT_TXN_TIMEOUT_SEC;
    const checkSuccess = (_b = extraArgs == null ? void 0 : extraArgs.checkSuccess) != null ? _b : false;
    let isPending = true;
    let count = 0;
    let lastTxn;
    while (isPending) {
      if (count >= timeoutSecs) {
        break;
      }
      try {
        lastTxn = await this.getTransactionByHash(txnHash);
        isPending = lastTxn.type === "pending_transaction";
        if (!isPending) {
          break;
        }
      } catch (e10) {
        const isApiError = e10 instanceof ApiError;
        const isRequestError = isApiError && e10.status !== 404 && e10.status >= 400 && e10.status < 500;
        if (!isApiError || isRequestError) {
          throw e10;
        }
      }
      await sleep(1e3);
      count += 1;
    }
    if (lastTxn === void 0) {
      throw new Error(`Waiting for transaction ${txnHash} failed`);
    }
    if (isPending) {
      throw new WaitForTransactionError(
        `Waiting for transaction ${txnHash} timed out after ${timeoutSecs} seconds`,
        lastTxn
      );
    }
    if (!checkSuccess) {
      return lastTxn;
    }
    if (!(lastTxn == null ? void 0 : lastTxn.success)) {
      throw new FailedTransactionError(
        `Transaction ${txnHash} failed with an error: ${lastTxn.vm_status}`,
        lastTxn
      );
    }
    return lastTxn;
  }
  /**
   * This function works the same as `waitForTransactionWithResult` except it
   * doesn't return the transaction in those cases, it returns nothing. For
   * more information, see the documentation for `waitForTransactionWithResult`.
   */
  async waitForTransaction(txnHash, extraArgs) {
    await this.waitForTransactionWithResult(txnHash, extraArgs);
  }
  async getLedgerInfo() {
    const { data } = await get({
      url: this.nodeUrl,
      originMethod: "getLedgerInfo",
      overrides: { ...this.config }
    });
    return data;
  }
  async getChainId() {
    const result = await this.getLedgerInfo();
    return result.chain_id;
  }
  async getTableItem(handle, data, query) {
    var _a;
    const response = await post({
      url: this.nodeUrl,
      body: data,
      endpoint: `tables/${handle}/item`,
      originMethod: "getTableItem",
      params: { ledger_version: (_a = query == null ? void 0 : query.ledgerVersion) == null ? void 0 : _a.toString() },
      overrides: { ...this.config }
    });
    return response.data;
  }
  /**
   * Generates a raw transaction out of a transaction payload
   * @param accountFrom
   * @param payload
   * @param extraArgs
   * @returns A raw transaction object
   */
  async generateRawTransaction(accountFrom, payload, extraArgs) {
    const [{ sequence_number: sequenceNumber }, chainId, { gas_estimate: gasEstimate }] = await Promise.all([
      (extraArgs == null ? void 0 : extraArgs.providedSequenceNumber) ? Promise.resolve({ sequence_number: extraArgs.providedSequenceNumber }) : this.getAccount(accountFrom),
      this.getChainId(),
      (extraArgs == null ? void 0 : extraArgs.gasUnitPrice) ? Promise.resolve({ gas_estimate: extraArgs.gasUnitPrice }) : this.estimateGasPrice()
    ]);
    const { maxGasAmount, gasUnitPrice, expireTimestamp } = {
      maxGasAmount: BigInt(DEFAULT_MAX_GAS_AMOUNT),
      gasUnitPrice: BigInt(gasEstimate),
      expireTimestamp: BigInt(Math.floor(Date.now() / 1e3) + DEFAULT_TXN_EXP_SEC_FROM_NOW),
      ...extraArgs
    };
    return new aptos_types_exports.RawTransaction(
      aptos_types_exports.AccountAddress.fromHex(accountFrom),
      BigInt(sequenceNumber),
      payload,
      maxGasAmount,
      gasUnitPrice,
      expireTimestamp,
      new aptos_types_exports.ChainId(chainId)
    );
  }
  /**
   * Helper for generating, signing, and submitting a transaction.
   *
   * @param sender AptosAccount of transaction sender.
   * @param payload Transaction payload.
   * @param extraArgs Extra args for building the transaction payload.
   * @returns The transaction response from the API.
   */
  async generateSignSubmitTransaction(sender, payload, extraArgs) {
    const rawTransaction = await this.generateRawTransaction(sender.address(), payload, extraArgs);
    const bcsTxn = _AptosClient2.generateBCSTransaction(sender, rawTransaction);
    const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
    return pendingTransaction.hash;
  }
  /**
   * Helper for signing and submitting a transaction.
   *
   * @param sender AptosAccount of transaction sender.
   * @param transaction A generated Raw transaction payload.
   * @returns The transaction response from the API.
   */
  async signAndSubmitTransaction(sender, transaction) {
    const bcsTxn = _AptosClient2.generateBCSTransaction(sender, transaction);
    const pendingTransaction = await this.submitSignedBCSTransaction(bcsTxn);
    return pendingTransaction.hash;
  }
  /**
   * Publishes a move package. `packageMetadata` and `modules` can be generated with command
   * `aptos move compile --save-metadata [ --included-artifacts=<...> ]`.
   * @param sender
   * @param packageMetadata package metadata bytes
   * @param modules bytecodes of modules
   * @param extraArgs
   * @returns Transaction hash
   */
  async publishPackage(sender, packageMetadata, modules, extraArgs) {
    const codeSerializer = new Serializer();
    serializeVector(modules, codeSerializer);
    const payload = new aptos_types_exports.TransactionPayloadEntryFunction(
      aptos_types_exports.EntryFunction.natural(
        "0x1::code",
        "publish_package_txn",
        [],
        [bcsSerializeBytes(packageMetadata), codeSerializer.getBytes()]
      )
    );
    return this.generateSignSubmitTransaction(sender, payload, extraArgs);
  }
  /**
   * Publishes a move packages by creating a resource account.
   * The package cannot be upgraded since it is deployed by resource account
   * `packageMetadata` and `modules` can be generated with command
   * `aptos move compile --save-metadata [ --included-artifacts=<...> ]`.
   * @param sender
   * @param seed seeds for creation of resource address
   * @param packageMetadata package metadata bytes
   * @param modules bytecodes of modules
   * @param extraArgs
   * @returns Transaction hash
   */
  async createResourceAccountAndPublishPackage(sender, seed, packageMetadata, modules, extraArgs) {
    const codeSerializer = new Serializer();
    serializeVector(modules, codeSerializer);
    const payload = new aptos_types_exports.TransactionPayloadEntryFunction(
      aptos_types_exports.EntryFunction.natural(
        "0x1::resource_account",
        "create_resource_account_and_publish_package",
        [],
        [bcsSerializeBytes(seed), bcsSerializeBytes(packageMetadata), codeSerializer.getBytes()]
      )
    );
    return this.generateSignSubmitTransaction(sender, payload, extraArgs);
  }
  /**
   * Helper for generating, submitting, and waiting for a transaction, and then
   * checking whether it was committed successfully. Under the hood this is just
   * `generateSignSubmitTransaction` and then `waitForTransactionWithResult`, see
   * those for information about the return / error semantics of this function.
   */
  async generateSignSubmitWaitForTransaction(sender, payload, extraArgs) {
    const txnHash = await this.generateSignSubmitTransaction(sender, payload, extraArgs);
    return this.waitForTransactionWithResult(txnHash, extraArgs);
  }
  async estimateGasPrice() {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: "estimate_gas_price",
      originMethod: "estimateGasPrice",
      overrides: { ...this.config }
    });
    return data;
  }
  async estimateMaxGasAmount(forAccount) {
    const typeTag = `0x1::coin::CoinStore<${APTOS_COIN}>`;
    const [{ gas_estimate: gasUnitPrice }, resources] = await Promise.all([
      this.estimateGasPrice(),
      this.getAccountResources(forAccount)
    ]);
    const accountResource = resources.find((r7) => r7.type === typeTag);
    const balance = BigInt(accountResource.data.coin.value);
    return balance / BigInt(gasUnitPrice);
  }
  /**
   * Rotate an account's auth key. After rotation, only the new private key can be used to sign txns for
   * the account.
   * WARNING: You must create a new instance of AptosAccount after using this function.
   * @param forAccount Account of which the auth key will be rotated
   * @param toPrivateKeyBytes New private key
   * @param extraArgs Extra args for building the transaction payload.
   * @returns PendingTransaction
   */
  async rotateAuthKeyEd25519(forAccount, toPrivateKeyBytes, extraArgs) {
    const { sequence_number: sequenceNumber, authentication_key: authKey } = await this.getAccount(
      forAccount.address()
    );
    const helperAccount = new AptosAccount(toPrivateKeyBytes);
    const challenge = new aptos_types_exports.RotationProofChallenge(
      aptos_types_exports.AccountAddress.CORE_CODE_ADDRESS,
      "account",
      "RotationProofChallenge",
      BigInt(sequenceNumber),
      aptos_types_exports.AccountAddress.fromHex(forAccount.address()),
      new aptos_types_exports.AccountAddress(new HexString(authKey).toUint8Array()),
      helperAccount.pubKey().toUint8Array()
    );
    const challengeHex = HexString.fromUint8Array(bcsToBytes(challenge));
    const proofSignedByCurrentPrivateKey = forAccount.signHexString(challengeHex);
    const proofSignedByNewPrivateKey = helperAccount.signHexString(challengeHex);
    const payload = new aptos_types_exports.TransactionPayloadEntryFunction(
      aptos_types_exports.EntryFunction.natural(
        "0x1::account",
        "rotate_authentication_key",
        [],
        [
          bcsSerializeU8(0),
          // ed25519 scheme
          bcsSerializeBytes(forAccount.pubKey().toUint8Array()),
          bcsSerializeU8(0),
          // ed25519 scheme
          bcsSerializeBytes(helperAccount.pubKey().toUint8Array()),
          bcsSerializeBytes(proofSignedByCurrentPrivateKey.toUint8Array()),
          bcsSerializeBytes(proofSignedByNewPrivateKey.toUint8Array())
        ]
      )
    );
    const rawTransaction = await this.generateRawTransaction(forAccount.address(), payload, extraArgs);
    const bcsTxn = _AptosClient2.generateBCSTransaction(forAccount, rawTransaction);
    return this.submitSignedBCSTransaction(bcsTxn);
  }
  /**
   * Lookup the original address by the current derived address
   * @param addressOrAuthKey
   * @returns original address
   */
  async lookupOriginalAddress(addressOrAuthKey) {
    const resource = await this.getAccountResource("0x1", "0x1::account::OriginatingAddress");
    const {
      address_map: { handle }
    } = resource.data;
    const origAddress = await this.getTableItem(handle, {
      key_type: "address",
      value_type: "address",
      key: HexString.ensure(addressOrAuthKey).hex()
    });
    return new HexString(origAddress);
  }
  async getBlockByHeight(blockHeight, withTransactions) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `blocks/by_height/${blockHeight}`,
      originMethod: "getBlockByHeight",
      params: { with_transactions: withTransactions },
      overrides: { ...this.config }
    });
    return data;
  }
  async getBlockByVersion(version2, withTransactions) {
    const { data } = await get({
      url: this.nodeUrl,
      endpoint: `blocks/by_version/${version2}`,
      originMethod: "getBlockByVersion",
      params: { with_transactions: withTransactions },
      overrides: { ...this.config }
    });
    return data;
  }
  async view(payload, ledger_version) {
    const { data } = await post({
      url: this.nodeUrl,
      body: payload,
      endpoint: "view",
      originMethod: "getTableItem",
      params: { ledger_version },
      overrides: { ...this.config }
    });
    return data;
  }
  // eslint-disable-next-line class-methods-use-this
  clearCache(tags) {
    clear(tags);
  }
};
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getAccount", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getAccountTransactions", 1);
__decorateClass([
  parseApiError,
  MemoizeExpiring(10 * 60 * 1e3)
], _AptosClient.prototype, "getAccountModules", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getAccountModule", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getAccountResources", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getAccountResource", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getEventsByCreationNumber", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getEventsByEventHandle", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "submitSignedBCSTransaction", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "submitBCSSimulation", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getTransactions", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getTransactionByHash", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getTransactionByVersion", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getLedgerInfo", 1);
__decorateClass([
  Memoize()
], _AptosClient.prototype, "getChainId", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getTableItem", 1);
__decorateClass([
  parseApiError,
  Memoize({
    ttlMs: 5 * 60 * 1e3,
    // cache result for 5min
    tags: ["gas_estimates"]
  })
], _AptosClient.prototype, "estimateGasPrice", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "estimateMaxGasAmount", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getBlockByHeight", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "getBlockByVersion", 1);
__decorateClass([
  parseApiError
], _AptosClient.prototype, "view", 1);
var AptosClient = _AptosClient;
var WaitForTransactionError = class extends Error {
  constructor(message, lastSubmittedTransaction) {
    super(message);
    this.lastSubmittedTransaction = lastSubmittedTransaction;
  }
};
var FailedTransactionError = class extends Error {
  constructor(message, transaction) {
    super(message);
    this.transaction = transaction;
  }
};
var ApiError = class extends Error {
  constructor(status, message, errorCode, vmErrorCode) {
    super(message);
    this.status = status;
    this.message = message;
    this.errorCode = errorCode;
    this.vmErrorCode = vmErrorCode;
  }
};
function parseApiError(target, propertyKey, descriptor) {
  const childFunction = descriptor.value;
  descriptor.value = async function wrapper(...args) {
    var _a, _b;
    try {
      const res = await childFunction.apply(this, [...args]);
      return res;
    } catch (e10) {
      if (e10 instanceof AptosApiError) {
        throw new ApiError(
          e10.status,
          JSON.stringify({ message: e10.message, ...e10.data }),
          (_a = e10.data) == null ? void 0 : _a.error_code,
          (_b = e10.data) == null ? void 0 : _b.vm_error_code
        );
      }
      throw e10;
    }
  };
  return descriptor;
}
var IndexerClient = class _IndexerClient {
  /**
   * @param endpoint URL of the Aptos Indexer API endpoint.
   */
  constructor(endpoint, config) {
    this.endpoint = endpoint;
    this.config = config;
  }
  /**
   * Indexer only accepts address in the long format, i.e a 66 chars long -> 0x<64 chars>
   * This method makes sure address is 66 chars long.
   * @param address
   */
  static validateAddress(address) {
    if (address.length < 66) {
      throw new Error(`${address} is less than 66 chars long.`);
    }
  }
  /**
   * Makes axios client call to fetch data from Aptos Indexer.
   *
   * @param graphqlQuery A GraphQL query to pass in the `data` axios call.
   */
  async queryIndexer(graphqlQuery) {
    const response = await post({
      url: this.endpoint,
      body: graphqlQuery,
      overrides: { WITH_CREDENTIALS: false, ...this.config }
    });
    if (response.data.errors) {
      throw new ApiError(
        response.data.errors[0].extensions.code,
        JSON.stringify({
          message: response.data.errors[0].message,
          error_code: response.data.errors[0].extensions.code
        })
      );
    }
    return response.data.data;
  }
  /**
   * Queries Indexer Ledger Info
   *
   * @returns GetLedgerInfoQuery response type
   */
  async getIndexerLedgerInfo() {
    const graphqlQuery = {
      query: GetIndexerLedgerInfo
    };
    return this.queryIndexer(graphqlQuery);
  }
  // TOKENS //
  /**
   * @deprecated please use `getOwnedTokens` query
   *
   * Queries an Aptos account's NFTs by owner address
   *
   * @param ownerAddress Hex-encoded 32 byte Aptos account address
   * @returns GetAccountCurrentTokensQuery response type
   */
  async getAccountNFTs(ownerAddress, options) {
    const address = HexString.ensure(ownerAddress).hex();
    _IndexerClient.validateAddress(address);
    const graphqlQuery = {
      query: GetAccountCurrentTokens,
      variables: { address, offset: options == null ? void 0 : options.offset, limit: options == null ? void 0 : options.limit }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries a token activities by token address (v2) or token data id (v1)
   *
   * @param idHash token address (v2) or token data id (v1)
   * @returns GetTokenActivitiesQuery response type
   */
  async getTokenActivities(token, extraArgs) {
    var _a, _b;
    const tokenAddress = HexString.ensure(token).hex();
    _IndexerClient.validateAddress(tokenAddress);
    const whereCondition = {
      token_data_id: { _eq: tokenAddress }
    };
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
    }
    const graphqlQuery = {
      query: GetTokenActivities,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Gets the count of token's activities by token address (v2) or token data id (v1)
   *
   * @param token token address (v2) or token data id (v1)
   * @returns GetTokenActivitiesCountQuery response type
   */
  async getTokenActivitiesCount(token) {
    const graphqlQuery = {
      query: GetTokenActivitiesCount,
      variables: { token_id: token }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Gets the count of tokens owned by an account
   *
   * @param ownerAddress Owner address
   * @returns AccountTokensCountQuery response type
   */
  async getAccountTokensCount(ownerAddress, extraArgs) {
    var _a, _b;
    const whereCondition = {
      owner_address: { _eq: ownerAddress },
      amount: { _gt: "0" }
    };
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
    }
    const address = HexString.ensure(ownerAddress).hex();
    _IndexerClient.validateAddress(address);
    const graphqlQuery = {
      query: GetAccountTokensCount,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries token data by token address (v2) or token data id (v1)
   *
   * @param token token address (v2) or token data id (v1)
   * @returns GetTokenDataQuery response type
   */
  // :!:>getTokenData
  async getTokenData(token, extraArgs) {
    var _a, _b;
    const tokenAddress = HexString.ensure(token).hex();
    _IndexerClient.validateAddress(tokenAddress);
    const whereCondition = {
      token_data_id: { _eq: tokenAddress }
    };
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
    }
    const graphqlQuery = {
      query: GetTokenData,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  // <:!:getTokenData
  /**
   * Queries token owners data by token address (v2) or token data id (v1).
   * This query returns historical owners data.
   *
   * To fetch token v2 standard, pass in the optional `tokenStandard` parameter and
   * dont pass `propertyVersion` parameter (as propertyVersion only compatible with v1 standard)
   *
   * @param token token address (v2) or token data id (v1)
   * @param propertyVersion Property version (optional) - only compatible with token v1 standard
   * @returns GetTokenOwnersDataQuery response type
   */
  async getTokenOwnersData(token, propertyVersion, extraArgs) {
    var _a, _b;
    const tokenAddress = HexString.ensure(token).hex();
    _IndexerClient.validateAddress(tokenAddress);
    const whereCondition = {
      token_data_id: { _eq: tokenAddress },
      amount: { _gt: "0" }
    };
    if (propertyVersion) {
      whereCondition.property_version_v1 = { _eq: propertyVersion };
    }
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
    }
    const graphqlQuery = {
      query: GetTokenOwnersData,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries current token owner data by token address (v2) or token data id (v1).
   * This query returns the current token owner data.
   *
   * To fetch token v2 standard, pass in the optional `tokenStandard` parameter and
   * dont pass `propertyVersion` parameter (as propertyVersion only compatible with v1 standard)
   *
   * @param token token address (v2) or token data id (v1)
   * @param propertyVersion Property version (optional) - only compatible with token v1 standard
   * @returns GetTokenCurrentOwnerDataQuery response type
   */
  async getTokenCurrentOwnerData(token, propertyVersion, extraArgs) {
    var _a, _b;
    const tokenAddress = HexString.ensure(token).hex();
    _IndexerClient.validateAddress(tokenAddress);
    const whereCondition = {
      token_data_id: { _eq: tokenAddress },
      amount: { _gt: "0" }
    };
    if (propertyVersion) {
      whereCondition.property_version_v1 = { _eq: propertyVersion };
    }
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
    }
    const graphqlQuery = {
      query: GetTokenCurrentOwnerData,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries account's current owned tokens.
   * This query returns all tokens (v1 and v2 standards) an account owns, including NFTs, fungible, soulbound, etc.
   * If you want to get only the token from a specific standrd, you can pass an optional tokenStandard param
   *
   * @param ownerAddress The token owner address we want to get the tokens for
   * @returns GetOwnedTokensQuery response type
   */
  async getOwnedTokens(ownerAddress, extraArgs) {
    var _a, _b;
    const address = HexString.ensure(ownerAddress).hex();
    _IndexerClient.validateAddress(address);
    const whereCondition = {
      owner_address: { _eq: address },
      amount: { _gt: 0 }
    };
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
    }
    const graphqlQuery = {
      query: GetOwnedTokens,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries account's current owned tokens by token address (v2) or token data id (v1).
   *
   * @param token token address (v2) or token data id (v1)
   * @returns GetOwnedTokensByTokenDataQuery response type
   */
  async getOwnedTokensByTokenData(token, extraArgs) {
    var _a, _b;
    const address = HexString.ensure(token).hex();
    _IndexerClient.validateAddress(address);
    const whereCondition = {
      token_data_id: { _eq: address },
      amount: { _gt: 0 }
    };
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
    }
    const graphqlQuery = {
      query: GetOwnedTokensByTokenData,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries all tokens of a specific collection that an account owns by the collection address
   *
   * @param ownerAddress owner address that owns the tokens
   * @param collectionAddress the collection address
   * @returns GetTokenOwnedFromCollectionQuery response type
   */
  async getTokenOwnedFromCollectionAddress(ownerAddress, collectionAddress, extraArgs) {
    var _a, _b;
    const ownerHexAddress = HexString.ensure(ownerAddress).hex();
    _IndexerClient.validateAddress(ownerHexAddress);
    const collectionHexAddress = HexString.ensure(collectionAddress).hex();
    _IndexerClient.validateAddress(collectionHexAddress);
    const whereCondition = {
      owner_address: { _eq: ownerHexAddress },
      current_token_data: { collection_id: { _eq: collectionHexAddress } },
      amount: { _gt: 0 }
    };
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
    }
    const graphqlQuery = {
      query: GetTokenOwnedFromCollection,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries all tokens of a specific collection that an account owns by the collection name and collection
   * creator address
   *
   * @param ownerAddress owner address that owns the tokens
   * @param collectionName the collection name
   * @param creatorAddress the collection creator address
   * @returns GetTokenOwnedFromCollectionQuery response type
   */
  async getTokenOwnedFromCollectionNameAndCreatorAddress(ownerAddress, collectionName, creatorAddress, extraArgs) {
    const collectionAddress = await this.getCollectionAddress(creatorAddress, collectionName, extraArgs);
    const tokens = await this.getTokenOwnedFromCollectionAddress(ownerAddress, collectionAddress, extraArgs);
    return tokens;
  }
  /**
   * Queries data of a specific collection by the collection creator address and the collection name.
   *
   * if, for some reason, a creator account has 2 collections with the same name in v1 and v2,
   * can pass an optional `tokenStandard` parameter to query a specific standard
   *
   * @param creatorAddress the collection creator address
   * @param collectionName the collection name
   * @returns GetCollectionDataQuery response type
   */
  async getCollectionData(creatorAddress, collectionName, extraArgs) {
    var _a, _b;
    const address = HexString.ensure(creatorAddress).hex();
    _IndexerClient.validateAddress(address);
    const whereCondition = {
      collection_name: { _eq: collectionName },
      creator_address: { _eq: address }
    };
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.token_standard = { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard };
    }
    const graphqlQuery = {
      query: GetCollectionData,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries a collection address.
   *
   * @param creatorAddress the collection creator address
   * @param collectionName the collection name
   * @returns the collection address
   */
  async getCollectionAddress(creatorAddress, collectionName, extraArgs) {
    return (await this.getCollectionData(creatorAddress, collectionName, extraArgs)).current_collections_v2[0].collection_id;
  }
  /**
   * Queries for all collections that an account has tokens for.
   *
   * @param ownerAddress the account address that owns the tokens
   * @returns GetCollectionsWithOwnedTokensQuery response type
   */
  async getCollectionsWithOwnedTokens(ownerAddress, extraArgs) {
    var _a, _b;
    const ownerHexAddress = HexString.ensure(ownerAddress).hex();
    _IndexerClient.validateAddress(ownerHexAddress);
    const whereCondition = {
      owner_address: { _eq: ownerHexAddress }
    };
    if (extraArgs == null ? void 0 : extraArgs.tokenStandard) {
      whereCondition.current_collection = { token_standard: { _eq: extraArgs == null ? void 0 : extraArgs.tokenStandard } };
    }
    const graphqlQuery = {
      query: GetCollectionsWithOwnedTokens,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  // TRANSACTIONS //
  /**
   * Gets the count of transactions submitted by an account
   *
   * @param address Account address
   * @returns GetAccountTransactionsCountQuery response type
   */
  async getAccountTransactionsCount(accountAddress) {
    const address = HexString.ensure(accountAddress).hex();
    _IndexerClient.validateAddress(address);
    const graphqlQuery = {
      query: GetAccountTransactionsCount,
      variables: { address }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries an account transactions data
   *
   * @param address Account address
   * @returns GetAccountTransactionsDataQuery response type
   */
  async getAccountTransactionsData(accountAddress, extraArgs) {
    var _a, _b;
    const address = HexString.ensure(accountAddress).hex();
    _IndexerClient.validateAddress(address);
    const whereCondition = {
      account_address: { _eq: address }
    };
    const graphqlQuery = {
      query: GetAccountTransactionsData,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries top user transactions
   *
   * @param limit
   * @returns GetTopUserTransactionsQuery response type
   */
  async getTopUserTransactions(limit) {
    const graphqlQuery = {
      query: GetTopUserTransactions,
      variables: { limit }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries top user transactions
   *
   * @param startVersion optional - can be set to tell indexer what version to start from
   * @returns GetUserTransactionsQuery response type
   */
  async getUserTransactions(extraArgs) {
    var _a, _b;
    const whereCondition = {
      version: { _lte: extraArgs == null ? void 0 : extraArgs.startVersion }
    };
    const graphqlQuery = {
      query: GetUserTransactions,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  // STAKING //
  /**
   * Queries delegated staking activities
   *
   * @param delegatorAddress Delegator address
   * @param poolAddress Pool address
   * @returns GetDelegatedStakingActivitiesQuery response type
   */
  async getDelegatedStakingActivities(delegatorAddress, poolAddress) {
    const delegator = HexString.ensure(delegatorAddress).hex();
    const pool = HexString.ensure(poolAddress).hex();
    _IndexerClient.validateAddress(delegator);
    _IndexerClient.validateAddress(pool);
    const graphqlQuery = {
      query: GetDelegatedStakingActivities,
      variables: {
        delegatorAddress: delegator,
        poolAddress: pool
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries current number of delegators in a pool
   *
   * @returns GetNumberOfDelegatorsQuery response type
   */
  async getNumberOfDelegators(poolAddress) {
    const address = HexString.ensure(poolAddress).hex();
    _IndexerClient.validateAddress(address);
    const graphqlQuery = {
      query: GetNumberOfDelegators,
      variables: { poolAddress: address }
    };
    return this.queryIndexer(graphqlQuery);
  }
  // ACCOUNT //
  /**
   * Queries an account coin data
   *
   * @param ownerAddress Owner address
   * @returns GetAccountCoinsDataQuery response type
   */
  async getAccountCoinsData(ownerAddress, extraArgs) {
    var _a, _b;
    const address = HexString.ensure(ownerAddress).hex();
    _IndexerClient.validateAddress(address);
    const whereCondition = {
      owner_address: { _eq: address }
    };
    const graphqlQuery = {
      query: GetAccountCoinsData,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries an account coin data count
   *
   * @param ownerAddress Owner address
   * @returns GetAccountCoinsDataCountQuery response type
   */
  async getAccountCoinsDataCount(ownerAddress) {
    const address = HexString.ensure(ownerAddress).hex();
    _IndexerClient.validateAddress(address);
    const graphqlQuery = {
      query: GetAccountCoinsDataCount,
      variables: {
        address
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
  /**
   * Queries an account owned objects
   *
   * @param ownerAddress Owner address
   * @returns GetCurrentObjectsQuery response type
   */
  async getAccountOwnedObjects(ownerAddress, extraArgs) {
    var _a, _b;
    const address = HexString.ensure(ownerAddress).hex();
    _IndexerClient.validateAddress(address);
    const whereCondition = {
      owner_address: { _eq: address }
    };
    const graphqlQuery = {
      query: GetCurrentObjects,
      variables: {
        where_condition: whereCondition,
        offset: (_a = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _a.offset,
        limit: (_b = extraArgs == null ? void 0 : extraArgs.options) == null ? void 0 : _b.limit,
        order_by: extraArgs == null ? void 0 : extraArgs.orderBy
      }
    };
    return this.queryIndexer(graphqlQuery);
  }
};
var Provider = class {
  constructor(network, config, doNotFixNodeUrl = false) {
    let fullNodeUrl = null;
    let indexerUrl = null;
    if (typeof network === "object" && isCustomEndpoints(network)) {
      fullNodeUrl = network.fullnodeUrl;
      indexerUrl = network.indexerUrl;
      this.network = "CUSTOM";
    } else {
      fullNodeUrl = NetworkToNodeAPI[network];
      indexerUrl = NetworkToIndexerAPI[network];
      this.network = network;
    }
    if (this.network === "CUSTOM" && !fullNodeUrl) {
      throw new Error("fullnode url is not provided");
    }
    if (indexerUrl) {
      this.indexerClient = new IndexerClient(indexerUrl, config);
    }
    this.aptosClient = new AptosClient(fullNodeUrl, config, doNotFixNodeUrl);
  }
};
function applyMixin(targetClass, baseClass, baseClassProp) {
  Object.getOwnPropertyNames(baseClass.prototype).forEach((propertyName) => {
    const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass.prototype, propertyName);
    if (!propertyDescriptor)
      return;
    propertyDescriptor.value = function(...args) {
      return this[baseClassProp][propertyName](...args);
    };
    Object.defineProperty(targetClass.prototype, propertyName, propertyDescriptor);
  });
  Object.getOwnPropertyNames(baseClass).forEach((propertyName) => {
    const propertyDescriptor = Object.getOwnPropertyDescriptor(baseClass, propertyName);
    if (!propertyDescriptor)
      return;
    propertyDescriptor.value = function(...args) {
      return this[baseClassProp][propertyName](...args);
    };
    if (targetClass.hasOwnProperty.call(targetClass, propertyName)) {
      return;
    }
    Object.defineProperty(targetClass, propertyName, propertyDescriptor);
  });
}
applyMixin(Provider, AptosClient, "aptosClient");
applyMixin(Provider, IndexerClient, "indexerClient");
function isCustomEndpoints(network) {
  return network.fullnodeUrl !== void 0 && typeof network.fullnodeUrl === "string";
}
var PropertyValue = class {
  constructor(type, value) {
    this.type = type;
    this.value = value;
  }
};
var PropertyMap = class {
  constructor() {
    this.data = {};
  }
  setProperty(key, value) {
    this.data[key] = value;
  }
};
function getPropertyType(typ) {
  let typeTag;
  if (typ === "string" || typ === "String") {
    typeTag = new TypeTagStruct(stringStructTag);
  } else {
    typeTag = new TypeTagParser(typ).parseTypeTag();
  }
  return typeTag;
}
function deserializePropertyMap(rawPropertyMap) {
  const entries = rawPropertyMap.map.data;
  const pm = new PropertyMap();
  entries.forEach((prop) => {
    const { key } = prop;
    const val = prop.value.value;
    const typ = prop.value.type;
    const typeTag = getPropertyType(typ);
    const newValue = deserializeValueBasedOnTypeTag(typeTag, val);
    const pv = new PropertyValue(typ, newValue);
    pm.setProperty(key, pv);
  });
  return pm;
}
function deserializeValueBasedOnTypeTag(tag, val) {
  const de = new Deserializer(new HexString(val).toUint8Array());
  let res = "";
  if (tag instanceof TypeTagU8) {
    res = de.deserializeU8().toString();
  } else if (tag instanceof TypeTagU64) {
    res = de.deserializeU64().toString();
  } else if (tag instanceof TypeTagU128) {
    res = de.deserializeU128().toString();
  } else if (tag instanceof TypeTagBool) {
    res = de.deserializeBool() ? "true" : "false";
  } else if (tag instanceof TypeTagAddress) {
    res = HexString.fromUint8Array(de.deserializeFixedBytes(32)).hex();
  } else if (tag instanceof TypeTagStruct && tag.isStringTypeTag()) {
    res = de.deserializeStr();
  } else {
    res = val;
  }
  return res;
}
var token_types_exports = {};
__export(token_types_exports, {
  PropertyMap: () => PropertyMap,
  PropertyValue: () => PropertyValue,
  Token: () => Token,
  TokenData: () => TokenData
});
var TokenData = class {
  constructor(collection, description, name, maximum, supply, uri, default_properties, mutability_config) {
    this.collection = collection;
    this.description = description;
    this.name = name;
    this.maximum = maximum;
    this.supply = supply;
    this.uri = uri;
    this.default_properties = deserializePropertyMap(default_properties);
    this.mutability_config = mutability_config;
  }
};
var Token = class {
  constructor(id, amount, token_properties) {
    this.id = id;
    this.amount = amount;
    this.token_properties = deserializePropertyMap(token_properties);
  }
};
var namePattern = new RegExp(
  "^(?:(?<subdomain>[^.]+)\\.(?!apt$))?(?<domain>[^.]+)(?:\\.apt)?$"
);
var TransactionWorkerEvents = ((TransactionWorkerEvents2) => {
  TransactionWorkerEvents2["TransactionSent"] = "transactionSent";
  TransactionWorkerEvents2["TransactionSendFailed"] = "transactionsendFailed";
  TransactionWorkerEvents2["TransactionExecuted"] = "transactionExecuted";
  TransactionWorkerEvents2["TransactionExecutionFailed"] = "transactionexecutionFailed";
  return TransactionWorkerEvents2;
})(TransactionWorkerEvents || {});
var generated_exports = {};
__export(generated_exports, {
  AptosErrorCode: () => AptosErrorCode,
  MoveFunctionVisibility: () => MoveFunctionVisibility,
  RoleType: () => RoleType
});
var AptosErrorCode = ((AptosErrorCode2) => {
  AptosErrorCode2["ACCOUNT_NOT_FOUND"] = "account_not_found";
  AptosErrorCode2["RESOURCE_NOT_FOUND"] = "resource_not_found";
  AptosErrorCode2["MODULE_NOT_FOUND"] = "module_not_found";
  AptosErrorCode2["STRUCT_FIELD_NOT_FOUND"] = "struct_field_not_found";
  AptosErrorCode2["VERSION_NOT_FOUND"] = "version_not_found";
  AptosErrorCode2["TRANSACTION_NOT_FOUND"] = "transaction_not_found";
  AptosErrorCode2["TABLE_ITEM_NOT_FOUND"] = "table_item_not_found";
  AptosErrorCode2["BLOCK_NOT_FOUND"] = "block_not_found";
  AptosErrorCode2["STATE_VALUE_NOT_FOUND"] = "state_value_not_found";
  AptosErrorCode2["VERSION_PRUNED"] = "version_pruned";
  AptosErrorCode2["BLOCK_PRUNED"] = "block_pruned";
  AptosErrorCode2["INVALID_INPUT"] = "invalid_input";
  AptosErrorCode2["INVALID_TRANSACTION_UPDATE"] = "invalid_transaction_update";
  AptosErrorCode2["SEQUENCE_NUMBER_TOO_OLD"] = "sequence_number_too_old";
  AptosErrorCode2["VM_ERROR"] = "vm_error";
  AptosErrorCode2["HEALTH_CHECK_FAILED"] = "health_check_failed";
  AptosErrorCode2["MEMPOOL_IS_FULL"] = "mempool_is_full";
  AptosErrorCode2["INTERNAL_ERROR"] = "internal_error";
  AptosErrorCode2["WEB_FRAMEWORK_ERROR"] = "web_framework_error";
  AptosErrorCode2["BCS_NOT_SUPPORTED"] = "bcs_not_supported";
  AptosErrorCode2["API_DISABLED"] = "api_disabled";
  return AptosErrorCode2;
})(AptosErrorCode || {});
var MoveFunctionVisibility = ((MoveFunctionVisibility2) => {
  MoveFunctionVisibility2["PRIVATE"] = "private";
  MoveFunctionVisibility2["PUBLIC"] = "public";
  MoveFunctionVisibility2["FRIEND"] = "friend";
  return MoveFunctionVisibility2;
})(MoveFunctionVisibility || {});
var RoleType = ((RoleType2) => {
  RoleType2["VALIDATOR"] = "validator";
  RoleType2["FULL_NODE"] = "full_node";
  return RoleType2;
})(RoleType || {});
var Account_Transactions_Select_Column = ((Account_Transactions_Select_Column2) => {
  Account_Transactions_Select_Column2["AccountAddress"] = "account_address";
  Account_Transactions_Select_Column2["TransactionVersion"] = "transaction_version";
  return Account_Transactions_Select_Column2;
})(Account_Transactions_Select_Column || {});
var Address_Events_Summary_Select_Column = ((Address_Events_Summary_Select_Column2) => {
  Address_Events_Summary_Select_Column2["AccountAddress"] = "account_address";
  Address_Events_Summary_Select_Column2["MinBlockHeight"] = "min_block_height";
  Address_Events_Summary_Select_Column2["NumDistinctVersions"] = "num_distinct_versions";
  return Address_Events_Summary_Select_Column2;
})(Address_Events_Summary_Select_Column || {});
var Address_Version_From_Events_Select_Column = ((Address_Version_From_Events_Select_Column2) => {
  Address_Version_From_Events_Select_Column2["AccountAddress"] = "account_address";
  Address_Version_From_Events_Select_Column2["TransactionVersion"] = "transaction_version";
  return Address_Version_From_Events_Select_Column2;
})(Address_Version_From_Events_Select_Column || {});
var Address_Version_From_Move_Resources_Select_Column = ((Address_Version_From_Move_Resources_Select_Column2) => {
  Address_Version_From_Move_Resources_Select_Column2["Address"] = "address";
  Address_Version_From_Move_Resources_Select_Column2["TransactionVersion"] = "transaction_version";
  return Address_Version_From_Move_Resources_Select_Column2;
})(Address_Version_From_Move_Resources_Select_Column || {});
var Block_Metadata_Transactions_Select_Column = ((Block_Metadata_Transactions_Select_Column2) => {
  Block_Metadata_Transactions_Select_Column2["BlockHeight"] = "block_height";
  Block_Metadata_Transactions_Select_Column2["Epoch"] = "epoch";
  Block_Metadata_Transactions_Select_Column2["FailedProposerIndices"] = "failed_proposer_indices";
  Block_Metadata_Transactions_Select_Column2["Id"] = "id";
  Block_Metadata_Transactions_Select_Column2["PreviousBlockVotesBitvec"] = "previous_block_votes_bitvec";
  Block_Metadata_Transactions_Select_Column2["Proposer"] = "proposer";
  Block_Metadata_Transactions_Select_Column2["Round"] = "round";
  Block_Metadata_Transactions_Select_Column2["Timestamp"] = "timestamp";
  Block_Metadata_Transactions_Select_Column2["Version"] = "version";
  return Block_Metadata_Transactions_Select_Column2;
})(Block_Metadata_Transactions_Select_Column || {});
var Coin_Activities_Select_Column = ((Coin_Activities_Select_Column2) => {
  Coin_Activities_Select_Column2["ActivityType"] = "activity_type";
  Coin_Activities_Select_Column2["Amount"] = "amount";
  Coin_Activities_Select_Column2["BlockHeight"] = "block_height";
  Coin_Activities_Select_Column2["CoinType"] = "coin_type";
  Coin_Activities_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
  Coin_Activities_Select_Column2["EventAccountAddress"] = "event_account_address";
  Coin_Activities_Select_Column2["EventCreationNumber"] = "event_creation_number";
  Coin_Activities_Select_Column2["EventIndex"] = "event_index";
  Coin_Activities_Select_Column2["EventSequenceNumber"] = "event_sequence_number";
  Coin_Activities_Select_Column2["IsGasFee"] = "is_gas_fee";
  Coin_Activities_Select_Column2["IsTransactionSuccess"] = "is_transaction_success";
  Coin_Activities_Select_Column2["OwnerAddress"] = "owner_address";
  Coin_Activities_Select_Column2["StorageRefundAmount"] = "storage_refund_amount";
  Coin_Activities_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Coin_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
  return Coin_Activities_Select_Column2;
})(Coin_Activities_Select_Column || {});
var Coin_Balances_Select_Column = ((Coin_Balances_Select_Column2) => {
  Coin_Balances_Select_Column2["Amount"] = "amount";
  Coin_Balances_Select_Column2["CoinType"] = "coin_type";
  Coin_Balances_Select_Column2["CoinTypeHash"] = "coin_type_hash";
  Coin_Balances_Select_Column2["OwnerAddress"] = "owner_address";
  Coin_Balances_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Coin_Balances_Select_Column2["TransactionVersion"] = "transaction_version";
  return Coin_Balances_Select_Column2;
})(Coin_Balances_Select_Column || {});
var Coin_Infos_Select_Column = ((Coin_Infos_Select_Column2) => {
  Coin_Infos_Select_Column2["CoinType"] = "coin_type";
  Coin_Infos_Select_Column2["CoinTypeHash"] = "coin_type_hash";
  Coin_Infos_Select_Column2["CreatorAddress"] = "creator_address";
  Coin_Infos_Select_Column2["Decimals"] = "decimals";
  Coin_Infos_Select_Column2["Name"] = "name";
  Coin_Infos_Select_Column2["SupplyAggregatorTableHandle"] = "supply_aggregator_table_handle";
  Coin_Infos_Select_Column2["SupplyAggregatorTableKey"] = "supply_aggregator_table_key";
  Coin_Infos_Select_Column2["Symbol"] = "symbol";
  Coin_Infos_Select_Column2["TransactionCreatedTimestamp"] = "transaction_created_timestamp";
  Coin_Infos_Select_Column2["TransactionVersionCreated"] = "transaction_version_created";
  return Coin_Infos_Select_Column2;
})(Coin_Infos_Select_Column || {});
var Coin_Supply_Select_Column = ((Coin_Supply_Select_Column2) => {
  Coin_Supply_Select_Column2["CoinType"] = "coin_type";
  Coin_Supply_Select_Column2["CoinTypeHash"] = "coin_type_hash";
  Coin_Supply_Select_Column2["Supply"] = "supply";
  Coin_Supply_Select_Column2["TransactionEpoch"] = "transaction_epoch";
  Coin_Supply_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Coin_Supply_Select_Column2["TransactionVersion"] = "transaction_version";
  return Coin_Supply_Select_Column2;
})(Coin_Supply_Select_Column || {});
var Collection_Datas_Select_Column = ((Collection_Datas_Select_Column2) => {
  Collection_Datas_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
  Collection_Datas_Select_Column2["CollectionName"] = "collection_name";
  Collection_Datas_Select_Column2["CreatorAddress"] = "creator_address";
  Collection_Datas_Select_Column2["Description"] = "description";
  Collection_Datas_Select_Column2["DescriptionMutable"] = "description_mutable";
  Collection_Datas_Select_Column2["Maximum"] = "maximum";
  Collection_Datas_Select_Column2["MaximumMutable"] = "maximum_mutable";
  Collection_Datas_Select_Column2["MetadataUri"] = "metadata_uri";
  Collection_Datas_Select_Column2["Supply"] = "supply";
  Collection_Datas_Select_Column2["TableHandle"] = "table_handle";
  Collection_Datas_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Collection_Datas_Select_Column2["TransactionVersion"] = "transaction_version";
  Collection_Datas_Select_Column2["UriMutable"] = "uri_mutable";
  return Collection_Datas_Select_Column2;
})(Collection_Datas_Select_Column || {});
var Current_Ans_Lookup_Select_Column = ((Current_Ans_Lookup_Select_Column2) => {
  Current_Ans_Lookup_Select_Column2["Domain"] = "domain";
  Current_Ans_Lookup_Select_Column2["ExpirationTimestamp"] = "expiration_timestamp";
  Current_Ans_Lookup_Select_Column2["IsDeleted"] = "is_deleted";
  Current_Ans_Lookup_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Ans_Lookup_Select_Column2["RegisteredAddress"] = "registered_address";
  Current_Ans_Lookup_Select_Column2["Subdomain"] = "subdomain";
  Current_Ans_Lookup_Select_Column2["TokenName"] = "token_name";
  return Current_Ans_Lookup_Select_Column2;
})(Current_Ans_Lookup_Select_Column || {});
var Current_Ans_Lookup_V2_Select_Column = ((Current_Ans_Lookup_V2_Select_Column2) => {
  Current_Ans_Lookup_V2_Select_Column2["Domain"] = "domain";
  Current_Ans_Lookup_V2_Select_Column2["ExpirationTimestamp"] = "expiration_timestamp";
  Current_Ans_Lookup_V2_Select_Column2["IsDeleted"] = "is_deleted";
  Current_Ans_Lookup_V2_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Ans_Lookup_V2_Select_Column2["RegisteredAddress"] = "registered_address";
  Current_Ans_Lookup_V2_Select_Column2["Subdomain"] = "subdomain";
  Current_Ans_Lookup_V2_Select_Column2["TokenName"] = "token_name";
  Current_Ans_Lookup_V2_Select_Column2["TokenStandard"] = "token_standard";
  return Current_Ans_Lookup_V2_Select_Column2;
})(Current_Ans_Lookup_V2_Select_Column || {});
var Current_Aptos_Names_Select_Column = ((Current_Aptos_Names_Select_Column2) => {
  Current_Aptos_Names_Select_Column2["Domain"] = "domain";
  Current_Aptos_Names_Select_Column2["DomainWithSuffix"] = "domain_with_suffix";
  Current_Aptos_Names_Select_Column2["ExpirationTimestamp"] = "expiration_timestamp";
  Current_Aptos_Names_Select_Column2["IsActive"] = "is_active";
  Current_Aptos_Names_Select_Column2["IsPrimary"] = "is_primary";
  Current_Aptos_Names_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Aptos_Names_Select_Column2["OwnerAddress"] = "owner_address";
  Current_Aptos_Names_Select_Column2["RegisteredAddress"] = "registered_address";
  Current_Aptos_Names_Select_Column2["Subdomain"] = "subdomain";
  Current_Aptos_Names_Select_Column2["TokenName"] = "token_name";
  Current_Aptos_Names_Select_Column2["TokenStandard"] = "token_standard";
  return Current_Aptos_Names_Select_Column2;
})(Current_Aptos_Names_Select_Column || {});
var Current_Coin_Balances_Select_Column = ((Current_Coin_Balances_Select_Column2) => {
  Current_Coin_Balances_Select_Column2["Amount"] = "amount";
  Current_Coin_Balances_Select_Column2["CoinType"] = "coin_type";
  Current_Coin_Balances_Select_Column2["CoinTypeHash"] = "coin_type_hash";
  Current_Coin_Balances_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Coin_Balances_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Coin_Balances_Select_Column2["OwnerAddress"] = "owner_address";
  return Current_Coin_Balances_Select_Column2;
})(Current_Coin_Balances_Select_Column || {});
var Current_Collection_Datas_Select_Column = ((Current_Collection_Datas_Select_Column2) => {
  Current_Collection_Datas_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
  Current_Collection_Datas_Select_Column2["CollectionName"] = "collection_name";
  Current_Collection_Datas_Select_Column2["CreatorAddress"] = "creator_address";
  Current_Collection_Datas_Select_Column2["Description"] = "description";
  Current_Collection_Datas_Select_Column2["DescriptionMutable"] = "description_mutable";
  Current_Collection_Datas_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Collection_Datas_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Collection_Datas_Select_Column2["Maximum"] = "maximum";
  Current_Collection_Datas_Select_Column2["MaximumMutable"] = "maximum_mutable";
  Current_Collection_Datas_Select_Column2["MetadataUri"] = "metadata_uri";
  Current_Collection_Datas_Select_Column2["Supply"] = "supply";
  Current_Collection_Datas_Select_Column2["TableHandle"] = "table_handle";
  Current_Collection_Datas_Select_Column2["UriMutable"] = "uri_mutable";
  return Current_Collection_Datas_Select_Column2;
})(Current_Collection_Datas_Select_Column || {});
var Current_Collection_Ownership_V2_View_Select_Column = ((Current_Collection_Ownership_V2_View_Select_Column2) => {
  Current_Collection_Ownership_V2_View_Select_Column2["CollectionId"] = "collection_id";
  Current_Collection_Ownership_V2_View_Select_Column2["CollectionName"] = "collection_name";
  Current_Collection_Ownership_V2_View_Select_Column2["CollectionUri"] = "collection_uri";
  Current_Collection_Ownership_V2_View_Select_Column2["CreatorAddress"] = "creator_address";
  Current_Collection_Ownership_V2_View_Select_Column2["DistinctTokens"] = "distinct_tokens";
  Current_Collection_Ownership_V2_View_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Collection_Ownership_V2_View_Select_Column2["OwnerAddress"] = "owner_address";
  Current_Collection_Ownership_V2_View_Select_Column2["SingleTokenUri"] = "single_token_uri";
  return Current_Collection_Ownership_V2_View_Select_Column2;
})(Current_Collection_Ownership_V2_View_Select_Column || {});
var Current_Collections_V2_Select_Column = ((Current_Collections_V2_Select_Column2) => {
  Current_Collections_V2_Select_Column2["CollectionId"] = "collection_id";
  Current_Collections_V2_Select_Column2["CollectionName"] = "collection_name";
  Current_Collections_V2_Select_Column2["CreatorAddress"] = "creator_address";
  Current_Collections_V2_Select_Column2["CurrentSupply"] = "current_supply";
  Current_Collections_V2_Select_Column2["Description"] = "description";
  Current_Collections_V2_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Collections_V2_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Collections_V2_Select_Column2["MaxSupply"] = "max_supply";
  Current_Collections_V2_Select_Column2["MutableDescription"] = "mutable_description";
  Current_Collections_V2_Select_Column2["MutableUri"] = "mutable_uri";
  Current_Collections_V2_Select_Column2["TableHandleV1"] = "table_handle_v1";
  Current_Collections_V2_Select_Column2["TokenStandard"] = "token_standard";
  Current_Collections_V2_Select_Column2["TotalMintedV2"] = "total_minted_v2";
  Current_Collections_V2_Select_Column2["Uri"] = "uri";
  return Current_Collections_V2_Select_Column2;
})(Current_Collections_V2_Select_Column || {});
var Current_Delegated_Staking_Pool_Balances_Select_Column = ((Current_Delegated_Staking_Pool_Balances_Select_Column2) => {
  Current_Delegated_Staking_Pool_Balances_Select_Column2["ActiveTableHandle"] = "active_table_handle";
  Current_Delegated_Staking_Pool_Balances_Select_Column2["InactiveTableHandle"] = "inactive_table_handle";
  Current_Delegated_Staking_Pool_Balances_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Delegated_Staking_Pool_Balances_Select_Column2["OperatorCommissionPercentage"] = "operator_commission_percentage";
  Current_Delegated_Staking_Pool_Balances_Select_Column2["StakingPoolAddress"] = "staking_pool_address";
  Current_Delegated_Staking_Pool_Balances_Select_Column2["TotalCoins"] = "total_coins";
  Current_Delegated_Staking_Pool_Balances_Select_Column2["TotalShares"] = "total_shares";
  return Current_Delegated_Staking_Pool_Balances_Select_Column2;
})(Current_Delegated_Staking_Pool_Balances_Select_Column || {});
var Current_Delegated_Voter_Select_Column = ((Current_Delegated_Voter_Select_Column2) => {
  Current_Delegated_Voter_Select_Column2["DelegationPoolAddress"] = "delegation_pool_address";
  Current_Delegated_Voter_Select_Column2["DelegatorAddress"] = "delegator_address";
  Current_Delegated_Voter_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Delegated_Voter_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Delegated_Voter_Select_Column2["PendingVoter"] = "pending_voter";
  Current_Delegated_Voter_Select_Column2["TableHandle"] = "table_handle";
  Current_Delegated_Voter_Select_Column2["Voter"] = "voter";
  return Current_Delegated_Voter_Select_Column2;
})(Current_Delegated_Voter_Select_Column || {});
var Current_Delegator_Balances_Select_Column = ((Current_Delegator_Balances_Select_Column2) => {
  Current_Delegator_Balances_Select_Column2["DelegatorAddress"] = "delegator_address";
  Current_Delegator_Balances_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Delegator_Balances_Select_Column2["ParentTableHandle"] = "parent_table_handle";
  Current_Delegator_Balances_Select_Column2["PoolAddress"] = "pool_address";
  Current_Delegator_Balances_Select_Column2["PoolType"] = "pool_type";
  Current_Delegator_Balances_Select_Column2["Shares"] = "shares";
  Current_Delegator_Balances_Select_Column2["TableHandle"] = "table_handle";
  return Current_Delegator_Balances_Select_Column2;
})(Current_Delegator_Balances_Select_Column || {});
var Current_Fungible_Asset_Balances_Select_Column = ((Current_Fungible_Asset_Balances_Select_Column2) => {
  Current_Fungible_Asset_Balances_Select_Column2["Amount"] = "amount";
  Current_Fungible_Asset_Balances_Select_Column2["AssetType"] = "asset_type";
  Current_Fungible_Asset_Balances_Select_Column2["IsFrozen"] = "is_frozen";
  Current_Fungible_Asset_Balances_Select_Column2["IsPrimary"] = "is_primary";
  Current_Fungible_Asset_Balances_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Fungible_Asset_Balances_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Fungible_Asset_Balances_Select_Column2["OwnerAddress"] = "owner_address";
  Current_Fungible_Asset_Balances_Select_Column2["StorageId"] = "storage_id";
  Current_Fungible_Asset_Balances_Select_Column2["TokenStandard"] = "token_standard";
  return Current_Fungible_Asset_Balances_Select_Column2;
})(Current_Fungible_Asset_Balances_Select_Column || {});
var Current_Objects_Select_Column = ((Current_Objects_Select_Column2) => {
  Current_Objects_Select_Column2["AllowUngatedTransfer"] = "allow_ungated_transfer";
  Current_Objects_Select_Column2["IsDeleted"] = "is_deleted";
  Current_Objects_Select_Column2["LastGuidCreationNum"] = "last_guid_creation_num";
  Current_Objects_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Objects_Select_Column2["ObjectAddress"] = "object_address";
  Current_Objects_Select_Column2["OwnerAddress"] = "owner_address";
  Current_Objects_Select_Column2["StateKeyHash"] = "state_key_hash";
  return Current_Objects_Select_Column2;
})(Current_Objects_Select_Column || {});
var Current_Staking_Pool_Voter_Select_Column = ((Current_Staking_Pool_Voter_Select_Column2) => {
  Current_Staking_Pool_Voter_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Staking_Pool_Voter_Select_Column2["OperatorAddress"] = "operator_address";
  Current_Staking_Pool_Voter_Select_Column2["StakingPoolAddress"] = "staking_pool_address";
  Current_Staking_Pool_Voter_Select_Column2["VoterAddress"] = "voter_address";
  return Current_Staking_Pool_Voter_Select_Column2;
})(Current_Staking_Pool_Voter_Select_Column || {});
var Current_Table_Items_Select_Column = ((Current_Table_Items_Select_Column2) => {
  Current_Table_Items_Select_Column2["DecodedKey"] = "decoded_key";
  Current_Table_Items_Select_Column2["DecodedValue"] = "decoded_value";
  Current_Table_Items_Select_Column2["IsDeleted"] = "is_deleted";
  Current_Table_Items_Select_Column2["Key"] = "key";
  Current_Table_Items_Select_Column2["KeyHash"] = "key_hash";
  Current_Table_Items_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Table_Items_Select_Column2["TableHandle"] = "table_handle";
  return Current_Table_Items_Select_Column2;
})(Current_Table_Items_Select_Column || {});
var Current_Token_Datas_Select_Column = ((Current_Token_Datas_Select_Column2) => {
  Current_Token_Datas_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
  Current_Token_Datas_Select_Column2["CollectionName"] = "collection_name";
  Current_Token_Datas_Select_Column2["CreatorAddress"] = "creator_address";
  Current_Token_Datas_Select_Column2["DefaultProperties"] = "default_properties";
  Current_Token_Datas_Select_Column2["Description"] = "description";
  Current_Token_Datas_Select_Column2["DescriptionMutable"] = "description_mutable";
  Current_Token_Datas_Select_Column2["LargestPropertyVersion"] = "largest_property_version";
  Current_Token_Datas_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Token_Datas_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Token_Datas_Select_Column2["Maximum"] = "maximum";
  Current_Token_Datas_Select_Column2["MaximumMutable"] = "maximum_mutable";
  Current_Token_Datas_Select_Column2["MetadataUri"] = "metadata_uri";
  Current_Token_Datas_Select_Column2["Name"] = "name";
  Current_Token_Datas_Select_Column2["PayeeAddress"] = "payee_address";
  Current_Token_Datas_Select_Column2["PropertiesMutable"] = "properties_mutable";
  Current_Token_Datas_Select_Column2["RoyaltyMutable"] = "royalty_mutable";
  Current_Token_Datas_Select_Column2["RoyaltyPointsDenominator"] = "royalty_points_denominator";
  Current_Token_Datas_Select_Column2["RoyaltyPointsNumerator"] = "royalty_points_numerator";
  Current_Token_Datas_Select_Column2["Supply"] = "supply";
  Current_Token_Datas_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
  Current_Token_Datas_Select_Column2["UriMutable"] = "uri_mutable";
  return Current_Token_Datas_Select_Column2;
})(Current_Token_Datas_Select_Column || {});
var Current_Token_Datas_V2_Select_Column = ((Current_Token_Datas_V2_Select_Column2) => {
  Current_Token_Datas_V2_Select_Column2["CollectionId"] = "collection_id";
  Current_Token_Datas_V2_Select_Column2["Description"] = "description";
  Current_Token_Datas_V2_Select_Column2["IsFungibleV2"] = "is_fungible_v2";
  Current_Token_Datas_V2_Select_Column2["LargestPropertyVersionV1"] = "largest_property_version_v1";
  Current_Token_Datas_V2_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Token_Datas_V2_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Token_Datas_V2_Select_Column2["Maximum"] = "maximum";
  Current_Token_Datas_V2_Select_Column2["Supply"] = "supply";
  Current_Token_Datas_V2_Select_Column2["TokenDataId"] = "token_data_id";
  Current_Token_Datas_V2_Select_Column2["TokenName"] = "token_name";
  Current_Token_Datas_V2_Select_Column2["TokenProperties"] = "token_properties";
  Current_Token_Datas_V2_Select_Column2["TokenStandard"] = "token_standard";
  Current_Token_Datas_V2_Select_Column2["TokenUri"] = "token_uri";
  return Current_Token_Datas_V2_Select_Column2;
})(Current_Token_Datas_V2_Select_Column || {});
var Current_Token_Ownerships_Select_Column = ((Current_Token_Ownerships_Select_Column2) => {
  Current_Token_Ownerships_Select_Column2["Amount"] = "amount";
  Current_Token_Ownerships_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
  Current_Token_Ownerships_Select_Column2["CollectionName"] = "collection_name";
  Current_Token_Ownerships_Select_Column2["CreatorAddress"] = "creator_address";
  Current_Token_Ownerships_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Token_Ownerships_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Token_Ownerships_Select_Column2["Name"] = "name";
  Current_Token_Ownerships_Select_Column2["OwnerAddress"] = "owner_address";
  Current_Token_Ownerships_Select_Column2["PropertyVersion"] = "property_version";
  Current_Token_Ownerships_Select_Column2["TableType"] = "table_type";
  Current_Token_Ownerships_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
  Current_Token_Ownerships_Select_Column2["TokenProperties"] = "token_properties";
  return Current_Token_Ownerships_Select_Column2;
})(Current_Token_Ownerships_Select_Column || {});
var Current_Token_Ownerships_V2_Select_Column = ((Current_Token_Ownerships_V2_Select_Column2) => {
  Current_Token_Ownerships_V2_Select_Column2["Amount"] = "amount";
  Current_Token_Ownerships_V2_Select_Column2["IsFungibleV2"] = "is_fungible_v2";
  Current_Token_Ownerships_V2_Select_Column2["IsSoulboundV2"] = "is_soulbound_v2";
  Current_Token_Ownerships_V2_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Token_Ownerships_V2_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Token_Ownerships_V2_Select_Column2["OwnerAddress"] = "owner_address";
  Current_Token_Ownerships_V2_Select_Column2["PropertyVersionV1"] = "property_version_v1";
  Current_Token_Ownerships_V2_Select_Column2["StorageId"] = "storage_id";
  Current_Token_Ownerships_V2_Select_Column2["TableTypeV1"] = "table_type_v1";
  Current_Token_Ownerships_V2_Select_Column2["TokenDataId"] = "token_data_id";
  Current_Token_Ownerships_V2_Select_Column2["TokenPropertiesMutatedV1"] = "token_properties_mutated_v1";
  Current_Token_Ownerships_V2_Select_Column2["TokenStandard"] = "token_standard";
  return Current_Token_Ownerships_V2_Select_Column2;
})(Current_Token_Ownerships_V2_Select_Column || {});
var Current_Token_Pending_Claims_Select_Column = ((Current_Token_Pending_Claims_Select_Column2) => {
  Current_Token_Pending_Claims_Select_Column2["Amount"] = "amount";
  Current_Token_Pending_Claims_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
  Current_Token_Pending_Claims_Select_Column2["CollectionId"] = "collection_id";
  Current_Token_Pending_Claims_Select_Column2["CollectionName"] = "collection_name";
  Current_Token_Pending_Claims_Select_Column2["CreatorAddress"] = "creator_address";
  Current_Token_Pending_Claims_Select_Column2["FromAddress"] = "from_address";
  Current_Token_Pending_Claims_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Current_Token_Pending_Claims_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Current_Token_Pending_Claims_Select_Column2["Name"] = "name";
  Current_Token_Pending_Claims_Select_Column2["PropertyVersion"] = "property_version";
  Current_Token_Pending_Claims_Select_Column2["TableHandle"] = "table_handle";
  Current_Token_Pending_Claims_Select_Column2["ToAddress"] = "to_address";
  Current_Token_Pending_Claims_Select_Column2["TokenDataId"] = "token_data_id";
  Current_Token_Pending_Claims_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
  return Current_Token_Pending_Claims_Select_Column2;
})(Current_Token_Pending_Claims_Select_Column || {});
var Cursor_Ordering = ((Cursor_Ordering2) => {
  Cursor_Ordering2["Asc"] = "ASC";
  Cursor_Ordering2["Desc"] = "DESC";
  return Cursor_Ordering2;
})(Cursor_Ordering || {});
var Delegated_Staking_Activities_Select_Column = ((Delegated_Staking_Activities_Select_Column2) => {
  Delegated_Staking_Activities_Select_Column2["Amount"] = "amount";
  Delegated_Staking_Activities_Select_Column2["DelegatorAddress"] = "delegator_address";
  Delegated_Staking_Activities_Select_Column2["EventIndex"] = "event_index";
  Delegated_Staking_Activities_Select_Column2["EventType"] = "event_type";
  Delegated_Staking_Activities_Select_Column2["PoolAddress"] = "pool_address";
  Delegated_Staking_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
  return Delegated_Staking_Activities_Select_Column2;
})(Delegated_Staking_Activities_Select_Column || {});
var Delegated_Staking_Pools_Select_Column = ((Delegated_Staking_Pools_Select_Column2) => {
  Delegated_Staking_Pools_Select_Column2["FirstTransactionVersion"] = "first_transaction_version";
  Delegated_Staking_Pools_Select_Column2["StakingPoolAddress"] = "staking_pool_address";
  return Delegated_Staking_Pools_Select_Column2;
})(Delegated_Staking_Pools_Select_Column || {});
var Delegator_Distinct_Pool_Select_Column = ((Delegator_Distinct_Pool_Select_Column2) => {
  Delegator_Distinct_Pool_Select_Column2["DelegatorAddress"] = "delegator_address";
  Delegator_Distinct_Pool_Select_Column2["PoolAddress"] = "pool_address";
  return Delegator_Distinct_Pool_Select_Column2;
})(Delegator_Distinct_Pool_Select_Column || {});
var Events_Select_Column = ((Events_Select_Column2) => {
  Events_Select_Column2["AccountAddress"] = "account_address";
  Events_Select_Column2["CreationNumber"] = "creation_number";
  Events_Select_Column2["Data"] = "data";
  Events_Select_Column2["EventIndex"] = "event_index";
  Events_Select_Column2["IndexedType"] = "indexed_type";
  Events_Select_Column2["SequenceNumber"] = "sequence_number";
  Events_Select_Column2["TransactionBlockHeight"] = "transaction_block_height";
  Events_Select_Column2["TransactionVersion"] = "transaction_version";
  Events_Select_Column2["Type"] = "type";
  return Events_Select_Column2;
})(Events_Select_Column || {});
var Fungible_Asset_Activities_Select_Column = ((Fungible_Asset_Activities_Select_Column2) => {
  Fungible_Asset_Activities_Select_Column2["Amount"] = "amount";
  Fungible_Asset_Activities_Select_Column2["AssetType"] = "asset_type";
  Fungible_Asset_Activities_Select_Column2["BlockHeight"] = "block_height";
  Fungible_Asset_Activities_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
  Fungible_Asset_Activities_Select_Column2["EventIndex"] = "event_index";
  Fungible_Asset_Activities_Select_Column2["GasFeePayerAddress"] = "gas_fee_payer_address";
  Fungible_Asset_Activities_Select_Column2["IsFrozen"] = "is_frozen";
  Fungible_Asset_Activities_Select_Column2["IsGasFee"] = "is_gas_fee";
  Fungible_Asset_Activities_Select_Column2["IsTransactionSuccess"] = "is_transaction_success";
  Fungible_Asset_Activities_Select_Column2["OwnerAddress"] = "owner_address";
  Fungible_Asset_Activities_Select_Column2["StorageId"] = "storage_id";
  Fungible_Asset_Activities_Select_Column2["StorageRefundAmount"] = "storage_refund_amount";
  Fungible_Asset_Activities_Select_Column2["TokenStandard"] = "token_standard";
  Fungible_Asset_Activities_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Fungible_Asset_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
  Fungible_Asset_Activities_Select_Column2["Type"] = "type";
  return Fungible_Asset_Activities_Select_Column2;
})(Fungible_Asset_Activities_Select_Column || {});
var Fungible_Asset_Metadata_Select_Column = ((Fungible_Asset_Metadata_Select_Column2) => {
  Fungible_Asset_Metadata_Select_Column2["AssetType"] = "asset_type";
  Fungible_Asset_Metadata_Select_Column2["CreatorAddress"] = "creator_address";
  Fungible_Asset_Metadata_Select_Column2["Decimals"] = "decimals";
  Fungible_Asset_Metadata_Select_Column2["IconUri"] = "icon_uri";
  Fungible_Asset_Metadata_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Fungible_Asset_Metadata_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Fungible_Asset_Metadata_Select_Column2["Name"] = "name";
  Fungible_Asset_Metadata_Select_Column2["ProjectUri"] = "project_uri";
  Fungible_Asset_Metadata_Select_Column2["SupplyAggregatorTableHandleV1"] = "supply_aggregator_table_handle_v1";
  Fungible_Asset_Metadata_Select_Column2["SupplyAggregatorTableKeyV1"] = "supply_aggregator_table_key_v1";
  Fungible_Asset_Metadata_Select_Column2["Symbol"] = "symbol";
  Fungible_Asset_Metadata_Select_Column2["TokenStandard"] = "token_standard";
  return Fungible_Asset_Metadata_Select_Column2;
})(Fungible_Asset_Metadata_Select_Column || {});
var Indexer_Status_Select_Column = ((Indexer_Status_Select_Column2) => {
  Indexer_Status_Select_Column2["Db"] = "db";
  Indexer_Status_Select_Column2["IsIndexerUp"] = "is_indexer_up";
  return Indexer_Status_Select_Column2;
})(Indexer_Status_Select_Column || {});
var Ledger_Infos_Select_Column = ((Ledger_Infos_Select_Column2) => {
  Ledger_Infos_Select_Column2["ChainId"] = "chain_id";
  return Ledger_Infos_Select_Column2;
})(Ledger_Infos_Select_Column || {});
var Move_Resources_Select_Column = ((Move_Resources_Select_Column2) => {
  Move_Resources_Select_Column2["Address"] = "address";
  Move_Resources_Select_Column2["TransactionVersion"] = "transaction_version";
  return Move_Resources_Select_Column2;
})(Move_Resources_Select_Column || {});
var Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column = ((Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2) => {
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["BuyItNowPrice"] = "buy_it_now_price";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["CoinType"] = "coin_type";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["CollectionId"] = "collection_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["ContractAddress"] = "contract_address";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["CurrentBidPrice"] = "current_bid_price";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["CurrentBidder"] = "current_bidder";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["ExpirationTime"] = "expiration_time";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["IsDeleted"] = "is_deleted";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["ListingId"] = "listing_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["Marketplace"] = "marketplace";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["Seller"] = "seller";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["StartingBidPrice"] = "starting_bid_price";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["TokenAmount"] = "token_amount";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["TokenDataId"] = "token_data_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2["TokenStandard"] = "token_standard";
  return Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column2;
})(Nft_Marketplace_V2_Current_Nft_Marketplace_Auctions_Select_Column || {});
var Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column = ((Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2) => {
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["Buyer"] = "buyer";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["CoinType"] = "coin_type";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["CollectionId"] = "collection_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["CollectionOfferId"] = "collection_offer_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["ContractAddress"] = "contract_address";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["ExpirationTime"] = "expiration_time";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["IsDeleted"] = "is_deleted";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["ItemPrice"] = "item_price";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["Marketplace"] = "marketplace";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["RemainingTokenAmount"] = "remaining_token_amount";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2["TokenStandard"] = "token_standard";
  return Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column2;
})(Nft_Marketplace_V2_Current_Nft_Marketplace_Collection_Offers_Select_Column || {});
var Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column = ((Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2) => {
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["CoinType"] = "coin_type";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["CollectionId"] = "collection_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["ContractAddress"] = "contract_address";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["IsDeleted"] = "is_deleted";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["ListingId"] = "listing_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["Marketplace"] = "marketplace";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["Price"] = "price";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["Seller"] = "seller";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["TokenAmount"] = "token_amount";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["TokenDataId"] = "token_data_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2["TokenStandard"] = "token_standard";
  return Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column2;
})(Nft_Marketplace_V2_Current_Nft_Marketplace_Listings_Select_Column || {});
var Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column = ((Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2) => {
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["Buyer"] = "buyer";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["CoinType"] = "coin_type";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["CollectionId"] = "collection_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["ContractAddress"] = "contract_address";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["ExpirationTime"] = "expiration_time";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["IsDeleted"] = "is_deleted";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["LastTransactionTimestamp"] = "last_transaction_timestamp";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["LastTransactionVersion"] = "last_transaction_version";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["Marketplace"] = "marketplace";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["OfferId"] = "offer_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["Price"] = "price";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["TokenAmount"] = "token_amount";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["TokenDataId"] = "token_data_id";
  Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2["TokenStandard"] = "token_standard";
  return Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column2;
})(Nft_Marketplace_V2_Current_Nft_Marketplace_Token_Offers_Select_Column || {});
var Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column = ((Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2) => {
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["Buyer"] = "buyer";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["CoinType"] = "coin_type";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["CollectionId"] = "collection_id";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["CollectionName"] = "collection_name";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["ContractAddress"] = "contract_address";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["CreatorAddress"] = "creator_address";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["EventIndex"] = "event_index";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["EventType"] = "event_type";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["FeeScheduleId"] = "fee_schedule_id";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["Marketplace"] = "marketplace";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["OfferOrListingId"] = "offer_or_listing_id";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["Price"] = "price";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["PropertyVersion"] = "property_version";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["Seller"] = "seller";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TokenAmount"] = "token_amount";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TokenDataId"] = "token_data_id";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TokenName"] = "token_name";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TokenStandard"] = "token_standard";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
  return Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column2;
})(Nft_Marketplace_V2_Nft_Marketplace_Activities_Select_Column || {});
var Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column = ((Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2) => {
  Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["AnimationOptimizerRetryCount"] = "animation_optimizer_retry_count";
  Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["AssetUri"] = "asset_uri";
  Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["CdnAnimationUri"] = "cdn_animation_uri";
  Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["CdnImageUri"] = "cdn_image_uri";
  Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["CdnJsonUri"] = "cdn_json_uri";
  Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["ImageOptimizerRetryCount"] = "image_optimizer_retry_count";
  Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["JsonParserRetryCount"] = "json_parser_retry_count";
  Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["RawAnimationUri"] = "raw_animation_uri";
  Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2["RawImageUri"] = "raw_image_uri";
  return Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column2;
})(Nft_Metadata_Crawler_Parsed_Asset_Uris_Select_Column || {});
var Num_Active_Delegator_Per_Pool_Select_Column = ((Num_Active_Delegator_Per_Pool_Select_Column2) => {
  Num_Active_Delegator_Per_Pool_Select_Column2["NumActiveDelegator"] = "num_active_delegator";
  Num_Active_Delegator_Per_Pool_Select_Column2["PoolAddress"] = "pool_address";
  return Num_Active_Delegator_Per_Pool_Select_Column2;
})(Num_Active_Delegator_Per_Pool_Select_Column || {});
var Order_By = ((Order_By2) => {
  Order_By2["Asc"] = "asc";
  Order_By2["AscNullsFirst"] = "asc_nulls_first";
  Order_By2["AscNullsLast"] = "asc_nulls_last";
  Order_By2["Desc"] = "desc";
  Order_By2["DescNullsFirst"] = "desc_nulls_first";
  Order_By2["DescNullsLast"] = "desc_nulls_last";
  return Order_By2;
})(Order_By || {});
var Processor_Status_Select_Column = ((Processor_Status_Select_Column2) => {
  Processor_Status_Select_Column2["LastSuccessVersion"] = "last_success_version";
  Processor_Status_Select_Column2["LastUpdated"] = "last_updated";
  Processor_Status_Select_Column2["Processor"] = "processor";
  return Processor_Status_Select_Column2;
})(Processor_Status_Select_Column || {});
var Proposal_Votes_Select_Column = ((Proposal_Votes_Select_Column2) => {
  Proposal_Votes_Select_Column2["NumVotes"] = "num_votes";
  Proposal_Votes_Select_Column2["ProposalId"] = "proposal_id";
  Proposal_Votes_Select_Column2["ShouldPass"] = "should_pass";
  Proposal_Votes_Select_Column2["StakingPoolAddress"] = "staking_pool_address";
  Proposal_Votes_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Proposal_Votes_Select_Column2["TransactionVersion"] = "transaction_version";
  Proposal_Votes_Select_Column2["VoterAddress"] = "voter_address";
  return Proposal_Votes_Select_Column2;
})(Proposal_Votes_Select_Column || {});
var Table_Items_Select_Column = ((Table_Items_Select_Column2) => {
  Table_Items_Select_Column2["DecodedKey"] = "decoded_key";
  Table_Items_Select_Column2["DecodedValue"] = "decoded_value";
  Table_Items_Select_Column2["Key"] = "key";
  Table_Items_Select_Column2["TableHandle"] = "table_handle";
  Table_Items_Select_Column2["TransactionVersion"] = "transaction_version";
  Table_Items_Select_Column2["WriteSetChangeIndex"] = "write_set_change_index";
  return Table_Items_Select_Column2;
})(Table_Items_Select_Column || {});
var Table_Metadatas_Select_Column = ((Table_Metadatas_Select_Column2) => {
  Table_Metadatas_Select_Column2["Handle"] = "handle";
  Table_Metadatas_Select_Column2["KeyType"] = "key_type";
  Table_Metadatas_Select_Column2["ValueType"] = "value_type";
  return Table_Metadatas_Select_Column2;
})(Table_Metadatas_Select_Column || {});
var Token_Activities_Select_Column = ((Token_Activities_Select_Column2) => {
  Token_Activities_Select_Column2["CoinAmount"] = "coin_amount";
  Token_Activities_Select_Column2["CoinType"] = "coin_type";
  Token_Activities_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
  Token_Activities_Select_Column2["CollectionName"] = "collection_name";
  Token_Activities_Select_Column2["CreatorAddress"] = "creator_address";
  Token_Activities_Select_Column2["EventAccountAddress"] = "event_account_address";
  Token_Activities_Select_Column2["EventCreationNumber"] = "event_creation_number";
  Token_Activities_Select_Column2["EventIndex"] = "event_index";
  Token_Activities_Select_Column2["EventSequenceNumber"] = "event_sequence_number";
  Token_Activities_Select_Column2["FromAddress"] = "from_address";
  Token_Activities_Select_Column2["Name"] = "name";
  Token_Activities_Select_Column2["PropertyVersion"] = "property_version";
  Token_Activities_Select_Column2["ToAddress"] = "to_address";
  Token_Activities_Select_Column2["TokenAmount"] = "token_amount";
  Token_Activities_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
  Token_Activities_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Token_Activities_Select_Column2["TransactionVersion"] = "transaction_version";
  Token_Activities_Select_Column2["TransferType"] = "transfer_type";
  return Token_Activities_Select_Column2;
})(Token_Activities_Select_Column || {});
var Token_Activities_V2_Select_Column = ((Token_Activities_V2_Select_Column2) => {
  Token_Activities_V2_Select_Column2["AfterValue"] = "after_value";
  Token_Activities_V2_Select_Column2["BeforeValue"] = "before_value";
  Token_Activities_V2_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
  Token_Activities_V2_Select_Column2["EventAccountAddress"] = "event_account_address";
  Token_Activities_V2_Select_Column2["EventIndex"] = "event_index";
  Token_Activities_V2_Select_Column2["FromAddress"] = "from_address";
  Token_Activities_V2_Select_Column2["IsFungibleV2"] = "is_fungible_v2";
  Token_Activities_V2_Select_Column2["PropertyVersionV1"] = "property_version_v1";
  Token_Activities_V2_Select_Column2["ToAddress"] = "to_address";
  Token_Activities_V2_Select_Column2["TokenAmount"] = "token_amount";
  Token_Activities_V2_Select_Column2["TokenDataId"] = "token_data_id";
  Token_Activities_V2_Select_Column2["TokenStandard"] = "token_standard";
  Token_Activities_V2_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Token_Activities_V2_Select_Column2["TransactionVersion"] = "transaction_version";
  Token_Activities_V2_Select_Column2["Type"] = "type";
  return Token_Activities_V2_Select_Column2;
})(Token_Activities_V2_Select_Column || {});
var Token_Datas_Select_Column = ((Token_Datas_Select_Column2) => {
  Token_Datas_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
  Token_Datas_Select_Column2["CollectionName"] = "collection_name";
  Token_Datas_Select_Column2["CreatorAddress"] = "creator_address";
  Token_Datas_Select_Column2["DefaultProperties"] = "default_properties";
  Token_Datas_Select_Column2["Description"] = "description";
  Token_Datas_Select_Column2["DescriptionMutable"] = "description_mutable";
  Token_Datas_Select_Column2["LargestPropertyVersion"] = "largest_property_version";
  Token_Datas_Select_Column2["Maximum"] = "maximum";
  Token_Datas_Select_Column2["MaximumMutable"] = "maximum_mutable";
  Token_Datas_Select_Column2["MetadataUri"] = "metadata_uri";
  Token_Datas_Select_Column2["Name"] = "name";
  Token_Datas_Select_Column2["PayeeAddress"] = "payee_address";
  Token_Datas_Select_Column2["PropertiesMutable"] = "properties_mutable";
  Token_Datas_Select_Column2["RoyaltyMutable"] = "royalty_mutable";
  Token_Datas_Select_Column2["RoyaltyPointsDenominator"] = "royalty_points_denominator";
  Token_Datas_Select_Column2["RoyaltyPointsNumerator"] = "royalty_points_numerator";
  Token_Datas_Select_Column2["Supply"] = "supply";
  Token_Datas_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
  Token_Datas_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Token_Datas_Select_Column2["TransactionVersion"] = "transaction_version";
  Token_Datas_Select_Column2["UriMutable"] = "uri_mutable";
  return Token_Datas_Select_Column2;
})(Token_Datas_Select_Column || {});
var Token_Ownerships_Select_Column = ((Token_Ownerships_Select_Column2) => {
  Token_Ownerships_Select_Column2["Amount"] = "amount";
  Token_Ownerships_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
  Token_Ownerships_Select_Column2["CollectionName"] = "collection_name";
  Token_Ownerships_Select_Column2["CreatorAddress"] = "creator_address";
  Token_Ownerships_Select_Column2["Name"] = "name";
  Token_Ownerships_Select_Column2["OwnerAddress"] = "owner_address";
  Token_Ownerships_Select_Column2["PropertyVersion"] = "property_version";
  Token_Ownerships_Select_Column2["TableHandle"] = "table_handle";
  Token_Ownerships_Select_Column2["TableType"] = "table_type";
  Token_Ownerships_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
  Token_Ownerships_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Token_Ownerships_Select_Column2["TransactionVersion"] = "transaction_version";
  return Token_Ownerships_Select_Column2;
})(Token_Ownerships_Select_Column || {});
var Tokens_Select_Column = ((Tokens_Select_Column2) => {
  Tokens_Select_Column2["CollectionDataIdHash"] = "collection_data_id_hash";
  Tokens_Select_Column2["CollectionName"] = "collection_name";
  Tokens_Select_Column2["CreatorAddress"] = "creator_address";
  Tokens_Select_Column2["Name"] = "name";
  Tokens_Select_Column2["PropertyVersion"] = "property_version";
  Tokens_Select_Column2["TokenDataIdHash"] = "token_data_id_hash";
  Tokens_Select_Column2["TokenProperties"] = "token_properties";
  Tokens_Select_Column2["TransactionTimestamp"] = "transaction_timestamp";
  Tokens_Select_Column2["TransactionVersion"] = "transaction_version";
  return Tokens_Select_Column2;
})(Tokens_Select_Column || {});
var User_Transactions_Select_Column = ((User_Transactions_Select_Column2) => {
  User_Transactions_Select_Column2["BlockHeight"] = "block_height";
  User_Transactions_Select_Column2["EntryFunctionIdStr"] = "entry_function_id_str";
  User_Transactions_Select_Column2["Epoch"] = "epoch";
  User_Transactions_Select_Column2["ExpirationTimestampSecs"] = "expiration_timestamp_secs";
  User_Transactions_Select_Column2["GasUnitPrice"] = "gas_unit_price";
  User_Transactions_Select_Column2["MaxGasAmount"] = "max_gas_amount";
  User_Transactions_Select_Column2["ParentSignatureType"] = "parent_signature_type";
  User_Transactions_Select_Column2["Sender"] = "sender";
  User_Transactions_Select_Column2["SequenceNumber"] = "sequence_number";
  User_Transactions_Select_Column2["Timestamp"] = "timestamp";
  User_Transactions_Select_Column2["Version"] = "version";
  return User_Transactions_Select_Column2;
})(User_Transactions_Select_Column || {});

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter32 = __toESM(require_eventemitter3(), 1);

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-PFWJQYHN.mjs
var n5 = "aptos:signAndSubmitTransaction";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-BIF2XL2R.mjs
var e2 = "aptos:signMessage";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-K5ZY2NHG.mjs
var n6 = "aptos:signTransaction";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-OYMA2PWW.mjs
var o4 = "aptos:connect";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7KTK52MK.mjs
var o5 = "aptos:disconnect";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-EKJ7Y4LP.mjs
var t5 = "aptos:account";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FTTDX4QF.mjs
var t6 = "aptos:network";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MNFE4AOY.mjs
var n7 = "aptos:onAccountChange";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-MJDSOKP4.mjs
var e3 = "aptos:onNetworkChange";

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-FFGPGN2W.mjs
var d3 = class o6 extends B {
  constructor({ address: e10, publicKey: n14, ansName: t14 }) {
    super();
    this.address = d.from(e10), this.publicKey = n14, this.ansName = t14;
  }
  serialize(e10) {
    if (this.address.serialize(e10), this.publicKey instanceof m) e10.serializeU32AsUleb128(C.Ed25519);
    else if (this.publicKey instanceof d2) e10.serializeU32AsUleb128(C.MultiEd25519);
    else if (this.publicKey instanceof f) e10.serializeU32AsUleb128(C.SingleKey);
    else if (this.publicKey instanceof f2) e10.serializeU32AsUleb128(C.MultiKey);
    else throw new Error("Unsupported public key");
    this.publicKey.serialize(e10), e10.serializeStr(this.ansName ?? "");
  }
  static deserialize(e10) {
    let n14 = d.deserialize(e10), t14 = e10.deserializeUleb128AsU32(), s3;
    switch (t14) {
      case C.Ed25519:
        s3 = m.deserialize(e10);
        break;
      case C.MultiEd25519:
        s3 = d2.deserialize(e10);
        break;
      case C.SingleKey:
        s3 = f.deserialize(e10);
        break;
      case C.MultiKey:
        s3 = f2.deserialize(e10);
        break;
      default:
        throw new Error(`Unknown variant index for WrappedPublicKey: ${t14}`);
    }
    let b2 = e10.deserializeStr() || void 0;
    return new o6({ address: n14, publicKey: s3, ansName: b2 });
  }
};

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-3XZSACFC.mjs
var t7 = "aptos:devnet";
var o7 = "aptos:testnet";
var A2 = "aptos:localnet";
var T = "aptos:mainnet";
var e4 = [t7, o7, A2, T];

// node_modules/@wallet-standard/app/lib/esm/wallets.js
var __classPrivateFieldSet = function(receiver, state, value, kind, f5) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind, f5) {
  if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
};
var _AppReadyEvent_detail;
var wallets = void 0;
var registered = /* @__PURE__ */ new Set();
var listeners = {};
function getWallets() {
  if (wallets)
    return wallets;
  wallets = Object.freeze({ register, get: get2, on });
  if (typeof window === "undefined")
    return wallets;
  const api = Object.freeze({ register });
  try {
    window.addEventListener("wallet-standard:register-wallet", ({ detail: callback }) => callback(api));
  } catch (error) {
    console.error("wallet-standard:register-wallet event listener could not be added\n", error);
  }
  try {
    window.dispatchEvent(new AppReadyEvent(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event could not be dispatched\n", error);
  }
  return wallets;
}
function register(...wallets2) {
  var _a;
  wallets2 = wallets2.filter((wallet) => !registered.has(wallet));
  if (!wallets2.length)
    return () => {
    };
  wallets2.forEach((wallet) => registered.add(wallet));
  (_a = listeners["register"]) == null ? void 0 : _a.forEach((listener) => guard(() => listener(...wallets2)));
  return function unregister() {
    var _a2;
    wallets2.forEach((wallet) => registered.delete(wallet));
    (_a2 = listeners["unregister"]) == null ? void 0 : _a2.forEach((listener) => guard(() => listener(...wallets2)));
  };
}
function get2() {
  return [...registered];
}
function on(event, listener) {
  var _a;
  ((_a = listeners[event]) == null ? void 0 : _a.push(listener)) || (listeners[event] = [listener]);
  return function off() {
    var _a2;
    listeners[event] = (_a2 = listeners[event]) == null ? void 0 : _a2.filter((existingListener) => listener !== existingListener);
  };
}
function guard(callback) {
  try {
    callback();
  } catch (error) {
    console.error(error);
  }
}
var AppReadyEvent = class extends Event {
  constructor(api) {
    super("wallet-standard:app-ready", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _AppReadyEvent_detail.set(this, void 0);
    __classPrivateFieldSet(this, _AppReadyEvent_detail, api, "f");
  }
  get detail() {
    return __classPrivateFieldGet(this, _AppReadyEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:app-ready";
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
_AppReadyEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@wallet-standard/wallet/lib/esm/register.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f5) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f5.call(receiver, value) : f5 ? f5.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f5) {
  if (kind === "a" && !f5) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f5 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f5 : kind === "a" ? f5.call(receiver) : f5 ? f5.value : state.get(receiver);
};
var _RegisterWalletEvent_detail;
function registerWallet(wallet) {
  const callback = ({ register: register2 }) => register2(wallet);
  try {
    window.dispatchEvent(new RegisterWalletEvent(callback));
  } catch (error) {
    console.error("wallet-standard:register-wallet event could not be dispatched\n", error);
  }
  try {
    window.addEventListener("wallet-standard:app-ready", ({ detail: api }) => callback(api));
  } catch (error) {
    console.error("wallet-standard:app-ready event listener could not be added\n", error);
  }
}
var RegisterWalletEvent = class extends Event {
  constructor(callback) {
    super("wallet-standard:register-wallet", {
      bubbles: false,
      cancelable: false,
      composed: false
    });
    _RegisterWalletEvent_detail.set(this, void 0);
    __classPrivateFieldSet2(this, _RegisterWalletEvent_detail, callback, "f");
  }
  get detail() {
    return __classPrivateFieldGet2(this, _RegisterWalletEvent_detail, "f");
  }
  get type() {
    return "wallet-standard:register-wallet";
  }
  /** @deprecated */
  preventDefault() {
    throw new Error("preventDefault cannot be called");
  }
  /** @deprecated */
  stopImmediatePropagation() {
    throw new Error("stopImmediatePropagation cannot be called");
  }
  /** @deprecated */
  stopPropagation() {
    throw new Error("stopPropagation cannot be called");
  }
};
_RegisterWalletEvent_detail = /* @__PURE__ */ new WeakMap();

// node_modules/@wallet-standard/wallet/lib/esm/util.js
var _ReadonlyWalletAccount_address;
var _ReadonlyWalletAccount_publicKey;
var _ReadonlyWalletAccount_chains;
var _ReadonlyWalletAccount_features;
var _ReadonlyWalletAccount_label;
var _ReadonlyWalletAccount_icon;
_ReadonlyWalletAccount_address = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_publicKey = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_chains = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_features = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_label = /* @__PURE__ */ new WeakMap(), _ReadonlyWalletAccount_icon = /* @__PURE__ */ new WeakMap();

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-7OMCNXQ7.mjs
var n8 = ["aptos:account", "aptos:connect", "aptos:disconnect", "aptos:network", "aptos:onAccountChange", "aptos:onNetworkChange", "aptos:signMessage", "aptos:signTransaction"];
function i2(t14, e10 = []) {
  return [...n8, ...e10].every((s3) => s3 in t14.features);
}
function d4() {
  let { get: t14, on: e10 } = getWallets(), s3 = t14(), a2 = [];
  return s3.map((l3) => {
    i2(l3) && a2.push(l3);
  }), { aptosWallets: a2, on: e10 };
}

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-KFHNVTDM.mjs
var n9 = ((e10) => (e10[e10.Unauthorized = 4100] = "Unauthorized", e10[e10.InternalError = -30001] = "InternalError", e10))(n9 || {});
var t8 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." } });
var r3 = class s extends Error {
  constructor(e10, o12) {
    var _a, _b;
    super(o12 ?? ((_a = t8[e10]) == null ? void 0 : _a.message) ?? "Unknown error occurred");
    this.code = e10, this.status = ((_b = t8[e10]) == null ? void 0 : _b.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, s.prototype);
  }
};

// node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-QHCUHEWC.mjs
var r4 = ((e10) => (e10.APPROVED = "Approved", e10.REJECTED = "Rejected", e10))(r4 || {});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/crypto/dist/index.mjs
var import_tweetnacl3 = __toESM(require_nacl_fast(), 1);
var import_ed2curve = __toESM(require_ed2curve(), 1);
var import_tweetnacl4 = __toESM(require_nacl_fast(), 1);

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@aptos-connect/wallet-api/dist/index.mjs
function base64ToBytes(base64) {
  const binaryString = atob(base64);
  return Uint8Array.from(binaryString, (m3) => m3.charCodeAt(0));
}
function bytesToBase64(bytes2) {
  const binaryString = String.fromCharCode(...bytes2);
  return btoa(binaryString);
}
function chainIdToNetwork(chainId) {
  switch (chainId) {
    case r2.mainnet:
      return e.MAINNET;
    case r2.testnet:
      return e.TESTNET;
    default:
      return e.DEVNET;
  }
}
function isSupportedNetwork(network) {
  return [e.MAINNET, e.TESTNET, e.DEVNET].includes(network);
}
function serializeAccountAuthenticatorInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serialize(value.authenticator);
}
function deserializeAccountAuthenticatorInput(deserializer) {
  const address = deserializer.deserialize(d);
  const authenticator = deserializer.deserialize(r);
  return { address, authenticator };
}
function serializePublicKey(serializer, value) {
  if (value instanceof m) {
    serializer.serializeU32AsUleb128(C.Ed25519);
  } else if (value instanceof d2) {
    serializer.serializeU32AsUleb128(C.MultiEd25519);
  } else if (value instanceof f) {
    serializer.serializeU32AsUleb128(C.SingleKey);
  } else if (value instanceof f2) {
    serializer.serializeU32AsUleb128(C.MultiKey);
  } else {
    throw new Error("Unexpected public key type");
  }
  serializer.serialize(value);
}
function deserializePublicKey(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case C.Ed25519:
      return deserializer.deserialize(m);
    case C.MultiEd25519:
      return deserializer.deserialize(d2);
    case C.SingleKey:
      return deserializer.deserialize(f);
    case C.MultiKey:
      return deserializer.deserialize(f2);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
function serializeAccountInfo(serializer, value) {
  serializer.serialize(value.address);
  serializePublicKey(serializer, value.publicKey);
  serializer.serializeStr(value.name ?? "");
}
function deserializeAccountInfo(deserializer) {
  const address = deserializer.deserialize(d);
  const publicKey = deserializePublicKey(deserializer);
  const name = deserializer.deserializeStr();
  return {
    address,
    publicKey,
    ...name.length > 0 ? { name } : void 0
  };
}
function serializeAccountInput(serializer, value) {
  serializer.serialize(value.address);
  serializer.serializeBool(value.publicKey !== void 0);
  if (value.publicKey) {
    serializePublicKey(serializer, value.publicKey);
  }
}
function deserializeAccountInput(deserializer) {
  const address = deserializer.deserialize(d);
  const hasPublicKey = deserializer.deserializeBool();
  const publicKey = hasPublicKey ? deserializePublicKey(deserializer) : void 0;
  return { address, publicKey };
}
function serializeDappInfo(serializer, value) {
  serializer.serializeStr(value.domain);
  serializer.serializeStr(value.name);
  serializer.serializeBool(value.imageURI !== void 0);
  if (value.imageURI !== void 0) {
    serializer.serializeStr(value.imageURI);
  }
}
function deserializeDappInfo(deserializer) {
  const domain = deserializer.deserializeStr();
  const name = deserializer.deserializeStr();
  const hasImageUri = deserializer.deserializeBool();
  const imageURI = hasImageUri ? deserializer.deserializeStr() : void 0;
  return { domain, imageURI, name };
}
var EntryFunctionArgumentVariant = ((EntryFunctionArgumentVariant2) => {
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Undefined"] = 0] = "Undefined";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Array"] = 1] = "Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["String"] = 2] = "String";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["Uint8Array"] = 3] = "Uint8Array";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["AccountAddress"] = 4] = "AccountAddress";
  EntryFunctionArgumentVariant2[EntryFunctionArgumentVariant2["FixedBytes"] = 5] = "FixedBytes";
  return EntryFunctionArgumentVariant2;
})(EntryFunctionArgumentVariant || {});
function serializeEntryFunctionArgument(serializer, argument) {
  if (argument === void 0 || argument === null) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    return;
  }
  if (Array.isArray(argument)) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.length);
    for (const subArgument of argument) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if (typeof argument === "string" || typeof argument === "number" || typeof argument === "boolean" || typeof argument === "bigint") {
    serializer.serializeU32AsUleb128(
      2
      /* String */
    );
    serializer.serializeStr(argument.toString());
    return;
  }
  if (argument instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(argument);
    return;
  }
  if (argument instanceof ArrayBuffer) {
    serializer.serializeU32AsUleb128(
      3
      /* Uint8Array */
    );
    serializer.serializeBytes(new Uint8Array(argument));
    return;
  }
  if ("values" in argument) {
    serializer.serializeU32AsUleb128(
      1
      /* Array */
    );
    serializer.serializeU32AsUleb128(argument.values.length);
    for (const subArgument of argument.values) {
      serializeEntryFunctionArgument(serializer, subArgument);
    }
    return;
  }
  if ("data" in argument) {
    serializer.serializeU32AsUleb128(
      4
      /* AccountAddress */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value === void 0) {
    serializer.serializeU32AsUleb128(
      0
      /* Undefined */
    );
    serializer.serialize(argument);
    return;
  }
  if (argument.value instanceof Uint8Array) {
    serializer.serializeU32AsUleb128(
      5
      /* FixedBytes */
    );
    serializer.serializeBytes(argument.value);
    return;
  }
  serializer.serializeU32AsUleb128(
    2
    /* String */
  );
  serializer.serializeStr(argument.value.toString());
}
function deserializeEntryFunctionArgument(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 0: {
      return void 0;
    }
    case 1: {
      const length = deserializer.deserializeUleb128AsU32();
      const args = [];
      for (let i4 = 0; i4 < length; i4 += 1) {
        const argument = deserializeEntryFunctionArgument(deserializer);
        args.push(argument);
      }
      return args;
    }
    case 3: {
      return deserializer.deserializeBytes();
    }
    case 4: {
      return deserializer.deserialize(d);
    }
    case 2: {
      return deserializer.deserializeStr();
    }
    case 5: {
      const bytes2 = deserializer.deserializeBytes();
      return new t(bytes2);
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function serializeSignature(serializer, value) {
  if (value instanceof h) {
    serializer.serializeU32AsUleb128(C.Ed25519);
  } else if (value instanceof y) {
    serializer.serializeU32AsUleb128(C.MultiEd25519);
  } else if (value instanceof l) {
    serializer.serializeU32AsUleb128(C.SingleKey);
  } else {
    throw new Error("Unexpected signature type");
  }
  serializer.serialize(value);
}
function deserializeSignature(deserializer) {
  const signingScheme = deserializer.deserializeUleb128AsU32();
  switch (signingScheme) {
    case C.Ed25519:
      return deserializer.deserialize(h);
    case C.MultiEd25519:
      return deserializer.deserialize(y);
    case C.SingleKey:
      return deserializer.deserialize(l);
    default:
      throw new Error(`Unknown signing scheme: ${signingScheme}`);
  }
}
var TransactionPayloadInputVariant = ((TransactionPayloadInputVariant2) => {
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["EntryFunction"] = 0] = "EntryFunction";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Script"] = 1] = "Script";
  TransactionPayloadInputVariant2[TransactionPayloadInputVariant2["Multisig"] = 2] = "Multisig";
  return TransactionPayloadInputVariant2;
})(TransactionPayloadInputVariant || {});
function serializeTypeArguments(serializer, typeArguments) {
  serializer.serializeU32AsUleb128(typeArguments.length);
  for (const typeArgument of typeArguments) {
    const typeTag = typeof typeArgument === "string" ? j(typeArgument, { allowGenerics: true }) : typeArgument;
    serializer.serialize(typeTag);
  }
}
function deserializeTypeArguments(deserializer) {
  const typeArguments = [];
  const typeArgumentsLength = deserializer.deserializeUleb128AsU32();
  for (let i4 = 0; i4 < typeArgumentsLength; i4 += 1) {
    const typeTag = deserializer.deserialize(t2);
    typeArguments.push(typeTag);
  }
  return typeArguments;
}
function serializeEntryFunctionArguments(serializer, functionArguments) {
  serializer.serializeU32AsUleb128(functionArguments.length);
  for (const functionArgument of functionArguments) {
    serializeEntryFunctionArgument(serializer, functionArgument);
  }
}
function deserializeEntryFunctionArguments(deserializer) {
  const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
  const functionArguments = [];
  for (let i4 = 0; i4 < functionArgumentsLength; i4 += 1) {
    const functionArgument = deserializeEntryFunctionArgument(deserializer);
    functionArguments.push(functionArgument);
  }
  return functionArguments;
}
function serializeTransactionPayloadInput(serializer, value) {
  if ("multisigAddress" in value) {
    serializer.serializeU32AsUleb128(
      2
      /* Multisig */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
    const multisigAddress = d.from(value.multisigAddress);
    serializer.serialize(multisigAddress);
  } else if ("function" in value) {
    serializer.serializeU32AsUleb128(
      0
      /* EntryFunction */
    );
    serializer.serializeStr(value.function);
    serializeEntryFunctionArguments(serializer, value.functionArguments);
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  } else {
    serializer.serializeU32AsUleb128(
      1
      /* Script */
    );
    const bytecode = i.fromHexInput(value.bytecode);
    serializer.serializeBytes(bytecode.toUint8Array());
    serializer.serializeU32AsUleb128(value.functionArguments.length);
    for (const argument of value.functionArguments) {
      argument.serializeForScriptFunction(serializer);
    }
    serializeTypeArguments(serializer, value.typeArguments ?? []);
  }
}
function deserializeTransactionPayloadInput(deserializer) {
  const variant = deserializer.deserializeUleb128AsU32();
  switch (variant) {
    case 2: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      const multisigAddress = deserializer.deserialize(d);
      return {
        function: functionId,
        functionArguments,
        multisigAddress,
        typeArguments
      };
    }
    case 0: {
      const functionId = deserializer.deserializeStr();
      const functionArguments = deserializeEntryFunctionArguments(deserializer);
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        function: functionId,
        functionArguments,
        typeArguments
      };
    }
    case 1: {
      const bytecode = deserializer.deserializeBytes();
      const functionArgumentsLength = deserializer.deserializeUleb128AsU32();
      const functionArguments = [];
      for (let i4 = 0; i4 < functionArgumentsLength; i4 += 1) {
        const argument = D(deserializer);
        functionArguments.push(argument);
      }
      const typeArguments = deserializeTypeArguments(deserializer);
      return {
        bytecode,
        functionArguments,
        typeArguments
      };
    }
    default: {
      throw new Error("Unexpected variant");
    }
  }
}
function serializeWalletRequest({
  dappInfo,
  name,
  version: version2
}) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  const data = serializer.toUint8Array();
  return { data, name, version: version2 };
}
function deserializeWalletRequest({
  data,
  name,
  version: version2
}) {
  const deserializer = new n2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  return { dappInfo, name, version: version2 };
}
function serializeWalletRequestWithArgs({ args, dappInfo, name, version: version2 }, serializeArgsFn) {
  const serializer = new n();
  serializeDappInfo(serializer, dappInfo);
  serializeArgsFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data, name, version: version2 };
}
function deserializeWalletRequestWithArgs({ data, name, version: version2 }, deserializeArgsFn) {
  const deserializer = new n2(data);
  const dappInfo = deserializeDappInfo(deserializer);
  const args = deserializeArgsFn(deserializer);
  return { args, dappInfo, name, version: version2 };
}
var ConnectRequest;
((ConnectRequest2) => {
  ConnectRequest2.name = "connect";
  ConnectRequest2.supportedVersions = [1, 2];
  ConnectRequest2.currentVersion = 2;
  function serializeArgs(serializer, value) {
    serializer.serializeOptionStr(value.dappId);
    serializer.serializeOptionStr(value.dappEd25519PublicKeyB64);
  }
  ConnectRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version2) {
    if (version2 === 1) {
      return {};
    }
    const dappId = deserializer.deserializeOptionStr();
    const dappEd25519PublicKeyB64 = deserializer.deserializeOptionStr();
    return { dappEd25519PublicKeyB64, dappId };
  }
  ConnectRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args = {}) {
    return serializeWalletRequestWithArgs({ args, dappInfo, name: ConnectRequest2.name, version: ConnectRequest2.currentVersion }, serializeArgs);
  }
  ConnectRequest2.serialize = serialize;
  function deserialize(request3) {
    return deserializeWalletRequestWithArgs(request3, (d8) => deserializeArgs(d8, request3.version));
  }
  ConnectRequest2.deserialize = deserialize;
  function isSerialized(request3) {
    return request3.name === ConnectRequest2.name && ConnectRequest2.supportedVersions.includes(request3.version);
  }
  ConnectRequest2.isSerialized = isSerialized;
})(ConnectRequest || (ConnectRequest = {}));
function makeUserApproval(args) {
  return { args, status: "approved" };
}
function makeUserResponseSerializeFn(serializeArgs) {
  return (serializer, value) => {
    serializer.serializeBool(value.status === "approved");
    if (value.status === "approved") {
      serializeArgs(serializer, value.args);
    }
  };
}
function makeUserResponseDeserializeFn(deserializeArgs) {
  return (deserializer) => {
    const isApproved = deserializer.deserializeBool();
    return isApproved ? { args: deserializeArgs(deserializer), status: "approved" } : { status: "dismissed" };
  };
}
function serializeWalletResponse(args, serializeFn) {
  const serializer = new n();
  serializeFn(serializer, args);
  const data = serializer.toUint8Array();
  return { data };
}
function deserializeWalletResponse({ data }, deserializeFn) {
  const deserializer = new n2(data);
  const args = deserializeFn(deserializer);
  return { args };
}
var ConnectResponse;
((ConnectResponse2) => {
  ConnectResponse2.supportedVersions = [1, 2];
  ConnectResponse2.currentVersion = 2;
  function serializeApprovalArgsV1(serializer, value) {
    serializeAccountInfo(serializer, value.account);
  }
  function serializeApprovalArgs(serializer, value) {
    serializeAccountInfo(serializer, value.account);
    serializer.serializeOptionStr(value.pairing !== void 0 ? JSON.stringify(value.pairing) : void 0);
  }
  function deserializeApprovalArgs(deserializer) {
    const account = deserializeAccountInfo(deserializer);
    const serializedPairing = deserializer.deserializeOptionStr();
    const pairing = serializedPairing !== void 0 ? JSON.parse(serializedPairing) : void 0;
    return { account, pairing };
  }
  const serializeArgsV1 = makeUserResponseSerializeFn(serializeApprovalArgsV1);
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args, version2 = ConnectResponse2.currentVersion) {
    return serializeWalletResponse(args, version2 === 1 ? serializeArgsV1 : serializeArgs);
  }
  ConnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  ConnectResponse2.deserialize = deserialize;
})(ConnectResponse || (ConnectResponse = {}));
var DisconnectRequest;
((DisconnectRequest2) => {
  DisconnectRequest2.name = "disconnect";
  DisconnectRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: DisconnectRequest2.name, version: DisconnectRequest2.currentVersion });
  }
  DisconnectRequest2.serialize = serialize;
  function deserialize(request3) {
    return deserializeWalletRequest(request3);
  }
  DisconnectRequest2.deserialize = deserialize;
  function isSerialized(request3) {
    return request3.name === DisconnectRequest2.name && request3.version === DisconnectRequest2.currentVersion;
  }
  DisconnectRequest2.isSerialized = isSerialized;
})(DisconnectRequest || (DisconnectRequest = {}));
var DisconnectResponse;
((DisconnectResponse2) => {
  function serialize(args) {
    return serializeWalletResponse(args, () => {
    });
  }
  DisconnectResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, () => ({}));
  }
  DisconnectResponse2.deserialize = deserialize;
})(DisconnectResponse || (DisconnectResponse = {}));
var GetConnectedAccountsRequest;
((GetConnectedAccountsRequest2) => {
  GetConnectedAccountsRequest2.name = "getConnectedAccounts";
  GetConnectedAccountsRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: GetConnectedAccountsRequest2.name, version: GetConnectedAccountsRequest2.currentVersion });
  }
  GetConnectedAccountsRequest2.serialize = serialize;
  function deserialize(request3) {
    return deserializeWalletRequest(request3);
  }
  GetConnectedAccountsRequest2.deserialize = deserialize;
  function isSerialized(request3) {
    return request3.name === GetConnectedAccountsRequest2.name && request3.version === GetConnectedAccountsRequest2.currentVersion;
  }
  GetConnectedAccountsRequest2.isSerialized = isSerialized;
})(GetConnectedAccountsRequest || (GetConnectedAccountsRequest = {}));
var GetConnectedAccountsResponse;
((GetConnectedAccountsResponse2) => {
  function serializeArgs(serializer, args) {
    serializer.serializeU32AsUleb128(args.length);
    for (const account of args) {
      serializeAccountInfo(serializer, account);
    }
  }
  function deserializeArgs(deserializer) {
    const length = deserializer.deserializeUleb128AsU32();
    const accounts = [];
    for (let i4 = 0; i4 < length; i4 += 1) {
      accounts.push(deserializeAccountInfo(deserializer));
    }
    return accounts;
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  GetConnectedAccountsResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  GetConnectedAccountsResponse2.deserialize = deserialize;
})(GetConnectedAccountsResponse || (GetConnectedAccountsResponse = {}));
var IsConnectedRequest;
((IsConnectedRequest2) => {
  IsConnectedRequest2.name = "isConnected";
  IsConnectedRequest2.currentVersion = 1;
  function serialize(dappInfo) {
    return serializeWalletRequest({ dappInfo, name: IsConnectedRequest2.name, version: IsConnectedRequest2.currentVersion });
  }
  IsConnectedRequest2.serialize = serialize;
  function deserialize(request3) {
    return deserializeWalletRequest(request3);
  }
  IsConnectedRequest2.deserialize = deserialize;
  function isSerialized(request3) {
    return request3.name === IsConnectedRequest2.name && request3.version === IsConnectedRequest2.currentVersion;
  }
  IsConnectedRequest2.isSerialized = isSerialized;
})(IsConnectedRequest || (IsConnectedRequest = {}));
var IsConnectedResponse;
((IsConnectedResponse2) => {
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value);
  }
  function deserializeArgs(deserializer) {
    return deserializer.deserializeBool();
  }
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  IsConnectedResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  IsConnectedResponse2.deserialize = deserialize;
})(IsConnectedResponse || (IsConnectedResponse = {}));
var SignAndSubmitTransactionRequest;
((SignAndSubmitTransactionRequest2) => {
  SignAndSubmitTransactionRequest2.name = "signAndSubmitTransaction";
  SignAndSubmitTransactionRequest2.supportedVersions = [1, 2, 3];
  SignAndSubmitTransactionRequest2.currentVersion = 3;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOptionStr(value.network);
    if ("bcsToBytes" in value.payload) {
      serializer.serializeBool(true);
      serializer.serialize(value.payload);
    } else {
      serializer.serializeBool(false);
      serializeTransactionPayloadInput(serializer, value.payload);
    }
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeU32AsUleb128(value.feePayer ? 1 : 0);
    if (value.feePayer) {
      serializeAccountAuthenticatorInput(serializer, value.feePayer);
    }
  }
  SignAndSubmitTransactionRequest2.serializeArgs = serializeArgs;
  function deserializeArgs(deserializer, version2) {
    const hasSignerAddress = version2 >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(d) : void 0;
    const network = version2 === 1 ? deserializer.deserializeStr() : deserializer.deserializeOptionStr();
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const isPayloadBcsSerializable = version2 === 1 || deserializer.deserializeBool();
    const payload = isPayloadBcsSerializable ? deserializer.deserialize(a) : deserializeTransactionPayloadInput(deserializer);
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeUleb128AsU32();
    const feePayer = hasFeePayer ? deserializeAccountAuthenticatorInput(deserializer) : void 0;
    return {
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      signerAddress
    };
  }
  SignAndSubmitTransactionRequest2.deserializeArgs = deserializeArgs;
  function serialize(dappInfo, args) {
    const request3 = { args, dappInfo, name: SignAndSubmitTransactionRequest2.name, version: SignAndSubmitTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request3, serializeArgs);
  }
  SignAndSubmitTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignAndSubmitTransactionRequest2.deserialize = deserialize;
  function isSerialized(request3) {
    return request3.name === SignAndSubmitTransactionRequest2.name && SignAndSubmitTransactionRequest2.supportedVersions.includes(request3.version);
  }
  SignAndSubmitTransactionRequest2.isSerialized = isSerialized;
})(SignAndSubmitTransactionRequest || (SignAndSubmitTransactionRequest = {}));
var SignAndSubmitTransactionResponse;
((SignAndSubmitTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.txnHash);
  }
  function deserializeApprovalArgs(deserializer) {
    const txnHash = deserializer.deserializeStr();
    return { txnHash };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignAndSubmitTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignAndSubmitTransactionResponse2.deserialize = deserialize;
})(SignAndSubmitTransactionResponse || (SignAndSubmitTransactionResponse = {}));
var SignMessageRequest;
((SignMessageRequest2) => {
  SignMessageRequest2.name = "signMessage";
  SignMessageRequest2.supportedVersions = [1, 2];
  SignMessageRequest2.currentVersion = 2;
  function serializeArgs(serializer, value) {
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeU8(value.chainId);
    serializer.serializeBytes(value.nonce);
    serializer.serializeBytes(value.message);
  }
  function deserializeArgs(deserializer, version2) {
    const hasSignerAddress = version2 >= 2 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(d) : void 0;
    const chainId = deserializer.deserializeU8();
    const nonce = deserializer.deserializeBytes();
    const message = deserializer.deserializeBytes();
    return { chainId, message, nonce, signerAddress };
  }
  function serialize(dappInfo, args) {
    const request3 = { args, dappInfo, name: SignMessageRequest2.name, version: SignMessageRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request3, serializeArgs);
  }
  SignMessageRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(serializedRequest, (d8) => deserializeArgs(d8, serializedRequest.version));
  }
  SignMessageRequest2.deserialize = deserialize;
  function isSerialized(request3) {
    return request3.name === SignMessageRequest2.name && request3.version === SignMessageRequest2.currentVersion;
  }
  SignMessageRequest2.isSerialized = isSerialized;
})(SignMessageRequest || (SignMessageRequest = {}));
var SignMessageResponse;
((SignMessageResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serializeStr(value.fullMessage);
    serializeSignature(serializer, value.signature);
  }
  function deserializeApprovalArgs(deserializer) {
    const fullMessage = deserializer.deserializeStr();
    const signature = deserializeSignature(deserializer);
    return { fullMessage, signature };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignMessageResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignMessageResponse2.deserialize = deserialize;
})(SignMessageResponse || (SignMessageResponse = {}));
var SignTransactionRequest;
((SignTransactionRequest2) => {
  SignTransactionRequest2.name = "signTransaction";
  SignTransactionRequest2.supportedVersions = [1, 2, 3];
  SignTransactionRequest2.currentVersion = 3;
  function normalizeArgs(args) {
    const { feePayer, secondarySigners, senderPublicKey, signerAddress, transaction } = args;
    const sender = {
      address: transaction.sender,
      publicKey: senderPublicKey
    };
    const network = chainIdToNetwork(args.transaction.chain_id.chainId);
    return {
      expirationTimestamp: Number(transaction.expiration_timestamp_secs),
      feePayer,
      gasUnitPrice: Number(transaction.gas_unit_price),
      maxGasAmount: Number(transaction.max_gas_amount),
      network,
      payload: transaction.payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  SignTransactionRequest2.normalizeArgs = normalizeArgs;
  function serializeArgs(serializer, value) {
    if (value.network !== void 0 && !isSupportedNetwork(value.network)) {
      throw new Error(`Unsupported network '${value.network}'`);
    }
    serializer.serializeBool(value.signerAddress !== void 0);
    if (value.signerAddress !== void 0) {
      serializer.serialize(value.signerAddress);
    }
    serializer.serializeOptionStr(value.network);
    serializer.serializeBool(value.sender !== void 0);
    if (value.sender !== void 0) {
      serializeAccountInput(serializer, value.sender);
    }
    serializer.serialize(value.payload);
    serializer.serializeU32AsUleb128(value.expirationSecondsFromNow ?? 0);
    serializer.serializeU64(value.expirationTimestamp ?? 0);
    serializer.serializeU32AsUleb128(value.gasUnitPrice ?? 0);
    serializer.serializeU32AsUleb128(value.maxGasAmount ?? 0);
    serializer.serializeBool(value.feePayer !== void 0);
    if (value.feePayer !== void 0) {
      serializeAccountInput(serializer, value.feePayer);
    }
    const secondarySigners = value.secondarySigners ?? [];
    serializer.serializeU32AsUleb128(secondarySigners.length);
    for (const signer of secondarySigners) {
      serializeAccountInput(serializer, signer);
    }
  }
  function deserializeArgs(deserializer, version2) {
    const hasSignerAddress = version2 >= 3 && deserializer.deserializeBool();
    const signerAddress = hasSignerAddress ? deserializer.deserialize(d) : void 0;
    const network = version2 === 1 ? deserializer.deserializeStr() : deserializer.deserializeOptionStr();
    if (network !== void 0 && !isSupportedNetwork(network)) {
      throw new Error(`Unsupported network '${network}'`);
    }
    const hasSender = deserializer.deserializeBool();
    const sender = hasSender ? deserializeAccountInput(deserializer) : void 0;
    const payload = deserializer.deserialize(a);
    const expirationSecondsFromNow = deserializer.deserializeUleb128AsU32();
    const expirationTimestamp = Number(deserializer.deserializeU64());
    const gasUnitPrice = deserializer.deserializeUleb128AsU32();
    const maxGasAmount = deserializer.deserializeUleb128AsU32();
    const hasFeePayer = deserializer.deserializeBool();
    const feePayer = hasFeePayer ? deserializeAccountInput(deserializer) : void 0;
    const secondarySignersLength = deserializer.deserializeUleb128AsU32();
    const secondarySigners = [];
    for (let i4 = 0; i4 < secondarySignersLength; i4 += 1) {
      secondarySigners.push(deserializeAccountInput(deserializer));
    }
    return {
      expirationSecondsFromNow: expirationSecondsFromNow > 0 ? expirationSecondsFromNow : void 0,
      expirationTimestamp: expirationTimestamp > 0 ? expirationTimestamp : void 0,
      feePayer,
      gasUnitPrice: gasUnitPrice > 0 ? gasUnitPrice : void 0,
      maxGasAmount: maxGasAmount > 0 ? maxGasAmount : void 0,
      network,
      payload,
      secondarySigners,
      sender,
      signerAddress
    };
  }
  function serialize(dappInfo, args) {
    const request3 = { args, dappInfo, name: SignTransactionRequest2.name, version: SignTransactionRequest2.currentVersion };
    return serializeWalletRequestWithArgs(request3, serializeArgs);
  }
  SignTransactionRequest2.serialize = serialize;
  function deserialize(serializedRequest) {
    return deserializeWalletRequestWithArgs(
      serializedRequest,
      (deserializer) => deserializeArgs(deserializer, serializedRequest.version)
    );
  }
  SignTransactionRequest2.deserialize = deserialize;
  function isSerialized(request3) {
    return request3.name === SignTransactionRequest2.name && SignTransactionRequest2.supportedVersions.includes(request3.version);
  }
  SignTransactionRequest2.isSerialized = isSerialized;
})(SignTransactionRequest || (SignTransactionRequest = {}));
var SignTransactionResponse;
((SignTransactionResponse2) => {
  function serializeApprovalArgs(serializer, value) {
    serializer.serialize(value.authenticator);
    serializer.serializeBool(value.rawTransaction !== void 0);
    if (value.rawTransaction !== void 0) {
      serializer.serialize(value.rawTransaction);
    }
  }
  function deserializeApprovalArgs(deserializer) {
    const authenticator = deserializer.deserialize(r);
    const hasRawTransaction = deserializer.deserializeBool();
    const rawTransaction = hasRawTransaction ? deserializer.deserialize(t3) : void 0;
    return {
      authenticator,
      rawTransaction
    };
  }
  const serializeArgs = makeUserResponseSerializeFn(serializeApprovalArgs);
  const deserializeArgs = makeUserResponseDeserializeFn(deserializeApprovalArgs);
  function serialize(args) {
    return serializeWalletResponse(args, serializeArgs);
  }
  SignTransactionResponse2.serialize = serialize;
  function deserialize(serializedResponse) {
    return deserializeWalletResponse(serializedResponse, deserializeArgs);
  }
  SignTransactionResponse2.deserialize = deserialize;
})(SignTransactionResponse || (SignTransactionResponse = {}));
function isTypedMessage(messageCls, message) {
  return (message == null ? void 0 : message.__messageType) === messageCls.TYPE;
}
var _AptosWalletRequestMessage = class _AptosWalletRequestMessage2 {
  constructor(nonce, serializedValue) {
    this.nonce = nonce;
    this.serializedValue = serializedValue;
    this.__messageType = _AptosWalletRequestMessage2.TYPE;
  }
};
_AptosWalletRequestMessage.TYPE = "AptosWalletRequest";
var _AptosWalletSuccessResponseMessage = class _AptosWalletSuccessResponseMessage2 {
  constructor(serializedValue, nonce) {
    this.serializedValue = serializedValue;
    this.nonce = nonce;
    this.__messageType = _AptosWalletSuccessResponseMessage2.TYPE;
  }
};
_AptosWalletSuccessResponseMessage.TYPE = "AptosWalletSuccessResponseMessage";
var _AptosWalletErrorResponseMessage = class _AptosWalletErrorResponseMessage2 {
  constructor(error, nonce) {
    this.error = error;
    this.nonce = nonce;
    this.__messageType = _AptosWalletErrorResponseMessage2.TYPE;
  }
};
_AptosWalletErrorResponseMessage.TYPE = "AptosWalletErrorResponseMessage";
var _PromptOpenerPingRequestMessage = class _PromptOpenerPingRequestMessage2 {
  constructor() {
    this.__messageType = _PromptOpenerPingRequestMessage2.TYPE;
  }
};
_PromptOpenerPingRequestMessage.TYPE = "PromptOpenerPingRequest";
var PromptOpenerPingRequestMessage = _PromptOpenerPingRequestMessage;
var _PromptOpenerPingResponseMessage = class _PromptOpenerPingResponseMessage2 {
  constructor() {
    this.__messageType = _PromptOpenerPingResponseMessage2.TYPE;
  }
};
_PromptOpenerPingResponseMessage.TYPE = "PromptOpenerPingResponse";
var PromptOpenerPingResponseMessage = _PromptOpenerPingResponseMessage;
var _PromptApprovalResponseMessage = class _PromptApprovalResponseMessage2 {
  constructor(serializedValue) {
    this.serializedValue = serializedValue;
    this.__messageType = _PromptApprovalResponseMessage2.TYPE;
  }
};
_PromptApprovalResponseMessage.TYPE = "PromptApprovalResponse";
var PromptApprovalResponseMessage = _PromptApprovalResponseMessage;
var _PromptUnauthorizedErrorMessage = class _PromptUnauthorizedErrorMessage2 {
  constructor() {
    this.__messageType = _PromptUnauthorizedErrorMessage2.TYPE;
  }
};
_PromptUnauthorizedErrorMessage.TYPE = "PromptUnauthorizedError";
var PromptUnauthorizedErrorMessage = _PromptUnauthorizedErrorMessage;
function urlEncodeWalletRequest(request3) {
  const serializer = new n();
  serializer.serializeStr(request3.name);
  serializer.serializeBytes(request3.data);
  serializer.serializeStr(request3.version.toString());
  return bytesToBase64(serializer.toUint8Array());
}

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/crypto/dist/index.mjs
var EncryptionEnvelopeError = class extends Error {
};
var EnvelopeMessageMismatchError = class _EnvelopeMessageMismatchError extends EncryptionEnvelopeError {
  constructor(message, field) {
    super(message);
    this.field = field;
    this.name = "EnvelopeMessageMismatchError";
    Object.setPrototypeOf(this, _EnvelopeMessageMismatchError.prototype);
  }
};
var DecryptionError = class _DecryptionError extends EncryptionEnvelopeError {
  constructor(message) {
    super(message);
    this.name = "DecryptionError";
    Object.setPrototypeOf(this, _DecryptionError.prototype);
  }
};
var KeyTypes = ((KeyTypes2) => {
  KeyTypes2["Ed25519PublicKey"] = "Ed25519PublicKey";
  KeyTypes2["Ed25519SecretKey"] = "Ed25519SecretKey";
  KeyTypes2["X25519PublicKey"] = "X25519PublicKey";
  KeyTypes2["X25519SecretKey"] = "X25519SecretKey";
  return KeyTypes2;
})(KeyTypes || {});
function createX25519KeyPair() {
  return keypairToX25519(import_tweetnacl4.default.box.keyPair());
}
function createEd25519KeyPair() {
  return keypairToEd25519(import_tweetnacl4.default.sign.keyPair());
}
function toKey(rawKey, type) {
  return {
    key: rawKey,
    type
  };
}
function keypairToEd25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "Ed25519PublicKey"
      /* Ed25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "Ed25519SecretKey"
      /* Ed25519SecretKey */
    )
  };
}
function keypairToX25519(keyPair) {
  return {
    publicKey: toKey(
      keyPair.publicKey,
      "X25519PublicKey"
      /* X25519PublicKey */
    ),
    secretKey: toKey(
      keyPair.secretKey,
      "X25519SecretKey"
      /* X25519SecretKey */
    )
  };
}
function decodeBase64(base64Str) {
  if (globalThis.Buffer) {
    return new Uint8Array(Buffer.from(base64Str, "base64"));
  }
  return Uint8Array.from(atob(base64Str), (m3) => m3.codePointAt(0));
}
function encodeBase64(bytes2) {
  if (globalThis.Buffer) {
    return Buffer.from(bytes2).toString("base64");
  }
  return btoa(Array.from(bytes2, (x2) => String.fromCodePoint(x2)).join(""));
}
function concatUint8array(arrayOne, arrayTwo) {
  const mergedArray = new Uint8Array(arrayOne.length + arrayTwo.length);
  mergedArray.set(arrayOne);
  mergedArray.set(arrayTwo, arrayOne.length);
  return mergedArray;
}
var SIGNATURE_PREFIX = "APTOS::IDENTITY_CONNECT";
function convertEd25519PublicKeyToX25519PublicKey(ed25519PublicKey, errorKeyName) {
  const x25519PublicKey = import_ed2curve.default.convertPublicKey(ed25519PublicKey.key.slice(0, 32));
  if (!x25519PublicKey)
    throw new Error(`${errorKeyName} is not a valid Ed25519 public key`);
  return toKey(
    x25519PublicKey,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
}
function convertEd25519SecretKeyToX25519SecretKey(ed25519SecretKey) {
  const x25519SecretKey = import_ed2curve.default.convertSecretKey(ed25519SecretKey.key.slice(0, 32));
  return toKey(
    x25519SecretKey,
    "X25519SecretKey"
    /* X25519SecretKey */
  );
}
function serializeEncryptionResult(enc) {
  return {
    nonceB64: encodeBase64(enc.nonce),
    securedB64: encodeBase64(enc.secured)
  };
}
function deserializeEncryptionResult(enc) {
  return {
    nonce: decodeBase64(enc.nonceB64),
    secured: decodeBase64(enc.securedB64)
  };
}
function encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  const nonce = import_tweetnacl3.default.randomBytes(import_tweetnacl3.default.box.nonceLength);
  const messageUint8 = new TextEncoder().encode(message);
  const secured = import_tweetnacl3.default.box(messageUint8, nonce, receiverX25519PublicKey.key, senderX25519SecretKey.key.slice(0, 32));
  return { nonce, secured };
}
function encryptObject(senderX25519SecretKey, receiverEd25519PublicKey, message) {
  const receiverX25519PublicKey = convertEd25519PublicKeyToX25519PublicKey(
    receiverEd25519PublicKey,
    "receiver public key"
  );
  return encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message);
}
function encryptObjectDirect(senderX25519SecretKey, receiverX25519PublicKey, message) {
  return encryptMessageDirect(senderX25519SecretKey, receiverX25519PublicKey, JSON.stringify(message));
}
function decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  let decryptedUint8;
  try {
    decryptedUint8 = import_tweetnacl3.default.box.open(
      securedMessage,
      nonce,
      senderX25519PublicKey.key.slice(0, 32),
      receiverX25519SecretKey.key.slice(0, 32)
    );
  } catch (e10) {
    throw new DecryptionError(`Could not decrypt message: ${e10.message}`);
  }
  if (!decryptedUint8)
    throw new DecryptionError("Could not decrypt message");
  return new TextDecoder().decode(decryptedUint8);
}
function decryptObject(senderX25519PublicKey, receiverEd25519SecretKey, securedMessage, nonce) {
  const receiverX25519SecretKey = convertEd25519SecretKeyToX25519SecretKey(receiverEd25519SecretKey);
  return decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);
}
function decryptObjectDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce) {
  const decryptedStr = decryptMessageDirect(senderX25519PublicKey, receiverX25519SecretKey, securedMessage, nonce);
  return JSON.parse(decryptedStr);
}
function messageHash(message, purpose) {
  const signaturePrefixHash = new Uint8Array(sha3_256(`${SIGNATURE_PREFIX}::${purpose}::`));
  return new Uint8Array(sha3_256(concatUint8array(signaturePrefixHash, message)));
}
function signWithEd25519SecretKey(message, signingEd25519SecretKey, purpose) {
  return import_tweetnacl3.default.sign.detached(messageHash(message, purpose), signingEd25519SecretKey.key);
}
function verifySignature(message, signature, signingPublicKey, purpose) {
  return signingPublicKey.verifySignature({ message: messageHash(message, purpose), signature });
}
var REQUIRED_FIELDS = [
  "receiverEd25519PublicKeyB64",
  "senderEd25519PublicKeyB64",
  "senderX25519PublicKeyB64",
  "sequence",
  "timestampMillis"
].sort();
function ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage) {
  const intersection = Object.keys(privateMessage).filter((x2) => Object.keys(publicMessage).includes(x2));
  if (intersection.length > 0) {
    const field = intersection[0];
    throw new EnvelopeMessageMismatchError(`Field ${field} appears in both private and public message fields`, field);
  }
}
function ensureMetadataFields(message) {
  const messageKeys = Object.keys(message).sort();
  const extraFields = messageKeys.filter((key) => !REQUIRED_FIELDS.includes(key));
  const missingFields = REQUIRED_FIELDS.filter((key) => !messageKeys.includes(key));
  if (extraFields.length > 0 || missingFields.length > 0) {
    let extraFieldsStr = extraFields.length > 0 ? `extra(${extraFields.join(", ")})` : "";
    const missingFieldsStr = missingFields.length > 0 ? `missing(${missingFields.join(", ")})` : "";
    extraFieldsStr = extraFieldsStr.length > 0 && missingFieldsStr.length > 0 ? `${extraFieldsStr}, ` : extraFieldsStr;
    throw new EnvelopeMessageMismatchError(
      `PublicMessage metadata fields do not conform to spec: ${extraFieldsStr}${missingFieldsStr}`,
      "_metadata"
    );
  }
}
function encryptAndSignEnvelope(senderEd25519SecretKey, senderEd25519PublicKey, receiverEd25519PublicKey, sequence, publicMessage, privateMessage) {
  const senderEphemeralX25519KeyPair = createX25519KeyPair();
  const metadata = constructMetadata(
    senderEd25519PublicKey,
    receiverEd25519PublicKey,
    sequence,
    senderEphemeralX25519KeyPair.publicKey
  );
  ensureMetadataFields(metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return dangerouslyEncryptAndSignEnvelopeUnvalidated(
    senderEd25519SecretKey,
    receiverEd25519PublicKey,
    metadata,
    privateMessage,
    publicMessage,
    senderEphemeralX25519KeyPair
  );
}
function constructMetadata(senderEd25519PublicKey, receiverEd25519PublicKey, sequence, senderEphemeralX25519PublicKey) {
  return {
    receiverEd25519PublicKeyB64: encodeBase64(receiverEd25519PublicKey.key),
    senderEd25519PublicKeyB64: encodeBase64(senderEd25519PublicKey.key),
    senderX25519PublicKeyB64: encodeBase64(senderEphemeralX25519PublicKey.key),
    sequence,
    timestampMillis: Date.now()
  };
}
function dangerouslyEncryptAndSignEnvelopeUnvalidated(senderEd25519SecretKey, receiverEd25519PublicKey, metadata, privateMessage, publicMessage, senderEphemeralX25519KeyPair) {
  const encryptionResult = encryptObject(
    senderEphemeralX25519KeyPair.secretKey,
    receiverEd25519PublicKey,
    privateMessage
  );
  const encryptedPrivateMessage = serializeEncryptionResult(encryptionResult);
  const encryptedPrivateMessageBytes = decodeBase64(encryptedPrivateMessage.securedB64);
  const serializedPublicMessage = JSON.stringify({ ...publicMessage, _metadata: metadata });
  const publicMessageBytes = new TextEncoder().encode(serializedPublicMessage);
  const messageSignature = signEnvelope(publicMessageBytes, encryptedPrivateMessageBytes, senderEd25519SecretKey);
  return {
    encryptedPrivateMessage,
    messageSignature,
    serializedPublicMessage
  };
}
function combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes) {
  const publicMessageBytesHash = sha3_256(publicMessageBytes);
  const privateMessageBytesHash = sha3_256(privateMessageBytes);
  const combinedHash = new Uint8Array(publicMessageBytesHash.length + privateMessageBytesHash.length);
  combinedHash.set(publicMessageBytesHash);
  combinedHash.set(privateMessageBytesHash, publicMessageBytesHash.length);
  return sha3_256(combinedHash);
}
function signEnvelope(publicMessageBytes, privateMessageBytes, senderEd25519SecretKey) {
  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);
  const signatureBytes = signWithEd25519SecretKey(messageHashBytes, senderEd25519SecretKey, "SECURED_ENVELOPE");
  return i.fromHexInput(signatureBytes).toString();
}
function verifyEnvelopeSignature(publicMessageBytes, privateMessageBytes, messageSignatureInput, senderEd25519PublicKey) {
  const messageSignature = new h(i.fromHexInput(messageSignatureInput).toUint8Array());
  const senderPublicKey = new m(senderEd25519PublicKey.key);
  const messageHashBytes = combineHashedEnvelopeMessageBytes(publicMessageBytes, privateMessageBytes);
  const messageVerified = verifySignature(messageHashBytes, messageSignature, senderPublicKey, "SECURED_ENVELOPE");
  if (!messageVerified) {
    throw new EnvelopeMessageMismatchError("Could not verify SecuredEnvelope signature", "messageSignature");
  }
}
function decryptEnvelope(senderEd25519PublicKey, receiverEd25519SecretKey, message) {
  const { encryptedPrivateMessage, messageSignature, serializedPublicMessage } = message;
  const publicMessage = JSON.parse(serializedPublicMessage);
  const rawPrivateMessage = decodeBase64(encryptedPrivateMessage.securedB64);
  const rawPublicMessage = new TextEncoder().encode(serializedPublicMessage);
  verifyEnvelopeSignature(rawPublicMessage, rawPrivateMessage, messageSignature, senderEd25519PublicKey);
  const senderEd25519PublicKeyB64 = encodeBase64(senderEd25519PublicKey.key);
  const expectedPublicKeyB64 = publicMessage._metadata.senderEd25519PublicKeyB64;
  if (senderEd25519PublicKeyB64 !== expectedPublicKeyB64) {
    throw new EnvelopeMessageMismatchError(
      "senderEd25519PublicKey in envelope does not match provided receiverEd25519SecretKey",
      "senderPublicKey"
    );
  }
  const senderX25519PublicKeyBytes = decodeBase64(publicMessage._metadata.senderX25519PublicKeyB64);
  const senderX25519PublicKey = toKey(
    senderX25519PublicKeyBytes,
    "X25519PublicKey"
    /* X25519PublicKey */
  );
  const encryptionResult = deserializeEncryptionResult(encryptedPrivateMessage);
  const privateMessage = decryptObject(
    senderX25519PublicKey,
    receiverEd25519SecretKey,
    encryptionResult.secured,
    encryptionResult.nonce
  );
  ensureMetadataFields(publicMessage._metadata);
  ensurePrivatePublicFieldsDisjoint(privateMessage, publicMessage);
  return {
    messageSignature,
    privateMessage,
    publicMessage
  };
}
function serializePublicKeyB64(publicKey) {
  const serializer = new n();
  serializePublicKey(serializer, publicKey);
  return bytesToBase64(serializer.toUint8Array());
}
function deserializePublicKeyB64(publicKeyB64) {
  const serializedPublicKey = base64ToBytes(publicKeyB64);
  const deserializer = new n2(serializedPublicKey);
  return deserializePublicKey(deserializer);
}
function deserializeEd25519PublicKeyB64(ed25519PublicKeyB64) {
  return new m(decodeBase64(ed25519PublicKeyB64));
}
var AccountConnectionAction = ((AccountConnectionAction2) => {
  AccountConnectionAction2["ADD"] = "add";
  AccountConnectionAction2["REMOVE"] = "remove";
  return AccountConnectionAction2;
})(AccountConnectionAction || {});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/node_modules/@aptos-connect/web-transport/dist/index.mjs
var DEFAULT_PROMPT_SIZE = { height: 695, width: 465 };
var PROMPT_POLLER_INTERVAL = 500;
var dismissalSerializedResponse = ConnectResponse.serialize({ status: "dismissed" });
var PromptUnauthorizedError = class extends Error {
  constructor() {
    super("Unauthorized");
  }
};
function openPrompt(url, size = DEFAULT_PROMPT_SIZE) {
  const { height, width } = size;
  const options = {
    height,
    left: window.screenLeft + Math.round((window.outerWidth - width) / 2),
    popup: true,
    top: window.screenTop + Math.round((window.outerHeight - height) / 2),
    width
  };
  const strOptions = Object.entries(options).map(([key, value]) => `${key}=${JSON.stringify(value)}`).reduce((acc, entry) => `${acc}, ${entry}`);
  const href = url instanceof URL ? url.href : url;
  const promptWindow = window.open(href, void 0, strOptions);
  if (promptWindow === null) {
    throw new Error("Couldn't open prompt");
  }
  return promptWindow;
}
async function waitForPromptResponse(baseUrl, promptWindow) {
  return new Promise((resolve, reject) => {
    const listeners2 = {
      onMessage: (message) => {
        if (message.source !== promptWindow || message.origin !== baseUrl) {
          return;
        }
        if (isTypedMessage(PromptUnauthorizedErrorMessage, message.data)) {
          window.removeEventListener("message", listeners2.onMessage);
          clearTimeout(listeners2.promptPollerId);
          reject(new PromptUnauthorizedError());
          return;
        }
        if (isTypedMessage(PromptOpenerPingRequestMessage, message.data)) {
          promptWindow.postMessage(new PromptOpenerPingResponseMessage(), baseUrl);
          return;
        }
        if (isTypedMessage(PromptApprovalResponseMessage, message.data)) {
          window.removeEventListener("message", listeners2.onMessage);
          clearTimeout(listeners2.promptPollerId);
          resolve(message.data.serializedValue);
        }
      },
      promptPollerId: setInterval(() => {
        if (promptWindow.closed) {
          window.removeEventListener("message", listeners2.onMessage);
          clearTimeout(listeners2.promptPollerId);
          resolve(dismissalSerializedResponse);
        }
      }, PROMPT_POLLER_INTERVAL)
    };
    window.addEventListener("message", listeners2.onMessage);
  });
}
var localDappStateKey = "@aptos-connect/dapp-local-state";
function serializeLocalDappState(state) {
  const serializer = new n();
  serializer.serializeU32AsUleb128(state.connectedAccounts.length);
  for (const account of state.connectedAccounts) {
    serializeAccountInfo(serializer, account);
  }
  return serializer.toUint8Array();
}
function deserializeLocalDappState(serializedValue) {
  const deserializer = new n2(serializedValue);
  const connectedAccountsLength = deserializer.deserializeUleb128AsU32();
  const connectedAccounts = [];
  for (let i4 = 0; i4 < connectedAccountsLength; i4 += 1) {
    connectedAccounts.push(deserializeAccountInfo(deserializer));
  }
  return { connectedAccounts };
}
function getState() {
  const encodedValue = window.localStorage.getItem(localDappStateKey);
  return encodedValue ? deserializeLocalDappState(base64ToBytes(encodedValue)) : { connectedAccounts: [] };
}
function setState(state) {
  const serializedValue = serializeLocalDappState(state);
  const encodedValue = bytesToBase64(serializedValue);
  window.localStorage.setItem(localDappStateKey, encodedValue);
}
function getConnectedAccounts() {
  const state = getState();
  return state.connectedAccounts;
}
function addConnectedAccount(account) {
  const { connectedAccounts, ...state } = getState();
  connectedAccounts.push(account);
  setState({ ...state, connectedAccounts });
}
function removeConnectedAccount(address) {
  const { connectedAccounts, ...state } = getState();
  const index = connectedAccounts.findIndex((a2) => a2.address.equals(address));
  if (index >= 0) {
    connectedAccounts.splice(index, 1);
  }
  setState({ ...state, connectedAccounts });
}
var WebWalletTransport = class {
  constructor(baseUrl) {
    this.baseUrl = baseUrl;
    this.baseUrl = baseUrl;
  }
  async sendPromptRequest(request3) {
    const url = new URL(`${this.baseUrl}/prompt/`);
    url.searchParams.set("request", urlEncodeWalletRequest(request3));
    const prompt = openPrompt(url);
    return waitForPromptResponse(this.baseUrl, prompt);
  }
  async sendRequest(request3) {
    switch (request3.name) {
      case IsConnectedRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return IsConnectedResponse.serialize(connectedAccounts.length > 0);
      }
      case GetConnectedAccountsRequest.name: {
        const connectedAccounts = getConnectedAccounts();
        return GetConnectedAccountsResponse.serialize(connectedAccounts);
      }
      case ConnectRequest.name: {
        const serializedResponse = await this.sendPromptRequest(request3);
        const response = ConnectResponse.deserialize(serializedResponse);
        if (response.args.status === "approved") {
          const { account, pairing } = response.args.args;
          if (pairing === void 0) {
            addConnectedAccount(account);
          }
        }
        return serializedResponse;
      }
      case DisconnectRequest.name: {
        const [activeAccount] = getConnectedAccounts();
        if (activeAccount) {
          removeConnectedAccount(activeAccount.address);
        }
        return DisconnectResponse.serialize({});
      }
      case SignMessageRequest.name:
      case SignTransactionRequest.name:
      case SignAndSubmitTransactionRequest.name: {
        return this.sendPromptRequest(request3);
      }
      default: {
        throw new Error("Unexpected request");
      }
    }
  }
};

// node_modules/@identity-connect/api/dist/index.mjs
var NetworkName = ((NetworkName22) => {
  NetworkName22["DEVNET"] = "devnet";
  NetworkName22["MAINNET"] = "mainnet";
  NetworkName22["TESTNET"] = "testnet";
  return NetworkName22;
})(NetworkName || {});
var PairingStatus = ((PairingStatus2) => {
  PairingStatus2["Finalized"] = "FINALIZED";
  PairingStatus2["Pending"] = "PENDING";
  return PairingStatus2;
})(PairingStatus || {});
var SigningRequestTypes = ((SigningRequestTypes2) => {
  SigningRequestTypes2["SIGN_AND_SUBMIT_TRANSACTION"] = "SIGN_AND_SUBMIT_TRANSACTION";
  SigningRequestTypes2["SIGN_MESSAGE"] = "SIGN_MESSAGE";
  SigningRequestTypes2["SIGN_TRANSACTION"] = "SIGN_TRANSACTION";
  return SigningRequestTypes2;
})(SigningRequestTypes || {});
var SigningRequestStatus = ((SigningRequestStatus2) => {
  SigningRequestStatus2["APPROVED"] = "APPROVED";
  SigningRequestStatus2["CANCELLED"] = "CANCELLED";
  SigningRequestStatus2["INVALID"] = "INVALID";
  SigningRequestStatus2["PENDING"] = "PENDING";
  SigningRequestStatus2["REJECTED"] = "REJECTED";
  return SigningRequestStatus2;
})(SigningRequestStatus || {});

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/node_modules/@identity-connect/wallet-api/dist/index.mjs
function isBcsSerializableV1(value) {
  return (value == null ? void 0 : value.serialize) !== void 0;
}
function isBcsSerializableV2(value) {
  return (value == null ? void 0 : value.serialize) !== void 0 && (value == null ? void 0 : value.bcsToBytes) !== void 0 && (value == null ? void 0 : value.bcsToHex) !== void 0;
}
function isBcsSerializable(value) {
  return isBcsSerializableV1(value) || isBcsSerializableV2(value);
}
function bcsSerialize(serializable) {
  if (isBcsSerializableV2(serializable)) {
    return serializable.bcsToHex().toString();
  }
  const serializedValueBytes = bcs_exports.bcsToBytes(serializable);
  return i.fromHexInput(serializedValueBytes).toString();
}
function bcsDeserialize(deserializableClass, serializedValue) {
  const serializedValueBytes = i.fromHexString(serializedValue).toUint8Array();
  const deserializer = new n2(serializedValueBytes);
  return deserializableClass.deserialize(deserializer);
}
var UnexpectedValueError = class _UnexpectedValueError extends Error {
  constructor(message) {
    super(message);
    this.name = "UnexpectedValueError";
    Object.setPrototypeOf(this, _UnexpectedValueError.prototype);
  }
};
function serializeEntryFunctionArg(arg) {
  if (arg instanceof Uint8Array) {
    return {
      type: "Uint8Array",
      value: i.fromHexInput(arg).toString()
    };
  }
  if (Array.isArray(arg)) {
    return arg.map(serializeEntryFunctionArg);
  }
  return arg;
}
function serializeEntryFunctionPayload(payload) {
  const normalizedArgs = payload.arguments.map(serializeEntryFunctionArg);
  return {
    ...payload,
    arguments: normalizedArgs,
    type: "entry_function_payload"
  };
}
function serializeJsonTransactionPayload(payload) {
  if (payload.type === "entry_function_payload" || payload.type === void 0) {
    return serializeEntryFunctionPayload(payload);
  }
  if (payload.type === "multisig_payload") {
    const innerPayload = payload.transaction_payload !== void 0 ? serializeEntryFunctionPayload(payload.transaction_payload) : void 0;
    return { ...payload, transaction_payload: innerPayload };
  }
  throw new UnexpectedValueError();
}
function serializeRawTransaction(rawTxn) {
  const value = bcsSerialize(rawTxn);
  if ("fee_payer_address" in rawTxn) {
    return { type: "fee_payer_raw_txn", value };
  }
  if ("secondary_signer_addresses" in rawTxn) {
    return { type: "multi_agent_raw_txn", value };
  }
  if ("chain_id" in rawTxn) {
    return { type: "raw_txn", value };
  }
  throw new UnexpectedValueError("Invalid raw transaction type");
}
function serializeSignAndSubmitTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("feePayerAuthenticator" in args) {
    return {
      feePayerAuthenticator: bcsSerialize(args.feePayerAuthenticator),
      rawTxn: serializeRawTransaction(args.rawTxn)
    };
  }
  if ("rawTxn" in args) {
    return { rawTxn: serializeRawTransaction(args.rawTxn) };
  }
  throw new UnexpectedValueError();
}
function serializeSignTransactionRequestArgs(args) {
  if ("payload" in args) {
    const serializedPayload = isBcsSerializable(args.payload) ? bcsSerialize(args.payload) : serializeJsonTransactionPayload(args.payload);
    return { options: args.options, payload: serializedPayload };
  }
  if ("rawTxn" in args) {
    const serializedRawTxn = serializeRawTransaction(args.rawTxn);
    return { rawTxn: serializedRawTxn };
  }
  throw new UnexpectedValueError();
}
function deserializeSignTransactionResponseArgs(args) {
  const accountAuthenticator = bcsDeserialize(r, args.accountAuthenticator);
  if ("rawTxn" in args) {
    const rawTxn = bcsDeserialize(t3, args.rawTxn);
    return { accountAuthenticator, rawTxn };
  }
  return { accountAuthenticator };
}

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-connect/wallet-adapter-plugin/node_modules/@identity-connect/dapp-sdk/dist/index.mjs
var DEFAULT_FRONTEND_URL = "https://aptosconnect.app";
var SignatureRequestError = class _SignatureRequestError extends Error {
  constructor(status) {
    super(status);
    this.name = "SignatureRequestError";
    Object.setPrototypeOf(this, _SignatureRequestError.prototype);
  }
};
var UnexpectedSignatureResponseError = class _UnexpectedSignatureResponseError extends Error {
  constructor(missingFields) {
    const message = `Missing the following fields: ${missingFields.join(", ")}`;
    super(message);
    this.name = "UnexpectedSignatureResponseError";
    Object.setPrototypeOf(this, _UnexpectedSignatureResponseError.prototype);
  }
};
var PairingExpiredError = class _PairingExpiredError extends Error {
  constructor() {
    super();
    this.name = "PairingExpiredError";
    Object.setPrototypeOf(this, _PairingExpiredError.prototype);
  }
};
var DAPP_PAIRINGS_WINDOW_STORAGE_KEY = "icDappPairings";
var windowStateAccessors = {
  async get(address) {
    const pairings = await this.getAll();
    return pairings[address];
  },
  async getAll() {
    const serialized = window.localStorage.getItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY);
    return serialized ? JSON.parse(serialized) : {};
  },
  async update(address, pairing) {
    const pairings = await this.getAll();
    if (pairing === void 0) {
      delete pairings[address];
    } else {
      pairings[address] = pairing;
    }
    const newSerialized = JSON.stringify(pairings);
    window.localStorage.setItem(DAPP_PAIRINGS_WINDOW_STORAGE_KEY, newSerialized);
  }
};
var SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS = [
  "address",
  "application",
  "chainId",
  "fullMessage",
  "message",
  "nonce",
  "prefix",
  "signature"
];
function validateSignMessageResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_MESSAGE_RESPONSE_REQUIRED_FIELDS.filter((field) => !providedFields.has(field));
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS = ["hash"];
function validateSignAndSubmitTransactionResponse(response) {
  const providedFields = new Set(Object.keys(response));
  const missingFields = SIGN_AND_SUBMIT_TRANSACTION_RESPONSE_REQUIRED_FIELDS.filter(
    (field) => !providedFields.has(field)
  );
  if (missingFields.length > 0) {
    throw new UnexpectedSignatureResponseError(missingFields);
  }
}
var API_VERSION = "0.2.0";
var SIGNING_REQUEST_POLLING_INTERVAL = 2500;
var SEQUENCE_NUMBER_MISMATCH_PATTERN = /^Sequence number mismatch, expected (?:\S+ to be )?(\d+)/;
async function waitFor(milliseconds) {
  return new Promise((resolve) => {
    setTimeout(resolve, milliseconds);
  });
}
async function withRetries(requestFn, onError, retries = 1) {
  for (let i4 = 0; i4 < retries; i4 += 1) {
    try {
      return await requestFn();
    } catch (err) {
      onError(err);
    }
  }
  return requestFn();
}
var ACPairingClient = class {
  constructor({
    accessors = windowStateAccessors,
    axiosConfig,
    defaultNetworkName = NetworkName.MAINNET
  } = {}) {
    this.onDisconnectListeners = /* @__PURE__ */ new Set();
    this.accessors = accessors;
    this.defaultNetworkName = defaultNetworkName;
    this.axiosInstance = axios_default.create({
      baseURL: DEFAULT_FRONTEND_URL,
      ...axiosConfig
    });
    const isClientSideRendering = typeof window !== "undefined";
    this.initPromise = isClientSideRendering ? this.syncFirstPairing() : void 0;
  }
  async getPairing(id) {
    const response = await this.axiosInstance.get(`v1/pairing/${id}/`);
    return response.data.data.pairing;
  }
  async syncFirstPairing() {
    const pairings = await this.accessors.getAll();
    const firstPairing = Object.values(pairings)[0];
    if (firstPairing === void 0) {
      return;
    }
    try {
      const { dappSpecificWallet, maxDappSequenceNumber } = await this.getPairing(firstPairing.pairingId);
      await this.accessors.update(firstPairing.accountAddress, {
        ...firstPairing,
        currSequenceNumber: maxDappSequenceNumber,
        dappWalletId: dappSpecificWallet == null ? void 0 : dappSpecificWallet.id
      });
    } catch (err) {
      await this.accessors.update(firstPairing.accountAddress, void 0);
    }
  }
  async createSigningRequest(pairing, type, networkName, requestBody) {
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);
    let sequenceNumber = pairing.currSequenceNumber + 1;
    return withRetries(
      async () => {
        const requestEnvelope = await encryptAndSignEnvelope(
          toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
          toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
          sequenceNumber,
          { apiVersion: API_VERSION, networkName, requestType: type },
          requestBody
        );
        const response = await this.axiosInstance.post(
          `v1/pairing/${pairing.pairingId}/signing-request/`,
          requestEnvelope
        );
        await this.accessors.update(pairing.accountAddress, {
          ...pairing,
          currSequenceNumber: sequenceNumber
        });
        return response.data.data.signingRequest;
      },
      (err) => {
        var _a, _b, _c;
        if (isAxiosError(err)) {
          const errorMessage = (_b = (_a = err.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message;
          const expectedSequenceNumber = (_c = errorMessage == null ? void 0 : errorMessage.match(SEQUENCE_NUMBER_MISMATCH_PATTERN)) == null ? void 0 : _c[1];
          if (expectedSequenceNumber !== void 0) {
            sequenceNumber = Number(expectedSequenceNumber);
            return;
          }
        }
        throw err;
      }
    );
  }
  async getSigningRequest(id) {
    var _a, _b;
    const response = await this.axiosInstance.get(
      `v1/signing-request/${id}/`,
      {
        validateStatus: (status) => status === 200 || status === 404
      }
    );
    return (_b = (_a = response.data) == null ? void 0 : _a.data) == null ? void 0 : _b.signingRequest;
  }
  async deletePairing(pairingId, secretKey, publicKey) {
    const requestEnvelope = await encryptAndSignEnvelope(
      secretKey,
      publicKey,
      publicKey,
      0,
      // ignored
      {},
      {}
    );
    await this.axiosInstance.post(
      `v1/pairing/${pairingId}/delete/`,
      requestEnvelope,
      { validateStatus: (status) => status === 204 || status === 404 }
    );
  }
  async cancelSigningRequest(pairing, id) {
    const sequenceNumber = pairing.currSequenceNumber;
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    const accountTransportEd25519PublicKey = decodeBase64(pairing.accountTransportEd25519PublicKeyB64);
    const requestEnvelope = await encryptAndSignEnvelope(
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      toKey(accountTransportEd25519PublicKey, KeyTypes.Ed25519PublicKey),
      sequenceNumber + 1,
      {},
      {}
    );
    const response = await this.axiosInstance.patch(
      `v1/signing-request/${id}/cancel/`,
      requestEnvelope
    );
    await this.accessors.update(pairing.accountAddress, {
      ...pairing,
      currSequenceNumber: sequenceNumber + 1
    });
    return response.data.data.signingRequest;
  }
  async signRequest(address, type, requestBody, { cancelToken, networkName } = {}) {
    await this.initPromise;
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The requested account is not paired");
    }
    let signingRequest;
    try {
      signingRequest = await this.createSigningRequest(
        pairing,
        type,
        networkName || this.defaultNetworkName,
        requestBody
      );
      while (signingRequest.status === "PENDING") {
        await waitFor(SIGNING_REQUEST_POLLING_INTERVAL);
        if (cancelToken == null ? void 0 : cancelToken.cancelled) {
          signingRequest.status = SigningRequestStatus.CANCELLED;
          break;
        }
        signingRequest = await this.getSigningRequest(signingRequest.id) ?? signingRequest;
      }
    } catch (err) {
      if (isAxiosError(err) && err.code === "404") {
        await this.accessors.update(address, void 0);
        for (const listener of this.onDisconnectListeners) {
          listener(address);
        }
        throw new PairingExpiredError();
      }
      throw err;
    }
    if (signingRequest.status !== "APPROVED") {
      throw new SignatureRequestError(signingRequest.status);
    }
    const decrypted = decryptEnvelope(
      toKey(decodeBase64(pairing.accountTransportEd25519PublicKeyB64), KeyTypes.Ed25519PublicKey),
      toKey(decodeBase64(pairing.dappEd25519SecretKeyB64), KeyTypes.Ed25519SecretKey),
      signingRequest.responseEnvelope
    );
    return decrypted.privateMessage;
  }
  // region Public API
  /**
   * Requests a connection to an account (internally known as pairing).
   * @returns either the address of the connected account, or undefined if the
   * connection was cancelled.
   */
  async addPairing({ publicKey, secretKey }, finalizedPairing) {
    await this.accessors.update(finalizedPairing.account.accountAddress, {
      accountAddress: finalizedPairing.account.accountAddress,
      accountAlias: finalizedPairing.account.userSubmittedAlias ?? void 0,
      accountPublicKeyB64: finalizedPairing.account.publicKeyB64,
      accountTransportEd25519PublicKeyB64: finalizedPairing.account.transportEd25519PublicKeyB64,
      currSequenceNumber: finalizedPairing.maxDappSequenceNumber,
      dappEd25519PublicKeyB64: encodeBase64(publicKey.key),
      dappEd25519SecretKeyB64: encodeBase64(secretKey.key),
      dappWalletId: finalizedPairing.dappSpecificWalletId,
      pairingId: finalizedPairing.id
    });
  }
  async disconnect(address) {
    const pairing = await this.accessors.get(address);
    if (pairing === void 0) {
      throw new Error("The specified account is not paired");
    }
    const dappEd25519SecretKey = decodeBase64(pairing.dappEd25519SecretKeyB64);
    const dappEd25519PublicKey = decodeBase64(pairing.dappEd25519PublicKeyB64);
    await this.deletePairing(
      pairing.pairingId,
      toKey(dappEd25519SecretKey, KeyTypes.Ed25519SecretKey),
      toKey(dappEd25519PublicKey, KeyTypes.Ed25519PublicKey)
    );
    await this.accessors.update(address, void 0);
    for (const listener of this.onDisconnectListeners) {
      listener(address);
    }
  }
  async signMessage(address, args, options) {
    const response = await this.signRequest(
      address,
      SigningRequestTypes.SIGN_MESSAGE,
      args,
      options
    );
    validateSignMessageResponse(response);
    return response;
  }
  async signTransaction(address, args, options) {
    const serializedRequestArgs = serializeSignTransactionRequestArgs(args);
    const serializedResponseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_TRANSACTION, serializedRequestArgs, options);
    return deserializeSignTransactionResponseArgs(serializedResponseArgs);
  }
  // endregion
  async signAndSubmitTransaction(address, args, options) {
    var _a, _b, _c, _d;
    const serializedRequestArgs = serializeSignAndSubmitTransactionRequestArgs(args);
    try {
      const responseArgs = await this.signRequest(address, SigningRequestTypes.SIGN_AND_SUBMIT_TRANSACTION, serializedRequestArgs, options);
      validateSignAndSubmitTransactionResponse(responseArgs);
      return responseArgs;
    } catch (e10) {
      if (e10 instanceof AxiosError && ((_b = (_a = e10.response) == null ? void 0 : _a.data) == null ? void 0 : _b.message)) {
        throw new Error((_d = (_c = e10.response) == null ? void 0 : _c.data) == null ? void 0 : _d.message);
      }
      throw e10;
    }
  }
  async getConnectedAccounts() {
    await this.initPromise;
    const pairings = await this.accessors.getAll();
    return Object.values(pairings).map(
      ({ accountAddress, accountEd25519PublicKeyB64, accountPublicKeyB64 }) => ({
        address: d.from(accountAddress),
        publicKey: accountPublicKeyB64 !== void 0 ? deserializePublicKeyB64(accountPublicKeyB64) : deserializeEd25519PublicKeyB64(accountEd25519PublicKeyB64)
      })
    );
  }
  onDisconnect(listener) {
    this.onDisconnectListeners.add(listener);
    return () => this.onDisconnectListeners.delete(listener);
  }
};
var ACDappClient = class {
  constructor({
    backendBaseURL,
    dappId,
    dappImageURI,
    dappName,
    defaultNetworkName = NetworkName.MAINNET,
    frontendBaseURL = DEFAULT_FRONTEND_URL
  } = {}) {
    this.defaultNetworkName = defaultNetworkName;
    this.dappInfo = {
      domain: window.location.origin,
      imageURI: dappImageURI,
      name: dappName ?? document.title
    };
    this.transport = new WebWalletTransport(frontendBaseURL);
    this.dappId = dappId;
    this.pairingClient = new ACPairingClient({
      axiosConfig: {
        baseURL: backendBaseURL ?? frontendBaseURL
      },
      defaultNetworkName
    });
  }
  // region Public API
  async getKeylessAccounts() {
    const serializedRequest = GetConnectedAccountsRequest.serialize(this.dappInfo);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = GetConnectedAccountsResponse.deserialize(serializedResponse);
    return response.args;
  }
  async getIcAccounts() {
    return this.pairingClient.getConnectedAccounts() ?? [];
  }
  async isIcAccount(address) {
    const icAccounts = await this.getIcAccounts();
    return icAccounts.find((account) => account.address.equals(d.from(address))) !== void 0;
  }
  async getConnectedAccounts() {
    const keylessAccounts = await this.getKeylessAccounts();
    const icAccounts = await this.getIcAccounts();
    return [...keylessAccounts, ...icAccounts];
  }
  async disconnect(address) {
    if (await this.isIcAccount(address)) {
      const stringAddress = d.from(address).toString();
      await this.pairingClient.disconnect(stringAddress);
    } else {
      const serializedRequest = DisconnectRequest.serialize(this.dappInfo);
      await this.transport.sendRequest(serializedRequest);
    }
  }
  async connect() {
    const dappKeypair = createEd25519KeyPair();
    const requestArgs = {
      dappEd25519PublicKeyB64: encodeBase64(dappKeypair.publicKey.key),
      dappId: this.dappId
    };
    const serializedRequest = ConnectRequest.serialize(this.dappInfo, requestArgs);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = ConnectResponse.deserialize(serializedResponse);
    if (response.args.status === "approved") {
      const { account, pairing } = response.args.args;
      if (pairing) {
        await this.pairingClient.addPairing(dappKeypair, pairing);
      }
      return makeUserApproval({ account });
    }
    return response.args;
  }
  async signMessage(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { chainId } = args;
      const network = chainIdToNetwork(chainId);
      let message;
      let nonce;
      try {
        message = new TextDecoder().decode(args.message);
        nonce = new TextDecoder().decode(args.nonce);
      } catch (err) {
        throw new Error("Only UTF-8 encoded text is supported when using IC");
      }
      const { fullMessage, signature: hexSignature } = await this.pairingClient.signMessage(
        signerAddress.toString(),
        {
          address: true,
          application: true,
          chainId: true,
          message,
          nonce
        },
        { networkName: network }
      );
      const signatureBytes = i.fromHexInput(hexSignature).toUint8Array();
      const signature = signatureBytes.length === h.LENGTH ? new h(signatureBytes) : l.deserialize(new n2(signatureBytes));
      return makeUserApproval({
        fullMessage,
        signature
      });
    }
    const serializedRequest = SignMessageRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignMessageResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signTransaction(args) {
    const normalizedArgs = "transaction" in args ? SignTransactionRequest.normalizeArgs(args) : args;
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const {
        expirationSecondsFromNow,
        expirationTimestamp,
        feePayer,
        gasUnitPrice,
        maxGasAmount,
        network,
        payload,
        secondarySigners,
        sender,
        sequenceNumber
      } = normalizedArgs;
      if (feePayer !== void 0) {
        throw new Error("Sponsored transaction not currently supported");
      }
      if (secondarySigners && secondarySigners.length > 0) {
        throw new Error("Multi-agent transactions not currently supported");
      }
      const responseArgs = await this.pairingClient.signTransaction(
        signerAddress.toString(),
        {
          options: {
            expirationSecondsFromNow,
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount,
            sender: sender == null ? void 0 : sender.address.toString(),
            sequenceNumber: sequenceNumber !== void 0 ? Number(sequenceNumber) : void 0
          },
          payload
        },
        {
          networkName: network
        }
      );
      return makeUserApproval({
        authenticator: responseArgs.accountAuthenticator,
        rawTransaction: responseArgs.rawTxn
      });
    }
    const serializedRequest = SignTransactionRequest.serialize(this.dappInfo, normalizedArgs);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  async signAndSubmitTransaction(args) {
    const { signerAddress } = args;
    if (await this.isIcAccount(signerAddress)) {
      const { expirationTimestamp, feePayer, gasUnitPrice, maxGasAmount, network } = args;
      const aptosConfig = new l2({ network });
      let payload;
      if ("bcsToBytes" in args.payload) {
        payload = args.payload;
      } else if ("bytecode" in args.payload) {
        payload = await vn(args.payload);
      } else {
        payload = args.payload.abi !== void 0 ? mn({ ...args.payload, abi: args.payload.abi }) : await vn({ aptosConfig, ...args.payload });
      }
      let convertedArgs;
      if (feePayer !== void 0) {
        const rawTxn = await fn({
          aptosConfig,
          feePayerAddress: feePayer.address,
          options: {
            gasUnitPrice,
            maxGasAmount
          },
          payload,
          sender: signerAddress
        });
        convertedArgs = {
          feePayerAuthenticator: feePayer.authenticator,
          rawTxn: new p(rawTxn, [], feePayer.address)
        };
      } else {
        convertedArgs = {
          options: {
            expirationTimestamp,
            gasUnitPrice,
            maxGasAmount
          },
          payload
        };
      }
      const { hash: hash2 } = await this.pairingClient.signAndSubmitTransaction(signerAddress.toString(), convertedArgs, {
        networkName: network
      });
      return makeUserApproval({ txnHash: hash2 });
    }
    const serializedRequest = SignAndSubmitTransactionRequest.serialize(this.dappInfo, args);
    const serializedResponse = await this.transport.sendRequest(serializedRequest);
    const response = SignAndSubmitTransactionResponse.deserialize(serializedResponse);
    return response.args;
  }
  // endregion
};

// node_modules/@aptos-labs/wallet-adapter-core/node_modules/@aptos-connect/wallet-adapter-plugin/dist/index.mjs
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var _address;
var _publicKey;
var AptosConnectAccount = class {
  constructor({ address, ansName, publicKey }) {
    this.chains = e4;
    this.features = [];
    __privateAdd(this, _address, void 0);
    __privateAdd(this, _publicKey, void 0);
    __privateSet(this, _publicKey, publicKey);
    __privateSet(this, _address, address);
    this.label = ansName;
  }
  get address() {
    return __privateGet(this, _address).toString();
  }
  get publicKey() {
    return __privateGet(this, _publicKey).toUint8Array();
  }
  get signingScheme() {
    if (__privateGet(this, _publicKey) instanceof m) {
      return C.Ed25519;
    }
    if (__privateGet(this, _publicKey) instanceof d2) {
      return C.MultiEd25519;
    }
    if (__privateGet(this, _publicKey) instanceof f) {
      return C.SingleKey;
    }
    if (__privateGet(this, _publicKey) instanceof f2) {
      return C.MultiKey;
    }
    throw new Error("Unsupported public key type");
  }
  // endregion
};
_address = /* @__PURE__ */ new WeakMap();
_publicKey = /* @__PURE__ */ new WeakMap();
var walletName = "Continue with Google";
var walletUrl = "https://aptosconnect.app";
var walletIcon = (
  // eslint-disable-next-line max-len
  "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMjQiIGhlaWdodD0iMjQiIHZpZXdCb3g9IjAgMCAyNCAyNCIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiBjbGFzcz0iaF8yMCB3XzIwIj48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTIzLjU0IDEyLjc2MTNDMjMuNTQgMTEuOTQ1OSAyMy40NjY4IDExLjE2MTggMjMuMzMwOSAxMC40MDkxSDEyLjVWMTQuODU3NUgxOC42ODkxQzE4LjQyMjUgMTYuMjk1IDE3LjYxMjMgMTcuNTEyOSAxNi4zOTQzIDE4LjMyODRWMjEuMjEzOEgyMC4xMTA5QzIyLjI4NTUgMTkuMjExOCAyMy41NCAxNi4yNjM2IDIzLjU0IDEyLjc2MTNaIiBmaWxsPSIjNDI4NUY0Ij48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik0xMi40OTk1IDIzLjk5OThDMTUuNjA0NSAyMy45OTk4IDE4LjIwNzcgMjIuOTcgMjAuMTEwNCAyMS4yMTM3TDE2LjM5MzggMTguMzI4MkMxNS4zNjQgMTkuMDE4MiAxNC4wNDY3IDE5LjQyNTkgMTIuNDk5NSAxOS40MjU5QzkuNTA0MjUgMTkuNDI1OSA2Ljk2OTAyIDE3LjQwMyA2LjA2NDcgMTQuNjg0OEgyLjIyMjY2VjE3LjY2NDRDNC4xMTQ5MyAyMS40MjI4IDguMDA0MDIgMjMuOTk5OCAxMi40OTk1IDIzLjk5OThaIiBmaWxsPSIjMzRBODUzIj48L3BhdGg+PHBhdGggZmlsbC1ydWxlPSJldmVub2RkIiBjbGlwLXJ1bGU9ImV2ZW5vZGQiIGQ9Ik02LjA2NTIzIDE0LjY4NTFDNS44MzUyMyAxMy45OTUxIDUuNzA0NTUgMTMuMjU4MSA1LjcwNDU1IDEyLjUwMDFDNS43MDQ1NSAxMS43NDIyIDUuODM1MjMgMTEuMDA1MSA2LjA2NTIzIDEwLjMxNTFWNy4zMzU1N0gyLjIyMzE4QzEuNDQ0MzIgOC44ODgwNyAxIDEwLjY0NDQgMSAxMi41MDAxQzEgMTQuMzU1OCAxLjQ0NDMyIDE2LjExMjIgMi4yMjMxOCAxNy42NjQ3TDYuMDY1MjMgMTQuNjg1MVoiIGZpbGw9IiNGQkJDMDUiPjwvcGF0aD48cGF0aCBmaWxsLXJ1bGU9ImV2ZW5vZGQiIGNsaXAtcnVsZT0iZXZlbm9kZCIgZD0iTTEyLjQ5OTUgNS41NzM4NkMxNC4xODc5IDUuNTczODYgMTUuNzAzOCA2LjE1NDA5IDE2Ljg5NTYgNy4yOTM2NEwyMC4xOTQgMy45OTUyM0MxOC4yMDI0IDIuMTM5NTUgMTUuNTk5MiAxIDEyLjQ5OTUgMUM4LjAwNDAyIDEgNC4xMTQ5MyAzLjU3NzA1IDIuMjIyNjYgNy4zMzU0NUw2LjA2NDcgMTAuMzE1QzYuOTY5MDIgNy41OTY4MiA5LjUwNDI1IDUuNTczODYgMTIuNDk5NSA1LjU3Mzg2WiIgZmlsbD0iI0VBNDMzNSI+PC9wYXRoPjwvc3ZnPg=="
);
function customAccountToStandardAccount({ address, name, publicKey }) {
  return new d3({
    address,
    ansName: name,
    publicKey
  });
}
var _AptosConnectWallet = class _AptosConnectWallet2 {
  constructor({ network = e.MAINNET, ...clientConfig }) {
    this.name = walletName;
    this.version = "1.0.0";
    this.icon = walletIcon;
    this.url = walletUrl;
    this.chains = e4;
    this.client = new ACDappClient(clientConfig);
    if (!o3[network]) {
      throw new Error("Network not supported");
    }
    const aptosConfig = new l2({ network });
    this.aptosClient = new t4(aptosConfig);
  }
  static get connectedAccount() {
    const serialized = localStorage.getItem(_AptosConnectWallet2.connectedAccountStorageKey);
    if (!serialized) {
      return void 0;
    }
    try {
      const { address, publicKey } = JSON.parse(serialized);
      return serialized ? new d3({
        address: d.from(address),
        publicKey: deserializePublicKeyB64(publicKey)
      }) : void 0;
    } catch (err) {
      console.warn("Failed to parse state, resetting it");
      this.connectedAccount = void 0;
      return void 0;
    }
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      const serialized = {
        address: value.address.toString(),
        publicKey: serializePublicKeyB64(value.publicKey)
      };
      localStorage.setItem(_AptosConnectWallet2.connectedAccountStorageKey, JSON.stringify(serialized));
    } else {
      localStorage.removeItem(_AptosConnectWallet2.connectedAccountStorageKey);
    }
  }
  // eslint-disable-next-line class-methods-use-this
  get accounts() {
    const { connectedAccount } = _AptosConnectWallet2;
    return connectedAccount ? [new AptosConnectAccount(connectedAccount)] : [];
  }
  get features() {
    return {
      [o4]: {
        connect: this.connect.bind(this),
        version: "1.0.0"
      },
      [o5]: {
        disconnect: this.disconnect.bind(this),
        version: "1.0.0"
      },
      [t5]: {
        account: this.getAccount.bind(this),
        version: "1.0.0"
      },
      [t6]: {
        network: this.getNetwork.bind(this),
        version: "1.0.0"
      },
      [n7]: {
        onAccountChange: this.onAccountChange.bind(this),
        version: "1.0.0"
      },
      [e3]: {
        onNetworkChange: this.onNetworkChange.bind(this),
        version: "1.0.0"
      },
      [n5]: {
        signAndSubmitTransaction: this.signAndSubmitTransaction.bind(this),
        version: "1.1.0"
      },
      [e2]: {
        signMessage: this.signMessage.bind(this),
        version: "1.0.0"
      },
      [n6]: {
        signTransaction: this.signTransaction.bind(this),
        version: "1.0.0"
      }
    };
  }
  async connect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount !== void 0) {
      return { args: connectedAccount, status: r4.APPROVED };
    }
    const response = await this.client.connect();
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    const newConnectedAccount = customAccountToStandardAccount(response.args.account);
    _AptosConnectWallet2.connectedAccount = newConnectedAccount;
    return {
      args: newConnectedAccount,
      status: r4.APPROVED
    };
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWallet2.connectedAccount = void 0;
    }
  }
  // eslint-disable-next-line class-methods-use-this
  async getAccount() {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    return customAccountToStandardAccount(connectedAccount);
  }
  async getNetwork() {
    const { network } = this.aptosClient.config;
    const chainId = await this.aptosClient.getChainId();
    const url = o3[network];
    return {
      chainId,
      name: network,
      url
    };
  }
  async signMessage(input) {
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const { chainId } = await this.getNetwork();
    const { message, nonce } = input;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    const { fullMessage, signature } = response.args;
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: "",
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      args: {
        fullMessage,
        signature,
        ...extraResponseArgs
      },
      status: r4.APPROVED
    };
  }
  async signTransaction(transaction, _asFeePayer) {
    var _a;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
    const secondarySigners = (_a = transaction.secondarySignerAddresses) == null ? void 0 : _a.map((address) => ({ address }));
    const response = await this.client.signTransaction({
      feePayer,
      secondarySigners,
      signerAddress: connectedAccount.address,
      transaction: transaction.rawTransaction
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    return {
      args: response.args.authenticator,
      status: r4.APPROVED
    };
  }
  async signAndSubmitTransaction(args) {
    const { gasUnitPrice, maxGasAmount, payload } = args;
    const { connectedAccount } = _AptosConnectWallet2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const response = await this.client.signAndSubmitTransaction({
      gasUnitPrice,
      maxGasAmount,
      network: this.aptosClient.config.network,
      payload,
      signerAddress: connectedAccount.address
    });
    if (response.status === "dismissed") {
      return { status: r4.REJECTED };
    }
    const txnResponse = await this.aptosClient.getTransactionByHash({
      transactionHash: response.args.txnHash
    });
    return {
      args: txnResponse,
      status: r4.APPROVED
    };
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // endregion
};
_AptosConnectWallet.connectedAccountStorageKey = "@aptos-connect/connectedAccount";
var AptosConnectWallet = _AptosConnectWallet;
function convertV1toV2(src, dst) {
  const serializedBytes = bcs_exports.bcsToBytes(src);
  const deserializerV2 = new n2(serializedBytes);
  return dst.deserialize(deserializerV2);
}
function convertPayloadInputFromV1ToV2(inputV1) {
  if ("multisig_address" in inputV1) {
    throw new Error("Multisig payload not supported");
  }
  if ("code" in inputV1) {
    throw new Error("Script payload not supported");
  }
  if ("function" in inputV1) {
    return {
      function: inputV1.function,
      functionArguments: inputV1.arguments,
      typeArguments: inputV1.type_arguments
    };
  }
  throw new Error("Unsupported payload type");
}
function customAccountToStandardAccount2({ address, name, publicKey }) {
  if (publicKey instanceof d2 || publicKey instanceof f2) {
    throw new Error("Unsupported public key type");
  }
  return {
    address: address.toString(),
    ansName: name,
    publicKey: publicKey.toString()
  };
}
function accountAuthenticatorToTransactionAuthenticator(accountAuthenticator) {
  if (accountAuthenticator instanceof u2) {
    return new o(accountAuthenticator.public_key, accountAuthenticator.signature);
  }
  if (accountAuthenticator instanceof n3) {
    if (accountAuthenticator.isEd25519()) {
      return new o(
        accountAuthenticator.public_key.publicKey,
        accountAuthenticator.signature.signature
      );
    }
    return new A(accountAuthenticator);
  }
  throw new Error("Cannot convert account authenticator to a compatible transaction authenticator");
}
function unwrapUserResponse(response) {
  if (response.status === "dismissed") {
    throw new r3(0, "Rejected");
  }
  return response.args;
}
var _AptosConnectWalletPlugin = class _AptosConnectWalletPlugin2 {
  constructor({ network = e.MAINNET, ...clientConfig }) {
    this.providerName = "open";
    this.version = "v2";
    this.name = walletName;
    this.url = walletUrl;
    this.icon = walletIcon;
    this.client = new ACDappClient(clientConfig);
    if (!o3[network]) {
      throw new Error("Network not supported");
    }
    const aptosConfig = new l2({ network });
    this.aptosClient = new t4(aptosConfig);
  }
  static get connectedAccount() {
    const value = localStorage.getItem(_AptosConnectWalletPlugin2.connectedAccountStorageKey);
    return value ? JSON.parse(value) : void 0;
  }
  static set connectedAccount(value) {
    if (value !== void 0) {
      localStorage.setItem(_AptosConnectWalletPlugin2.connectedAccountStorageKey, JSON.stringify(value));
    } else {
      localStorage.removeItem(_AptosConnectWalletPlugin2.connectedAccountStorageKey);
    }
  }
  // endregion
  async connect() {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (connectedAccount !== void 0) {
      return connectedAccount;
    }
    const response = await this.client.connect();
    if (response.status === "dismissed") {
      throw new r3(n9.Unauthorized);
    }
    const newConnectedAccount = customAccountToStandardAccount2(response.args.account);
    _AptosConnectWalletPlugin2.connectedAccount = newConnectedAccount;
    return newConnectedAccount;
  }
  async account() {
    const [firstAccount] = await this.client.getConnectedAccounts();
    if (firstAccount === void 0) {
      throw new r3(n9.Unauthorized);
    }
    return customAccountToStandardAccount2(firstAccount);
  }
  async disconnect() {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (connectedAccount) {
      await this.client.disconnect(connectedAccount.address);
      _AptosConnectWalletPlugin2.connectedAccount = void 0;
    }
  }
  async signAndSubmitTransaction(payloadV1InputOrGenerateTxnInput, optionsV1) {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    let payload;
    let options;
    if ("data" in payloadV1InputOrGenerateTxnInput) {
      const { data: payloadV2Input, options: optionsV2 } = payloadV1InputOrGenerateTxnInput;
      payload = payloadV2Input;
      options = {
        expirationTimestamp: optionsV2 == null ? void 0 : optionsV2.expireTimestamp,
        gasUnitPrice: optionsV2 == null ? void 0 : optionsV2.gasUnitPrice,
        maxGasAmount: optionsV2 == null ? void 0 : optionsV2.maxGasAmount,
        network: this.aptosClient.config.network
      };
    } else {
      payload = convertPayloadInputFromV1ToV2(payloadV1InputOrGenerateTxnInput);
      options = {
        expirationTimestamp: optionsV1 == null ? void 0 : optionsV1.expirationTimestamp,
        gasUnitPrice: (optionsV1 == null ? void 0 : optionsV1.gasUnitPrice) ?? (optionsV1 == null ? void 0 : optionsV1.gas_unit_price),
        maxGasAmount: (optionsV1 == null ? void 0 : optionsV1.maxGasAmount) ?? (optionsV1 == null ? void 0 : optionsV1.max_gas_amount),
        network: this.aptosClient.config.network
      };
    }
    const response = await this.client.signAndSubmitTransaction({
      signerAddress: d.from(connectedAccount.address),
      ...options,
      payload
    });
    const { txnHash } = unwrapUserResponse(response);
    return { hash: txnHash };
  }
  async signAndSubmitBCSTransaction(payloadV1, options) {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const payload = convertV1toV2(payloadV1, a);
    const response = await this.client.signAndSubmitTransaction({
      expirationTimestamp: options == null ? void 0 : options.expirationTimestamp,
      gasUnitPrice: (options == null ? void 0 : options.gasUnitPrice) ?? (options == null ? void 0 : options.gas_unit_price),
      maxGasAmount: (options == null ? void 0 : options.maxGasAmount) ?? (options == null ? void 0 : options.max_gas_amount),
      network: this.aptosClient.config.network,
      payload,
      signerAddress: d.from(connectedAccount.address)
    });
    const { txnHash } = unwrapUserResponse(response);
    return { hash: txnHash };
  }
  async signMessage(args) {
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    const chainId = await this.aptosClient.getChainId();
    const { message, nonce } = args;
    const encoder = new TextEncoder();
    const messageBytes = encoder.encode(message);
    const nonceBytes = encoder.encode(nonce);
    const response = await this.client.signMessage({
      chainId,
      message: messageBytes,
      nonce: nonceBytes,
      signerAddress: d.from(connectedAccount.address)
    });
    const { fullMessage, signature } = unwrapUserResponse(response);
    const extraResponseArgs = {
      address: connectedAccount.address.toString(),
      application: this.client.dappInfo.domain,
      chainId,
      message,
      nonce,
      prefix: "APTOS"
    };
    return {
      fullMessage,
      signature: signature.toString(),
      ...extraResponseArgs
    };
  }
  async signTransaction(transactionOrPayload, optionsOrAsFeePayer) {
    var _a;
    const { connectedAccount } = _AptosConnectWalletPlugin2;
    if (!connectedAccount) {
      throw new r3(n9.Unauthorized);
    }
    if ("rawTransaction" in transactionOrPayload) {
      const transaction = transactionOrPayload;
      const feePayer = transaction.feePayerAddress ? { address: transaction.feePayerAddress } : void 0;
      const secondarySigners = (_a = transaction.secondarySignerAddresses) == null ? void 0 : _a.map((address) => ({ address }));
      const response2 = await this.client.signTransaction({
        feePayer,
        secondarySigners,
        signerAddress: d.from(connectedAccount.address),
        transaction: transaction.rawTransaction
      });
      const { authenticator: authenticator2 } = unwrapUserResponse(response2);
      return authenticator2;
    }
    if (!(transactionOrPayload instanceof aptos_types_exports.TransactionPayload)) {
      throw new Error("Not supported");
    }
    const payload = convertV1toV2(transactionOrPayload, a);
    const options = optionsOrAsFeePayer;
    const sender = (options == null ? void 0 : options.sender) ? {
      address: d.from(options.sender)
    } : void 0;
    const response = await this.client.signTransaction({
      expirationSecondsFromNow: options == null ? void 0 : options.expirationSecondsFromNow,
      expirationTimestamp: options == null ? void 0 : options.expirationTimestamp,
      gasUnitPrice: (options == null ? void 0 : options.gasUnitPrice) ?? (options == null ? void 0 : options.gas_unit_price),
      maxGasAmount: (options == null ? void 0 : options.maxGasAmount) ?? (options == null ? void 0 : options.max_gas_amount),
      network: this.aptosClient.config.network,
      payload,
      sender,
      sequenceNumber: options == null ? void 0 : options.sequenceNumber,
      signerAddress: d.from(connectedAccount.address)
    });
    const { authenticator, rawTransaction } = unwrapUserResponse(response);
    if (rawTransaction === void 0) {
      throw new Error("The wallet did not return a raw transaction");
    }
    const txnAuthenticator = accountAuthenticatorToTransactionAuthenticator(authenticator);
    const signedTransaction = new n4(rawTransaction, txnAuthenticator);
    return signedTransaction.bcsToBytes();
  }
  // eslint-disable-next-line class-methods-use-this
  async onNetworkChange(_callback) {
  }
  // eslint-disable-next-line class-methods-use-this
  async onAccountChange(_callback) {
  }
  async network() {
    const { network } = this.aptosClient.config;
    const chainId = await this.aptosClient.getChainId();
    const url = o3[network];
    return {
      chainId: chainId.toString(),
      name: network,
      url
    };
  }
};
_AptosConnectWalletPlugin.connectedAccountStorageKey = "AptosConnectWalletPlugin.connectedAccount";

// node_modules/@atomrigslab/aptos-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-3XZSACFC.mjs
var t10 = "aptos:devnet";
var o9 = "aptos:testnet";
var A3 = "aptos:localnet";
var T2 = "aptos:mainnet";
var e6 = [t10, o9, A3, T2];

// node_modules/@atomrigslab/aptos-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-KFHNVTDM.mjs
var n10 = ((e10) => (e10[e10.Unauthorized = 4100] = "Unauthorized", e10[e10.InternalError = -30001] = "InternalError", e10))(n10 || {});
var t11 = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." } });

// node_modules/@atomrigslab/aptos-wallet-adapter/node_modules/@aptos-labs/wallet-standard/dist/esm/chunk-YVBEQ4QF.mjs
var r5 = ((e10) => (e10.APPROVED = "Approved", e10.REJECTED = "Rejected", e10))(r5 || {});

// node_modules/@atomrigslab/aptos-wallet-adapter/dist/index.es.js
var h2 = class {
  constructor(t14 = {}) {
    this.option = t14, this.url = "https://www.twallet.ai", this.version = "1.0.0", this.name = "T wallet", this.icon = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAGAAAABgCAYAAADimHc4AAAQbUlEQVR4nO2da4wk11WAv3urume6e96z6519Obt2lsR2TNaWMQ52Hg6JkBD+kYAUoQiEQUImigT5gSUSZGIB4QdBSJEiEgHhkURAiC0lPyICRAZjRUFxYuLHvuY949mZ2ZndncfOdFdX1T38qK7u6urqnu6ent7dGR9pPV1V99469zv3nnvq3ltl9fCRH7MLeS/wGHAWeDtwB9AHWLsp9BYWA2wCV4BJ4P+Al4AX2y1QtWGAe4AngV8BTrd7430mM8BzwFeAc61kbMUAZ4A/Aj7eyg0OoPwT8CxwsZnEuslC/6BU4Fvwd5ZfBS4An2km8U4GGAH+A/gcoHan14GTPwG+BxxqlKiRAe4GXgU+1EGlDpp8kIDhmXoJ6hngNPAycHwPlDpochT4EUGUWCNJBugD/hcY2judDpz0Az8ABuIXkgzwb8DhvdboAMoo8N34ybgBngYe7Yo6B1MeAT4dPRF9DhgDFrut0QGVE8ACVPeAL94cXQ6k/FX4IzTASeCjN0eXAylPAKegYoDfu1maHGD5FFQM8Os3UZGDKr8GYBOMzA0flxuJUiAC+Rs+hW0Dwv6dtCjVrSejyfRZaB3UvU0ZBh6z2cVUg7YUG1c9Co7P8dO9HD6WRtsK8dvX6lYWpRUiwrUll7nxAqmUYuhQCiMSGKd1+ZANPNhOTm0pVi8XGTmS4qMfH+MdD+XoG7RQSiFm/xoAYHvTZ+InW3z3aysszRU5fDRFm1V+wCaYdGtJtKW4uljk6OkenvqzOzl6updrSy7bmybok2qf+iAJfFC6V/HoE8Pc+3A/X/r0LNPntjl8LI3xWy7xLvXwkR9fJpgwalqcvEFE+OTnT3H6viyXpwpoa59CryPGF468rYelWYcvfGoG1zFkci2vxC5qgsm3lmRjw+U9vzjC3ffnWJxxDhx8CLzA8pzDyTMZHv2lYTZvtN78gaymxZjF+EKmx+Lun85SKLR1030jWinyN3xO35ulL2vhey0PBErT4vjteUJ2wCI3YFHMy751902JgqJj6O2zyPa3ZQBpdk24+r4KZBcB8H4SBbuK+toygMiuHkD2neyGh73bmysRfMsmnx3AS5f82X41jgpavO1BZusGllfcdZG7MICgjbAxOIIGjs6+xtDqHCm/CGqfbowTg68t1oaPs3j6QVwb+sz6rtxB2wZQAlcPDXDHuVl+9t+/wImZH4GzXbq4T0dmEUAglWHp5P388MOfZPXsPajpFdrt9m0ZQBuf6yNHuHf2Eo9/+bdh8wqM3gmZgYge+80Pqcof32Pswos8Mf0y3//dL/PCyFm0maWdWci2BuF8Zoj+jes8/o1nIL8OR98Jdk+ggAr/6X32r1QvFFgpGDsDYvi5bz7D8OoiW7mRdlC2Z4CtvlHOvvw8LLwOh07RziTIbS/Gh5ETsDLFAz98nnx2uK1iWnZBRttk8uucmH0Fevuo52r2mwOCBAcjApkBjr35GrmtVXw7BbTWGFs2gG+l6M2v01vYhL4M4kpJl9LfVgu8zSQ0giqtRKlUL+kbW/QUNtnWGfbcAMHNwSgFAkYEgyASvL0AIFQWKG53g6iqHwpF4LfDv5YIJhwj2ghHWzaACvAGsMVQFIMv4IvBF8FAaXFif/SIqNvRKjCApRSWUqSUwhKDof3atmiA8DaCLwLGUADyhTybi0sUtrdxjQl6RJjjNreAikSfmgB8Jpuhf+wImVwfvUbwwucDoNVF8ZZ7gGBAPIpiQCmWJibZshTZDzzG4LvfhTU0hKjbv+XHJURqNm9QeP0cSy+8RO/8AsP3jeGWmECqlKp5I7RggNCp+6A8HCUsvn6O4gPv4/Qf/j6jj72n+aL2gay98hPm//TzLLz4HQp3HUeUi5g0e9oDJPR22ufK+fMc+eDP8K7nnsPat/tQ6svQA+9m8JtfZeXJj7H83HnI+oCPIKWhujlp7UFMDIKPs75EcXSIsX/8uwMJPxQF3PG3f4N/6jiF6wuI8kHMjvmi0qQBgkEm6AEe2/kZ7njqSciNtarz/hPdz9gnfot88U0Qr+IlmhwFm+4BUirUuAW0yjL0gbdeIwhl8NFHsK0BTDFPQKr5EKTFKMhgnDyp3CA9h0YTU1xb8VhecknbbU0z4XtCb0Zz59vTbeW/GZIaHsTuH8TNF6A301LeFgdhMGLQVv0u9o0vXePpZ+Y5k+ttSZFQVrY8zt6b4dtv/FRb+W+GiO8jyqc0J9DSqNhiGCqgQMQgpvFgc6CG5l0sCjdvgCYXWsK+0e4TcPPD160qrdWgzSXJ+jdQKvhUSru75TSg9e3Yf7q4JNlIPvbUCI9/ZIC0XQ1xYMhiYNBiacHFa7CByfeEnkx7A/jtKB03wPAhm+FDtcXe2PC5vu5x8u7bJ7rphnStqb3wrU3eMfYaT//GPBdeLXTrtre8dM0Ah4+myKD5639Y4SMPjvP0k/NMvHGwDSGyBy6onvi+kEVz12iafF7487+/zNY1ny9+61S3VLjpIiKIkfI7LErr7hkgFN9AJqc5tt1DJrd/B9sAdmWtXGmFthR2ysKyLbStsSytum6AUBRg27djuFkr6bRCjIvnFvFdD3QKy7aweyy0pQPYKY1labSlUaggaDXS/R6wH8WyAZUh2z9E3/AQdqqnDJzSOrJIsI3d+KWn5lIk/pYB2pDtLcPsZJGJiwUuvu5w4dVtxo4/QE9PD9pSiPERYzBGgld2w8XE2NKx8JYBmpK56SITFxwunStw6VyB6Ykii/Mua9d8fE/oH7AZO96D8X28oinDjc5KSGXPTuT6Wy6oRq5f85m65DB+vsDFcw6TFx3mZ4qsLns4BUNPj6Kv3yKb0wwMWoTveHmuF4PLjvChrX1Bu5tsu5WkUDDMTBQZv+Bw6XyByUsO89MuSwsumxs+WityfZq+PsWxE6nyFhUpb4yKuPMSlKbgl3501QUVHWEFD30dLBRXcNlc7+6m3oV5l8lS6x6/6DA17nA5dCW+kMlo+voshkctDt1RQmOqoQbRS6nAaGveoeWXG2x0C2c3H8T6BjT3HcswOmhhWYrsVc3xt+3dvND1qx5Tk0Hrnhp3mJpwmJt2WV32KOR9UmlFf79FNhu4kipwkTn1puFH92WxA/zIvbpmgIfen+N/Zt9ZdU516DnMLQoz00UmLjmMXwhcycxUkeVFjxslV5LNafpymrFjNkrbhPsrawCH/lUSrtVA3QX8bhtAKbA69OC1MO8yNekwNRFAn55wWJgvcv2aj+9BbyZo3SMjFocP2xF4UvHfSYDbgU/lPDTf8sPjWz4KWl/3mZ4MQE9ccpiadJifdVld8XAKQsqGXE6Ty2lO3mlVogQTCRZKwKKtr2Pwo2VKPF1CmbHrt5QBiiVXMj3hMDlRZHLCYXa6yNKiy41Ng9aQzWpyOYujR1MoJbUtLsG1dAJ+JerrHPyuDsJJsnjZLbuR8XGHmSmHy2+6rK/5eD5kMiqISkYsDh22qyFLAnzoHPyIu6gBGgHYED5UwzeVn2Harhlgfc1ndiZo1eMXA/89P1dkdcWjkBfSaUWuX5PLavoHrJo3XavjaUmudDPw4y16L+FHykmCv4snYYU0GE89T5idLjIxHvjtyXGHuVmX5WWXzQ2DUiW/3ac5MpZCN4qGaiqdAD+xdUu1iyhBgMZQa+CHhTYFX2rzStXpKvjQSg9QQSv0ij74eU6eqLwNf2XZY2oigD1+yWF6qsjlN12uX/OqXMngoMXoaGtbkerCrxtCNgnfSPVxp+DHdGkEv/EYICAiGE8wfrArGsuQ6e+hf/QY//z1bdbWPN54bYuFN12uLLvk86WopN8qRSXp9ndo1VQyUpMG8Xti5RPgl9NVgYmki8OvuRbVMRl+1XRNAnyR4NvRG0B/MFcN4pvgglbYaY2d0aQyGjurSWc16WyKVG8vc9N53KJPJhu4kt5e3diVtCIdgB/tKWVw0Dz8BD/eFvyqvBLLy4bt5v3gISmlSWU16UyKVNYugbewey2stEIpHSyx+YJXdBk7aqH24qMc3YKfADURPrXpOgQ/cEGDJzKkcxapbADbTmuUpYLxyQ9WcLyCqdSmJHvyPY4G8BNnFaNPt/H8u4DfqIckwk+6fxPwEbBHz+RQSmFC2K6B3X8Gp3XpFPw4VKhxO/UN0dhIHYVf+mN7BXPzV8Z3C78m/q/fohONJJHy6sEvx/FSrW+C/pW8DeAHZSs7coubI3H4po7Sewk/Hj1Rx/Bx+Am9oFLujvABRIuwtTOlPZJuwRc6C19i5RIvt0E9or1K2NaIrKib8YWrbsKPppP66aBJ+El6hnkbwSeeX65q48lk93aIRm9e+m26AN/EjkV2hC9VaXeAL2HeOvUI/9Sck2ltfHmlq+0/WpnI1r263XUH+OUe3wg+keM40DrwCdNGy2+kZyP48fwQBhqvaN81/1k1ou+lmOqKJ8I3VAPaAX7ZAjvBL6dLANRV+JXuJZjvad8x3zeeuar2+rWgOLw68KtaNJHQsFPrt1TOw27hRxKYpOux/OXmD8CaIC9q4wueY77asXmcJKmCJw3hVxTswhJiPfhJ8BLhx3RP0rF8+yh8hYj5ugiilVK4ef8vjZG9ebe0Bn5CpfZoCVEqtW8YPtbAD8usuR4eVxpQ6/CD+xjkLxSglVZ4jplz8+bbusPbxaWb8EswSvWr/EgEmKBH6HbK/6HGrUgcvlSSNg9fYZDvgEwDaJHgzW5n0/uE+J3bq9POEqIkwY8PyvXgh1zi6VqBH+0ldZYQo8d14Ud7ShX8Uh0xvxNm1QgoS+EV/AVnw/uMtnZpAWkCfrSCEfhVykPjFt0IftTtEEsb1SNyssZFEUvbIFyugU+sp5RVUgjms2DmwuJ1eFHbmsKG+zl32/+BTrX5zbGaSsZCyESFpTn4phbqjvAj4JPhU5O2JfhEekKEVz34YF4W/Gejg225uYezEdtXi79gXLnWshES4Jfzd2AJseq4WfhU/06EH9WrDfjR43K94+eCD2ysGfwPx7FV+RttK4wvGzeuOI+ILzd0qslBuQPwy1nqLKTs6HYSwsdW4RM/7hz8baO8R0DW4qFmtcOXwAh+Uca3VosPiS/LO0ZGHYIfpq+q3C24hFh932gZUqVnBP6KUf5DwMWkOD9xxLVSCuPLxa2rxfu9gvkvy1bJS5Ctwi/NFta05vAatA6fGPxYL0iEn3T/VuFXnYvUO5JPxLxolH8/yPkEekCDN+WDl81kJX+9+Hhh03sGgt5RNmID+FIPPvUjonLlIHEJsR58iZYTh1+O4yUCJVn/Srk7wCd+LgF+oNmzosz7geVGT7gNY05tKZRWOJveH+fX3HvcvP8vitLnZMrv69TCLytYD34sIqpUnlr49dIhDa6xN0uIsXpVww82MhjkXw3+faLMZ5OpVov6+bPnEi9oW6FK/7vW8nuugGXr++0e/Zva1r+sNScrLV0w0Q8GxuFHla8HLj420Fw6qGP4OPzo/SFW7g7woz0nPFmGL/MiPG8wXwFeTQRa1U0q0rQBgo8bELRQAW0pS1nqfUqr92qtzgKnlVKHgRyCJeWPB9afWqg+rmMkEtI1ApoEP1pOUtp68KP3Db5b7guyhbAqItPAKyAvich/S/BJ4USWlQJr5f8BAd7FbxCpVMcAAAAASUVORK5CYII=", this.chains = e6, this.accounts = [], this.provider = typeof window < "u" ? window.dekey : void 0, this.initializing = false, this.account = async () => {
      var e10;
      const s3 = await ((e10 = this.provider) == null ? void 0 : e10.request({
        method: "aptos_account"
      }));
      return {
        address: s3.address,
        publicKey: s3.publicKey
      };
    }, this.connect = async () => {
      var n14, r7, o12;
      if (!this.initializing) {
        this.initializing = true, await import(
          // @ts-ignore
          "./index-DRmafxZ_-ZDXV45WQ.js"
        );
        const a2 = f3((n14 = this.option) == null ? void 0 : n14.env);
        if (!a2)
          throw this.initializing = false, new Error(`walletDomain not found with env: ${(r7 = this.option) == null ? void 0 : r7.env}`);
        if (!(window != null && window.initializeDekeyProvider))
          throw this.initializing = false, new Error("initializeDekeyProvider not found");
        await window.initializeDekeyProvider(a2), this.provider = window.dekey;
      }
      if (!await this.checkProvider())
        return {
          status: r5.REJECTED
        };
      const e10 = await ((o12 = this.provider) == null ? void 0 : o12.request({
        method: "aptos_requestAccounts"
      }));
      return e10 ? {
        status: r5.APPROVED,
        args: {
          address: e10.address,
          publicKey: e10.publicKey
        }
      } : (await new Promise((a2) => setTimeout(a2, 2e3)), {
        status: r5.REJECTED
      });
    }, this.checkProvider = async () => new Promise((s3) => {
      setTimeout(() => {
        s3(false);
      }, 1e4);
      const e10 = setInterval(() => {
        this.provider && (s3(true), clearInterval(e10));
      }, 100);
    }), this.network = async () => {
      const { chainId: s3, name: e10, url: n14 } = await this.provider.request({
        method: "aptos_network"
      });
      return {
        name: e10,
        chainId: s3,
        url: n14
      };
    }, this.disconnect = async () => Promise.resolve(), this.signTransaction = async (s3, e10) => {
      try {
        const n14 = s3.rawTransaction.bcsToBytes(), { concatedSig: r7, uncompressedPubkey: o12 } = await this.provider.request({
          method: "aptos_signTransaction",
          params: [Array.from(n14)]
        }), a2 = new u(o12), l3 = new m2(r7), w = new n3(
          new f(a2),
          new l(l3)
        );
        return Promise.resolve({
          status: r5.APPROVED,
          args: w
        });
      } catch (n14) {
        throw n14.message;
      }
    }, this.signAndSubmitTransaction = async (s3) => {
      const e10 = s3.rawTransaction.bcsToBytes(), n14 = await this.provider.request({
        method: "aptos_signAndSubmitTransaction",
        params: [Array.from(e10)]
      });
      return {
        status: r5.APPROVED,
        args: n14
      };
    }, this.signMessage = async (s3) => {
      var e10;
      try {
        const n14 = await ((e10 = this.provider) == null ? void 0 : e10.request({
          method: "aptos_signMessage",
          params: [s3.message]
        }));
        return {
          status: r5.APPROVED,
          args: n14
        };
      } catch (n14) {
        throw n14.message;
      }
    }, this.onAccountChange = async () => Promise.resolve(), this.onNetworkChange = async (s3) => {
      const e10 = async () => {
        const n14 = await this.network(), { name: r7, chainId: o12, url: a2 } = n14;
        s3({
          name: r7,
          chainId: o12,
          url: a2
        });
      };
      this.provider.on("chainChanged", () => {
        e10();
      });
    }, !(t14 != null && t14.env) && (t14 == null ? void 0 : t14.registerWallet) === true && u3(this);
  }
  get features() {
    return {
      "aptos:connect": {
        version: "1.0.0",
        connect: this.connect
      },
      "aptos:network": {
        version: "1.0.0",
        network: this.network
      },
      "aptos:disconnect": {
        version: "1.0.0",
        disconnect: this.disconnect
      },
      "aptos:signTransaction": {
        version: "1.0.0",
        signTransaction: this.signTransaction
      },
      "aptos:signAndSubmitTransaction": {
        version: "1.0.0",
        signAndSubmitTransaction: this.signAndSubmitTransaction
      },
      "aptos:signMessage": {
        version: "1.0.0",
        signMessage: this.signMessage
      },
      "aptos:onAccountChange": {
        version: "1.0.0",
        onAccountChange: this.onAccountChange
      },
      "aptos:onNetworkChange": {
        version: "1.0.0",
        onNetworkChange: this.onNetworkChange
      },
      "aptos:account": {
        version: "1.0.0",
        account: this.account
      }
    };
  }
};
var f3 = (i4) => i4 === "LOCAL" ? "http://localhost:5173" : i4 === "DEV" ? "https://dev.twallet.ai" : i4 === "QA" ? "https://qa.twallet.ai" : "https://www.twallet.ai";
var u3 = (i4) => {
  typeof window > "u" || registerWallet(i4);
};
var W = class extends h2 {
  constructor(t14 = {}) {
    super({ ...t14, env: "DEV" }), this.url = "https://dev.twallet.ai", this.name = "Dev T wallet", (t14 == null ? void 0 : t14.registerWallet) === true && u3(this);
  }
};

// node_modules/graphql-request/build/legacy/classes/ClientError.js
var ClientError = class _ClientError extends Error {
  constructor(response, request3) {
    const message = `${_ClientError.extractMessage(response)}: ${JSON.stringify({
      response,
      request: request3
    })}`;
    super(message);
    __publicField(this, "response");
    __publicField(this, "request");
    Object.setPrototypeOf(this, _ClientError.prototype);
    this.response = response;
    this.request = request3;
    if (typeof Error.captureStackTrace === `function`) {
      Error.captureStackTrace(this, _ClientError);
    }
  }
  static extractMessage(response) {
    var _a, _b;
    return ((_b = (_a = response.errors) == null ? void 0 : _a[0]) == null ? void 0 : _b.message) ?? `GraphQL Error (Code: ${String(response.status)})`;
  }
};

// node_modules/graphql-request/build/lib/prelude.js
var uppercase = (str) => str.toUpperCase();
var callOrIdentity = (value) => {
  return typeof value === `function` ? value() : value;
};
var zip = (a2, b2) => a2.map((k2, i4) => [k2, b2[i4]]);
var HeadersInitToPlainObject = (headers) => {
  let oHeaders = {};
  if (headers instanceof Headers) {
    oHeaders = HeadersInstanceToPlainObject(headers);
  } else if (Array.isArray(headers)) {
    headers.forEach(([name, value]) => {
      if (name && value !== void 0) {
        oHeaders[name] = value;
      }
    });
  } else if (headers) {
    oHeaders = headers;
  }
  return oHeaders;
};
var HeadersInstanceToPlainObject = (headers) => {
  const o12 = {};
  headers.forEach((v, k2) => {
    o12[k2] = v;
  });
  return o12;
};
var tryCatch = (fn3) => {
  try {
    const result = fn3();
    if (isPromiseLikeValue(result)) {
      return result.catch((error) => {
        return errorFromMaybeError(error);
      });
    }
    return result;
  } catch (error) {
    return errorFromMaybeError(error);
  }
};
var errorFromMaybeError = (maybeError) => {
  if (maybeError instanceof Error)
    return maybeError;
  return new Error(String(maybeError));
};
var isPromiseLikeValue = (value) => {
  return typeof value === `object` && value !== null && `then` in value && typeof value.then === `function` && `catch` in value && typeof value.catch === `function` && `finally` in value && typeof value.finally === `function`;
};
var casesExhausted = (value) => {
  throw new Error(`Unhandled case: ${String(value)}`);
};
var isPlainObject = (value) => {
  return typeof value === `object` && value !== null && !Array.isArray(value);
};

// node_modules/graphql-request/build/legacy/functions/batchRequests.js
var parseBatchRequestArgs = (documentsOrOptions, requestHeaders) => {
  return documentsOrOptions.documents ? documentsOrOptions : {
    documents: documentsOrOptions,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql-request/build/legacy/functions/rawRequest.js
var parseRawRequestArgs = (queryOrOptions, variables, requestHeaders) => {
  return queryOrOptions.query ? queryOrOptions : {
    query: queryOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};

// node_modules/graphql/version.mjs
var versionInfo = Object.freeze({
  major: 16,
  minor: 9,
  patch: 0,
  preReleaseTag: null
});

// node_modules/graphql/jsutils/devAssert.mjs
function devAssert(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(message);
  }
}

// node_modules/graphql/jsutils/isObjectLike.mjs
function isObjectLike(value) {
  return typeof value == "object" && value !== null;
}

// node_modules/graphql/jsutils/invariant.mjs
function invariant(condition, message) {
  const booleanCondition = Boolean(condition);
  if (!booleanCondition) {
    throw new Error(
      message != null ? message : "Unexpected invariant triggered."
    );
  }
}

// node_modules/graphql/language/location.mjs
var LineRegExp = /\r\n|[\n\r]/g;
function getLocation(source, position) {
  let lastLineStart = 0;
  let line = 1;
  for (const match of source.body.matchAll(LineRegExp)) {
    typeof match.index === "number" || invariant(false);
    if (match.index >= position) {
      break;
    }
    lastLineStart = match.index + match[0].length;
    line += 1;
  }
  return {
    line,
    column: position + 1 - lastLineStart
  };
}

// node_modules/graphql/language/printLocation.mjs
function printLocation(location) {
  return printSourceLocation(
    location.source,
    getLocation(location.source, location.start)
  );
}
function printSourceLocation(source, sourceLocation) {
  const firstLineColumnOffset = source.locationOffset.column - 1;
  const body = "".padStart(firstLineColumnOffset) + source.body;
  const lineIndex = sourceLocation.line - 1;
  const lineOffset = source.locationOffset.line - 1;
  const lineNum = sourceLocation.line + lineOffset;
  const columnOffset = sourceLocation.line === 1 ? firstLineColumnOffset : 0;
  const columnNum = sourceLocation.column + columnOffset;
  const locationStr = `${source.name}:${lineNum}:${columnNum}
`;
  const lines = body.split(/\r\n|[\n\r]/g);
  const locationLine = lines[lineIndex];
  if (locationLine.length > 120) {
    const subLineIndex = Math.floor(columnNum / 80);
    const subLineColumnNum = columnNum % 80;
    const subLines = [];
    for (let i4 = 0; i4 < locationLine.length; i4 += 80) {
      subLines.push(locationLine.slice(i4, i4 + 80));
    }
    return locationStr + printPrefixedLines([
      [`${lineNum} |`, subLines[0]],
      ...subLines.slice(1, subLineIndex + 1).map((subLine) => ["|", subLine]),
      ["|", "^".padStart(subLineColumnNum)],
      ["|", subLines[subLineIndex + 1]]
    ]);
  }
  return locationStr + printPrefixedLines([
    // Lines specified like this: ["prefix", "string"],
    [`${lineNum - 1} |`, lines[lineIndex - 1]],
    [`${lineNum} |`, locationLine],
    ["|", "^".padStart(columnNum)],
    [`${lineNum + 1} |`, lines[lineIndex + 1]]
  ]);
}
function printPrefixedLines(lines) {
  const existingLines = lines.filter(([_, line]) => line !== void 0);
  const padLen = Math.max(...existingLines.map(([prefix]) => prefix.length));
  return existingLines.map(([prefix, line]) => prefix.padStart(padLen) + (line ? " " + line : "")).join("\n");
}

// node_modules/graphql/error/GraphQLError.mjs
function toNormalizedOptions(args) {
  const firstArg = args[0];
  if (firstArg == null || "kind" in firstArg || "length" in firstArg) {
    return {
      nodes: firstArg,
      source: args[1],
      positions: args[2],
      path: args[3],
      originalError: args[4],
      extensions: args[5]
    };
  }
  return firstArg;
}
var GraphQLError = class _GraphQLError extends Error {
  /**
   * An array of `{ line, column }` locations within the source GraphQL document
   * which correspond to this error.
   *
   * Errors during validation often contain multiple locations, for example to
   * point out two things with the same name. Errors during execution include a
   * single location, the field which produced the error.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array describing the JSON-path into the execution response which
   * corresponds to this error. Only included for errors during execution.
   *
   * Enumerable, and appears in the result of JSON.stringify().
   */
  /**
   * An array of GraphQL AST Nodes corresponding to this error.
   */
  /**
   * The source GraphQL document for the first location of this error.
   *
   * Note that if this Error represents more than one node, the source may not
   * represent nodes after the first node.
   */
  /**
   * An array of character offsets within the source GraphQL document
   * which correspond to this error.
   */
  /**
   * The original error thrown from a field resolver during execution.
   */
  /**
   * Extension fields to add to the formatted error.
   */
  /**
   * @deprecated Please use the `GraphQLErrorOptions` constructor overload instead.
   */
  constructor(message, ...rawArgs) {
    var _this$nodes, _nodeLocations$, _ref;
    const { nodes, source, positions, path, originalError, extensions } = toNormalizedOptions(rawArgs);
    super(message);
    this.name = "GraphQLError";
    this.path = path !== null && path !== void 0 ? path : void 0;
    this.originalError = originalError !== null && originalError !== void 0 ? originalError : void 0;
    this.nodes = undefinedIfEmpty(
      Array.isArray(nodes) ? nodes : nodes ? [nodes] : void 0
    );
    const nodeLocations = undefinedIfEmpty(
      (_this$nodes = this.nodes) === null || _this$nodes === void 0 ? void 0 : _this$nodes.map((node) => node.loc).filter((loc) => loc != null)
    );
    this.source = source !== null && source !== void 0 ? source : nodeLocations === null || nodeLocations === void 0 ? void 0 : (_nodeLocations$ = nodeLocations[0]) === null || _nodeLocations$ === void 0 ? void 0 : _nodeLocations$.source;
    this.positions = positions !== null && positions !== void 0 ? positions : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => loc.start);
    this.locations = positions && source ? positions.map((pos) => getLocation(source, pos)) : nodeLocations === null || nodeLocations === void 0 ? void 0 : nodeLocations.map((loc) => getLocation(loc.source, loc.start));
    const originalExtensions = isObjectLike(
      originalError === null || originalError === void 0 ? void 0 : originalError.extensions
    ) ? originalError === null || originalError === void 0 ? void 0 : originalError.extensions : void 0;
    this.extensions = (_ref = extensions !== null && extensions !== void 0 ? extensions : originalExtensions) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ Object.create(null);
    Object.defineProperties(this, {
      message: {
        writable: true,
        enumerable: true
      },
      name: {
        enumerable: false
      },
      nodes: {
        enumerable: false
      },
      source: {
        enumerable: false
      },
      positions: {
        enumerable: false
      },
      originalError: {
        enumerable: false
      }
    });
    if (originalError !== null && originalError !== void 0 && originalError.stack) {
      Object.defineProperty(this, "stack", {
        value: originalError.stack,
        writable: true,
        configurable: true
      });
    } else if (Error.captureStackTrace) {
      Error.captureStackTrace(this, _GraphQLError);
    } else {
      Object.defineProperty(this, "stack", {
        value: Error().stack,
        writable: true,
        configurable: true
      });
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLError";
  }
  toString() {
    let output2 = this.message;
    if (this.nodes) {
      for (const node of this.nodes) {
        if (node.loc) {
          output2 += "\n\n" + printLocation(node.loc);
        }
      }
    } else if (this.source && this.locations) {
      for (const location of this.locations) {
        output2 += "\n\n" + printSourceLocation(this.source, location);
      }
    }
    return output2;
  }
  toJSON() {
    const formattedError = {
      message: this.message
    };
    if (this.locations != null) {
      formattedError.locations = this.locations;
    }
    if (this.path != null) {
      formattedError.path = this.path;
    }
    if (this.extensions != null && Object.keys(this.extensions).length > 0) {
      formattedError.extensions = this.extensions;
    }
    return formattedError;
  }
};
function undefinedIfEmpty(array) {
  return array === void 0 || array.length === 0 ? void 0 : array;
}

// node_modules/graphql/error/syntaxError.mjs
function syntaxError(source, position, description) {
  return new GraphQLError(`Syntax Error: ${description}`, {
    source,
    positions: [position]
  });
}

// node_modules/graphql/language/ast.mjs
var Location = class {
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The Token at which this Node begins.
   */
  /**
   * The Token at which this Node ends.
   */
  /**
   * The Source document the AST represents.
   */
  constructor(startToken, endToken, source) {
    this.start = startToken.start;
    this.end = endToken.end;
    this.startToken = startToken;
    this.endToken = endToken;
    this.source = source;
  }
  get [Symbol.toStringTag]() {
    return "Location";
  }
  toJSON() {
    return {
      start: this.start,
      end: this.end
    };
  }
};
var Token2 = class {
  /**
   * The kind of Token.
   */
  /**
   * The character offset at which this Node begins.
   */
  /**
   * The character offset at which this Node ends.
   */
  /**
   * The 1-indexed line number on which this Token appears.
   */
  /**
   * The 1-indexed column number at which this Token begins.
   */
  /**
   * For non-punctuation tokens, represents the interpreted value of the token.
   *
   * Note: is undefined for punctuation tokens, but typed as string for
   * convenience in the parser.
   */
  /**
   * Tokens exist as nodes in a double-linked-list amongst all tokens
   * including ignored tokens. <SOF> is always the first node and <EOF>
   * the last.
   */
  constructor(kind, start, end, line, column, value) {
    this.kind = kind;
    this.start = start;
    this.end = end;
    this.line = line;
    this.column = column;
    this.value = value;
    this.prev = null;
    this.next = null;
  }
  get [Symbol.toStringTag]() {
    return "Token";
  }
  toJSON() {
    return {
      kind: this.kind,
      value: this.value,
      line: this.line,
      column: this.column
    };
  }
};
var QueryDocumentKeys = {
  Name: [],
  Document: ["definitions"],
  OperationDefinition: [
    "name",
    "variableDefinitions",
    "directives",
    "selectionSet"
  ],
  VariableDefinition: ["variable", "type", "defaultValue", "directives"],
  Variable: ["name"],
  SelectionSet: ["selections"],
  Field: ["alias", "name", "arguments", "directives", "selectionSet"],
  Argument: ["name", "value"],
  FragmentSpread: ["name", "directives"],
  InlineFragment: ["typeCondition", "directives", "selectionSet"],
  FragmentDefinition: [
    "name",
    // Note: fragment variable definitions are deprecated and will removed in v17.0.0
    "variableDefinitions",
    "typeCondition",
    "directives",
    "selectionSet"
  ],
  IntValue: [],
  FloatValue: [],
  StringValue: [],
  BooleanValue: [],
  NullValue: [],
  EnumValue: [],
  ListValue: ["values"],
  ObjectValue: ["fields"],
  ObjectField: ["name", "value"],
  Directive: ["name", "arguments"],
  NamedType: ["name"],
  ListType: ["type"],
  NonNullType: ["type"],
  SchemaDefinition: ["description", "directives", "operationTypes"],
  OperationTypeDefinition: ["type"],
  ScalarTypeDefinition: ["description", "name", "directives"],
  ObjectTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  FieldDefinition: ["description", "name", "arguments", "type", "directives"],
  InputValueDefinition: [
    "description",
    "name",
    "type",
    "defaultValue",
    "directives"
  ],
  InterfaceTypeDefinition: [
    "description",
    "name",
    "interfaces",
    "directives",
    "fields"
  ],
  UnionTypeDefinition: ["description", "name", "directives", "types"],
  EnumTypeDefinition: ["description", "name", "directives", "values"],
  EnumValueDefinition: ["description", "name", "directives"],
  InputObjectTypeDefinition: ["description", "name", "directives", "fields"],
  DirectiveDefinition: ["description", "name", "arguments", "locations"],
  SchemaExtension: ["directives", "operationTypes"],
  ScalarTypeExtension: ["name", "directives"],
  ObjectTypeExtension: ["name", "interfaces", "directives", "fields"],
  InterfaceTypeExtension: ["name", "interfaces", "directives", "fields"],
  UnionTypeExtension: ["name", "directives", "types"],
  EnumTypeExtension: ["name", "directives", "values"],
  InputObjectTypeExtension: ["name", "directives", "fields"]
};
var kindValues = new Set(Object.keys(QueryDocumentKeys));
function isNode(maybeNode) {
  const maybeKind = maybeNode === null || maybeNode === void 0 ? void 0 : maybeNode.kind;
  return typeof maybeKind === "string" && kindValues.has(maybeKind);
}
var OperationTypeNode;
(function(OperationTypeNode2) {
  OperationTypeNode2["QUERY"] = "query";
  OperationTypeNode2["MUTATION"] = "mutation";
  OperationTypeNode2["SUBSCRIPTION"] = "subscription";
})(OperationTypeNode || (OperationTypeNode = {}));

// node_modules/graphql/language/directiveLocation.mjs
var DirectiveLocation;
(function(DirectiveLocation2) {
  DirectiveLocation2["QUERY"] = "QUERY";
  DirectiveLocation2["MUTATION"] = "MUTATION";
  DirectiveLocation2["SUBSCRIPTION"] = "SUBSCRIPTION";
  DirectiveLocation2["FIELD"] = "FIELD";
  DirectiveLocation2["FRAGMENT_DEFINITION"] = "FRAGMENT_DEFINITION";
  DirectiveLocation2["FRAGMENT_SPREAD"] = "FRAGMENT_SPREAD";
  DirectiveLocation2["INLINE_FRAGMENT"] = "INLINE_FRAGMENT";
  DirectiveLocation2["VARIABLE_DEFINITION"] = "VARIABLE_DEFINITION";
  DirectiveLocation2["SCHEMA"] = "SCHEMA";
  DirectiveLocation2["SCALAR"] = "SCALAR";
  DirectiveLocation2["OBJECT"] = "OBJECT";
  DirectiveLocation2["FIELD_DEFINITION"] = "FIELD_DEFINITION";
  DirectiveLocation2["ARGUMENT_DEFINITION"] = "ARGUMENT_DEFINITION";
  DirectiveLocation2["INTERFACE"] = "INTERFACE";
  DirectiveLocation2["UNION"] = "UNION";
  DirectiveLocation2["ENUM"] = "ENUM";
  DirectiveLocation2["ENUM_VALUE"] = "ENUM_VALUE";
  DirectiveLocation2["INPUT_OBJECT"] = "INPUT_OBJECT";
  DirectiveLocation2["INPUT_FIELD_DEFINITION"] = "INPUT_FIELD_DEFINITION";
})(DirectiveLocation || (DirectiveLocation = {}));

// node_modules/graphql/language/kinds.mjs
var Kind;
(function(Kind2) {
  Kind2["NAME"] = "Name";
  Kind2["DOCUMENT"] = "Document";
  Kind2["OPERATION_DEFINITION"] = "OperationDefinition";
  Kind2["VARIABLE_DEFINITION"] = "VariableDefinition";
  Kind2["SELECTION_SET"] = "SelectionSet";
  Kind2["FIELD"] = "Field";
  Kind2["ARGUMENT"] = "Argument";
  Kind2["FRAGMENT_SPREAD"] = "FragmentSpread";
  Kind2["INLINE_FRAGMENT"] = "InlineFragment";
  Kind2["FRAGMENT_DEFINITION"] = "FragmentDefinition";
  Kind2["VARIABLE"] = "Variable";
  Kind2["INT"] = "IntValue";
  Kind2["FLOAT"] = "FloatValue";
  Kind2["STRING"] = "StringValue";
  Kind2["BOOLEAN"] = "BooleanValue";
  Kind2["NULL"] = "NullValue";
  Kind2["ENUM"] = "EnumValue";
  Kind2["LIST"] = "ListValue";
  Kind2["OBJECT"] = "ObjectValue";
  Kind2["OBJECT_FIELD"] = "ObjectField";
  Kind2["DIRECTIVE"] = "Directive";
  Kind2["NAMED_TYPE"] = "NamedType";
  Kind2["LIST_TYPE"] = "ListType";
  Kind2["NON_NULL_TYPE"] = "NonNullType";
  Kind2["SCHEMA_DEFINITION"] = "SchemaDefinition";
  Kind2["OPERATION_TYPE_DEFINITION"] = "OperationTypeDefinition";
  Kind2["SCALAR_TYPE_DEFINITION"] = "ScalarTypeDefinition";
  Kind2["OBJECT_TYPE_DEFINITION"] = "ObjectTypeDefinition";
  Kind2["FIELD_DEFINITION"] = "FieldDefinition";
  Kind2["INPUT_VALUE_DEFINITION"] = "InputValueDefinition";
  Kind2["INTERFACE_TYPE_DEFINITION"] = "InterfaceTypeDefinition";
  Kind2["UNION_TYPE_DEFINITION"] = "UnionTypeDefinition";
  Kind2["ENUM_TYPE_DEFINITION"] = "EnumTypeDefinition";
  Kind2["ENUM_VALUE_DEFINITION"] = "EnumValueDefinition";
  Kind2["INPUT_OBJECT_TYPE_DEFINITION"] = "InputObjectTypeDefinition";
  Kind2["DIRECTIVE_DEFINITION"] = "DirectiveDefinition";
  Kind2["SCHEMA_EXTENSION"] = "SchemaExtension";
  Kind2["SCALAR_TYPE_EXTENSION"] = "ScalarTypeExtension";
  Kind2["OBJECT_TYPE_EXTENSION"] = "ObjectTypeExtension";
  Kind2["INTERFACE_TYPE_EXTENSION"] = "InterfaceTypeExtension";
  Kind2["UNION_TYPE_EXTENSION"] = "UnionTypeExtension";
  Kind2["ENUM_TYPE_EXTENSION"] = "EnumTypeExtension";
  Kind2["INPUT_OBJECT_TYPE_EXTENSION"] = "InputObjectTypeExtension";
})(Kind || (Kind = {}));

// node_modules/graphql/language/characterClasses.mjs
function isWhiteSpace2(code) {
  return code === 9 || code === 32;
}
function isDigit(code) {
  return code >= 48 && code <= 57;
}
function isLetter(code) {
  return code >= 97 && code <= 122 || // A-Z
  code >= 65 && code <= 90;
}
function isNameStart(code) {
  return isLetter(code) || code === 95;
}
function isNameContinue(code) {
  return isLetter(code) || isDigit(code) || code === 95;
}

// node_modules/graphql/language/blockString.mjs
function dedentBlockStringLines(lines) {
  var _firstNonEmptyLine2;
  let commonIndent = Number.MAX_SAFE_INTEGER;
  let firstNonEmptyLine = null;
  let lastNonEmptyLine = -1;
  for (let i4 = 0; i4 < lines.length; ++i4) {
    var _firstNonEmptyLine;
    const line = lines[i4];
    const indent2 = leadingWhitespace(line);
    if (indent2 === line.length) {
      continue;
    }
    firstNonEmptyLine = (_firstNonEmptyLine = firstNonEmptyLine) !== null && _firstNonEmptyLine !== void 0 ? _firstNonEmptyLine : i4;
    lastNonEmptyLine = i4;
    if (i4 !== 0 && indent2 < commonIndent) {
      commonIndent = indent2;
    }
  }
  return lines.map((line, i4) => i4 === 0 ? line : line.slice(commonIndent)).slice(
    (_firstNonEmptyLine2 = firstNonEmptyLine) !== null && _firstNonEmptyLine2 !== void 0 ? _firstNonEmptyLine2 : 0,
    lastNonEmptyLine + 1
  );
}
function leadingWhitespace(str) {
  let i4 = 0;
  while (i4 < str.length && isWhiteSpace2(str.charCodeAt(i4))) {
    ++i4;
  }
  return i4;
}
function printBlockString(value, options) {
  const escapedValue = value.replace(/"""/g, '\\"""');
  const lines = escapedValue.split(/\r\n|[\n\r]/g);
  const isSingleLine = lines.length === 1;
  const forceLeadingNewLine = lines.length > 1 && lines.slice(1).every((line) => line.length === 0 || isWhiteSpace2(line.charCodeAt(0)));
  const hasTrailingTripleQuotes = escapedValue.endsWith('\\"""');
  const hasTrailingQuote = value.endsWith('"') && !hasTrailingTripleQuotes;
  const hasTrailingSlash = value.endsWith("\\");
  const forceTrailingNewline = hasTrailingQuote || hasTrailingSlash;
  const printAsMultipleLines = !(options !== null && options !== void 0 && options.minimize) && // add leading and trailing new lines only if it improves readability
  (!isSingleLine || value.length > 70 || forceTrailingNewline || forceLeadingNewLine || hasTrailingTripleQuotes);
  let result = "";
  const skipLeadingNewLine = isSingleLine && isWhiteSpace2(value.charCodeAt(0));
  if (printAsMultipleLines && !skipLeadingNewLine || forceLeadingNewLine) {
    result += "\n";
  }
  result += escapedValue;
  if (printAsMultipleLines || forceTrailingNewline) {
    result += "\n";
  }
  return '"""' + result + '"""';
}

// node_modules/graphql/language/tokenKind.mjs
var TokenKind;
(function(TokenKind2) {
  TokenKind2["SOF"] = "<SOF>";
  TokenKind2["EOF"] = "<EOF>";
  TokenKind2["BANG"] = "!";
  TokenKind2["DOLLAR"] = "$";
  TokenKind2["AMP"] = "&";
  TokenKind2["PAREN_L"] = "(";
  TokenKind2["PAREN_R"] = ")";
  TokenKind2["SPREAD"] = "...";
  TokenKind2["COLON"] = ":";
  TokenKind2["EQUALS"] = "=";
  TokenKind2["AT"] = "@";
  TokenKind2["BRACKET_L"] = "[";
  TokenKind2["BRACKET_R"] = "]";
  TokenKind2["BRACE_L"] = "{";
  TokenKind2["PIPE"] = "|";
  TokenKind2["BRACE_R"] = "}";
  TokenKind2["NAME"] = "Name";
  TokenKind2["INT"] = "Int";
  TokenKind2["FLOAT"] = "Float";
  TokenKind2["STRING"] = "String";
  TokenKind2["BLOCK_STRING"] = "BlockString";
  TokenKind2["COMMENT"] = "Comment";
})(TokenKind || (TokenKind = {}));

// node_modules/graphql/language/lexer.mjs
var Lexer = class {
  /**
   * The previously focused non-ignored token.
   */
  /**
   * The currently focused non-ignored token.
   */
  /**
   * The (1-indexed) line containing the current token.
   */
  /**
   * The character offset at which the current line begins.
   */
  constructor(source) {
    const startOfFileToken = new Token2(TokenKind.SOF, 0, 0, 0, 0);
    this.source = source;
    this.lastToken = startOfFileToken;
    this.token = startOfFileToken;
    this.line = 1;
    this.lineStart = 0;
  }
  get [Symbol.toStringTag]() {
    return "Lexer";
  }
  /**
   * Advances the token stream to the next non-ignored token.
   */
  advance() {
    this.lastToken = this.token;
    const token = this.token = this.lookahead();
    return token;
  }
  /**
   * Looks ahead and returns the next non-ignored token, but does not change
   * the state of Lexer.
   */
  lookahead() {
    let token = this.token;
    if (token.kind !== TokenKind.EOF) {
      do {
        if (token.next) {
          token = token.next;
        } else {
          const nextToken2 = readNextToken(this, token.end);
          token.next = nextToken2;
          nextToken2.prev = token;
          token = nextToken2;
        }
      } while (token.kind === TokenKind.COMMENT);
    }
    return token;
  }
};
function isPunctuatorTokenKind(kind) {
  return kind === TokenKind.BANG || kind === TokenKind.DOLLAR || kind === TokenKind.AMP || kind === TokenKind.PAREN_L || kind === TokenKind.PAREN_R || kind === TokenKind.SPREAD || kind === TokenKind.COLON || kind === TokenKind.EQUALS || kind === TokenKind.AT || kind === TokenKind.BRACKET_L || kind === TokenKind.BRACKET_R || kind === TokenKind.BRACE_L || kind === TokenKind.PIPE || kind === TokenKind.BRACE_R;
}
function isUnicodeScalarValue(code) {
  return code >= 0 && code <= 55295 || code >= 57344 && code <= 1114111;
}
function isSupplementaryCodePoint(body, location) {
  return isLeadingSurrogate(body.charCodeAt(location)) && isTrailingSurrogate(body.charCodeAt(location + 1));
}
function isLeadingSurrogate(code) {
  return code >= 55296 && code <= 56319;
}
function isTrailingSurrogate(code) {
  return code >= 56320 && code <= 57343;
}
function printCodePointAt(lexer, location) {
  const code = lexer.source.body.codePointAt(location);
  if (code === void 0) {
    return TokenKind.EOF;
  } else if (code >= 32 && code <= 126) {
    const char = String.fromCodePoint(code);
    return char === '"' ? `'"'` : `"${char}"`;
  }
  return "U+" + code.toString(16).toUpperCase().padStart(4, "0");
}
function createToken(lexer, kind, start, end, value) {
  const line = lexer.line;
  const col = 1 + start - lexer.lineStart;
  return new Token2(kind, start, end, line, col, value);
}
function readNextToken(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    switch (code) {
      case 65279:
      case 9:
      case 32:
      case 44:
        ++position;
        continue;
      case 10:
        ++position;
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 13:
        if (body.charCodeAt(position + 1) === 10) {
          position += 2;
        } else {
          ++position;
        }
        ++lexer.line;
        lexer.lineStart = position;
        continue;
      case 35:
        return readComment(lexer, position);
      case 33:
        return createToken(lexer, TokenKind.BANG, position, position + 1);
      case 36:
        return createToken(lexer, TokenKind.DOLLAR, position, position + 1);
      case 38:
        return createToken(lexer, TokenKind.AMP, position, position + 1);
      case 40:
        return createToken(lexer, TokenKind.PAREN_L, position, position + 1);
      case 41:
        return createToken(lexer, TokenKind.PAREN_R, position, position + 1);
      case 46:
        if (body.charCodeAt(position + 1) === 46 && body.charCodeAt(position + 2) === 46) {
          return createToken(lexer, TokenKind.SPREAD, position, position + 3);
        }
        break;
      case 58:
        return createToken(lexer, TokenKind.COLON, position, position + 1);
      case 61:
        return createToken(lexer, TokenKind.EQUALS, position, position + 1);
      case 64:
        return createToken(lexer, TokenKind.AT, position, position + 1);
      case 91:
        return createToken(lexer, TokenKind.BRACKET_L, position, position + 1);
      case 93:
        return createToken(lexer, TokenKind.BRACKET_R, position, position + 1);
      case 123:
        return createToken(lexer, TokenKind.BRACE_L, position, position + 1);
      case 124:
        return createToken(lexer, TokenKind.PIPE, position, position + 1);
      case 125:
        return createToken(lexer, TokenKind.BRACE_R, position, position + 1);
      case 34:
        if (body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
          return readBlockString(lexer, position);
        }
        return readString(lexer, position);
    }
    if (isDigit(code) || code === 45) {
      return readNumber(lexer, position, code);
    }
    if (isNameStart(code)) {
      return readName(lexer, position);
    }
    throw syntaxError(
      lexer.source,
      position,
      code === 39 ? `Unexpected single quote character ('), did you mean to use a double quote (")?` : isUnicodeScalarValue(code) || isSupplementaryCodePoint(body, position) ? `Unexpected character: ${printCodePointAt(lexer, position)}.` : `Invalid character: ${printCodePointAt(lexer, position)}.`
    );
  }
  return createToken(lexer, TokenKind.EOF, bodyLength, bodyLength);
}
function readComment(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.COMMENT,
    start,
    position,
    body.slice(start + 1, position)
  );
}
function readNumber(lexer, start, firstCode) {
  const body = lexer.source.body;
  let position = start;
  let code = firstCode;
  let isFloat = false;
  if (code === 45) {
    code = body.charCodeAt(++position);
  }
  if (code === 48) {
    code = body.charCodeAt(++position);
    if (isDigit(code)) {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid number, unexpected digit after 0: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  } else {
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46) {
    isFloat = true;
    code = body.charCodeAt(++position);
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 69 || code === 101) {
    isFloat = true;
    code = body.charCodeAt(++position);
    if (code === 43 || code === 45) {
      code = body.charCodeAt(++position);
    }
    position = readDigits(lexer, position, code);
    code = body.charCodeAt(position);
  }
  if (code === 46 || isNameStart(code)) {
    throw syntaxError(
      lexer.source,
      position,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        position
      )}.`
    );
  }
  return createToken(
    lexer,
    isFloat ? TokenKind.FLOAT : TokenKind.INT,
    start,
    position,
    body.slice(start, position)
  );
}
function readDigits(lexer, start, firstCode) {
  if (!isDigit(firstCode)) {
    throw syntaxError(
      lexer.source,
      start,
      `Invalid number, expected digit but got: ${printCodePointAt(
        lexer,
        start
      )}.`
    );
  }
  const body = lexer.source.body;
  let position = start + 1;
  while (isDigit(body.charCodeAt(position))) {
    ++position;
  }
  return position;
}
function readString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  let chunkStart = position;
  let value = "";
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34) {
      value += body.slice(chunkStart, position);
      return createToken(lexer, TokenKind.STRING, start, position + 1, value);
    }
    if (code === 92) {
      value += body.slice(chunkStart, position);
      const escape2 = body.charCodeAt(position + 1) === 117 ? body.charCodeAt(position + 2) === 123 ? readEscapedUnicodeVariableWidth(lexer, position) : readEscapedUnicodeFixedWidth(lexer, position) : readEscapedCharacter(lexer, position);
      value += escape2.value;
      position += escape2.size;
      chunkStart = position;
      continue;
    }
    if (code === 10 || code === 13) {
      break;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readEscapedUnicodeVariableWidth(lexer, position) {
  const body = lexer.source.body;
  let point = 0;
  let size = 3;
  while (size < 12) {
    const code = body.charCodeAt(position + size++);
    if (code === 125) {
      if (size < 5 || !isUnicodeScalarValue(point)) {
        break;
      }
      return {
        value: String.fromCodePoint(point),
        size
      };
    }
    point = point << 4 | readHexDigit(code);
    if (point < 0) {
      break;
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(
      position,
      position + size
    )}".`
  );
}
function readEscapedUnicodeFixedWidth(lexer, position) {
  const body = lexer.source.body;
  const code = read16BitHexCode(body, position + 2);
  if (isUnicodeScalarValue(code)) {
    return {
      value: String.fromCodePoint(code),
      size: 6
    };
  }
  if (isLeadingSurrogate(code)) {
    if (body.charCodeAt(position + 6) === 92 && body.charCodeAt(position + 7) === 117) {
      const trailingCode = read16BitHexCode(body, position + 8);
      if (isTrailingSurrogate(trailingCode)) {
        return {
          value: String.fromCodePoint(code, trailingCode),
          size: 12
        };
      }
    }
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid Unicode escape sequence: "${body.slice(position, position + 6)}".`
  );
}
function read16BitHexCode(body, position) {
  return readHexDigit(body.charCodeAt(position)) << 12 | readHexDigit(body.charCodeAt(position + 1)) << 8 | readHexDigit(body.charCodeAt(position + 2)) << 4 | readHexDigit(body.charCodeAt(position + 3));
}
function readHexDigit(code) {
  return code >= 48 && code <= 57 ? code - 48 : code >= 65 && code <= 70 ? code - 55 : code >= 97 && code <= 102 ? code - 87 : -1;
}
function readEscapedCharacter(lexer, position) {
  const body = lexer.source.body;
  const code = body.charCodeAt(position + 1);
  switch (code) {
    case 34:
      return {
        value: '"',
        size: 2
      };
    case 92:
      return {
        value: "\\",
        size: 2
      };
    case 47:
      return {
        value: "/",
        size: 2
      };
    case 98:
      return {
        value: "\b",
        size: 2
      };
    case 102:
      return {
        value: "\f",
        size: 2
      };
    case 110:
      return {
        value: "\n",
        size: 2
      };
    case 114:
      return {
        value: "\r",
        size: 2
      };
    case 116:
      return {
        value: "	",
        size: 2
      };
  }
  throw syntaxError(
    lexer.source,
    position,
    `Invalid character escape sequence: "${body.slice(
      position,
      position + 2
    )}".`
  );
}
function readBlockString(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let lineStart = lexer.lineStart;
  let position = start + 3;
  let chunkStart = position;
  let currentLine = "";
  const blockLines = [];
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (code === 34 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      const token = createToken(
        lexer,
        TokenKind.BLOCK_STRING,
        start,
        position + 3,
        // Return a string of the lines joined with U+000A.
        dedentBlockStringLines(blockLines).join("\n")
      );
      lexer.line += blockLines.length - 1;
      lexer.lineStart = lineStart;
      return token;
    }
    if (code === 92 && body.charCodeAt(position + 1) === 34 && body.charCodeAt(position + 2) === 34 && body.charCodeAt(position + 3) === 34) {
      currentLine += body.slice(chunkStart, position);
      chunkStart = position + 1;
      position += 4;
      continue;
    }
    if (code === 10 || code === 13) {
      currentLine += body.slice(chunkStart, position);
      blockLines.push(currentLine);
      if (code === 13 && body.charCodeAt(position + 1) === 10) {
        position += 2;
      } else {
        ++position;
      }
      currentLine = "";
      chunkStart = position;
      lineStart = position;
      continue;
    }
    if (isUnicodeScalarValue(code)) {
      ++position;
    } else if (isSupplementaryCodePoint(body, position)) {
      position += 2;
    } else {
      throw syntaxError(
        lexer.source,
        position,
        `Invalid character within String: ${printCodePointAt(
          lexer,
          position
        )}.`
      );
    }
  }
  throw syntaxError(lexer.source, position, "Unterminated string.");
}
function readName(lexer, start) {
  const body = lexer.source.body;
  const bodyLength = body.length;
  let position = start + 1;
  while (position < bodyLength) {
    const code = body.charCodeAt(position);
    if (isNameContinue(code)) {
      ++position;
    } else {
      break;
    }
  }
  return createToken(
    lexer,
    TokenKind.NAME,
    start,
    position,
    body.slice(start, position)
  );
}

// node_modules/graphql/jsutils/inspect.mjs
var MAX_ARRAY_LENGTH = 10;
var MAX_RECURSIVE_DEPTH = 2;
function inspect(value) {
  return formatValue(value, []);
}
function formatValue(value, seenValues) {
  switch (typeof value) {
    case "string":
      return JSON.stringify(value);
    case "function":
      return value.name ? `[function ${value.name}]` : "[function]";
    case "object":
      return formatObjectValue(value, seenValues);
    default:
      return String(value);
  }
}
function formatObjectValue(value, previouslySeenValues) {
  if (value === null) {
    return "null";
  }
  if (previouslySeenValues.includes(value)) {
    return "[Circular]";
  }
  const seenValues = [...previouslySeenValues, value];
  if (isJSONable(value)) {
    const jsonValue = value.toJSON();
    if (jsonValue !== value) {
      return typeof jsonValue === "string" ? jsonValue : formatValue(jsonValue, seenValues);
    }
  } else if (Array.isArray(value)) {
    return formatArray(value, seenValues);
  }
  return formatObject(value, seenValues);
}
function isJSONable(value) {
  return typeof value.toJSON === "function";
}
function formatObject(object, seenValues) {
  const entries = Object.entries(object);
  if (entries.length === 0) {
    return "{}";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[" + getObjectTag(object) + "]";
  }
  const properties = entries.map(
    ([key, value]) => key + ": " + formatValue(value, seenValues)
  );
  return "{ " + properties.join(", ") + " }";
}
function formatArray(array, seenValues) {
  if (array.length === 0) {
    return "[]";
  }
  if (seenValues.length > MAX_RECURSIVE_DEPTH) {
    return "[Array]";
  }
  const len = Math.min(MAX_ARRAY_LENGTH, array.length);
  const remaining = array.length - len;
  const items = [];
  for (let i4 = 0; i4 < len; ++i4) {
    items.push(formatValue(array[i4], seenValues));
  }
  if (remaining === 1) {
    items.push("... 1 more item");
  } else if (remaining > 1) {
    items.push(`... ${remaining} more items`);
  }
  return "[" + items.join(", ") + "]";
}
function getObjectTag(object) {
  const tag = Object.prototype.toString.call(object).replace(/^\[object /, "").replace(/]$/, "");
  if (tag === "Object" && typeof object.constructor === "function") {
    const name = object.constructor.name;
    if (typeof name === "string" && name !== "") {
      return name;
    }
  }
  return tag;
}

// node_modules/graphql/jsutils/instanceOf.mjs
var isProduction = globalThis.process && // eslint-disable-next-line no-undef
false;
var instanceOf = (
  /* c8 ignore next 6 */
  // FIXME: https://github.com/graphql/graphql-js/issues/2317
  isProduction ? function instanceOf2(value, constructor) {
    return value instanceof constructor;
  } : function instanceOf3(value, constructor) {
    if (value instanceof constructor) {
      return true;
    }
    if (typeof value === "object" && value !== null) {
      var _value$constructor;
      const className = constructor.prototype[Symbol.toStringTag];
      const valueClassName = (
        // We still need to support constructor's name to detect conflicts with older versions of this library.
        Symbol.toStringTag in value ? value[Symbol.toStringTag] : (_value$constructor = value.constructor) === null || _value$constructor === void 0 ? void 0 : _value$constructor.name
      );
      if (className === valueClassName) {
        const stringifiedValue = inspect(value);
        throw new Error(`Cannot use ${className} "${stringifiedValue}" from another module or realm.

Ensure that there is only one instance of "graphql" in the node_modules
directory. If different versions of "graphql" are the dependencies of other
relied on modules, use "resolutions" to ensure only one version is installed.

https://yarnpkg.com/en/docs/selective-version-resolutions

Duplicate "graphql" modules cannot be used at the same time since different
versions may have different capabilities and behavior. The data from one
version used in the function from another could produce confusing and
spurious results.`);
      }
    }
    return false;
  }
);

// node_modules/graphql/language/source.mjs
var Source = class {
  constructor(body, name = "GraphQL request", locationOffset = {
    line: 1,
    column: 1
  }) {
    typeof body === "string" || devAssert(false, `Body must be a string. Received: ${inspect(body)}.`);
    this.body = body;
    this.name = name;
    this.locationOffset = locationOffset;
    this.locationOffset.line > 0 || devAssert(
      false,
      "line in locationOffset is 1-indexed and must be positive."
    );
    this.locationOffset.column > 0 || devAssert(
      false,
      "column in locationOffset is 1-indexed and must be positive."
    );
  }
  get [Symbol.toStringTag]() {
    return "Source";
  }
};
function isSource(source) {
  return instanceOf(source, Source);
}

// node_modules/graphql/language/parser.mjs
function parse(source, options) {
  const parser = new Parser(source, options);
  return parser.parseDocument();
}
var Parser = class {
  constructor(source, options = {}) {
    const sourceObj = isSource(source) ? source : new Source(source);
    this._lexer = new Lexer(sourceObj);
    this._options = options;
    this._tokenCounter = 0;
  }
  /**
   * Converts a name lex token into a name parse node.
   */
  parseName() {
    const token = this.expectToken(TokenKind.NAME);
    return this.node(token, {
      kind: Kind.NAME,
      value: token.value
    });
  }
  // Implements the parsing rules in the Document section.
  /**
   * Document : Definition+
   */
  parseDocument() {
    return this.node(this._lexer.token, {
      kind: Kind.DOCUMENT,
      definitions: this.many(
        TokenKind.SOF,
        this.parseDefinition,
        TokenKind.EOF
      )
    });
  }
  /**
   * Definition :
   *   - ExecutableDefinition
   *   - TypeSystemDefinition
   *   - TypeSystemExtension
   *
   * ExecutableDefinition :
   *   - OperationDefinition
   *   - FragmentDefinition
   *
   * TypeSystemDefinition :
   *   - SchemaDefinition
   *   - TypeDefinition
   *   - DirectiveDefinition
   *
   * TypeDefinition :
   *   - ScalarTypeDefinition
   *   - ObjectTypeDefinition
   *   - InterfaceTypeDefinition
   *   - UnionTypeDefinition
   *   - EnumTypeDefinition
   *   - InputObjectTypeDefinition
   */
  parseDefinition() {
    if (this.peek(TokenKind.BRACE_L)) {
      return this.parseOperationDefinition();
    }
    const hasDescription = this.peekDescription();
    const keywordToken = hasDescription ? this._lexer.lookahead() : this._lexer.token;
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaDefinition();
        case "scalar":
          return this.parseScalarTypeDefinition();
        case "type":
          return this.parseObjectTypeDefinition();
        case "interface":
          return this.parseInterfaceTypeDefinition();
        case "union":
          return this.parseUnionTypeDefinition();
        case "enum":
          return this.parseEnumTypeDefinition();
        case "input":
          return this.parseInputObjectTypeDefinition();
        case "directive":
          return this.parseDirectiveDefinition();
      }
      if (hasDescription) {
        throw syntaxError(
          this._lexer.source,
          this._lexer.token.start,
          "Unexpected description, descriptions are supported only on type definitions."
        );
      }
      switch (keywordToken.value) {
        case "query":
        case "mutation":
        case "subscription":
          return this.parseOperationDefinition();
        case "fragment":
          return this.parseFragmentDefinition();
        case "extend":
          return this.parseTypeSystemExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  // Implements the parsing rules in the Operations section.
  /**
   * OperationDefinition :
   *  - SelectionSet
   *  - OperationType Name? VariableDefinitions? Directives? SelectionSet
   */
  parseOperationDefinition() {
    const start = this._lexer.token;
    if (this.peek(TokenKind.BRACE_L)) {
      return this.node(start, {
        kind: Kind.OPERATION_DEFINITION,
        operation: OperationTypeNode.QUERY,
        name: void 0,
        variableDefinitions: [],
        directives: [],
        selectionSet: this.parseSelectionSet()
      });
    }
    const operation = this.parseOperationType();
    let name;
    if (this.peek(TokenKind.NAME)) {
      name = this.parseName();
    }
    return this.node(start, {
      kind: Kind.OPERATION_DEFINITION,
      operation,
      name,
      variableDefinitions: this.parseVariableDefinitions(),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * OperationType : one of query mutation subscription
   */
  parseOperationType() {
    const operationToken = this.expectToken(TokenKind.NAME);
    switch (operationToken.value) {
      case "query":
        return OperationTypeNode.QUERY;
      case "mutation":
        return OperationTypeNode.MUTATION;
      case "subscription":
        return OperationTypeNode.SUBSCRIPTION;
    }
    throw this.unexpected(operationToken);
  }
  /**
   * VariableDefinitions : ( VariableDefinition+ )
   */
  parseVariableDefinitions() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseVariableDefinition,
      TokenKind.PAREN_R
    );
  }
  /**
   * VariableDefinition : Variable : Type DefaultValue? Directives[Const]?
   */
  parseVariableDefinition() {
    return this.node(this._lexer.token, {
      kind: Kind.VARIABLE_DEFINITION,
      variable: this.parseVariable(),
      type: (this.expectToken(TokenKind.COLON), this.parseTypeReference()),
      defaultValue: this.expectOptionalToken(TokenKind.EQUALS) ? this.parseConstValueLiteral() : void 0,
      directives: this.parseConstDirectives()
    });
  }
  /**
   * Variable : $ Name
   */
  parseVariable() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.DOLLAR);
    return this.node(start, {
      kind: Kind.VARIABLE,
      name: this.parseName()
    });
  }
  /**
   * ```
   * SelectionSet : { Selection+ }
   * ```
   */
  parseSelectionSet() {
    return this.node(this._lexer.token, {
      kind: Kind.SELECTION_SET,
      selections: this.many(
        TokenKind.BRACE_L,
        this.parseSelection,
        TokenKind.BRACE_R
      )
    });
  }
  /**
   * Selection :
   *   - Field
   *   - FragmentSpread
   *   - InlineFragment
   */
  parseSelection() {
    return this.peek(TokenKind.SPREAD) ? this.parseFragment() : this.parseField();
  }
  /**
   * Field : Alias? Name Arguments? Directives? SelectionSet?
   *
   * Alias : Name :
   */
  parseField() {
    const start = this._lexer.token;
    const nameOrAlias = this.parseName();
    let alias;
    let name;
    if (this.expectOptionalToken(TokenKind.COLON)) {
      alias = nameOrAlias;
      name = this.parseName();
    } else {
      name = nameOrAlias;
    }
    return this.node(start, {
      kind: Kind.FIELD,
      alias,
      name,
      arguments: this.parseArguments(false),
      directives: this.parseDirectives(false),
      selectionSet: this.peek(TokenKind.BRACE_L) ? this.parseSelectionSet() : void 0
    });
  }
  /**
   * Arguments[Const] : ( Argument[?Const]+ )
   */
  parseArguments(isConst) {
    const item = isConst ? this.parseConstArgument : this.parseArgument;
    return this.optionalMany(TokenKind.PAREN_L, item, TokenKind.PAREN_R);
  }
  /**
   * Argument[Const] : Name : Value[?Const]
   */
  parseArgument(isConst = false) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.ARGUMENT,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  parseConstArgument() {
    return this.parseArgument(true);
  }
  // Implements the parsing rules in the Fragments section.
  /**
   * Corresponds to both FragmentSpread and InlineFragment in the spec.
   *
   * FragmentSpread : ... FragmentName Directives?
   *
   * InlineFragment : ... TypeCondition? Directives? SelectionSet
   */
  parseFragment() {
    const start = this._lexer.token;
    this.expectToken(TokenKind.SPREAD);
    const hasTypeCondition = this.expectOptionalKeyword("on");
    if (!hasTypeCondition && this.peek(TokenKind.NAME)) {
      return this.node(start, {
        kind: Kind.FRAGMENT_SPREAD,
        name: this.parseFragmentName(),
        directives: this.parseDirectives(false)
      });
    }
    return this.node(start, {
      kind: Kind.INLINE_FRAGMENT,
      typeCondition: hasTypeCondition ? this.parseNamedType() : void 0,
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentDefinition :
   *   - fragment FragmentName on TypeCondition Directives? SelectionSet
   *
   * TypeCondition : NamedType
   */
  parseFragmentDefinition() {
    const start = this._lexer.token;
    this.expectKeyword("fragment");
    if (this._options.allowLegacyFragmentVariables === true) {
      return this.node(start, {
        kind: Kind.FRAGMENT_DEFINITION,
        name: this.parseFragmentName(),
        variableDefinitions: this.parseVariableDefinitions(),
        typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
        directives: this.parseDirectives(false),
        selectionSet: this.parseSelectionSet()
      });
    }
    return this.node(start, {
      kind: Kind.FRAGMENT_DEFINITION,
      name: this.parseFragmentName(),
      typeCondition: (this.expectKeyword("on"), this.parseNamedType()),
      directives: this.parseDirectives(false),
      selectionSet: this.parseSelectionSet()
    });
  }
  /**
   * FragmentName : Name but not `on`
   */
  parseFragmentName() {
    if (this._lexer.token.value === "on") {
      throw this.unexpected();
    }
    return this.parseName();
  }
  // Implements the parsing rules in the Values section.
  /**
   * Value[Const] :
   *   - [~Const] Variable
   *   - IntValue
   *   - FloatValue
   *   - StringValue
   *   - BooleanValue
   *   - NullValue
   *   - EnumValue
   *   - ListValue[?Const]
   *   - ObjectValue[?Const]
   *
   * BooleanValue : one of `true` `false`
   *
   * NullValue : `null`
   *
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseValueLiteral(isConst) {
    const token = this._lexer.token;
    switch (token.kind) {
      case TokenKind.BRACKET_L:
        return this.parseList(isConst);
      case TokenKind.BRACE_L:
        return this.parseObject(isConst);
      case TokenKind.INT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.INT,
          value: token.value
        });
      case TokenKind.FLOAT:
        this.advanceLexer();
        return this.node(token, {
          kind: Kind.FLOAT,
          value: token.value
        });
      case TokenKind.STRING:
      case TokenKind.BLOCK_STRING:
        return this.parseStringLiteral();
      case TokenKind.NAME:
        this.advanceLexer();
        switch (token.value) {
          case "true":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: true
            });
          case "false":
            return this.node(token, {
              kind: Kind.BOOLEAN,
              value: false
            });
          case "null":
            return this.node(token, {
              kind: Kind.NULL
            });
          default:
            return this.node(token, {
              kind: Kind.ENUM,
              value: token.value
            });
        }
      case TokenKind.DOLLAR:
        if (isConst) {
          this.expectToken(TokenKind.DOLLAR);
          if (this._lexer.token.kind === TokenKind.NAME) {
            const varName = this._lexer.token.value;
            throw syntaxError(
              this._lexer.source,
              token.start,
              `Unexpected variable "$${varName}" in constant value.`
            );
          } else {
            throw this.unexpected(token);
          }
        }
        return this.parseVariable();
      default:
        throw this.unexpected();
    }
  }
  parseConstValueLiteral() {
    return this.parseValueLiteral(true);
  }
  parseStringLiteral() {
    const token = this._lexer.token;
    this.advanceLexer();
    return this.node(token, {
      kind: Kind.STRING,
      value: token.value,
      block: token.kind === TokenKind.BLOCK_STRING
    });
  }
  /**
   * ListValue[Const] :
   *   - [ ]
   *   - [ Value[?Const]+ ]
   */
  parseList(isConst) {
    const item = () => this.parseValueLiteral(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.LIST,
      values: this.any(TokenKind.BRACKET_L, item, TokenKind.BRACKET_R)
    });
  }
  /**
   * ```
   * ObjectValue[Const] :
   *   - { }
   *   - { ObjectField[?Const]+ }
   * ```
   */
  parseObject(isConst) {
    const item = () => this.parseObjectField(isConst);
    return this.node(this._lexer.token, {
      kind: Kind.OBJECT,
      fields: this.any(TokenKind.BRACE_L, item, TokenKind.BRACE_R)
    });
  }
  /**
   * ObjectField[Const] : Name : Value[?Const]
   */
  parseObjectField(isConst) {
    const start = this._lexer.token;
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    return this.node(start, {
      kind: Kind.OBJECT_FIELD,
      name,
      value: this.parseValueLiteral(isConst)
    });
  }
  // Implements the parsing rules in the Directives section.
  /**
   * Directives[Const] : Directive[?Const]+
   */
  parseDirectives(isConst) {
    const directives = [];
    while (this.peek(TokenKind.AT)) {
      directives.push(this.parseDirective(isConst));
    }
    return directives;
  }
  parseConstDirectives() {
    return this.parseDirectives(true);
  }
  /**
   * ```
   * Directive[Const] : @ Name Arguments[?Const]?
   * ```
   */
  parseDirective(isConst) {
    const start = this._lexer.token;
    this.expectToken(TokenKind.AT);
    return this.node(start, {
      kind: Kind.DIRECTIVE,
      name: this.parseName(),
      arguments: this.parseArguments(isConst)
    });
  }
  // Implements the parsing rules in the Types section.
  /**
   * Type :
   *   - NamedType
   *   - ListType
   *   - NonNullType
   */
  parseTypeReference() {
    const start = this._lexer.token;
    let type;
    if (this.expectOptionalToken(TokenKind.BRACKET_L)) {
      const innerType = this.parseTypeReference();
      this.expectToken(TokenKind.BRACKET_R);
      type = this.node(start, {
        kind: Kind.LIST_TYPE,
        type: innerType
      });
    } else {
      type = this.parseNamedType();
    }
    if (this.expectOptionalToken(TokenKind.BANG)) {
      return this.node(start, {
        kind: Kind.NON_NULL_TYPE,
        type
      });
    }
    return type;
  }
  /**
   * NamedType : Name
   */
  parseNamedType() {
    return this.node(this._lexer.token, {
      kind: Kind.NAMED_TYPE,
      name: this.parseName()
    });
  }
  // Implements the parsing rules in the Type Definition section.
  peekDescription() {
    return this.peek(TokenKind.STRING) || this.peek(TokenKind.BLOCK_STRING);
  }
  /**
   * Description : StringValue
   */
  parseDescription() {
    if (this.peekDescription()) {
      return this.parseStringLiteral();
    }
  }
  /**
   * ```
   * SchemaDefinition : Description? schema Directives[Const]? { OperationTypeDefinition+ }
   * ```
   */
  parseSchemaDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.many(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    return this.node(start, {
      kind: Kind.SCHEMA_DEFINITION,
      description,
      directives,
      operationTypes
    });
  }
  /**
   * OperationTypeDefinition : OperationType : NamedType
   */
  parseOperationTypeDefinition() {
    const start = this._lexer.token;
    const operation = this.parseOperationType();
    this.expectToken(TokenKind.COLON);
    const type = this.parseNamedType();
    return this.node(start, {
      kind: Kind.OPERATION_TYPE_DEFINITION,
      operation,
      type
    });
  }
  /**
   * ScalarTypeDefinition : Description? scalar Name Directives[Const]?
   */
  parseScalarTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * ObjectTypeDefinition :
   *   Description?
   *   type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition?
   */
  parseObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * ImplementsInterfaces :
   *   - implements `&`? NamedType
   *   - ImplementsInterfaces & NamedType
   */
  parseImplementsInterfaces() {
    return this.expectOptionalKeyword("implements") ? this.delimitedMany(TokenKind.AMP, this.parseNamedType) : [];
  }
  /**
   * ```
   * FieldsDefinition : { FieldDefinition+ }
   * ```
   */
  parseFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseFieldDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * FieldDefinition :
   *   - Description? Name ArgumentsDefinition? : Type Directives[Const]?
   */
  parseFieldDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.FIELD_DEFINITION,
      description,
      name,
      arguments: args,
      type,
      directives
    });
  }
  /**
   * ArgumentsDefinition : ( InputValueDefinition+ )
   */
  parseArgumentDefs() {
    return this.optionalMany(
      TokenKind.PAREN_L,
      this.parseInputValueDef,
      TokenKind.PAREN_R
    );
  }
  /**
   * InputValueDefinition :
   *   - Description? Name : Type DefaultValue? Directives[Const]?
   */
  parseInputValueDef() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseName();
    this.expectToken(TokenKind.COLON);
    const type = this.parseTypeReference();
    let defaultValue;
    if (this.expectOptionalToken(TokenKind.EQUALS)) {
      defaultValue = this.parseConstValueLiteral();
    }
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.INPUT_VALUE_DEFINITION,
      description,
      name,
      type,
      defaultValue,
      directives
    });
  }
  /**
   * InterfaceTypeDefinition :
   *   - Description? interface Name Directives[Const]? FieldsDefinition?
   */
  parseInterfaceTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_DEFINITION,
      description,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeDefinition :
   *   - Description? union Name Directives[Const]? UnionMemberTypes?
   */
  parseUnionTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    return this.node(start, {
      kind: Kind.UNION_TYPE_DEFINITION,
      description,
      name,
      directives,
      types
    });
  }
  /**
   * UnionMemberTypes :
   *   - = `|`? NamedType
   *   - UnionMemberTypes | NamedType
   */
  parseUnionMemberTypes() {
    return this.expectOptionalToken(TokenKind.EQUALS) ? this.delimitedMany(TokenKind.PIPE, this.parseNamedType) : [];
  }
  /**
   * EnumTypeDefinition :
   *   - Description? enum Name Directives[Const]? EnumValuesDefinition?
   */
  parseEnumTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    return this.node(start, {
      kind: Kind.ENUM_TYPE_DEFINITION,
      description,
      name,
      directives,
      values
    });
  }
  /**
   * ```
   * EnumValuesDefinition : { EnumValueDefinition+ }
   * ```
   */
  parseEnumValuesDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseEnumValueDefinition,
      TokenKind.BRACE_R
    );
  }
  /**
   * EnumValueDefinition : Description? EnumValue Directives[Const]?
   */
  parseEnumValueDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    const name = this.parseEnumValueName();
    const directives = this.parseConstDirectives();
    return this.node(start, {
      kind: Kind.ENUM_VALUE_DEFINITION,
      description,
      name,
      directives
    });
  }
  /**
   * EnumValue : Name but not `true`, `false` or `null`
   */
  parseEnumValueName() {
    if (this._lexer.token.value === "true" || this._lexer.token.value === "false" || this._lexer.token.value === "null") {
      throw syntaxError(
        this._lexer.source,
        this._lexer.token.start,
        `${getTokenDesc(
          this._lexer.token
        )} is reserved and cannot be used for an enum value.`
      );
    }
    return this.parseName();
  }
  /**
   * InputObjectTypeDefinition :
   *   - Description? input Name Directives[Const]? InputFieldsDefinition?
   */
  parseInputObjectTypeDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_DEFINITION,
      description,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * InputFieldsDefinition : { InputValueDefinition+ }
   * ```
   */
  parseInputFieldsDefinition() {
    return this.optionalMany(
      TokenKind.BRACE_L,
      this.parseInputValueDef,
      TokenKind.BRACE_R
    );
  }
  /**
   * TypeSystemExtension :
   *   - SchemaExtension
   *   - TypeExtension
   *
   * TypeExtension :
   *   - ScalarTypeExtension
   *   - ObjectTypeExtension
   *   - InterfaceTypeExtension
   *   - UnionTypeExtension
   *   - EnumTypeExtension
   *   - InputObjectTypeDefinition
   */
  parseTypeSystemExtension() {
    const keywordToken = this._lexer.lookahead();
    if (keywordToken.kind === TokenKind.NAME) {
      switch (keywordToken.value) {
        case "schema":
          return this.parseSchemaExtension();
        case "scalar":
          return this.parseScalarTypeExtension();
        case "type":
          return this.parseObjectTypeExtension();
        case "interface":
          return this.parseInterfaceTypeExtension();
        case "union":
          return this.parseUnionTypeExtension();
        case "enum":
          return this.parseEnumTypeExtension();
        case "input":
          return this.parseInputObjectTypeExtension();
      }
    }
    throw this.unexpected(keywordToken);
  }
  /**
   * ```
   * SchemaExtension :
   *  - extend schema Directives[Const]? { OperationTypeDefinition+ }
   *  - extend schema Directives[Const]
   * ```
   */
  parseSchemaExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("schema");
    const directives = this.parseConstDirectives();
    const operationTypes = this.optionalMany(
      TokenKind.BRACE_L,
      this.parseOperationTypeDefinition,
      TokenKind.BRACE_R
    );
    if (directives.length === 0 && operationTypes.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCHEMA_EXTENSION,
      directives,
      operationTypes
    });
  }
  /**
   * ScalarTypeExtension :
   *   - extend scalar Name Directives[Const]
   */
  parseScalarTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("scalar");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    if (directives.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.SCALAR_TYPE_EXTENSION,
      name,
      directives
    });
  }
  /**
   * ObjectTypeExtension :
   *  - extend type Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend type Name ImplementsInterfaces? Directives[Const]
   *  - extend type Name ImplementsInterfaces
   */
  parseObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("type");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.OBJECT_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * InterfaceTypeExtension :
   *  - extend interface Name ImplementsInterfaces? Directives[Const]? FieldsDefinition
   *  - extend interface Name ImplementsInterfaces? Directives[Const]
   *  - extend interface Name ImplementsInterfaces
   */
  parseInterfaceTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("interface");
    const name = this.parseName();
    const interfaces = this.parseImplementsInterfaces();
    const directives = this.parseConstDirectives();
    const fields = this.parseFieldsDefinition();
    if (interfaces.length === 0 && directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INTERFACE_TYPE_EXTENSION,
      name,
      interfaces,
      directives,
      fields
    });
  }
  /**
   * UnionTypeExtension :
   *   - extend union Name Directives[Const]? UnionMemberTypes
   *   - extend union Name Directives[Const]
   */
  parseUnionTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("union");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const types = this.parseUnionMemberTypes();
    if (directives.length === 0 && types.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.UNION_TYPE_EXTENSION,
      name,
      directives,
      types
    });
  }
  /**
   * EnumTypeExtension :
   *   - extend enum Name Directives[Const]? EnumValuesDefinition
   *   - extend enum Name Directives[Const]
   */
  parseEnumTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("enum");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const values = this.parseEnumValuesDefinition();
    if (directives.length === 0 && values.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.ENUM_TYPE_EXTENSION,
      name,
      directives,
      values
    });
  }
  /**
   * InputObjectTypeExtension :
   *   - extend input Name Directives[Const]? InputFieldsDefinition
   *   - extend input Name Directives[Const]
   */
  parseInputObjectTypeExtension() {
    const start = this._lexer.token;
    this.expectKeyword("extend");
    this.expectKeyword("input");
    const name = this.parseName();
    const directives = this.parseConstDirectives();
    const fields = this.parseInputFieldsDefinition();
    if (directives.length === 0 && fields.length === 0) {
      throw this.unexpected();
    }
    return this.node(start, {
      kind: Kind.INPUT_OBJECT_TYPE_EXTENSION,
      name,
      directives,
      fields
    });
  }
  /**
   * ```
   * DirectiveDefinition :
   *   - Description? directive @ Name ArgumentsDefinition? `repeatable`? on DirectiveLocations
   * ```
   */
  parseDirectiveDefinition() {
    const start = this._lexer.token;
    const description = this.parseDescription();
    this.expectKeyword("directive");
    this.expectToken(TokenKind.AT);
    const name = this.parseName();
    const args = this.parseArgumentDefs();
    const repeatable = this.expectOptionalKeyword("repeatable");
    this.expectKeyword("on");
    const locations = this.parseDirectiveLocations();
    return this.node(start, {
      kind: Kind.DIRECTIVE_DEFINITION,
      description,
      name,
      arguments: args,
      repeatable,
      locations
    });
  }
  /**
   * DirectiveLocations :
   *   - `|`? DirectiveLocation
   *   - DirectiveLocations | DirectiveLocation
   */
  parseDirectiveLocations() {
    return this.delimitedMany(TokenKind.PIPE, this.parseDirectiveLocation);
  }
  /*
   * DirectiveLocation :
   *   - ExecutableDirectiveLocation
   *   - TypeSystemDirectiveLocation
   *
   * ExecutableDirectiveLocation : one of
   *   `QUERY`
   *   `MUTATION`
   *   `SUBSCRIPTION`
   *   `FIELD`
   *   `FRAGMENT_DEFINITION`
   *   `FRAGMENT_SPREAD`
   *   `INLINE_FRAGMENT`
   *
   * TypeSystemDirectiveLocation : one of
   *   `SCHEMA`
   *   `SCALAR`
   *   `OBJECT`
   *   `FIELD_DEFINITION`
   *   `ARGUMENT_DEFINITION`
   *   `INTERFACE`
   *   `UNION`
   *   `ENUM`
   *   `ENUM_VALUE`
   *   `INPUT_OBJECT`
   *   `INPUT_FIELD_DEFINITION`
   */
  parseDirectiveLocation() {
    const start = this._lexer.token;
    const name = this.parseName();
    if (Object.prototype.hasOwnProperty.call(DirectiveLocation, name.value)) {
      return name;
    }
    throw this.unexpected(start);
  }
  // Core parsing utility functions
  /**
   * Returns a node that, if configured to do so, sets a "loc" field as a
   * location object, used to identify the place in the source that created a
   * given parsed object.
   */
  node(startToken, node) {
    if (this._options.noLocation !== true) {
      node.loc = new Location(
        startToken,
        this._lexer.lastToken,
        this._lexer.source
      );
    }
    return node;
  }
  /**
   * Determines if the next token is of a given kind
   */
  peek(kind) {
    return this._lexer.token.kind === kind;
  }
  /**
   * If the next token is of the given kind, return that token after advancing the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return token;
    }
    throw syntaxError(
      this._lexer.source,
      token.start,
      `Expected ${getTokenKindDesc(kind)}, found ${getTokenDesc(token)}.`
    );
  }
  /**
   * If the next token is of the given kind, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalToken(kind) {
    const token = this._lexer.token;
    if (token.kind === kind) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * If the next token is a given keyword, advance the lexer.
   * Otherwise, do not change the parser state and throw an error.
   */
  expectKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
    } else {
      throw syntaxError(
        this._lexer.source,
        token.start,
        `Expected "${value}", found ${getTokenDesc(token)}.`
      );
    }
  }
  /**
   * If the next token is a given keyword, return "true" after advancing the lexer.
   * Otherwise, do not change the parser state and return "false".
   */
  expectOptionalKeyword(value) {
    const token = this._lexer.token;
    if (token.kind === TokenKind.NAME && token.value === value) {
      this.advanceLexer();
      return true;
    }
    return false;
  }
  /**
   * Helper function for creating an error when an unexpected lexed token is encountered.
   */
  unexpected(atToken) {
    const token = atToken !== null && atToken !== void 0 ? atToken : this._lexer.token;
    return syntaxError(
      this._lexer.source,
      token.start,
      `Unexpected ${getTokenDesc(token)}.`
    );
  }
  /**
   * Returns a possibly empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  any(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    while (!this.expectOptionalToken(closeKind)) {
      nodes.push(parseFn.call(this));
    }
    return nodes;
  }
  /**
   * Returns a list of parse nodes, determined by the parseFn.
   * It can be empty only if open token is missing otherwise it will always return non-empty list
   * that begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  optionalMany(openKind, parseFn, closeKind) {
    if (this.expectOptionalToken(openKind)) {
      const nodes = [];
      do {
        nodes.push(parseFn.call(this));
      } while (!this.expectOptionalToken(closeKind));
      return nodes;
    }
    return [];
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list begins with a lex token of openKind and ends with a lex token of closeKind.
   * Advances the parser to the next lex token after the closing token.
   */
  many(openKind, parseFn, closeKind) {
    this.expectToken(openKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (!this.expectOptionalToken(closeKind));
    return nodes;
  }
  /**
   * Returns a non-empty list of parse nodes, determined by the parseFn.
   * This list may begin with a lex token of delimiterKind followed by items separated by lex tokens of tokenKind.
   * Advances the parser to the next lex token after last item in the list.
   */
  delimitedMany(delimiterKind, parseFn) {
    this.expectOptionalToken(delimiterKind);
    const nodes = [];
    do {
      nodes.push(parseFn.call(this));
    } while (this.expectOptionalToken(delimiterKind));
    return nodes;
  }
  advanceLexer() {
    const { maxTokens } = this._options;
    const token = this._lexer.advance();
    if (maxTokens !== void 0 && token.kind !== TokenKind.EOF) {
      ++this._tokenCounter;
      if (this._tokenCounter > maxTokens) {
        throw syntaxError(
          this._lexer.source,
          token.start,
          `Document contains more that ${maxTokens} tokens. Parsing aborted.`
        );
      }
    }
  }
};
function getTokenDesc(token) {
  const value = token.value;
  return getTokenKindDesc(token.kind) + (value != null ? ` "${value}"` : "");
}
function getTokenKindDesc(kind) {
  return isPunctuatorTokenKind(kind) ? `"${kind}"` : kind;
}

// node_modules/graphql/jsutils/didYouMean.mjs
var MAX_SUGGESTIONS = 5;
function didYouMean(firstArg, secondArg) {
  const [subMessage, suggestionsArg] = secondArg ? [firstArg, secondArg] : [void 0, firstArg];
  let message = " Did you mean ";
  if (subMessage) {
    message += subMessage + " ";
  }
  const suggestions = suggestionsArg.map((x2) => `"${x2}"`);
  switch (suggestions.length) {
    case 0:
      return "";
    case 1:
      return message + suggestions[0] + "?";
    case 2:
      return message + suggestions[0] + " or " + suggestions[1] + "?";
  }
  const selected = suggestions.slice(0, MAX_SUGGESTIONS);
  const lastItem = selected.pop();
  return message + selected.join(", ") + ", or " + lastItem + "?";
}

// node_modules/graphql/jsutils/identityFunc.mjs
function identityFunc(x2) {
  return x2;
}

// node_modules/graphql/jsutils/keyMap.mjs
function keyMap(list, keyFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = item;
  }
  return result;
}

// node_modules/graphql/jsutils/keyValMap.mjs
function keyValMap(list, keyFn, valFn) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const item of list) {
    result[keyFn(item)] = valFn(item);
  }
  return result;
}

// node_modules/graphql/jsutils/mapValue.mjs
function mapValue(map, fn3) {
  const result = /* @__PURE__ */ Object.create(null);
  for (const key of Object.keys(map)) {
    result[key] = fn3(map[key], key);
  }
  return result;
}

// node_modules/graphql/jsutils/naturalCompare.mjs
function naturalCompare(aStr, bStr) {
  let aIndex = 0;
  let bIndex = 0;
  while (aIndex < aStr.length && bIndex < bStr.length) {
    let aChar = aStr.charCodeAt(aIndex);
    let bChar = bStr.charCodeAt(bIndex);
    if (isDigit2(aChar) && isDigit2(bChar)) {
      let aNum = 0;
      do {
        ++aIndex;
        aNum = aNum * 10 + aChar - DIGIT_0;
        aChar = aStr.charCodeAt(aIndex);
      } while (isDigit2(aChar) && aNum > 0);
      let bNum = 0;
      do {
        ++bIndex;
        bNum = bNum * 10 + bChar - DIGIT_0;
        bChar = bStr.charCodeAt(bIndex);
      } while (isDigit2(bChar) && bNum > 0);
      if (aNum < bNum) {
        return -1;
      }
      if (aNum > bNum) {
        return 1;
      }
    } else {
      if (aChar < bChar) {
        return -1;
      }
      if (aChar > bChar) {
        return 1;
      }
      ++aIndex;
      ++bIndex;
    }
  }
  return aStr.length - bStr.length;
}
var DIGIT_0 = 48;
var DIGIT_9 = 57;
function isDigit2(code) {
  return !isNaN(code) && DIGIT_0 <= code && code <= DIGIT_9;
}

// node_modules/graphql/jsutils/suggestionList.mjs
function suggestionList(input, options) {
  const optionsByDistance = /* @__PURE__ */ Object.create(null);
  const lexicalDistance = new LexicalDistance(input);
  const threshold = Math.floor(input.length * 0.4) + 1;
  for (const option of options) {
    const distance = lexicalDistance.measure(option, threshold);
    if (distance !== void 0) {
      optionsByDistance[option] = distance;
    }
  }
  return Object.keys(optionsByDistance).sort((a2, b2) => {
    const distanceDiff = optionsByDistance[a2] - optionsByDistance[b2];
    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a2, b2);
  });
}
var LexicalDistance = class {
  constructor(input) {
    this._input = input;
    this._inputLowerCase = input.toLowerCase();
    this._inputArray = stringToArray(this._inputLowerCase);
    this._rows = [
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0),
      new Array(input.length + 1).fill(0)
    ];
  }
  measure(option, threshold) {
    if (this._input === option) {
      return 0;
    }
    const optionLowerCase = option.toLowerCase();
    if (this._inputLowerCase === optionLowerCase) {
      return 1;
    }
    let a2 = stringToArray(optionLowerCase);
    let b2 = this._inputArray;
    if (a2.length < b2.length) {
      const tmp = a2;
      a2 = b2;
      b2 = tmp;
    }
    const aLength = a2.length;
    const bLength = b2.length;
    if (aLength - bLength > threshold) {
      return void 0;
    }
    const rows = this._rows;
    for (let j2 = 0; j2 <= bLength; j2++) {
      rows[0][j2] = j2;
    }
    for (let i4 = 1; i4 <= aLength; i4++) {
      const upRow = rows[(i4 - 1) % 3];
      const currentRow = rows[i4 % 3];
      let smallestCell = currentRow[0] = i4;
      for (let j2 = 1; j2 <= bLength; j2++) {
        const cost = a2[i4 - 1] === b2[j2 - 1] ? 0 : 1;
        let currentCell = Math.min(
          upRow[j2] + 1,
          // delete
          currentRow[j2 - 1] + 1,
          // insert
          upRow[j2 - 1] + cost
          // substitute
        );
        if (i4 > 1 && j2 > 1 && a2[i4 - 1] === b2[j2 - 2] && a2[i4 - 2] === b2[j2 - 1]) {
          const doubleDiagonalCell = rows[(i4 - 2) % 3][j2 - 2];
          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);
        }
        if (currentCell < smallestCell) {
          smallestCell = currentCell;
        }
        currentRow[j2] = currentCell;
      }
      if (smallestCell > threshold) {
        return void 0;
      }
    }
    const distance = rows[aLength % 3][bLength];
    return distance <= threshold ? distance : void 0;
  }
};
function stringToArray(str) {
  const strLength = str.length;
  const array = new Array(strLength);
  for (let i4 = 0; i4 < strLength; ++i4) {
    array[i4] = str.charCodeAt(i4);
  }
  return array;
}

// node_modules/graphql/jsutils/toObjMap.mjs
function toObjMap(obj) {
  if (obj == null) {
    return /* @__PURE__ */ Object.create(null);
  }
  if (Object.getPrototypeOf(obj) === null) {
    return obj;
  }
  const map = /* @__PURE__ */ Object.create(null);
  for (const [key, value] of Object.entries(obj)) {
    map[key] = value;
  }
  return map;
}

// node_modules/graphql/language/printString.mjs
function printString(str) {
  return `"${str.replace(escapedRegExp, escapedReplacer)}"`;
}
var escapedRegExp = /[\x00-\x1f\x22\x5c\x7f-\x9f]/g;
function escapedReplacer(str) {
  return escapeSequences[str.charCodeAt(0)];
}
var escapeSequences = [
  "\\u0000",
  "\\u0001",
  "\\u0002",
  "\\u0003",
  "\\u0004",
  "\\u0005",
  "\\u0006",
  "\\u0007",
  "\\b",
  "\\t",
  "\\n",
  "\\u000B",
  "\\f",
  "\\r",
  "\\u000E",
  "\\u000F",
  "\\u0010",
  "\\u0011",
  "\\u0012",
  "\\u0013",
  "\\u0014",
  "\\u0015",
  "\\u0016",
  "\\u0017",
  "\\u0018",
  "\\u0019",
  "\\u001A",
  "\\u001B",
  "\\u001C",
  "\\u001D",
  "\\u001E",
  "\\u001F",
  "",
  "",
  '\\"',
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 2F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 3F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 4F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\\\",
  "",
  "",
  "",
  // 5F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  // 6F
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "",
  "\\u007F",
  "\\u0080",
  "\\u0081",
  "\\u0082",
  "\\u0083",
  "\\u0084",
  "\\u0085",
  "\\u0086",
  "\\u0087",
  "\\u0088",
  "\\u0089",
  "\\u008A",
  "\\u008B",
  "\\u008C",
  "\\u008D",
  "\\u008E",
  "\\u008F",
  "\\u0090",
  "\\u0091",
  "\\u0092",
  "\\u0093",
  "\\u0094",
  "\\u0095",
  "\\u0096",
  "\\u0097",
  "\\u0098",
  "\\u0099",
  "\\u009A",
  "\\u009B",
  "\\u009C",
  "\\u009D",
  "\\u009E",
  "\\u009F"
];

// node_modules/graphql/language/visitor.mjs
var BREAK = Object.freeze({});
function visit(root, visitor, visitorKeys = QueryDocumentKeys) {
  const enterLeaveMap = /* @__PURE__ */ new Map();
  for (const kind of Object.values(Kind)) {
    enterLeaveMap.set(kind, getEnterLeaveForKind(visitor, kind));
  }
  let stack = void 0;
  let inArray = Array.isArray(root);
  let keys = [root];
  let index = -1;
  let edits = [];
  let node = root;
  let key = void 0;
  let parent = void 0;
  const path = [];
  const ancestors = [];
  do {
    index++;
    const isLeaving = index === keys.length;
    const isEdited = isLeaving && edits.length !== 0;
    if (isLeaving) {
      key = ancestors.length === 0 ? void 0 : path[path.length - 1];
      node = parent;
      parent = ancestors.pop();
      if (isEdited) {
        if (inArray) {
          node = node.slice();
          let editOffset = 0;
          for (const [editKey, editValue] of edits) {
            const arrayKey = editKey - editOffset;
            if (editValue === null) {
              node.splice(arrayKey, 1);
              editOffset++;
            } else {
              node[arrayKey] = editValue;
            }
          }
        } else {
          node = Object.defineProperties(
            {},
            Object.getOwnPropertyDescriptors(node)
          );
          for (const [editKey, editValue] of edits) {
            node[editKey] = editValue;
          }
        }
      }
      index = stack.index;
      keys = stack.keys;
      edits = stack.edits;
      inArray = stack.inArray;
      stack = stack.prev;
    } else if (parent) {
      key = inArray ? index : keys[index];
      node = parent[key];
      if (node === null || node === void 0) {
        continue;
      }
      path.push(key);
    }
    let result;
    if (!Array.isArray(node)) {
      var _enterLeaveMap$get, _enterLeaveMap$get2;
      isNode(node) || devAssert(false, `Invalid AST Node: ${inspect(node)}.`);
      const visitFn = isLeaving ? (_enterLeaveMap$get = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get === void 0 ? void 0 : _enterLeaveMap$get.leave : (_enterLeaveMap$get2 = enterLeaveMap.get(node.kind)) === null || _enterLeaveMap$get2 === void 0 ? void 0 : _enterLeaveMap$get2.enter;
      result = visitFn === null || visitFn === void 0 ? void 0 : visitFn.call(visitor, node, key, parent, path, ancestors);
      if (result === BREAK) {
        break;
      }
      if (result === false) {
        if (!isLeaving) {
          path.pop();
          continue;
        }
      } else if (result !== void 0) {
        edits.push([key, result]);
        if (!isLeaving) {
          if (isNode(result)) {
            node = result;
          } else {
            path.pop();
            continue;
          }
        }
      }
    }
    if (result === void 0 && isEdited) {
      edits.push([key, node]);
    }
    if (isLeaving) {
      path.pop();
    } else {
      var _node$kind;
      stack = {
        inArray,
        index,
        keys,
        edits,
        prev: stack
      };
      inArray = Array.isArray(node);
      keys = inArray ? node : (_node$kind = visitorKeys[node.kind]) !== null && _node$kind !== void 0 ? _node$kind : [];
      index = -1;
      edits = [];
      if (parent) {
        ancestors.push(parent);
      }
      parent = node;
    }
  } while (stack !== void 0);
  if (edits.length !== 0) {
    return edits[edits.length - 1][1];
  }
  return root;
}
function getEnterLeaveForKind(visitor, kind) {
  const kindVisitor = visitor[kind];
  if (typeof kindVisitor === "object") {
    return kindVisitor;
  } else if (typeof kindVisitor === "function") {
    return {
      enter: kindVisitor,
      leave: void 0
    };
  }
  return {
    enter: visitor.enter,
    leave: visitor.leave
  };
}

// node_modules/graphql/language/printer.mjs
function print(ast) {
  return visit(ast, printDocASTReducer);
}
var MAX_LINE_LENGTH = 80;
var printDocASTReducer = {
  Name: {
    leave: (node) => node.value
  },
  Variable: {
    leave: (node) => "$" + node.name
  },
  // Document
  Document: {
    leave: (node) => join(node.definitions, "\n\n")
  },
  OperationDefinition: {
    leave(node) {
      const varDefs = wrap("(", join(node.variableDefinitions, ", "), ")");
      const prefix = join(
        [
          node.operation,
          join([node.name, varDefs]),
          join(node.directives, " ")
        ],
        " "
      );
      return (prefix === "query" ? "" : prefix + " ") + node.selectionSet;
    }
  },
  VariableDefinition: {
    leave: ({ variable, type, defaultValue, directives }) => variable + ": " + type + wrap(" = ", defaultValue) + wrap(" ", join(directives, " "))
  },
  SelectionSet: {
    leave: ({ selections }) => block(selections)
  },
  Field: {
    leave({ alias, name, arguments: args, directives, selectionSet }) {
      const prefix = wrap("", alias, ": ") + name;
      let argsLine = prefix + wrap("(", join(args, ", "), ")");
      if (argsLine.length > MAX_LINE_LENGTH) {
        argsLine = prefix + wrap("(\n", indent(join(args, "\n")), "\n)");
      }
      return join([argsLine, join(directives, " "), selectionSet], " ");
    }
  },
  Argument: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Fragments
  FragmentSpread: {
    leave: ({ name, directives }) => "..." + name + wrap(" ", join(directives, " "))
  },
  InlineFragment: {
    leave: ({ typeCondition, directives, selectionSet }) => join(
      [
        "...",
        wrap("on ", typeCondition),
        join(directives, " "),
        selectionSet
      ],
      " "
    )
  },
  FragmentDefinition: {
    leave: ({ name, typeCondition, variableDefinitions, directives, selectionSet }) => (
      // or removed in the future.
      `fragment ${name}${wrap("(", join(variableDefinitions, ", "), ")")} on ${typeCondition} ${wrap("", join(directives, " "), " ")}` + selectionSet
    )
  },
  // Value
  IntValue: {
    leave: ({ value }) => value
  },
  FloatValue: {
    leave: ({ value }) => value
  },
  StringValue: {
    leave: ({ value, block: isBlockString }) => isBlockString ? printBlockString(value) : printString(value)
  },
  BooleanValue: {
    leave: ({ value }) => value ? "true" : "false"
  },
  NullValue: {
    leave: () => "null"
  },
  EnumValue: {
    leave: ({ value }) => value
  },
  ListValue: {
    leave: ({ values }) => "[" + join(values, ", ") + "]"
  },
  ObjectValue: {
    leave: ({ fields }) => "{" + join(fields, ", ") + "}"
  },
  ObjectField: {
    leave: ({ name, value }) => name + ": " + value
  },
  // Directive
  Directive: {
    leave: ({ name, arguments: args }) => "@" + name + wrap("(", join(args, ", "), ")")
  },
  // Type
  NamedType: {
    leave: ({ name }) => name
  },
  ListType: {
    leave: ({ type }) => "[" + type + "]"
  },
  NonNullType: {
    leave: ({ type }) => type + "!"
  },
  // Type System Definitions
  SchemaDefinition: {
    leave: ({ description, directives, operationTypes }) => wrap("", description, "\n") + join(["schema", join(directives, " "), block(operationTypes)], " ")
  },
  OperationTypeDefinition: {
    leave: ({ operation, type }) => operation + ": " + type
  },
  ScalarTypeDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join(["scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  FieldDefinition: {
    leave: ({ description, name, arguments: args, type, directives }) => wrap("", description, "\n") + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + ": " + type + wrap(" ", join(directives, " "))
  },
  InputValueDefinition: {
    leave: ({ description, name, type, defaultValue, directives }) => wrap("", description, "\n") + join(
      [name + ": " + type, wrap("= ", defaultValue), join(directives, " ")],
      " "
    )
  },
  InterfaceTypeDefinition: {
    leave: ({ description, name, interfaces, directives, fields }) => wrap("", description, "\n") + join(
      [
        "interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeDefinition: {
    leave: ({ description, name, directives, types }) => wrap("", description, "\n") + join(
      ["union", name, join(directives, " "), wrap("= ", join(types, " | "))],
      " "
    )
  },
  EnumTypeDefinition: {
    leave: ({ description, name, directives, values }) => wrap("", description, "\n") + join(["enum", name, join(directives, " "), block(values)], " ")
  },
  EnumValueDefinition: {
    leave: ({ description, name, directives }) => wrap("", description, "\n") + join([name, join(directives, " ")], " ")
  },
  InputObjectTypeDefinition: {
    leave: ({ description, name, directives, fields }) => wrap("", description, "\n") + join(["input", name, join(directives, " "), block(fields)], " ")
  },
  DirectiveDefinition: {
    leave: ({ description, name, arguments: args, repeatable, locations }) => wrap("", description, "\n") + "directive @" + name + (hasMultilineItems(args) ? wrap("(\n", indent(join(args, "\n")), "\n)") : wrap("(", join(args, ", "), ")")) + (repeatable ? " repeatable" : "") + " on " + join(locations, " | ")
  },
  SchemaExtension: {
    leave: ({ directives, operationTypes }) => join(
      ["extend schema", join(directives, " "), block(operationTypes)],
      " "
    )
  },
  ScalarTypeExtension: {
    leave: ({ name, directives }) => join(["extend scalar", name, join(directives, " ")], " ")
  },
  ObjectTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend type",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  InterfaceTypeExtension: {
    leave: ({ name, interfaces, directives, fields }) => join(
      [
        "extend interface",
        name,
        wrap("implements ", join(interfaces, " & ")),
        join(directives, " "),
        block(fields)
      ],
      " "
    )
  },
  UnionTypeExtension: {
    leave: ({ name, directives, types }) => join(
      [
        "extend union",
        name,
        join(directives, " "),
        wrap("= ", join(types, " | "))
      ],
      " "
    )
  },
  EnumTypeExtension: {
    leave: ({ name, directives, values }) => join(["extend enum", name, join(directives, " "), block(values)], " ")
  },
  InputObjectTypeExtension: {
    leave: ({ name, directives, fields }) => join(["extend input", name, join(directives, " "), block(fields)], " ")
  }
};
function join(maybeArray, separator = "") {
  var _maybeArray$filter$jo;
  return (_maybeArray$filter$jo = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.filter((x2) => x2).join(separator)) !== null && _maybeArray$filter$jo !== void 0 ? _maybeArray$filter$jo : "";
}
function block(array) {
  return wrap("{\n", indent(join(array, "\n")), "\n}");
}
function wrap(start, maybeString, end = "") {
  return maybeString != null && maybeString !== "" ? start + maybeString + end : "";
}
function indent(str) {
  return wrap("  ", str.replace(/\n/g, "\n  "));
}
function hasMultilineItems(maybeArray) {
  var _maybeArray$some;
  return (_maybeArray$some = maybeArray === null || maybeArray === void 0 ? void 0 : maybeArray.some((str) => str.includes("\n"))) !== null && _maybeArray$some !== void 0 ? _maybeArray$some : false;
}

// node_modules/graphql/utilities/valueFromASTUntyped.mjs
function valueFromASTUntyped(valueNode, variables) {
  switch (valueNode.kind) {
    case Kind.NULL:
      return null;
    case Kind.INT:
      return parseInt(valueNode.value, 10);
    case Kind.FLOAT:
      return parseFloat(valueNode.value);
    case Kind.STRING:
    case Kind.ENUM:
    case Kind.BOOLEAN:
      return valueNode.value;
    case Kind.LIST:
      return valueNode.values.map(
        (node) => valueFromASTUntyped(node, variables)
      );
    case Kind.OBJECT:
      return keyValMap(
        valueNode.fields,
        (field) => field.name.value,
        (field) => valueFromASTUntyped(field.value, variables)
      );
    case Kind.VARIABLE:
      return variables === null || variables === void 0 ? void 0 : variables[valueNode.name.value];
  }
}

// node_modules/graphql/type/assertName.mjs
function assertName(name) {
  name != null || devAssert(false, "Must provide name.");
  typeof name === "string" || devAssert(false, "Expected name to be a string.");
  if (name.length === 0) {
    throw new GraphQLError("Expected name to be a non-empty string.");
  }
  for (let i4 = 1; i4 < name.length; ++i4) {
    if (!isNameContinue(name.charCodeAt(i4))) {
      throw new GraphQLError(
        `Names must only contain [_a-zA-Z0-9] but "${name}" does not.`
      );
    }
  }
  if (!isNameStart(name.charCodeAt(0))) {
    throw new GraphQLError(
      `Names must start with [_a-zA-Z] but "${name}" does not.`
    );
  }
  return name;
}
function assertEnumValueName(name) {
  if (name === "true" || name === "false" || name === "null") {
    throw new GraphQLError(`Enum values cannot be named: ${name}`);
  }
  return assertName(name);
}

// node_modules/graphql/type/definition.mjs
function isType(type) {
  return isScalarType(type) || isObjectType(type) || isInterfaceType(type) || isUnionType(type) || isEnumType(type) || isInputObjectType(type) || isListType(type) || isNonNullType(type);
}
function isScalarType(type) {
  return instanceOf(type, GraphQLScalarType);
}
function isObjectType(type) {
  return instanceOf(type, GraphQLObjectType);
}
function isInterfaceType(type) {
  return instanceOf(type, GraphQLInterfaceType);
}
function isUnionType(type) {
  return instanceOf(type, GraphQLUnionType);
}
function isEnumType(type) {
  return instanceOf(type, GraphQLEnumType);
}
function isInputObjectType(type) {
  return instanceOf(type, GraphQLInputObjectType);
}
function isListType(type) {
  return instanceOf(type, GraphQLList);
}
function isNonNullType(type) {
  return instanceOf(type, GraphQLNonNull);
}
function isInputType(type) {
  return isScalarType(type) || isEnumType(type) || isInputObjectType(type) || isWrappingType(type) && isInputType(type.ofType);
}
function isLeafType(type) {
  return isScalarType(type) || isEnumType(type);
}
function isCompositeType(type) {
  return isObjectType(type) || isInterfaceType(type) || isUnionType(type);
}
function isAbstractType(type) {
  return isInterfaceType(type) || isUnionType(type);
}
var GraphQLList = class {
  constructor(ofType) {
    isType(ofType) || devAssert(false, `Expected ${inspect(ofType)} to be a GraphQL type.`);
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLList";
  }
  toString() {
    return "[" + String(this.ofType) + "]";
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLNonNull = class {
  constructor(ofType) {
    isNullableType(ofType) || devAssert(
      false,
      `Expected ${inspect(ofType)} to be a GraphQL nullable type.`
    );
    this.ofType = ofType;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLNonNull";
  }
  toString() {
    return String(this.ofType) + "!";
  }
  toJSON() {
    return this.toString();
  }
};
function isWrappingType(type) {
  return isListType(type) || isNonNullType(type);
}
function isNullableType(type) {
  return isType(type) && !isNonNullType(type);
}
function getNullableType(type) {
  if (type) {
    return isNonNullType(type) ? type.ofType : type;
  }
}
function getNamedType(type) {
  if (type) {
    let unwrappedType = type;
    while (isWrappingType(unwrappedType)) {
      unwrappedType = unwrappedType.ofType;
    }
    return unwrappedType;
  }
}
function resolveReadonlyArrayThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
function resolveObjMapThunk(thunk) {
  return typeof thunk === "function" ? thunk() : thunk;
}
var GraphQLScalarType = class {
  constructor(config) {
    var _config$parseValue, _config$serialize, _config$parseLiteral, _config$extensionASTN;
    const parseValue2 = (_config$parseValue = config.parseValue) !== null && _config$parseValue !== void 0 ? _config$parseValue : identityFunc;
    this.name = assertName(config.name);
    this.description = config.description;
    this.specifiedByURL = config.specifiedByURL;
    this.serialize = (_config$serialize = config.serialize) !== null && _config$serialize !== void 0 ? _config$serialize : identityFunc;
    this.parseValue = parseValue2;
    this.parseLiteral = (_config$parseLiteral = config.parseLiteral) !== null && _config$parseLiteral !== void 0 ? _config$parseLiteral : (node, variables) => parseValue2(valueFromASTUntyped(node, variables));
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN = config.extensionASTNodes) !== null && _config$extensionASTN !== void 0 ? _config$extensionASTN : [];
    config.specifiedByURL == null || typeof config.specifiedByURL === "string" || devAssert(
      false,
      `${this.name} must provide "specifiedByURL" as a string, but got: ${inspect(config.specifiedByURL)}.`
    );
    config.serialize == null || typeof config.serialize === "function" || devAssert(
      false,
      `${this.name} must provide "serialize" function. If this custom Scalar is also used as an input type, ensure "parseValue" and "parseLiteral" functions are also provided.`
    );
    if (config.parseLiteral) {
      typeof config.parseValue === "function" && typeof config.parseLiteral === "function" || devAssert(
        false,
        `${this.name} must provide both "parseValue" and "parseLiteral" functions.`
      );
    }
  }
  get [Symbol.toStringTag]() {
    return "GraphQLScalarType";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      specifiedByURL: this.specifiedByURL,
      serialize: this.serialize,
      parseValue: this.parseValue,
      parseLiteral: this.parseLiteral,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLObjectType = class {
  constructor(config) {
    var _config$extensionASTN2;
    this.name = assertName(config.name);
    this.description = config.description;
    this.isTypeOf = config.isTypeOf;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN2 = config.extensionASTNodes) !== null && _config$extensionASTN2 !== void 0 ? _config$extensionASTN2 : [];
    this._fields = () => defineFieldMap(config);
    this._interfaces = () => defineInterfaces(config);
    config.isTypeOf == null || typeof config.isTypeOf === "function" || devAssert(
      false,
      `${this.name} must provide "isTypeOf" as a function, but got: ${inspect(config.isTypeOf)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      isTypeOf: this.isTypeOf,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInterfaces(config) {
  var _config$interfaces;
  const interfaces = resolveReadonlyArrayThunk(
    (_config$interfaces = config.interfaces) !== null && _config$interfaces !== void 0 ? _config$interfaces : []
  );
  Array.isArray(interfaces) || devAssert(
    false,
    `${config.name} interfaces must be an Array or a function which returns an Array.`
  );
  return interfaces;
}
function defineFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    var _fieldConfig$args;
    isPlainObj(fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field config must be an object.`
    );
    fieldConfig.resolve == null || typeof fieldConfig.resolve === "function" || devAssert(
      false,
      `${config.name}.${fieldName} field resolver must be a function if provided, but got: ${inspect(fieldConfig.resolve)}.`
    );
    const argsConfig = (_fieldConfig$args = fieldConfig.args) !== null && _fieldConfig$args !== void 0 ? _fieldConfig$args : {};
    isPlainObj(argsConfig) || devAssert(
      false,
      `${config.name}.${fieldName} args must be an object with argument names as keys.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      args: defineArguments(argsConfig),
      resolve: fieldConfig.resolve,
      subscribe: fieldConfig.subscribe,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function defineArguments(config) {
  return Object.entries(config).map(([argName, argConfig]) => ({
    name: assertName(argName),
    description: argConfig.description,
    type: argConfig.type,
    defaultValue: argConfig.defaultValue,
    deprecationReason: argConfig.deprecationReason,
    extensions: toObjMap(argConfig.extensions),
    astNode: argConfig.astNode
  }));
}
function isPlainObj(obj) {
  return isObjectLike(obj) && !Array.isArray(obj);
}
function fieldsToFieldsConfig(fields) {
  return mapValue(fields, (field) => ({
    description: field.description,
    type: field.type,
    args: argsToArgsConfig(field.args),
    resolve: field.resolve,
    subscribe: field.subscribe,
    deprecationReason: field.deprecationReason,
    extensions: field.extensions,
    astNode: field.astNode
  }));
}
function argsToArgsConfig(args) {
  return keyValMap(
    args,
    (arg) => arg.name,
    (arg) => ({
      description: arg.description,
      type: arg.type,
      defaultValue: arg.defaultValue,
      deprecationReason: arg.deprecationReason,
      extensions: arg.extensions,
      astNode: arg.astNode
    })
  );
}
function isRequiredArgument(arg) {
  return isNonNullType(arg.type) && arg.defaultValue === void 0;
}
var GraphQLInterfaceType = class {
  constructor(config) {
    var _config$extensionASTN3;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN3 = config.extensionASTNodes) !== null && _config$extensionASTN3 !== void 0 ? _config$extensionASTN3 : [];
    this._fields = defineFieldMap.bind(void 0, config);
    this._interfaces = defineInterfaces.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInterfaceType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  getInterfaces() {
    if (typeof this._interfaces === "function") {
      this._interfaces = this._interfaces();
    }
    return this._interfaces;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      interfaces: this.getInterfaces(),
      fields: fieldsToFieldsConfig(this.getFields()),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLUnionType = class {
  constructor(config) {
    var _config$extensionASTN4;
    this.name = assertName(config.name);
    this.description = config.description;
    this.resolveType = config.resolveType;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN4 = config.extensionASTNodes) !== null && _config$extensionASTN4 !== void 0 ? _config$extensionASTN4 : [];
    this._types = defineTypes.bind(void 0, config);
    config.resolveType == null || typeof config.resolveType === "function" || devAssert(
      false,
      `${this.name} must provide "resolveType" as a function, but got: ${inspect(config.resolveType)}.`
    );
  }
  get [Symbol.toStringTag]() {
    return "GraphQLUnionType";
  }
  getTypes() {
    if (typeof this._types === "function") {
      this._types = this._types();
    }
    return this._types;
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      types: this.getTypes(),
      resolveType: this.resolveType,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineTypes(config) {
  const types = resolveReadonlyArrayThunk(config.types);
  Array.isArray(types) || devAssert(
    false,
    `Must provide Array of types or a function which returns such an array for Union ${config.name}.`
  );
  return types;
}
var GraphQLEnumType = class {
  /* <T> */
  constructor(config) {
    var _config$extensionASTN5;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN5 = config.extensionASTNodes) !== null && _config$extensionASTN5 !== void 0 ? _config$extensionASTN5 : [];
    this._values = typeof config.values === "function" ? config.values : defineEnumValues(this.name, config.values);
    this._valueLookup = null;
    this._nameLookup = null;
  }
  get [Symbol.toStringTag]() {
    return "GraphQLEnumType";
  }
  getValues() {
    if (typeof this._values === "function") {
      this._values = defineEnumValues(this.name, this._values());
    }
    return this._values;
  }
  getValue(name) {
    if (this._nameLookup === null) {
      this._nameLookup = keyMap(this.getValues(), (value) => value.name);
    }
    return this._nameLookup[name];
  }
  serialize(outputValue) {
    if (this._valueLookup === null) {
      this._valueLookup = new Map(
        this.getValues().map((enumValue2) => [enumValue2.value, enumValue2])
      );
    }
    const enumValue = this._valueLookup.get(outputValue);
    if (enumValue === void 0) {
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent value: ${inspect(outputValue)}`
      );
    }
    return enumValue.name;
  }
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      const valueStr = inspect(inputValue);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-string value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr)
      );
    }
    const enumValue = this.getValue(inputValue);
    if (enumValue == null) {
      throw new GraphQLError(
        `Value "${inputValue}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, inputValue)
      );
    }
    return enumValue.value;
  }
  parseLiteral(valueNode, _variables) {
    if (valueNode.kind !== Kind.ENUM) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Enum "${this.name}" cannot represent non-enum value: ${valueStr}.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    const enumValue = this.getValue(valueNode.value);
    if (enumValue == null) {
      const valueStr = print(valueNode);
      throw new GraphQLError(
        `Value "${valueStr}" does not exist in "${this.name}" enum.` + didYouMeanEnumValue(this, valueStr),
        {
          nodes: valueNode
        }
      );
    }
    return enumValue.value;
  }
  toConfig() {
    const values = keyValMap(
      this.getValues(),
      (value) => value.name,
      (value) => ({
        description: value.description,
        value: value.value,
        deprecationReason: value.deprecationReason,
        extensions: value.extensions,
        astNode: value.astNode
      })
    );
    return {
      name: this.name,
      description: this.description,
      values,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function didYouMeanEnumValue(enumType, unknownValueStr) {
  const allNames = enumType.getValues().map((value) => value.name);
  const suggestedValues = suggestionList(unknownValueStr, allNames);
  return didYouMean("the enum value", suggestedValues);
}
function defineEnumValues(typeName, valueMap) {
  isPlainObj(valueMap) || devAssert(
    false,
    `${typeName} values must be an object with value names as keys.`
  );
  return Object.entries(valueMap).map(([valueName, valueConfig]) => {
    isPlainObj(valueConfig) || devAssert(
      false,
      `${typeName}.${valueName} must refer to an object with a "value" key representing an internal value but got: ${inspect(valueConfig)}.`
    );
    return {
      name: assertEnumValueName(valueName),
      description: valueConfig.description,
      value: valueConfig.value !== void 0 ? valueConfig.value : valueName,
      deprecationReason: valueConfig.deprecationReason,
      extensions: toObjMap(valueConfig.extensions),
      astNode: valueConfig.astNode
    };
  });
}
var GraphQLInputObjectType = class {
  constructor(config) {
    var _config$extensionASTN6, _config$isOneOf;
    this.name = assertName(config.name);
    this.description = config.description;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    this.extensionASTNodes = (_config$extensionASTN6 = config.extensionASTNodes) !== null && _config$extensionASTN6 !== void 0 ? _config$extensionASTN6 : [];
    this.isOneOf = (_config$isOneOf = config.isOneOf) !== null && _config$isOneOf !== void 0 ? _config$isOneOf : false;
    this._fields = defineInputFieldMap.bind(void 0, config);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLInputObjectType";
  }
  getFields() {
    if (typeof this._fields === "function") {
      this._fields = this._fields();
    }
    return this._fields;
  }
  toConfig() {
    const fields = mapValue(this.getFields(), (field) => ({
      description: field.description,
      type: field.type,
      defaultValue: field.defaultValue,
      deprecationReason: field.deprecationReason,
      extensions: field.extensions,
      astNode: field.astNode
    }));
    return {
      name: this.name,
      description: this.description,
      fields,
      extensions: this.extensions,
      astNode: this.astNode,
      extensionASTNodes: this.extensionASTNodes,
      isOneOf: this.isOneOf
    };
  }
  toString() {
    return this.name;
  }
  toJSON() {
    return this.toString();
  }
};
function defineInputFieldMap(config) {
  const fieldMap = resolveObjMapThunk(config.fields);
  isPlainObj(fieldMap) || devAssert(
    false,
    `${config.name} fields must be an object with field names as keys or a function which returns such an object.`
  );
  return mapValue(fieldMap, (fieldConfig, fieldName) => {
    !("resolve" in fieldConfig) || devAssert(
      false,
      `${config.name}.${fieldName} field has a resolve property, but Input Types cannot define resolvers.`
    );
    return {
      name: assertName(fieldName),
      description: fieldConfig.description,
      type: fieldConfig.type,
      defaultValue: fieldConfig.defaultValue,
      deprecationReason: fieldConfig.deprecationReason,
      extensions: toObjMap(fieldConfig.extensions),
      astNode: fieldConfig.astNode
    };
  });
}
function isRequiredInputField(field) {
  return isNonNullType(field.type) && field.defaultValue === void 0;
}

// node_modules/graphql/utilities/typeComparators.mjs
function isTypeSubTypeOf(schema, maybeSubType, superType) {
  if (maybeSubType === superType) {
    return true;
  }
  if (isNonNullType(superType)) {
    if (isNonNullType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isNonNullType(maybeSubType)) {
    return isTypeSubTypeOf(schema, maybeSubType.ofType, superType);
  }
  if (isListType(superType)) {
    if (isListType(maybeSubType)) {
      return isTypeSubTypeOf(schema, maybeSubType.ofType, superType.ofType);
    }
    return false;
  }
  if (isListType(maybeSubType)) {
    return false;
  }
  return isAbstractType(superType) && (isInterfaceType(maybeSubType) || isObjectType(maybeSubType)) && schema.isSubType(superType, maybeSubType);
}
function doTypesOverlap(schema, typeA, typeB) {
  if (typeA === typeB) {
    return true;
  }
  if (isAbstractType(typeA)) {
    if (isAbstractType(typeB)) {
      return schema.getPossibleTypes(typeA).some((type) => schema.isSubType(typeB, type));
    }
    return schema.isSubType(typeA, typeB);
  }
  if (isAbstractType(typeB)) {
    return schema.isSubType(typeB, typeA);
  }
  return false;
}

// node_modules/graphql/type/scalars.mjs
var GRAPHQL_MAX_INT = 2147483647;
var GRAPHQL_MIN_INT = -2147483648;
var GraphQLInt = new GraphQLScalarType({
  name: "Int",
  description: "The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isInteger(num)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(coercedValue)}`
      );
    }
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        "Int cannot represent non 32-bit signed integer value: " + inspect(coercedValue)
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isInteger(inputValue)) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${inspect(inputValue)}`
      );
    }
    if (inputValue > GRAPHQL_MAX_INT || inputValue < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${inputValue}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Int cannot represent non-integer value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    const num = parseInt(valueNode.value, 10);
    if (num > GRAPHQL_MAX_INT || num < GRAPHQL_MIN_INT) {
      throw new GraphQLError(
        `Int cannot represent non 32-bit signed integer value: ${valueNode.value}`,
        {
          nodes: valueNode
        }
      );
    }
    return num;
  }
});
var GraphQLFloat = new GraphQLScalarType({
  name: "Float",
  description: "The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue ? 1 : 0;
    }
    let num = coercedValue;
    if (typeof coercedValue === "string" && coercedValue !== "") {
      num = Number(coercedValue);
    }
    if (typeof num !== "number" || !Number.isFinite(num)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(coercedValue)}`
      );
    }
    return num;
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "number" || !Number.isFinite(inputValue)) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.FLOAT && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        `Float cannot represent non numeric value: ${print(valueNode)}`,
        valueNode
      );
    }
    return parseFloat(valueNode.value);
  }
});
var GraphQLString = new GraphQLScalarType({
  name: "String",
  description: "The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (typeof coercedValue === "boolean") {
      return coercedValue ? "true" : "false";
    }
    if (typeof coercedValue === "number" && Number.isFinite(coercedValue)) {
      return coercedValue.toString();
    }
    throw new GraphQLError(
      `String cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "string") {
      throw new GraphQLError(
        `String cannot represent a non string value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING) {
      throw new GraphQLError(
        `String cannot represent a non string value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLBoolean = new GraphQLScalarType({
  name: "Boolean",
  description: "The `Boolean` scalar type represents `true` or `false`.",
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "boolean") {
      return coercedValue;
    }
    if (Number.isFinite(coercedValue)) {
      return coercedValue !== 0;
    }
    throw new GraphQLError(
      `Boolean cannot represent a non boolean value: ${inspect(coercedValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue !== "boolean") {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${inspect(inputValue)}`
      );
    }
    return inputValue;
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.BOOLEAN) {
      throw new GraphQLError(
        `Boolean cannot represent a non boolean value: ${print(valueNode)}`,
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var GraphQLID = new GraphQLScalarType({
  name: "ID",
  description: 'The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.',
  serialize(outputValue) {
    const coercedValue = serializeObject(outputValue);
    if (typeof coercedValue === "string") {
      return coercedValue;
    }
    if (Number.isInteger(coercedValue)) {
      return String(coercedValue);
    }
    throw new GraphQLError(
      `ID cannot represent value: ${inspect(outputValue)}`
    );
  },
  parseValue(inputValue) {
    if (typeof inputValue === "string") {
      return inputValue;
    }
    if (typeof inputValue === "number" && Number.isInteger(inputValue)) {
      return inputValue.toString();
    }
    throw new GraphQLError(`ID cannot represent value: ${inspect(inputValue)}`);
  },
  parseLiteral(valueNode) {
    if (valueNode.kind !== Kind.STRING && valueNode.kind !== Kind.INT) {
      throw new GraphQLError(
        "ID cannot represent a non-string and non-integer value: " + print(valueNode),
        {
          nodes: valueNode
        }
      );
    }
    return valueNode.value;
  }
});
var specifiedScalarTypes = Object.freeze([
  GraphQLString,
  GraphQLInt,
  GraphQLFloat,
  GraphQLBoolean,
  GraphQLID
]);
function serializeObject(outputValue) {
  if (isObjectLike(outputValue)) {
    if (typeof outputValue.valueOf === "function") {
      const valueOfResult = outputValue.valueOf();
      if (!isObjectLike(valueOfResult)) {
        return valueOfResult;
      }
    }
    if (typeof outputValue.toJSON === "function") {
      return outputValue.toJSON();
    }
  }
  return outputValue;
}

// node_modules/graphql/type/directives.mjs
var GraphQLDirective = class {
  constructor(config) {
    var _config$isRepeatable, _config$args;
    this.name = assertName(config.name);
    this.description = config.description;
    this.locations = config.locations;
    this.isRepeatable = (_config$isRepeatable = config.isRepeatable) !== null && _config$isRepeatable !== void 0 ? _config$isRepeatable : false;
    this.extensions = toObjMap(config.extensions);
    this.astNode = config.astNode;
    Array.isArray(config.locations) || devAssert(false, `@${config.name} locations must be an Array.`);
    const args = (_config$args = config.args) !== null && _config$args !== void 0 ? _config$args : {};
    isObjectLike(args) && !Array.isArray(args) || devAssert(
      false,
      `@${config.name} args must be an object with argument names as keys.`
    );
    this.args = defineArguments(args);
  }
  get [Symbol.toStringTag]() {
    return "GraphQLDirective";
  }
  toConfig() {
    return {
      name: this.name,
      description: this.description,
      locations: this.locations,
      args: argsToArgsConfig(this.args),
      isRepeatable: this.isRepeatable,
      extensions: this.extensions,
      astNode: this.astNode
    };
  }
  toString() {
    return "@" + this.name;
  }
  toJSON() {
    return this.toString();
  }
};
var GraphQLIncludeDirective = new GraphQLDirective({
  name: "include",
  description: "Directs the executor to include this field or fragment only when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Included when true."
    }
  }
});
var GraphQLSkipDirective = new GraphQLDirective({
  name: "skip",
  description: "Directs the executor to skip this field or fragment when the `if` argument is true.",
  locations: [
    DirectiveLocation.FIELD,
    DirectiveLocation.FRAGMENT_SPREAD,
    DirectiveLocation.INLINE_FRAGMENT
  ],
  args: {
    if: {
      type: new GraphQLNonNull(GraphQLBoolean),
      description: "Skipped when true."
    }
  }
});
var DEFAULT_DEPRECATION_REASON = "No longer supported";
var GraphQLDeprecatedDirective = new GraphQLDirective({
  name: "deprecated",
  description: "Marks an element of a GraphQL schema as no longer supported.",
  locations: [
    DirectiveLocation.FIELD_DEFINITION,
    DirectiveLocation.ARGUMENT_DEFINITION,
    DirectiveLocation.INPUT_FIELD_DEFINITION,
    DirectiveLocation.ENUM_VALUE
  ],
  args: {
    reason: {
      type: GraphQLString,
      description: "Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https://commonmark.org/).",
      defaultValue: DEFAULT_DEPRECATION_REASON
    }
  }
});
var GraphQLSpecifiedByDirective = new GraphQLDirective({
  name: "specifiedBy",
  description: "Exposes a URL that specifies the behavior of this scalar.",
  locations: [DirectiveLocation.SCALAR],
  args: {
    url: {
      type: new GraphQLNonNull(GraphQLString),
      description: "The URL that specifies the behavior of this scalar."
    }
  }
});
var GraphQLOneOfDirective = new GraphQLDirective({
  name: "oneOf",
  description: "Indicates exactly one field must be supplied and this field must not be `null`.",
  locations: [DirectiveLocation.INPUT_OBJECT],
  args: {}
});
var specifiedDirectives = Object.freeze([
  GraphQLIncludeDirective,
  GraphQLSkipDirective,
  GraphQLDeprecatedDirective,
  GraphQLSpecifiedByDirective,
  GraphQLOneOfDirective
]);

// node_modules/graphql/jsutils/isIterableObject.mjs
function isIterableObject(maybeIterable) {
  return typeof maybeIterable === "object" && typeof (maybeIterable === null || maybeIterable === void 0 ? void 0 : maybeIterable[Symbol.iterator]) === "function";
}

// node_modules/graphql/utilities/astFromValue.mjs
function astFromValue(value, type) {
  if (isNonNullType(type)) {
    const astValue = astFromValue(value, type.ofType);
    if ((astValue === null || astValue === void 0 ? void 0 : astValue.kind) === Kind.NULL) {
      return null;
    }
    return astValue;
  }
  if (value === null) {
    return {
      kind: Kind.NULL
    };
  }
  if (value === void 0) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (isIterableObject(value)) {
      const valuesNodes = [];
      for (const item of value) {
        const itemNode = astFromValue(item, itemType);
        if (itemNode != null) {
          valuesNodes.push(itemNode);
        }
      }
      return {
        kind: Kind.LIST,
        values: valuesNodes
      };
    }
    return astFromValue(value, itemType);
  }
  if (isInputObjectType(type)) {
    if (!isObjectLike(value)) {
      return null;
    }
    const fieldNodes = [];
    for (const field of Object.values(type.getFields())) {
      const fieldValue = astFromValue(value[field.name], field.type);
      if (fieldValue) {
        fieldNodes.push({
          kind: Kind.OBJECT_FIELD,
          name: {
            kind: Kind.NAME,
            value: field.name
          },
          value: fieldValue
        });
      }
    }
    return {
      kind: Kind.OBJECT,
      fields: fieldNodes
    };
  }
  if (isLeafType(type)) {
    const serialized = type.serialize(value);
    if (serialized == null) {
      return null;
    }
    if (typeof serialized === "boolean") {
      return {
        kind: Kind.BOOLEAN,
        value: serialized
      };
    }
    if (typeof serialized === "number" && Number.isFinite(serialized)) {
      const stringNum = String(serialized);
      return integerStringRegExp.test(stringNum) ? {
        kind: Kind.INT,
        value: stringNum
      } : {
        kind: Kind.FLOAT,
        value: stringNum
      };
    }
    if (typeof serialized === "string") {
      if (isEnumType(type)) {
        return {
          kind: Kind.ENUM,
          value: serialized
        };
      }
      if (type === GraphQLID && integerStringRegExp.test(serialized)) {
        return {
          kind: Kind.INT,
          value: serialized
        };
      }
      return {
        kind: Kind.STRING,
        value: serialized
      };
    }
    throw new TypeError(`Cannot convert value to AST: ${inspect(serialized)}.`);
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
var integerStringRegExp = /^-?(?:0|[1-9][0-9]*)$/;

// node_modules/graphql/type/introspection.mjs
var __Schema = new GraphQLObjectType({
  name: "__Schema",
  description: "A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.",
  fields: () => ({
    description: {
      type: GraphQLString,
      resolve: (schema) => schema.description
    },
    types: {
      description: "A list of all types supported by this server.",
      type: new GraphQLNonNull(new GraphQLList(new GraphQLNonNull(__Type))),
      resolve(schema) {
        return Object.values(schema.getTypeMap());
      }
    },
    queryType: {
      description: "The type that query operations will be rooted at.",
      type: new GraphQLNonNull(__Type),
      resolve: (schema) => schema.getQueryType()
    },
    mutationType: {
      description: "If this server supports mutation, the type that mutation operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getMutationType()
    },
    subscriptionType: {
      description: "If this server support subscription, the type that subscription operations will be rooted at.",
      type: __Type,
      resolve: (schema) => schema.getSubscriptionType()
    },
    directives: {
      description: "A list of all directives supported by this server.",
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__Directive))
      ),
      resolve: (schema) => schema.getDirectives()
    }
  })
});
var __Directive = new GraphQLObjectType({
  name: "__Directive",
  description: "A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.\n\nIn some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (directive) => directive.name
    },
    description: {
      type: GraphQLString,
      resolve: (directive) => directive.description
    },
    isRepeatable: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (directive) => directive.isRepeatable
    },
    locations: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__DirectiveLocation))
      ),
      resolve: (directive) => directive.locations
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    }
  })
});
var __DirectiveLocation = new GraphQLEnumType({
  name: "__DirectiveLocation",
  description: "A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.",
  values: {
    QUERY: {
      value: DirectiveLocation.QUERY,
      description: "Location adjacent to a query operation."
    },
    MUTATION: {
      value: DirectiveLocation.MUTATION,
      description: "Location adjacent to a mutation operation."
    },
    SUBSCRIPTION: {
      value: DirectiveLocation.SUBSCRIPTION,
      description: "Location adjacent to a subscription operation."
    },
    FIELD: {
      value: DirectiveLocation.FIELD,
      description: "Location adjacent to a field."
    },
    FRAGMENT_DEFINITION: {
      value: DirectiveLocation.FRAGMENT_DEFINITION,
      description: "Location adjacent to a fragment definition."
    },
    FRAGMENT_SPREAD: {
      value: DirectiveLocation.FRAGMENT_SPREAD,
      description: "Location adjacent to a fragment spread."
    },
    INLINE_FRAGMENT: {
      value: DirectiveLocation.INLINE_FRAGMENT,
      description: "Location adjacent to an inline fragment."
    },
    VARIABLE_DEFINITION: {
      value: DirectiveLocation.VARIABLE_DEFINITION,
      description: "Location adjacent to a variable definition."
    },
    SCHEMA: {
      value: DirectiveLocation.SCHEMA,
      description: "Location adjacent to a schema definition."
    },
    SCALAR: {
      value: DirectiveLocation.SCALAR,
      description: "Location adjacent to a scalar definition."
    },
    OBJECT: {
      value: DirectiveLocation.OBJECT,
      description: "Location adjacent to an object type definition."
    },
    FIELD_DEFINITION: {
      value: DirectiveLocation.FIELD_DEFINITION,
      description: "Location adjacent to a field definition."
    },
    ARGUMENT_DEFINITION: {
      value: DirectiveLocation.ARGUMENT_DEFINITION,
      description: "Location adjacent to an argument definition."
    },
    INTERFACE: {
      value: DirectiveLocation.INTERFACE,
      description: "Location adjacent to an interface definition."
    },
    UNION: {
      value: DirectiveLocation.UNION,
      description: "Location adjacent to a union definition."
    },
    ENUM: {
      value: DirectiveLocation.ENUM,
      description: "Location adjacent to an enum definition."
    },
    ENUM_VALUE: {
      value: DirectiveLocation.ENUM_VALUE,
      description: "Location adjacent to an enum value definition."
    },
    INPUT_OBJECT: {
      value: DirectiveLocation.INPUT_OBJECT,
      description: "Location adjacent to an input object type definition."
    },
    INPUT_FIELD_DEFINITION: {
      value: DirectiveLocation.INPUT_FIELD_DEFINITION,
      description: "Location adjacent to an input object field definition."
    }
  }
});
var __Type = new GraphQLObjectType({
  name: "__Type",
  description: "The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.\n\nDepending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.",
  fields: () => ({
    kind: {
      type: new GraphQLNonNull(__TypeKind),
      resolve(type) {
        if (isScalarType(type)) {
          return TypeKind.SCALAR;
        }
        if (isObjectType(type)) {
          return TypeKind.OBJECT;
        }
        if (isInterfaceType(type)) {
          return TypeKind.INTERFACE;
        }
        if (isUnionType(type)) {
          return TypeKind.UNION;
        }
        if (isEnumType(type)) {
          return TypeKind.ENUM;
        }
        if (isInputObjectType(type)) {
          return TypeKind.INPUT_OBJECT;
        }
        if (isListType(type)) {
          return TypeKind.LIST;
        }
        if (isNonNullType(type)) {
          return TypeKind.NON_NULL;
        }
        invariant(false, `Unexpected type: "${inspect(type)}".`);
      }
    },
    name: {
      type: GraphQLString,
      resolve: (type) => "name" in type ? type.name : void 0
    },
    description: {
      type: GraphQLString,
      resolve: (type) => (
        /* c8 ignore next */
        "description" in type ? type.description : void 0
      )
    },
    specifiedByURL: {
      type: GraphQLString,
      resolve: (obj) => "specifiedByURL" in obj ? obj.specifiedByURL : void 0
    },
    fields: {
      type: new GraphQLList(new GraphQLNonNull(__Field)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isObjectType(type) || isInterfaceType(type)) {
          const fields = Object.values(type.getFields());
          return includeDeprecated ? fields : fields.filter((field) => field.deprecationReason == null);
        }
      }
    },
    interfaces: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type) {
        if (isObjectType(type) || isInterfaceType(type)) {
          return type.getInterfaces();
        }
      }
    },
    possibleTypes: {
      type: new GraphQLList(new GraphQLNonNull(__Type)),
      resolve(type, _args, _context, { schema }) {
        if (isAbstractType(type)) {
          return schema.getPossibleTypes(type);
        }
      }
    },
    enumValues: {
      type: new GraphQLList(new GraphQLNonNull(__EnumValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isEnumType(type)) {
          const values = type.getValues();
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    inputFields: {
      type: new GraphQLList(new GraphQLNonNull(__InputValue)),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(type, { includeDeprecated }) {
        if (isInputObjectType(type)) {
          const values = Object.values(type.getFields());
          return includeDeprecated ? values : values.filter((field) => field.deprecationReason == null);
        }
      }
    },
    ofType: {
      type: __Type,
      resolve: (type) => "ofType" in type ? type.ofType : void 0
    },
    isOneOf: {
      type: GraphQLBoolean,
      resolve: (type) => {
        if (isInputObjectType(type)) {
          return type.isOneOf;
        }
      }
    }
  })
});
var __Field = new GraphQLObjectType({
  name: "__Field",
  description: "Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (field) => field.name
    },
    description: {
      type: GraphQLString,
      resolve: (field) => field.description
    },
    args: {
      type: new GraphQLNonNull(
        new GraphQLList(new GraphQLNonNull(__InputValue))
      ),
      args: {
        includeDeprecated: {
          type: GraphQLBoolean,
          defaultValue: false
        }
      },
      resolve(field, { includeDeprecated }) {
        return includeDeprecated ? field.args : field.args.filter((arg) => arg.deprecationReason == null);
      }
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (field) => field.type
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (field) => field.deprecationReason
    }
  })
});
var __InputValue = new GraphQLObjectType({
  name: "__InputValue",
  description: "Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (inputValue) => inputValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (inputValue) => inputValue.description
    },
    type: {
      type: new GraphQLNonNull(__Type),
      resolve: (inputValue) => inputValue.type
    },
    defaultValue: {
      type: GraphQLString,
      description: "A GraphQL-formatted string representing the default value for this input value.",
      resolve(inputValue) {
        const { type, defaultValue } = inputValue;
        const valueAST = astFromValue(defaultValue, type);
        return valueAST ? print(valueAST) : null;
      }
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (field) => field.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (obj) => obj.deprecationReason
    }
  })
});
var __EnumValue = new GraphQLObjectType({
  name: "__EnumValue",
  description: "One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.",
  fields: () => ({
    name: {
      type: new GraphQLNonNull(GraphQLString),
      resolve: (enumValue) => enumValue.name
    },
    description: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.description
    },
    isDeprecated: {
      type: new GraphQLNonNull(GraphQLBoolean),
      resolve: (enumValue) => enumValue.deprecationReason != null
    },
    deprecationReason: {
      type: GraphQLString,
      resolve: (enumValue) => enumValue.deprecationReason
    }
  })
});
var TypeKind;
(function(TypeKind2) {
  TypeKind2["SCALAR"] = "SCALAR";
  TypeKind2["OBJECT"] = "OBJECT";
  TypeKind2["INTERFACE"] = "INTERFACE";
  TypeKind2["UNION"] = "UNION";
  TypeKind2["ENUM"] = "ENUM";
  TypeKind2["INPUT_OBJECT"] = "INPUT_OBJECT";
  TypeKind2["LIST"] = "LIST";
  TypeKind2["NON_NULL"] = "NON_NULL";
})(TypeKind || (TypeKind = {}));
var __TypeKind = new GraphQLEnumType({
  name: "__TypeKind",
  description: "An enum describing what kind of type a given `__Type` is.",
  values: {
    SCALAR: {
      value: TypeKind.SCALAR,
      description: "Indicates this type is a scalar."
    },
    OBJECT: {
      value: TypeKind.OBJECT,
      description: "Indicates this type is an object. `fields` and `interfaces` are valid fields."
    },
    INTERFACE: {
      value: TypeKind.INTERFACE,
      description: "Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields."
    },
    UNION: {
      value: TypeKind.UNION,
      description: "Indicates this type is a union. `possibleTypes` is a valid field."
    },
    ENUM: {
      value: TypeKind.ENUM,
      description: "Indicates this type is an enum. `enumValues` is a valid field."
    },
    INPUT_OBJECT: {
      value: TypeKind.INPUT_OBJECT,
      description: "Indicates this type is an input object. `inputFields` is a valid field."
    },
    LIST: {
      value: TypeKind.LIST,
      description: "Indicates this type is a list. `ofType` is a valid field."
    },
    NON_NULL: {
      value: TypeKind.NON_NULL,
      description: "Indicates this type is a non-null. `ofType` is a valid field."
    }
  }
});
var SchemaMetaFieldDef = {
  name: "__schema",
  type: new GraphQLNonNull(__Schema),
  description: "Access the current type schema of this server.",
  args: [],
  resolve: (_source, _args, _context, { schema }) => schema,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeMetaFieldDef = {
  name: "__type",
  type: __Type,
  description: "Request the type information of a single type.",
  args: [
    {
      name: "name",
      description: void 0,
      type: new GraphQLNonNull(GraphQLString),
      defaultValue: void 0,
      deprecationReason: void 0,
      extensions: /* @__PURE__ */ Object.create(null),
      astNode: void 0
    }
  ],
  resolve: (_source, { name }, _context, { schema }) => schema.getType(name),
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var TypeNameMetaFieldDef = {
  name: "__typename",
  type: new GraphQLNonNull(GraphQLString),
  description: "The name of the current Object type at runtime.",
  args: [],
  resolve: (_source, _args, _context, { parentType }) => parentType.name,
  deprecationReason: void 0,
  extensions: /* @__PURE__ */ Object.create(null),
  astNode: void 0
};
var introspectionTypes = Object.freeze([
  __Schema,
  __Directive,
  __DirectiveLocation,
  __Type,
  __Field,
  __InputValue,
  __EnumValue,
  __TypeKind
]);

// node_modules/graphql/utilities/typeFromAST.mjs
function typeFromAST(schema, typeNode) {
  switch (typeNode.kind) {
    case Kind.LIST_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLList(innerType);
    }
    case Kind.NON_NULL_TYPE: {
      const innerType = typeFromAST(schema, typeNode.type);
      return innerType && new GraphQLNonNull(innerType);
    }
    case Kind.NAMED_TYPE:
      return schema.getType(typeNode.name.value);
  }
}

// node_modules/graphql/language/predicates.mjs
function isExecutableDefinitionNode(node) {
  return node.kind === Kind.OPERATION_DEFINITION || node.kind === Kind.FRAGMENT_DEFINITION;
}
function isTypeSystemDefinitionNode(node) {
  return node.kind === Kind.SCHEMA_DEFINITION || isTypeDefinitionNode(node) || node.kind === Kind.DIRECTIVE_DEFINITION;
}
function isTypeDefinitionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_DEFINITION || node.kind === Kind.OBJECT_TYPE_DEFINITION || node.kind === Kind.INTERFACE_TYPE_DEFINITION || node.kind === Kind.UNION_TYPE_DEFINITION || node.kind === Kind.ENUM_TYPE_DEFINITION || node.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION;
}
function isTypeSystemExtensionNode(node) {
  return node.kind === Kind.SCHEMA_EXTENSION || isTypeExtensionNode(node);
}
function isTypeExtensionNode(node) {
  return node.kind === Kind.SCALAR_TYPE_EXTENSION || node.kind === Kind.OBJECT_TYPE_EXTENSION || node.kind === Kind.INTERFACE_TYPE_EXTENSION || node.kind === Kind.UNION_TYPE_EXTENSION || node.kind === Kind.ENUM_TYPE_EXTENSION || node.kind === Kind.INPUT_OBJECT_TYPE_EXTENSION;
}

// node_modules/graphql/validation/rules/ExecutableDefinitionsRule.mjs
function ExecutableDefinitionsRule(context) {
  return {
    Document(node) {
      for (const definition of node.definitions) {
        if (!isExecutableDefinitionNode(definition)) {
          const defName = definition.kind === Kind.SCHEMA_DEFINITION || definition.kind === Kind.SCHEMA_EXTENSION ? "schema" : '"' + definition.name.value + '"';
          context.reportError(
            new GraphQLError(`The ${defName} definition is not executable.`, {
              nodes: definition
            })
          );
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/FieldsOnCorrectTypeRule.mjs
function FieldsOnCorrectTypeRule(context) {
  return {
    Field(node) {
      const type = context.getParentType();
      if (type) {
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          const schema = context.getSchema();
          const fieldName = node.name.value;
          let suggestion = didYouMean(
            "to use an inline fragment on",
            getSuggestedTypeNames(schema, type, fieldName)
          );
          if (suggestion === "") {
            suggestion = didYouMean(getSuggestedFieldNames(type, fieldName));
          }
          context.reportError(
            new GraphQLError(
              `Cannot query field "${fieldName}" on type "${type.name}".` + suggestion,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}
function getSuggestedTypeNames(schema, type, fieldName) {
  if (!isAbstractType(type)) {
    return [];
  }
  const suggestedTypes = /* @__PURE__ */ new Set();
  const usageCount = /* @__PURE__ */ Object.create(null);
  for (const possibleType of schema.getPossibleTypes(type)) {
    if (!possibleType.getFields()[fieldName]) {
      continue;
    }
    suggestedTypes.add(possibleType);
    usageCount[possibleType.name] = 1;
    for (const possibleInterface of possibleType.getInterfaces()) {
      var _usageCount$possibleI;
      if (!possibleInterface.getFields()[fieldName]) {
        continue;
      }
      suggestedTypes.add(possibleInterface);
      usageCount[possibleInterface.name] = ((_usageCount$possibleI = usageCount[possibleInterface.name]) !== null && _usageCount$possibleI !== void 0 ? _usageCount$possibleI : 0) + 1;
    }
  }
  return [...suggestedTypes].sort((typeA, typeB) => {
    const usageCountDiff = usageCount[typeB.name] - usageCount[typeA.name];
    if (usageCountDiff !== 0) {
      return usageCountDiff;
    }
    if (isInterfaceType(typeA) && schema.isSubType(typeA, typeB)) {
      return -1;
    }
    if (isInterfaceType(typeB) && schema.isSubType(typeB, typeA)) {
      return 1;
    }
    return naturalCompare(typeA.name, typeB.name);
  }).map((x2) => x2.name);
}
function getSuggestedFieldNames(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type)) {
    const possibleFieldNames = Object.keys(type.getFields());
    return suggestionList(fieldName, possibleFieldNames);
  }
  return [];
}

// node_modules/graphql/validation/rules/FragmentsOnCompositeTypesRule.mjs
function FragmentsOnCompositeTypesRule(context) {
  return {
    InlineFragment(node) {
      const typeCondition = node.typeCondition;
      if (typeCondition) {
        const type = typeFromAST(context.getSchema(), typeCondition);
        if (type && !isCompositeType(type)) {
          const typeStr = print(typeCondition);
          context.reportError(
            new GraphQLError(
              `Fragment cannot condition on non composite type "${typeStr}".`,
              {
                nodes: typeCondition
              }
            )
          );
        }
      }
    },
    FragmentDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.typeCondition);
      if (type && !isCompositeType(type)) {
        const typeStr = print(node.typeCondition);
        context.reportError(
          new GraphQLError(
            `Fragment "${node.name.value}" cannot condition on non composite type "${typeStr}".`,
            {
              nodes: node.typeCondition
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownArgumentNamesRule.mjs
function KnownArgumentNamesRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...KnownArgumentNamesOnDirectivesRule(context),
    Argument(argNode) {
      const argDef = context.getArgument();
      const fieldDef = context.getFieldDef();
      const parentType = context.getParentType();
      if (!argDef && fieldDef && parentType) {
        const argName = argNode.name.value;
        const knownArgsNames = fieldDef.args.map((arg) => arg.name);
        const suggestions = suggestionList(argName, knownArgsNames);
        context.reportError(
          new GraphQLError(
            `Unknown argument "${argName}" on field "${parentType.name}.${fieldDef.name}".` + didYouMean(suggestions),
            {
              nodes: argNode
            }
          )
        );
      }
    }
  };
}
function KnownArgumentNamesOnDirectivesRule(context) {
  const directiveArgs = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    directiveArgs[directive.name] = directive.args.map((arg) => arg.name);
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argsNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      directiveArgs[def.name.value] = argsNodes.map((arg) => arg.name.value);
    }
  }
  return {
    Directive(directiveNode) {
      const directiveName = directiveNode.name.value;
      const knownArgs = directiveArgs[directiveName];
      if (directiveNode.arguments && knownArgs) {
        for (const argNode of directiveNode.arguments) {
          const argName = argNode.name.value;
          if (!knownArgs.includes(argName)) {
            const suggestions = suggestionList(argName, knownArgs);
            context.reportError(
              new GraphQLError(
                `Unknown argument "${argName}" on directive "@${directiveName}".` + didYouMean(suggestions),
                {
                  nodes: argNode
                }
              )
            );
          }
        }
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/KnownDirectivesRule.mjs
function KnownDirectivesRule(context) {
  const locationsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    locationsMap[directive.name] = directive.locations;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      locationsMap[def.name.value] = def.locations.map((name) => name.value);
    }
  }
  return {
    Directive(node, _key, _parent, _path, ancestors) {
      const name = node.name.value;
      const locations = locationsMap[name];
      if (!locations) {
        context.reportError(
          new GraphQLError(`Unknown directive "@${name}".`, {
            nodes: node
          })
        );
        return;
      }
      const candidateLocation = getDirectiveLocationForASTPath(ancestors);
      if (candidateLocation && !locations.includes(candidateLocation)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${name}" may not be used on ${candidateLocation}.`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getDirectiveLocationForASTPath(ancestors) {
  const appliedTo = ancestors[ancestors.length - 1];
  "kind" in appliedTo || invariant(false);
  switch (appliedTo.kind) {
    case Kind.OPERATION_DEFINITION:
      return getDirectiveLocationForOperation(appliedTo.operation);
    case Kind.FIELD:
      return DirectiveLocation.FIELD;
    case Kind.FRAGMENT_SPREAD:
      return DirectiveLocation.FRAGMENT_SPREAD;
    case Kind.INLINE_FRAGMENT:
      return DirectiveLocation.INLINE_FRAGMENT;
    case Kind.FRAGMENT_DEFINITION:
      return DirectiveLocation.FRAGMENT_DEFINITION;
    case Kind.VARIABLE_DEFINITION:
      return DirectiveLocation.VARIABLE_DEFINITION;
    case Kind.SCHEMA_DEFINITION:
    case Kind.SCHEMA_EXTENSION:
      return DirectiveLocation.SCHEMA;
    case Kind.SCALAR_TYPE_DEFINITION:
    case Kind.SCALAR_TYPE_EXTENSION:
      return DirectiveLocation.SCALAR;
    case Kind.OBJECT_TYPE_DEFINITION:
    case Kind.OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.OBJECT;
    case Kind.FIELD_DEFINITION:
      return DirectiveLocation.FIELD_DEFINITION;
    case Kind.INTERFACE_TYPE_DEFINITION:
    case Kind.INTERFACE_TYPE_EXTENSION:
      return DirectiveLocation.INTERFACE;
    case Kind.UNION_TYPE_DEFINITION:
    case Kind.UNION_TYPE_EXTENSION:
      return DirectiveLocation.UNION;
    case Kind.ENUM_TYPE_DEFINITION:
    case Kind.ENUM_TYPE_EXTENSION:
      return DirectiveLocation.ENUM;
    case Kind.ENUM_VALUE_DEFINITION:
      return DirectiveLocation.ENUM_VALUE;
    case Kind.INPUT_OBJECT_TYPE_DEFINITION:
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return DirectiveLocation.INPUT_OBJECT;
    case Kind.INPUT_VALUE_DEFINITION: {
      const parentNode = ancestors[ancestors.length - 3];
      "kind" in parentNode || invariant(false);
      return parentNode.kind === Kind.INPUT_OBJECT_TYPE_DEFINITION ? DirectiveLocation.INPUT_FIELD_DEFINITION : DirectiveLocation.ARGUMENT_DEFINITION;
    }
    default:
      invariant(false, "Unexpected kind: " + inspect(appliedTo.kind));
  }
}
function getDirectiveLocationForOperation(operation) {
  switch (operation) {
    case OperationTypeNode.QUERY:
      return DirectiveLocation.QUERY;
    case OperationTypeNode.MUTATION:
      return DirectiveLocation.MUTATION;
    case OperationTypeNode.SUBSCRIPTION:
      return DirectiveLocation.SUBSCRIPTION;
  }
}

// node_modules/graphql/validation/rules/KnownFragmentNamesRule.mjs
function KnownFragmentNamesRule(context) {
  return {
    FragmentSpread(node) {
      const fragmentName = node.name.value;
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        context.reportError(
          new GraphQLError(`Unknown fragment "${fragmentName}".`, {
            nodes: node.name
          })
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/KnownTypeNamesRule.mjs
function KnownTypeNamesRule(context) {
  const schema = context.getSchema();
  const existingTypesMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = true;
    }
  }
  const typeNames = [
    ...Object.keys(existingTypesMap),
    ...Object.keys(definedTypes)
  ];
  return {
    NamedType(node, _1, parent, _2, ancestors) {
      const typeName = node.name.value;
      if (!existingTypesMap[typeName] && !definedTypes[typeName]) {
        var _ancestors$;
        const definitionNode = (_ancestors$ = ancestors[2]) !== null && _ancestors$ !== void 0 ? _ancestors$ : parent;
        const isSDL = definitionNode != null && isSDLNode(definitionNode);
        if (isSDL && standardTypeNames.includes(typeName)) {
          return;
        }
        const suggestedTypes = suggestionList(
          typeName,
          isSDL ? standardTypeNames.concat(typeNames) : typeNames
        );
        context.reportError(
          new GraphQLError(
            `Unknown type "${typeName}".` + didYouMean(suggestedTypes),
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
var standardTypeNames = [...specifiedScalarTypes, ...introspectionTypes].map(
  (type) => type.name
);
function isSDLNode(value) {
  return "kind" in value && (isTypeSystemDefinitionNode(value) || isTypeSystemExtensionNode(value));
}

// node_modules/graphql/validation/rules/LoneAnonymousOperationRule.mjs
function LoneAnonymousOperationRule(context) {
  let operationCount = 0;
  return {
    Document(node) {
      operationCount = node.definitions.filter(
        (definition) => definition.kind === Kind.OPERATION_DEFINITION
      ).length;
    },
    OperationDefinition(node) {
      if (!node.name && operationCount > 1) {
        context.reportError(
          new GraphQLError(
            "This anonymous operation must be the only defined operation.",
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/LoneSchemaDefinitionRule.mjs
function LoneSchemaDefinitionRule(context) {
  var _ref, _ref2, _oldSchema$astNode;
  const oldSchema = context.getSchema();
  const alreadyDefined = (_ref = (_ref2 = (_oldSchema$astNode = oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.astNode) !== null && _oldSchema$astNode !== void 0 ? _oldSchema$astNode : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getQueryType()) !== null && _ref2 !== void 0 ? _ref2 : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getMutationType()) !== null && _ref !== void 0 ? _ref : oldSchema === null || oldSchema === void 0 ? void 0 : oldSchema.getSubscriptionType();
  let schemaDefinitionsCount = 0;
  return {
    SchemaDefinition(node) {
      if (alreadyDefined) {
        context.reportError(
          new GraphQLError(
            "Cannot define a new schema within a schema extension.",
            {
              nodes: node
            }
          )
        );
        return;
      }
      if (schemaDefinitionsCount > 0) {
        context.reportError(
          new GraphQLError("Must provide only one schema definition.", {
            nodes: node
          })
        );
      }
      ++schemaDefinitionsCount;
    }
  };
}

// node_modules/graphql/validation/rules/MaxIntrospectionDepthRule.mjs
var MAX_LISTS_DEPTH = 3;
function MaxIntrospectionDepthRule(context) {
  function checkDepth(node, visitedFragments = /* @__PURE__ */ Object.create(null), depth = 0) {
    if (node.kind === Kind.FRAGMENT_SPREAD) {
      const fragmentName = node.name.value;
      if (visitedFragments[fragmentName] === true) {
        return false;
      }
      const fragment = context.getFragment(fragmentName);
      if (!fragment) {
        return false;
      }
      try {
        visitedFragments[fragmentName] = true;
        return checkDepth(fragment, visitedFragments, depth);
      } finally {
        visitedFragments[fragmentName] = void 0;
      }
    }
    if (node.kind === Kind.FIELD && // check all introspection lists
    (node.name.value === "fields" || node.name.value === "interfaces" || node.name.value === "possibleTypes" || node.name.value === "inputFields")) {
      depth++;
      if (depth >= MAX_LISTS_DEPTH) {
        return true;
      }
    }
    if ("selectionSet" in node && node.selectionSet) {
      for (const child of node.selectionSet.selections) {
        if (checkDepth(child, visitedFragments, depth)) {
          return true;
        }
      }
    }
    return false;
  }
  return {
    Field(node) {
      if (node.name.value === "__schema" || node.name.value === "__type") {
        if (checkDepth(node)) {
          context.reportError(
            new GraphQLError("Maximum introspection depth exceeded", {
              nodes: [node]
            })
          );
          return false;
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoFragmentCyclesRule.mjs
function NoFragmentCyclesRule(context) {
  const visitedFrags = /* @__PURE__ */ Object.create(null);
  const spreadPath = [];
  const spreadPathIndexByName = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      detectCycleRecursive(node);
      return false;
    }
  };
  function detectCycleRecursive(fragment) {
    if (visitedFrags[fragment.name.value]) {
      return;
    }
    const fragmentName = fragment.name.value;
    visitedFrags[fragmentName] = true;
    const spreadNodes = context.getFragmentSpreads(fragment.selectionSet);
    if (spreadNodes.length === 0) {
      return;
    }
    spreadPathIndexByName[fragmentName] = spreadPath.length;
    for (const spreadNode of spreadNodes) {
      const spreadName = spreadNode.name.value;
      const cycleIndex = spreadPathIndexByName[spreadName];
      spreadPath.push(spreadNode);
      if (cycleIndex === void 0) {
        const spreadFragment = context.getFragment(spreadName);
        if (spreadFragment) {
          detectCycleRecursive(spreadFragment);
        }
      } else {
        const cyclePath = spreadPath.slice(cycleIndex);
        const viaPath = cyclePath.slice(0, -1).map((s3) => '"' + s3.name.value + '"').join(", ");
        context.reportError(
          new GraphQLError(
            `Cannot spread fragment "${spreadName}" within itself` + (viaPath !== "" ? ` via ${viaPath}.` : "."),
            {
              nodes: cyclePath
            }
          )
        );
      }
      spreadPath.pop();
    }
    spreadPathIndexByName[fragmentName] = void 0;
  }
}

// node_modules/graphql/validation/rules/NoUndefinedVariablesRule.mjs
function NoUndefinedVariablesRule(context) {
  let variableNameDefined = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        variableNameDefined = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          const varName = node.name.value;
          if (variableNameDefined[varName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${varName}" is not defined by operation "${operation.name.value}".` : `Variable "$${varName}" is not defined.`,
                {
                  nodes: [node, operation]
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(node) {
      variableNameDefined[node.variable.name.value] = true;
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedFragmentsRule.mjs
function NoUnusedFragmentsRule(context) {
  const operationDefs = [];
  const fragmentDefs = [];
  return {
    OperationDefinition(node) {
      operationDefs.push(node);
      return false;
    },
    FragmentDefinition(node) {
      fragmentDefs.push(node);
      return false;
    },
    Document: {
      leave() {
        const fragmentNameUsed = /* @__PURE__ */ Object.create(null);
        for (const operation of operationDefs) {
          for (const fragment of context.getRecursivelyReferencedFragments(
            operation
          )) {
            fragmentNameUsed[fragment.name.value] = true;
          }
        }
        for (const fragmentDef of fragmentDefs) {
          const fragName = fragmentDef.name.value;
          if (fragmentNameUsed[fragName] !== true) {
            context.reportError(
              new GraphQLError(`Fragment "${fragName}" is never used.`, {
                nodes: fragmentDef
              })
            );
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/NoUnusedVariablesRule.mjs
function NoUnusedVariablesRule(context) {
  let variableDefs = [];
  return {
    OperationDefinition: {
      enter() {
        variableDefs = [];
      },
      leave(operation) {
        const variableNameUsed = /* @__PURE__ */ Object.create(null);
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node } of usages) {
          variableNameUsed[node.name.value] = true;
        }
        for (const variableDef of variableDefs) {
          const variableName = variableDef.variable.name.value;
          if (variableNameUsed[variableName] !== true) {
            context.reportError(
              new GraphQLError(
                operation.name ? `Variable "$${variableName}" is never used in operation "${operation.name.value}".` : `Variable "$${variableName}" is never used.`,
                {
                  nodes: variableDef
                }
              )
            );
          }
        }
      }
    },
    VariableDefinition(def) {
      variableDefs.push(def);
    }
  };
}

// node_modules/graphql/utilities/sortValueNode.mjs
function sortValueNode(valueNode) {
  switch (valueNode.kind) {
    case Kind.OBJECT:
      return { ...valueNode, fields: sortFields(valueNode.fields) };
    case Kind.LIST:
      return { ...valueNode, values: valueNode.values.map(sortValueNode) };
    case Kind.INT:
    case Kind.FLOAT:
    case Kind.STRING:
    case Kind.BOOLEAN:
    case Kind.NULL:
    case Kind.ENUM:
    case Kind.VARIABLE:
      return valueNode;
  }
}
function sortFields(fields) {
  return fields.map((fieldNode) => ({
    ...fieldNode,
    value: sortValueNode(fieldNode.value)
  })).sort(
    (fieldA, fieldB) => naturalCompare(fieldA.name.value, fieldB.name.value)
  );
}

// node_modules/graphql/validation/rules/OverlappingFieldsCanBeMergedRule.mjs
function reasonMessage(reason) {
  if (Array.isArray(reason)) {
    return reason.map(
      ([responseName, subReason]) => `subfields "${responseName}" conflict because ` + reasonMessage(subReason)
    ).join(" and ");
  }
  return reason;
}
function OverlappingFieldsCanBeMergedRule(context) {
  const comparedFragmentPairs = new PairSet();
  const cachedFieldsAndFragmentNames = /* @__PURE__ */ new Map();
  return {
    SelectionSet(selectionSet) {
      const conflicts = findConflictsWithinSelectionSet(
        context,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        context.getParentType(),
        selectionSet
      );
      for (const [[responseName, reason], fields1, fields2] of conflicts) {
        const reasonMsg = reasonMessage(reason);
        context.reportError(
          new GraphQLError(
            `Fields "${responseName}" conflict because ${reasonMsg}. Use different aliases on the fields to fetch both if this was intentional.`,
            {
              nodes: fields1.concat(fields2)
            }
          )
        );
      }
    }
  };
}
function findConflictsWithinSelectionSet(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentType, selectionSet) {
  const conflicts = [];
  const [fieldMap, fragmentNames] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType,
    selectionSet
  );
  collectConflictsWithin(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    fieldMap
  );
  if (fragmentNames.length !== 0) {
    for (let i4 = 0; i4 < fragmentNames.length; i4++) {
      collectConflictsBetweenFieldsAndFragment(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        false,
        fieldMap,
        fragmentNames[i4]
      );
      for (let j2 = i4 + 1; j2 < fragmentNames.length; j2++) {
        collectConflictsBetweenFragments(
          context,
          conflicts,
          cachedFieldsAndFragmentNames,
          comparedFragmentPairs,
          false,
          fragmentNames[i4],
          fragmentNames[j2]
        );
      }
    }
  }
  return conflicts;
}
function collectConflictsBetweenFieldsAndFragment(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fieldMap, fragmentName) {
  const fragment = context.getFragment(fragmentName);
  if (!fragment) {
    return;
  }
  const [fieldMap2, referencedFragmentNames] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment
  );
  if (fieldMap === fieldMap2) {
    return;
  }
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap,
    fieldMap2
  );
  for (const referencedFragmentName of referencedFragmentNames) {
    if (comparedFragmentPairs.has(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    )) {
      continue;
    }
    comparedFragmentPairs.add(
      referencedFragmentName,
      fragmentName,
      areMutuallyExclusive
    );
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap,
      referencedFragmentName
    );
  }
}
function collectConflictsBetweenFragments(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, fragmentName1, fragmentName2) {
  if (fragmentName1 === fragmentName2) {
    return;
  }
  if (comparedFragmentPairs.has(
    fragmentName1,
    fragmentName2,
    areMutuallyExclusive
  )) {
    return;
  }
  comparedFragmentPairs.add(fragmentName1, fragmentName2, areMutuallyExclusive);
  const fragment1 = context.getFragment(fragmentName1);
  const fragment2 = context.getFragment(fragmentName2);
  if (!fragment1 || !fragment2) {
    return;
  }
  const [fieldMap1, referencedFragmentNames1] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment1
  );
  const [fieldMap2, referencedFragmentNames2] = getReferencedFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragment2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const referencedFragmentName2 of referencedFragmentNames2) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fragmentName1,
      referencedFragmentName2
    );
  }
  for (const referencedFragmentName1 of referencedFragmentNames1) {
    collectConflictsBetweenFragments(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      referencedFragmentName1,
      fragmentName2
    );
  }
}
function findConflictsBetweenSubSelectionSets(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, areMutuallyExclusive, parentType1, selectionSet1, parentType2, selectionSet2) {
  const conflicts = [];
  const [fieldMap1, fragmentNames1] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType1,
    selectionSet1
  );
  const [fieldMap2, fragmentNames2] = getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    parentType2,
    selectionSet2
  );
  collectConflictsBetween(
    context,
    conflicts,
    cachedFieldsAndFragmentNames,
    comparedFragmentPairs,
    areMutuallyExclusive,
    fieldMap1,
    fieldMap2
  );
  for (const fragmentName2 of fragmentNames2) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap1,
      fragmentName2
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    collectConflictsBetweenFieldsAndFragment(
      context,
      conflicts,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      fieldMap2,
      fragmentName1
    );
  }
  for (const fragmentName1 of fragmentNames1) {
    for (const fragmentName2 of fragmentNames2) {
      collectConflictsBetweenFragments(
        context,
        conflicts,
        cachedFieldsAndFragmentNames,
        comparedFragmentPairs,
        areMutuallyExclusive,
        fragmentName1,
        fragmentName2
      );
    }
  }
  return conflicts;
}
function collectConflictsWithin(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, fieldMap) {
  for (const [responseName, fields] of Object.entries(fieldMap)) {
    if (fields.length > 1) {
      for (let i4 = 0; i4 < fields.length; i4++) {
        for (let j2 = i4 + 1; j2 < fields.length; j2++) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            false,
            // within one collection is never mutually exclusive
            responseName,
            fields[i4],
            fields[j2]
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function collectConflictsBetween(context, conflicts, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, fieldMap1, fieldMap2) {
  for (const [responseName, fields1] of Object.entries(fieldMap1)) {
    const fields2 = fieldMap2[responseName];
    if (fields2) {
      for (const field1 of fields1) {
        for (const field2 of fields2) {
          const conflict = findConflict(
            context,
            cachedFieldsAndFragmentNames,
            comparedFragmentPairs,
            parentFieldsAreMutuallyExclusive,
            responseName,
            field1,
            field2
          );
          if (conflict) {
            conflicts.push(conflict);
          }
        }
      }
    }
  }
}
function findConflict(context, cachedFieldsAndFragmentNames, comparedFragmentPairs, parentFieldsAreMutuallyExclusive, responseName, field1, field2) {
  const [parentType1, node1, def1] = field1;
  const [parentType2, node2, def2] = field2;
  const areMutuallyExclusive = parentFieldsAreMutuallyExclusive || parentType1 !== parentType2 && isObjectType(parentType1) && isObjectType(parentType2);
  if (!areMutuallyExclusive) {
    const name1 = node1.name.value;
    const name2 = node2.name.value;
    if (name1 !== name2) {
      return [
        [responseName, `"${name1}" and "${name2}" are different fields`],
        [node1],
        [node2]
      ];
    }
    if (!sameArguments(node1, node2)) {
      return [
        [responseName, "they have differing arguments"],
        [node1],
        [node2]
      ];
    }
  }
  const type1 = def1 === null || def1 === void 0 ? void 0 : def1.type;
  const type2 = def2 === null || def2 === void 0 ? void 0 : def2.type;
  if (type1 && type2 && doTypesConflict(type1, type2)) {
    return [
      [
        responseName,
        `they return conflicting types "${inspect(type1)}" and "${inspect(
          type2
        )}"`
      ],
      [node1],
      [node2]
    ];
  }
  const selectionSet1 = node1.selectionSet;
  const selectionSet2 = node2.selectionSet;
  if (selectionSet1 && selectionSet2) {
    const conflicts = findConflictsBetweenSubSelectionSets(
      context,
      cachedFieldsAndFragmentNames,
      comparedFragmentPairs,
      areMutuallyExclusive,
      getNamedType(type1),
      selectionSet1,
      getNamedType(type2),
      selectionSet2
    );
    return subfieldConflicts(conflicts, responseName, node1, node2);
  }
}
function sameArguments(node1, node2) {
  const args1 = node1.arguments;
  const args2 = node2.arguments;
  if (args1 === void 0 || args1.length === 0) {
    return args2 === void 0 || args2.length === 0;
  }
  if (args2 === void 0 || args2.length === 0) {
    return false;
  }
  if (args1.length !== args2.length) {
    return false;
  }
  const values2 = new Map(args2.map(({ name, value }) => [name.value, value]));
  return args1.every((arg1) => {
    const value1 = arg1.value;
    const value2 = values2.get(arg1.name.value);
    if (value2 === void 0) {
      return false;
    }
    return stringifyValue(value1) === stringifyValue(value2);
  });
}
function stringifyValue(value) {
  return print(sortValueNode(value));
}
function doTypesConflict(type1, type2) {
  if (isListType(type1)) {
    return isListType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isListType(type2)) {
    return true;
  }
  if (isNonNullType(type1)) {
    return isNonNullType(type2) ? doTypesConflict(type1.ofType, type2.ofType) : true;
  }
  if (isNonNullType(type2)) {
    return true;
  }
  if (isLeafType(type1) || isLeafType(type2)) {
    return type1 !== type2;
  }
  return false;
}
function getFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, parentType, selectionSet) {
  const cached = cachedFieldsAndFragmentNames.get(selectionSet);
  if (cached) {
    return cached;
  }
  const nodeAndDefs = /* @__PURE__ */ Object.create(null);
  const fragmentNames = /* @__PURE__ */ Object.create(null);
  _collectFieldsAndFragmentNames(
    context,
    parentType,
    selectionSet,
    nodeAndDefs,
    fragmentNames
  );
  const result = [nodeAndDefs, Object.keys(fragmentNames)];
  cachedFieldsAndFragmentNames.set(selectionSet, result);
  return result;
}
function getReferencedFieldsAndFragmentNames(context, cachedFieldsAndFragmentNames, fragment) {
  const cached = cachedFieldsAndFragmentNames.get(fragment.selectionSet);
  if (cached) {
    return cached;
  }
  const fragmentType = typeFromAST(context.getSchema(), fragment.typeCondition);
  return getFieldsAndFragmentNames(
    context,
    cachedFieldsAndFragmentNames,
    fragmentType,
    fragment.selectionSet
  );
}
function _collectFieldsAndFragmentNames(context, parentType, selectionSet, nodeAndDefs, fragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        const fieldName = selection.name.value;
        let fieldDef;
        if (isObjectType(parentType) || isInterfaceType(parentType)) {
          fieldDef = parentType.getFields()[fieldName];
        }
        const responseName = selection.alias ? selection.alias.value : fieldName;
        if (!nodeAndDefs[responseName]) {
          nodeAndDefs[responseName] = [];
        }
        nodeAndDefs[responseName].push([parentType, selection, fieldDef]);
        break;
      }
      case Kind.FRAGMENT_SPREAD:
        fragmentNames[selection.name.value] = true;
        break;
      case Kind.INLINE_FRAGMENT: {
        const typeCondition = selection.typeCondition;
        const inlineFragmentType = typeCondition ? typeFromAST(context.getSchema(), typeCondition) : parentType;
        _collectFieldsAndFragmentNames(
          context,
          inlineFragmentType,
          selection.selectionSet,
          nodeAndDefs,
          fragmentNames
        );
        break;
      }
    }
  }
}
function subfieldConflicts(conflicts, responseName, node1, node2) {
  if (conflicts.length > 0) {
    return [
      [responseName, conflicts.map(([reason]) => reason)],
      [node1, ...conflicts.map(([, fields1]) => fields1).flat()],
      [node2, ...conflicts.map(([, , fields2]) => fields2).flat()]
    ];
  }
}
var PairSet = class {
  constructor() {
    this._data = /* @__PURE__ */ new Map();
  }
  has(a2, b2, areMutuallyExclusive) {
    var _this$_data$get;
    const [key1, key2] = a2 < b2 ? [a2, b2] : [b2, a2];
    const result = (_this$_data$get = this._data.get(key1)) === null || _this$_data$get === void 0 ? void 0 : _this$_data$get.get(key2);
    if (result === void 0) {
      return false;
    }
    return areMutuallyExclusive ? true : areMutuallyExclusive === result;
  }
  add(a2, b2, areMutuallyExclusive) {
    const [key1, key2] = a2 < b2 ? [a2, b2] : [b2, a2];
    const map = this._data.get(key1);
    if (map === void 0) {
      this._data.set(key1, /* @__PURE__ */ new Map([[key2, areMutuallyExclusive]]));
    } else {
      map.set(key2, areMutuallyExclusive);
    }
  }
};

// node_modules/graphql/validation/rules/PossibleFragmentSpreadsRule.mjs
function PossibleFragmentSpreadsRule(context) {
  return {
    InlineFragment(node) {
      const fragType = context.getType();
      const parentType = context.getParentType();
      if (isCompositeType(fragType) && isCompositeType(parentType) && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    },
    FragmentSpread(node) {
      const fragName = node.name.value;
      const fragType = getFragmentType(context, fragName);
      const parentType = context.getParentType();
      if (fragType && parentType && !doTypesOverlap(context.getSchema(), fragType, parentType)) {
        const parentTypeStr = inspect(parentType);
        const fragTypeStr = inspect(fragType);
        context.reportError(
          new GraphQLError(
            `Fragment "${fragName}" cannot be spread here as objects of type "${parentTypeStr}" can never be of type "${fragTypeStr}".`,
            {
              nodes: node
            }
          )
        );
      }
    }
  };
}
function getFragmentType(context, name) {
  const frag = context.getFragment(name);
  if (frag) {
    const type = typeFromAST(context.getSchema(), frag.typeCondition);
    if (isCompositeType(type)) {
      return type;
    }
  }
}

// node_modules/graphql/validation/rules/PossibleTypeExtensionsRule.mjs
function PossibleTypeExtensionsRule(context) {
  const schema = context.getSchema();
  const definedTypes = /* @__PURE__ */ Object.create(null);
  for (const def of context.getDocument().definitions) {
    if (isTypeDefinitionNode(def)) {
      definedTypes[def.name.value] = def;
    }
  }
  return {
    ScalarTypeExtension: checkExtension,
    ObjectTypeExtension: checkExtension,
    InterfaceTypeExtension: checkExtension,
    UnionTypeExtension: checkExtension,
    EnumTypeExtension: checkExtension,
    InputObjectTypeExtension: checkExtension
  };
  function checkExtension(node) {
    const typeName = node.name.value;
    const defNode = definedTypes[typeName];
    const existingType = schema === null || schema === void 0 ? void 0 : schema.getType(typeName);
    let expectedKind;
    if (defNode) {
      expectedKind = defKindToExtKind[defNode.kind];
    } else if (existingType) {
      expectedKind = typeToExtKind(existingType);
    }
    if (expectedKind) {
      if (expectedKind !== node.kind) {
        const kindStr = extensionKindToTypeName(node.kind);
        context.reportError(
          new GraphQLError(`Cannot extend non-${kindStr} type "${typeName}".`, {
            nodes: defNode ? [defNode, node] : node
          })
        );
      }
    } else {
      const allTypeNames = Object.keys({
        ...definedTypes,
        ...schema === null || schema === void 0 ? void 0 : schema.getTypeMap()
      });
      const suggestedTypes = suggestionList(typeName, allTypeNames);
      context.reportError(
        new GraphQLError(
          `Cannot extend type "${typeName}" because it is not defined.` + didYouMean(suggestedTypes),
          {
            nodes: node.name
          }
        )
      );
    }
  }
}
var defKindToExtKind = {
  [Kind.SCALAR_TYPE_DEFINITION]: Kind.SCALAR_TYPE_EXTENSION,
  [Kind.OBJECT_TYPE_DEFINITION]: Kind.OBJECT_TYPE_EXTENSION,
  [Kind.INTERFACE_TYPE_DEFINITION]: Kind.INTERFACE_TYPE_EXTENSION,
  [Kind.UNION_TYPE_DEFINITION]: Kind.UNION_TYPE_EXTENSION,
  [Kind.ENUM_TYPE_DEFINITION]: Kind.ENUM_TYPE_EXTENSION,
  [Kind.INPUT_OBJECT_TYPE_DEFINITION]: Kind.INPUT_OBJECT_TYPE_EXTENSION
};
function typeToExtKind(type) {
  if (isScalarType(type)) {
    return Kind.SCALAR_TYPE_EXTENSION;
  }
  if (isObjectType(type)) {
    return Kind.OBJECT_TYPE_EXTENSION;
  }
  if (isInterfaceType(type)) {
    return Kind.INTERFACE_TYPE_EXTENSION;
  }
  if (isUnionType(type)) {
    return Kind.UNION_TYPE_EXTENSION;
  }
  if (isEnumType(type)) {
    return Kind.ENUM_TYPE_EXTENSION;
  }
  if (isInputObjectType(type)) {
    return Kind.INPUT_OBJECT_TYPE_EXTENSION;
  }
  invariant(false, "Unexpected type: " + inspect(type));
}
function extensionKindToTypeName(kind) {
  switch (kind) {
    case Kind.SCALAR_TYPE_EXTENSION:
      return "scalar";
    case Kind.OBJECT_TYPE_EXTENSION:
      return "object";
    case Kind.INTERFACE_TYPE_EXTENSION:
      return "interface";
    case Kind.UNION_TYPE_EXTENSION:
      return "union";
    case Kind.ENUM_TYPE_EXTENSION:
      return "enum";
    case Kind.INPUT_OBJECT_TYPE_EXTENSION:
      return "input object";
    default:
      invariant(false, "Unexpected kind: " + inspect(kind));
  }
}

// node_modules/graphql/validation/rules/ProvidedRequiredArgumentsRule.mjs
function ProvidedRequiredArgumentsRule(context) {
  return {
    // eslint-disable-next-line new-cap
    ...ProvidedRequiredArgumentsOnDirectivesRule(context),
    Field: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(fieldNode) {
        var _fieldNode$arguments;
        const fieldDef = context.getFieldDef();
        if (!fieldDef) {
          return false;
        }
        const providedArgs = new Set(
          // FIXME: https://github.com/graphql/graphql-js/issues/2203
          /* c8 ignore next */
          (_fieldNode$arguments = fieldNode.arguments) === null || _fieldNode$arguments === void 0 ? void 0 : _fieldNode$arguments.map((arg) => arg.name.value)
        );
        for (const argDef of fieldDef.args) {
          if (!providedArgs.has(argDef.name) && isRequiredArgument(argDef)) {
            const argTypeStr = inspect(argDef.type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldDef.name}" argument "${argDef.name}" of type "${argTypeStr}" is required, but it was not provided.`,
                {
                  nodes: fieldNode
                }
              )
            );
          }
        }
      }
    }
  };
}
function ProvidedRequiredArgumentsOnDirectivesRule(context) {
  var _schema$getDirectives;
  const requiredArgsMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = (_schema$getDirectives = schema === null || schema === void 0 ? void 0 : schema.getDirectives()) !== null && _schema$getDirectives !== void 0 ? _schema$getDirectives : specifiedDirectives;
  for (const directive of definedDirectives) {
    requiredArgsMap[directive.name] = keyMap(
      directive.args.filter(isRequiredArgument),
      (arg) => arg.name
    );
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      var _def$arguments;
      const argNodes = (_def$arguments = def.arguments) !== null && _def$arguments !== void 0 ? _def$arguments : [];
      requiredArgsMap[def.name.value] = keyMap(
        argNodes.filter(isRequiredArgumentNode),
        (arg) => arg.name.value
      );
    }
  }
  return {
    Directive: {
      // Validate on leave to allow for deeper errors to appear first.
      leave(directiveNode) {
        const directiveName = directiveNode.name.value;
        const requiredArgs = requiredArgsMap[directiveName];
        if (requiredArgs) {
          var _directiveNode$argume;
          const argNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
          const argNodeMap = new Set(argNodes.map((arg) => arg.name.value));
          for (const [argName, argDef] of Object.entries(requiredArgs)) {
            if (!argNodeMap.has(argName)) {
              const argType = isType(argDef.type) ? inspect(argDef.type) : print(argDef.type);
              context.reportError(
                new GraphQLError(
                  `Directive "@${directiveName}" argument "${argName}" of type "${argType}" is required, but it was not provided.`,
                  {
                    nodes: directiveNode
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}
function isRequiredArgumentNode(arg) {
  return arg.type.kind === Kind.NON_NULL_TYPE && arg.defaultValue == null;
}

// node_modules/graphql/validation/rules/ScalarLeafsRule.mjs
function ScalarLeafsRule(context) {
  return {
    Field(node) {
      const type = context.getType();
      const selectionSet = node.selectionSet;
      if (type) {
        if (isLeafType(getNamedType(type))) {
          if (selectionSet) {
            const fieldName = node.name.value;
            const typeStr = inspect(type);
            context.reportError(
              new GraphQLError(
                `Field "${fieldName}" must not have a selection since type "${typeStr}" has no subfields.`,
                {
                  nodes: selectionSet
                }
              )
            );
          }
        } else if (!selectionSet) {
          const fieldName = node.name.value;
          const typeStr = inspect(type);
          context.reportError(
            new GraphQLError(
              `Field "${fieldName}" of type "${typeStr}" must have a selection of subfields. Did you mean "${fieldName} { ... }"?`,
              {
                nodes: node
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/utilities/valueFromAST.mjs
function valueFromAST(valueNode, type, variables) {
  if (!valueNode) {
    return;
  }
  if (valueNode.kind === Kind.VARIABLE) {
    const variableName = valueNode.name.value;
    if (variables == null || variables[variableName] === void 0) {
      return;
    }
    const variableValue = variables[variableName];
    if (variableValue === null && isNonNullType(type)) {
      return;
    }
    return variableValue;
  }
  if (isNonNullType(type)) {
    if (valueNode.kind === Kind.NULL) {
      return;
    }
    return valueFromAST(valueNode, type.ofType, variables);
  }
  if (valueNode.kind === Kind.NULL) {
    return null;
  }
  if (isListType(type)) {
    const itemType = type.ofType;
    if (valueNode.kind === Kind.LIST) {
      const coercedValues = [];
      for (const itemNode of valueNode.values) {
        if (isMissingVariable(itemNode, variables)) {
          if (isNonNullType(itemType)) {
            return;
          }
          coercedValues.push(null);
        } else {
          const itemValue = valueFromAST(itemNode, itemType, variables);
          if (itemValue === void 0) {
            return;
          }
          coercedValues.push(itemValue);
        }
      }
      return coercedValues;
    }
    const coercedValue = valueFromAST(valueNode, itemType, variables);
    if (coercedValue === void 0) {
      return;
    }
    return [coercedValue];
  }
  if (isInputObjectType(type)) {
    if (valueNode.kind !== Kind.OBJECT) {
      return;
    }
    const coercedObj = /* @__PURE__ */ Object.create(null);
    const fieldNodes = keyMap(valueNode.fields, (field) => field.name.value);
    for (const field of Object.values(type.getFields())) {
      const fieldNode = fieldNodes[field.name];
      if (!fieldNode || isMissingVariable(fieldNode.value, variables)) {
        if (field.defaultValue !== void 0) {
          coercedObj[field.name] = field.defaultValue;
        } else if (isNonNullType(field.type)) {
          return;
        }
        continue;
      }
      const fieldValue = valueFromAST(fieldNode.value, field.type, variables);
      if (fieldValue === void 0) {
        return;
      }
      coercedObj[field.name] = fieldValue;
    }
    if (type.isOneOf) {
      const keys = Object.keys(coercedObj);
      if (keys.length !== 1) {
        return;
      }
      if (coercedObj[keys[0]] === null) {
        return;
      }
    }
    return coercedObj;
  }
  if (isLeafType(type)) {
    let result;
    try {
      result = type.parseLiteral(valueNode, variables);
    } catch (_error) {
      return;
    }
    if (result === void 0) {
      return;
    }
    return result;
  }
  invariant(false, "Unexpected input type: " + inspect(type));
}
function isMissingVariable(valueNode, variables) {
  return valueNode.kind === Kind.VARIABLE && (variables == null || variables[valueNode.name.value] === void 0);
}

// node_modules/graphql/execution/values.mjs
function getArgumentValues(def, node, variableValues) {
  var _node$arguments;
  const coercedValues = {};
  const argumentNodes = (_node$arguments = node.arguments) !== null && _node$arguments !== void 0 ? _node$arguments : [];
  const argNodeMap = keyMap(argumentNodes, (arg) => arg.name.value);
  for (const argDef of def.args) {
    const name = argDef.name;
    const argType = argDef.type;
    const argumentNode = argNodeMap[name];
    if (!argumentNode) {
      if (argDef.defaultValue !== void 0) {
        coercedValues[name] = argDef.defaultValue;
      } else if (isNonNullType(argType)) {
        throw new GraphQLError(
          `Argument "${name}" of required type "${inspect(argType)}" was not provided.`,
          {
            nodes: node
          }
        );
      }
      continue;
    }
    const valueNode = argumentNode.value;
    let isNull = valueNode.kind === Kind.NULL;
    if (valueNode.kind === Kind.VARIABLE) {
      const variableName = valueNode.name.value;
      if (variableValues == null || !hasOwnProperty(variableValues, variableName)) {
        if (argDef.defaultValue !== void 0) {
          coercedValues[name] = argDef.defaultValue;
        } else if (isNonNullType(argType)) {
          throw new GraphQLError(
            `Argument "${name}" of required type "${inspect(argType)}" was provided the variable "$${variableName}" which was not provided a runtime value.`,
            {
              nodes: valueNode
            }
          );
        }
        continue;
      }
      isNull = variableValues[variableName] == null;
    }
    if (isNull && isNonNullType(argType)) {
      throw new GraphQLError(
        `Argument "${name}" of non-null type "${inspect(argType)}" must not be null.`,
        {
          nodes: valueNode
        }
      );
    }
    const coercedValue = valueFromAST(valueNode, argType, variableValues);
    if (coercedValue === void 0) {
      throw new GraphQLError(
        `Argument "${name}" has invalid value ${print(valueNode)}.`,
        {
          nodes: valueNode
        }
      );
    }
    coercedValues[name] = coercedValue;
  }
  return coercedValues;
}
function getDirectiveValues(directiveDef, node, variableValues) {
  var _node$directives;
  const directiveNode = (_node$directives = node.directives) === null || _node$directives === void 0 ? void 0 : _node$directives.find(
    (directive) => directive.name.value === directiveDef.name
  );
  if (directiveNode) {
    return getArgumentValues(directiveDef, directiveNode, variableValues);
  }
}
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

// node_modules/graphql/execution/collectFields.mjs
function collectFields(schema, fragments, variableValues, runtimeType, selectionSet) {
  const fields = /* @__PURE__ */ new Map();
  collectFieldsImpl(
    schema,
    fragments,
    variableValues,
    runtimeType,
    selectionSet,
    fields,
    /* @__PURE__ */ new Set()
  );
  return fields;
}
function collectSubfields(schema, fragments, variableValues, returnType, fieldNodes) {
  const subFieldNodes = /* @__PURE__ */ new Map();
  const visitedFragmentNames = /* @__PURE__ */ new Set();
  for (const node of fieldNodes) {
    if (node.selectionSet) {
      collectFieldsImpl(
        schema,
        fragments,
        variableValues,
        returnType,
        node.selectionSet,
        subFieldNodes,
        visitedFragmentNames
      );
    }
  }
  return subFieldNodes;
}
function collectFieldsImpl(schema, fragments, variableValues, runtimeType, selectionSet, fields, visitedFragmentNames) {
  for (const selection of selectionSet.selections) {
    switch (selection.kind) {
      case Kind.FIELD: {
        if (!shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        const name = getFieldEntryKey(selection);
        const fieldList = fields.get(name);
        if (fieldList !== void 0) {
          fieldList.push(selection);
        } else {
          fields.set(name, [selection]);
        }
        break;
      }
      case Kind.INLINE_FRAGMENT: {
        if (!shouldIncludeNode(variableValues, selection) || !doesFragmentConditionMatch(schema, selection, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          selection.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
      case Kind.FRAGMENT_SPREAD: {
        const fragName = selection.name.value;
        if (visitedFragmentNames.has(fragName) || !shouldIncludeNode(variableValues, selection)) {
          continue;
        }
        visitedFragmentNames.add(fragName);
        const fragment = fragments[fragName];
        if (!fragment || !doesFragmentConditionMatch(schema, fragment, runtimeType)) {
          continue;
        }
        collectFieldsImpl(
          schema,
          fragments,
          variableValues,
          runtimeType,
          fragment.selectionSet,
          fields,
          visitedFragmentNames
        );
        break;
      }
    }
  }
}
function shouldIncludeNode(variableValues, node) {
  const skip = getDirectiveValues(GraphQLSkipDirective, node, variableValues);
  if ((skip === null || skip === void 0 ? void 0 : skip.if) === true) {
    return false;
  }
  const include = getDirectiveValues(
    GraphQLIncludeDirective,
    node,
    variableValues
  );
  if ((include === null || include === void 0 ? void 0 : include.if) === false) {
    return false;
  }
  return true;
}
function doesFragmentConditionMatch(schema, fragment, type) {
  const typeConditionNode = fragment.typeCondition;
  if (!typeConditionNode) {
    return true;
  }
  const conditionalType = typeFromAST(schema, typeConditionNode);
  if (conditionalType === type) {
    return true;
  }
  if (isAbstractType(conditionalType)) {
    return schema.isSubType(conditionalType, type);
  }
  return false;
}
function getFieldEntryKey(node) {
  return node.alias ? node.alias.value : node.name.value;
}

// node_modules/graphql/validation/rules/SingleFieldSubscriptionsRule.mjs
function SingleFieldSubscriptionsRule(context) {
  return {
    OperationDefinition(node) {
      if (node.operation === "subscription") {
        const schema = context.getSchema();
        const subscriptionType = schema.getSubscriptionType();
        if (subscriptionType) {
          const operationName = node.name ? node.name.value : null;
          const variableValues = /* @__PURE__ */ Object.create(null);
          const document2 = context.getDocument();
          const fragments = /* @__PURE__ */ Object.create(null);
          for (const definition of document2.definitions) {
            if (definition.kind === Kind.FRAGMENT_DEFINITION) {
              fragments[definition.name.value] = definition;
            }
          }
          const fields = collectFields(
            schema,
            fragments,
            variableValues,
            subscriptionType,
            node.selectionSet
          );
          if (fields.size > 1) {
            const fieldSelectionLists = [...fields.values()];
            const extraFieldSelectionLists = fieldSelectionLists.slice(1);
            const extraFieldSelections = extraFieldSelectionLists.flat();
            context.reportError(
              new GraphQLError(
                operationName != null ? `Subscription "${operationName}" must select only one top level field.` : "Anonymous Subscription must select only one top level field.",
                {
                  nodes: extraFieldSelections
                }
              )
            );
          }
          for (const fieldNodes of fields.values()) {
            const field = fieldNodes[0];
            const fieldName = field.name.value;
            if (fieldName.startsWith("__")) {
              context.reportError(
                new GraphQLError(
                  operationName != null ? `Subscription "${operationName}" must not select an introspection top level field.` : "Anonymous Subscription must not select an introspection top level field.",
                  {
                    nodes: fieldNodes
                  }
                )
              );
            }
          }
        }
      }
    }
  };
}

// node_modules/graphql/jsutils/groupBy.mjs
function groupBy(list, keyFn) {
  const result = /* @__PURE__ */ new Map();
  for (const item of list) {
    const key = keyFn(item);
    const group = result.get(key);
    if (group === void 0) {
      result.set(key, [item]);
    } else {
      group.push(item);
    }
  }
  return result;
}

// node_modules/graphql/validation/rules/UniqueArgumentDefinitionNamesRule.mjs
function UniqueArgumentDefinitionNamesRule(context) {
  return {
    DirectiveDefinition(directiveNode) {
      var _directiveNode$argume;
      const argumentNodes = (_directiveNode$argume = directiveNode.arguments) !== null && _directiveNode$argume !== void 0 ? _directiveNode$argume : [];
      return checkArgUniqueness(`@${directiveNode.name.value}`, argumentNodes);
    },
    InterfaceTypeDefinition: checkArgUniquenessPerField,
    InterfaceTypeExtension: checkArgUniquenessPerField,
    ObjectTypeDefinition: checkArgUniquenessPerField,
    ObjectTypeExtension: checkArgUniquenessPerField
  };
  function checkArgUniquenessPerField(typeNode) {
    var _typeNode$fields;
    const typeName = typeNode.name.value;
    const fieldNodes = (_typeNode$fields = typeNode.fields) !== null && _typeNode$fields !== void 0 ? _typeNode$fields : [];
    for (const fieldDef of fieldNodes) {
      var _fieldDef$arguments;
      const fieldName = fieldDef.name.value;
      const argumentNodes = (_fieldDef$arguments = fieldDef.arguments) !== null && _fieldDef$arguments !== void 0 ? _fieldDef$arguments : [];
      checkArgUniqueness(`${typeName}.${fieldName}`, argumentNodes);
    }
    return false;
  }
  function checkArgUniqueness(parentName, argumentNodes) {
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `Argument "${parentName}(${argName}:)" can only be defined once.`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueArgumentNamesRule.mjs
function UniqueArgumentNamesRule(context) {
  return {
    Field: checkArgUniqueness,
    Directive: checkArgUniqueness
  };
  function checkArgUniqueness(parentNode) {
    var _parentNode$arguments;
    const argumentNodes = (_parentNode$arguments = parentNode.arguments) !== null && _parentNode$arguments !== void 0 ? _parentNode$arguments : [];
    const seenArgs = groupBy(argumentNodes, (arg) => arg.name.value);
    for (const [argName, argNodes] of seenArgs) {
      if (argNodes.length > 1) {
        context.reportError(
          new GraphQLError(
            `There can be only one argument named "${argName}".`,
            {
              nodes: argNodes.map((node) => node.name)
            }
          )
        );
      }
    }
  }
}

// node_modules/graphql/validation/rules/UniqueDirectiveNamesRule.mjs
function UniqueDirectiveNamesRule(context) {
  const knownDirectiveNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    DirectiveDefinition(node) {
      const directiveName = node.name.value;
      if (schema !== null && schema !== void 0 && schema.getDirective(directiveName)) {
        context.reportError(
          new GraphQLError(
            `Directive "@${directiveName}" already exists in the schema. It cannot be redefined.`,
            {
              nodes: node.name
            }
          )
        );
        return;
      }
      if (knownDirectiveNames[directiveName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one directive named "@${directiveName}".`,
            {
              nodes: [knownDirectiveNames[directiveName], node.name]
            }
          )
        );
      } else {
        knownDirectiveNames[directiveName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueDirectivesPerLocationRule.mjs
function UniqueDirectivesPerLocationRule(context) {
  const uniqueDirectiveMap = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  const definedDirectives = schema ? schema.getDirectives() : specifiedDirectives;
  for (const directive of definedDirectives) {
    uniqueDirectiveMap[directive.name] = !directive.isRepeatable;
  }
  const astDefinitions = context.getDocument().definitions;
  for (const def of astDefinitions) {
    if (def.kind === Kind.DIRECTIVE_DEFINITION) {
      uniqueDirectiveMap[def.name.value] = !def.repeatable;
    }
  }
  const schemaDirectives = /* @__PURE__ */ Object.create(null);
  const typeDirectivesMap = /* @__PURE__ */ Object.create(null);
  return {
    // Many different AST nodes may contain directives. Rather than listing
    // them all, just listen for entering any node, and check to see if it
    // defines any directives.
    enter(node) {
      if (!("directives" in node) || !node.directives) {
        return;
      }
      let seenDirectives;
      if (node.kind === Kind.SCHEMA_DEFINITION || node.kind === Kind.SCHEMA_EXTENSION) {
        seenDirectives = schemaDirectives;
      } else if (isTypeDefinitionNode(node) || isTypeExtensionNode(node)) {
        const typeName = node.name.value;
        seenDirectives = typeDirectivesMap[typeName];
        if (seenDirectives === void 0) {
          typeDirectivesMap[typeName] = seenDirectives = /* @__PURE__ */ Object.create(null);
        }
      } else {
        seenDirectives = /* @__PURE__ */ Object.create(null);
      }
      for (const directive of node.directives) {
        const directiveName = directive.name.value;
        if (uniqueDirectiveMap[directiveName]) {
          if (seenDirectives[directiveName]) {
            context.reportError(
              new GraphQLError(
                `The directive "@${directiveName}" can only be used once at this location.`,
                {
                  nodes: [seenDirectives[directiveName], directive]
                }
              )
            );
          } else {
            seenDirectives[directiveName] = directive;
          }
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueEnumValueNamesRule.mjs
function UniqueEnumValueNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownValueNames = /* @__PURE__ */ Object.create(null);
  return {
    EnumTypeDefinition: checkValueUniqueness,
    EnumTypeExtension: checkValueUniqueness
  };
  function checkValueUniqueness(node) {
    var _node$values;
    const typeName = node.name.value;
    if (!knownValueNames[typeName]) {
      knownValueNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const valueNodes = (_node$values = node.values) !== null && _node$values !== void 0 ? _node$values : [];
    const valueNames = knownValueNames[typeName];
    for (const valueDef of valueNodes) {
      const valueName = valueDef.name.value;
      const existingType = existingTypeMap[typeName];
      if (isEnumType(existingType) && existingType.getValue(valueName)) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: valueDef.name
            }
          )
        );
      } else if (valueNames[valueName]) {
        context.reportError(
          new GraphQLError(
            `Enum value "${typeName}.${valueName}" can only be defined once.`,
            {
              nodes: [valueNames[valueName], valueDef.name]
            }
          )
        );
      } else {
        valueNames[valueName] = valueDef.name;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueFieldDefinitionNamesRule.mjs
function UniqueFieldDefinitionNamesRule(context) {
  const schema = context.getSchema();
  const existingTypeMap = schema ? schema.getTypeMap() : /* @__PURE__ */ Object.create(null);
  const knownFieldNames = /* @__PURE__ */ Object.create(null);
  return {
    InputObjectTypeDefinition: checkFieldUniqueness,
    InputObjectTypeExtension: checkFieldUniqueness,
    InterfaceTypeDefinition: checkFieldUniqueness,
    InterfaceTypeExtension: checkFieldUniqueness,
    ObjectTypeDefinition: checkFieldUniqueness,
    ObjectTypeExtension: checkFieldUniqueness
  };
  function checkFieldUniqueness(node) {
    var _node$fields;
    const typeName = node.name.value;
    if (!knownFieldNames[typeName]) {
      knownFieldNames[typeName] = /* @__PURE__ */ Object.create(null);
    }
    const fieldNodes = (_node$fields = node.fields) !== null && _node$fields !== void 0 ? _node$fields : [];
    const fieldNames = knownFieldNames[typeName];
    for (const fieldDef of fieldNodes) {
      const fieldName = fieldDef.name.value;
      if (hasField(existingTypeMap[typeName], fieldName)) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" already exists in the schema. It cannot also be defined in this type extension.`,
            {
              nodes: fieldDef.name
            }
          )
        );
      } else if (fieldNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `Field "${typeName}.${fieldName}" can only be defined once.`,
            {
              nodes: [fieldNames[fieldName], fieldDef.name]
            }
          )
        );
      } else {
        fieldNames[fieldName] = fieldDef.name;
      }
    }
    return false;
  }
}
function hasField(type, fieldName) {
  if (isObjectType(type) || isInterfaceType(type) || isInputObjectType(type)) {
    return type.getFields()[fieldName] != null;
  }
  return false;
}

// node_modules/graphql/validation/rules/UniqueFragmentNamesRule.mjs
function UniqueFragmentNamesRule(context) {
  const knownFragmentNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: () => false,
    FragmentDefinition(node) {
      const fragmentName = node.name.value;
      if (knownFragmentNames[fragmentName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one fragment named "${fragmentName}".`,
            {
              nodes: [knownFragmentNames[fragmentName], node.name]
            }
          )
        );
      } else {
        knownFragmentNames[fragmentName] = node.name;
      }
      return false;
    }
  };
}

// node_modules/graphql/validation/rules/UniqueInputFieldNamesRule.mjs
function UniqueInputFieldNamesRule(context) {
  const knownNameStack = [];
  let knownNames = /* @__PURE__ */ Object.create(null);
  return {
    ObjectValue: {
      enter() {
        knownNameStack.push(knownNames);
        knownNames = /* @__PURE__ */ Object.create(null);
      },
      leave() {
        const prevKnownNames = knownNameStack.pop();
        prevKnownNames || invariant(false);
        knownNames = prevKnownNames;
      }
    },
    ObjectField(node) {
      const fieldName = node.name.value;
      if (knownNames[fieldName]) {
        context.reportError(
          new GraphQLError(
            `There can be only one input field named "${fieldName}".`,
            {
              nodes: [knownNames[fieldName], node.name]
            }
          )
        );
      } else {
        knownNames[fieldName] = node.name;
      }
    }
  };
}

// node_modules/graphql/validation/rules/UniqueOperationNamesRule.mjs
function UniqueOperationNamesRule(context) {
  const knownOperationNames = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition(node) {
      const operationName = node.name;
      if (operationName) {
        if (knownOperationNames[operationName.value]) {
          context.reportError(
            new GraphQLError(
              `There can be only one operation named "${operationName.value}".`,
              {
                nodes: [
                  knownOperationNames[operationName.value],
                  operationName
                ]
              }
            )
          );
        } else {
          knownOperationNames[operationName.value] = operationName;
        }
      }
      return false;
    },
    FragmentDefinition: () => false
  };
}

// node_modules/graphql/validation/rules/UniqueOperationTypesRule.mjs
function UniqueOperationTypesRule(context) {
  const schema = context.getSchema();
  const definedOperationTypes = /* @__PURE__ */ Object.create(null);
  const existingOperationTypes = schema ? {
    query: schema.getQueryType(),
    mutation: schema.getMutationType(),
    subscription: schema.getSubscriptionType()
  } : {};
  return {
    SchemaDefinition: checkOperationTypes,
    SchemaExtension: checkOperationTypes
  };
  function checkOperationTypes(node) {
    var _node$operationTypes;
    const operationTypesNodes = (_node$operationTypes = node.operationTypes) !== null && _node$operationTypes !== void 0 ? _node$operationTypes : [];
    for (const operationType of operationTypesNodes) {
      const operation = operationType.operation;
      const alreadyDefinedOperationType = definedOperationTypes[operation];
      if (existingOperationTypes[operation]) {
        context.reportError(
          new GraphQLError(
            `Type for ${operation} already defined in the schema. It cannot be redefined.`,
            {
              nodes: operationType
            }
          )
        );
      } else if (alreadyDefinedOperationType) {
        context.reportError(
          new GraphQLError(
            `There can be only one ${operation} type in schema.`,
            {
              nodes: [alreadyDefinedOperationType, operationType]
            }
          )
        );
      } else {
        definedOperationTypes[operation] = operationType;
      }
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueTypeNamesRule.mjs
function UniqueTypeNamesRule(context) {
  const knownTypeNames = /* @__PURE__ */ Object.create(null);
  const schema = context.getSchema();
  return {
    ScalarTypeDefinition: checkTypeName,
    ObjectTypeDefinition: checkTypeName,
    InterfaceTypeDefinition: checkTypeName,
    UnionTypeDefinition: checkTypeName,
    EnumTypeDefinition: checkTypeName,
    InputObjectTypeDefinition: checkTypeName
  };
  function checkTypeName(node) {
    const typeName = node.name.value;
    if (schema !== null && schema !== void 0 && schema.getType(typeName)) {
      context.reportError(
        new GraphQLError(
          `Type "${typeName}" already exists in the schema. It cannot also be defined in this type definition.`,
          {
            nodes: node.name
          }
        )
      );
      return;
    }
    if (knownTypeNames[typeName]) {
      context.reportError(
        new GraphQLError(`There can be only one type named "${typeName}".`, {
          nodes: [knownTypeNames[typeName], node.name]
        })
      );
    } else {
      knownTypeNames[typeName] = node.name;
    }
    return false;
  }
}

// node_modules/graphql/validation/rules/UniqueVariableNamesRule.mjs
function UniqueVariableNamesRule(context) {
  return {
    OperationDefinition(operationNode) {
      var _operationNode$variab;
      const variableDefinitions = (_operationNode$variab = operationNode.variableDefinitions) !== null && _operationNode$variab !== void 0 ? _operationNode$variab : [];
      const seenVariableDefinitions = groupBy(
        variableDefinitions,
        (node) => node.variable.name.value
      );
      for (const [variableName, variableNodes] of seenVariableDefinitions) {
        if (variableNodes.length > 1) {
          context.reportError(
            new GraphQLError(
              `There can be only one variable named "$${variableName}".`,
              {
                nodes: variableNodes.map((node) => node.variable.name)
              }
            )
          );
        }
      }
    }
  };
}

// node_modules/graphql/validation/rules/ValuesOfCorrectTypeRule.mjs
function ValuesOfCorrectTypeRule(context) {
  let variableDefinitions = {};
  return {
    OperationDefinition: {
      enter() {
        variableDefinitions = {};
      }
    },
    VariableDefinition(definition) {
      variableDefinitions[definition.variable.name.value] = definition;
    },
    ListValue(node) {
      const type = getNullableType(context.getParentInputType());
      if (!isListType(type)) {
        isValidValueNode(context, node);
        return false;
      }
    },
    ObjectValue(node) {
      const type = getNamedType(context.getInputType());
      if (!isInputObjectType(type)) {
        isValidValueNode(context, node);
        return false;
      }
      const fieldNodeMap = keyMap(node.fields, (field) => field.name.value);
      for (const fieldDef of Object.values(type.getFields())) {
        const fieldNode = fieldNodeMap[fieldDef.name];
        if (!fieldNode && isRequiredInputField(fieldDef)) {
          const typeStr = inspect(fieldDef.type);
          context.reportError(
            new GraphQLError(
              `Field "${type.name}.${fieldDef.name}" of required type "${typeStr}" was not provided.`,
              {
                nodes: node
              }
            )
          );
        }
      }
      if (type.isOneOf) {
        validateOneOfInputObject(
          context,
          node,
          type,
          fieldNodeMap,
          variableDefinitions
        );
      }
    },
    ObjectField(node) {
      const parentType = getNamedType(context.getParentInputType());
      const fieldType = context.getInputType();
      if (!fieldType && isInputObjectType(parentType)) {
        const suggestions = suggestionList(
          node.name.value,
          Object.keys(parentType.getFields())
        );
        context.reportError(
          new GraphQLError(
            `Field "${node.name.value}" is not defined by type "${parentType.name}".` + didYouMean(suggestions),
            {
              nodes: node
            }
          )
        );
      }
    },
    NullValue(node) {
      const type = context.getInputType();
      if (isNonNullType(type)) {
        context.reportError(
          new GraphQLError(
            `Expected value of type "${inspect(type)}", found ${print(node)}.`,
            {
              nodes: node
            }
          )
        );
      }
    },
    EnumValue: (node) => isValidValueNode(context, node),
    IntValue: (node) => isValidValueNode(context, node),
    FloatValue: (node) => isValidValueNode(context, node),
    StringValue: (node) => isValidValueNode(context, node),
    BooleanValue: (node) => isValidValueNode(context, node)
  };
}
function isValidValueNode(context, node) {
  const locationType = context.getInputType();
  if (!locationType) {
    return;
  }
  const type = getNamedType(locationType);
  if (!isLeafType(type)) {
    const typeStr = inspect(locationType);
    context.reportError(
      new GraphQLError(
        `Expected value of type "${typeStr}", found ${print(node)}.`,
        {
          nodes: node
        }
      )
    );
    return;
  }
  try {
    const parseResult = type.parseLiteral(
      node,
      void 0
      /* variables */
    );
    if (parseResult === void 0) {
      const typeStr = inspect(locationType);
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}.`,
          {
            nodes: node
          }
        )
      );
    }
  } catch (error) {
    const typeStr = inspect(locationType);
    if (error instanceof GraphQLError) {
      context.reportError(error);
    } else {
      context.reportError(
        new GraphQLError(
          `Expected value of type "${typeStr}", found ${print(node)}; ` + error.message,
          {
            nodes: node,
            originalError: error
          }
        )
      );
    }
  }
}
function validateOneOfInputObject(context, node, type, fieldNodeMap, variableDefinitions) {
  var _fieldNodeMap$keys$;
  const keys = Object.keys(fieldNodeMap);
  const isNotExactlyOneField = keys.length !== 1;
  if (isNotExactlyOneField) {
    context.reportError(
      new GraphQLError(
        `OneOf Input Object "${type.name}" must specify exactly one key.`,
        {
          nodes: [node]
        }
      )
    );
    return;
  }
  const value = (_fieldNodeMap$keys$ = fieldNodeMap[keys[0]]) === null || _fieldNodeMap$keys$ === void 0 ? void 0 : _fieldNodeMap$keys$.value;
  const isNullLiteral = !value || value.kind === Kind.NULL;
  const isVariable = (value === null || value === void 0 ? void 0 : value.kind) === Kind.VARIABLE;
  if (isNullLiteral) {
    context.reportError(
      new GraphQLError(`Field "${type.name}.${keys[0]}" must be non-null.`, {
        nodes: [node]
      })
    );
    return;
  }
  if (isVariable) {
    const variableName = value.name.value;
    const definition = variableDefinitions[variableName];
    const isNullableVariable = definition.type.kind !== Kind.NON_NULL_TYPE;
    if (isNullableVariable) {
      context.reportError(
        new GraphQLError(
          `Variable "${variableName}" must be non-nullable to be used for OneOf Input Object "${type.name}".`,
          {
            nodes: [node]
          }
        )
      );
    }
  }
}

// node_modules/graphql/validation/rules/VariablesAreInputTypesRule.mjs
function VariablesAreInputTypesRule(context) {
  return {
    VariableDefinition(node) {
      const type = typeFromAST(context.getSchema(), node.type);
      if (type !== void 0 && !isInputType(type)) {
        const variableName = node.variable.name.value;
        const typeName = print(node.type);
        context.reportError(
          new GraphQLError(
            `Variable "$${variableName}" cannot be non-input type "${typeName}".`,
            {
              nodes: node.type
            }
          )
        );
      }
    }
  };
}

// node_modules/graphql/validation/rules/VariablesInAllowedPositionRule.mjs
function VariablesInAllowedPositionRule(context) {
  let varDefMap = /* @__PURE__ */ Object.create(null);
  return {
    OperationDefinition: {
      enter() {
        varDefMap = /* @__PURE__ */ Object.create(null);
      },
      leave(operation) {
        const usages = context.getRecursiveVariableUsages(operation);
        for (const { node, type, defaultValue } of usages) {
          const varName = node.name.value;
          const varDef = varDefMap[varName];
          if (varDef && type) {
            const schema = context.getSchema();
            const varType = typeFromAST(schema, varDef.type);
            if (varType && !allowedVariableUsage(
              schema,
              varType,
              varDef.defaultValue,
              type,
              defaultValue
            )) {
              const varTypeStr = inspect(varType);
              const typeStr = inspect(type);
              context.reportError(
                new GraphQLError(
                  `Variable "$${varName}" of type "${varTypeStr}" used in position expecting type "${typeStr}".`,
                  {
                    nodes: [varDef, node]
                  }
                )
              );
            }
          }
        }
      }
    },
    VariableDefinition(node) {
      varDefMap[node.variable.name.value] = node;
    }
  };
}
function allowedVariableUsage(schema, varType, varDefaultValue, locationType, locationDefaultValue) {
  if (isNonNullType(locationType) && !isNonNullType(varType)) {
    const hasNonNullVariableDefaultValue = varDefaultValue != null && varDefaultValue.kind !== Kind.NULL;
    const hasLocationDefaultValue = locationDefaultValue !== void 0;
    if (!hasNonNullVariableDefaultValue && !hasLocationDefaultValue) {
      return false;
    }
    const nullableLocationType = locationType.ofType;
    return isTypeSubTypeOf(schema, varType, nullableLocationType);
  }
  return isTypeSubTypeOf(schema, varType, locationType);
}

// node_modules/graphql/validation/specifiedRules.mjs
var recommendedRules = Object.freeze([MaxIntrospectionDepthRule]);
var specifiedRules = Object.freeze([
  ExecutableDefinitionsRule,
  UniqueOperationNamesRule,
  LoneAnonymousOperationRule,
  SingleFieldSubscriptionsRule,
  KnownTypeNamesRule,
  FragmentsOnCompositeTypesRule,
  VariablesAreInputTypesRule,
  ScalarLeafsRule,
  FieldsOnCorrectTypeRule,
  UniqueFragmentNamesRule,
  KnownFragmentNamesRule,
  NoUnusedFragmentsRule,
  PossibleFragmentSpreadsRule,
  NoFragmentCyclesRule,
  UniqueVariableNamesRule,
  NoUndefinedVariablesRule,
  NoUnusedVariablesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  KnownArgumentNamesRule,
  UniqueArgumentNamesRule,
  ValuesOfCorrectTypeRule,
  ProvidedRequiredArgumentsRule,
  VariablesInAllowedPositionRule,
  OverlappingFieldsCanBeMergedRule,
  UniqueInputFieldNamesRule,
  ...recommendedRules
]);
var specifiedSDLRules = Object.freeze([
  LoneSchemaDefinitionRule,
  UniqueOperationTypesRule,
  UniqueTypeNamesRule,
  UniqueEnumValueNamesRule,
  UniqueFieldDefinitionNamesRule,
  UniqueArgumentDefinitionNamesRule,
  UniqueDirectiveNamesRule,
  KnownTypeNamesRule,
  KnownDirectivesRule,
  UniqueDirectivesPerLocationRule,
  PossibleTypeExtensionsRule,
  KnownArgumentNamesOnDirectivesRule,
  UniqueArgumentNamesRule,
  UniqueInputFieldNamesRule,
  ProvidedRequiredArgumentsOnDirectivesRule
]);

// node_modules/graphql/jsutils/memoize3.mjs
function memoize3(fn3) {
  let cache0;
  return function memoized(a1, a2, a3) {
    if (cache0 === void 0) {
      cache0 = /* @__PURE__ */ new WeakMap();
    }
    let cache1 = cache0.get(a1);
    if (cache1 === void 0) {
      cache1 = /* @__PURE__ */ new WeakMap();
      cache0.set(a1, cache1);
    }
    let cache2 = cache1.get(a2);
    if (cache2 === void 0) {
      cache2 = /* @__PURE__ */ new WeakMap();
      cache1.set(a2, cache2);
    }
    let fnResult = cache2.get(a3);
    if (fnResult === void 0) {
      fnResult = fn3(a1, a2, a3);
      cache2.set(a3, fnResult);
    }
    return fnResult;
  };
}

// node_modules/graphql/execution/execute.mjs
var collectSubfields2 = memoize3(
  (exeContext, returnType, fieldNodes) => collectSubfields(
    exeContext.schema,
    exeContext.fragments,
    exeContext.variableValues,
    returnType,
    fieldNodes
  )
);

// node_modules/graphql/utilities/extendSchema.mjs
var stdTypeMap = keyMap(
  [...specifiedScalarTypes, ...introspectionTypes],
  (type) => type.name
);

// node_modules/graphql/utilities/findBreakingChanges.mjs
var BreakingChangeType;
(function(BreakingChangeType2) {
  BreakingChangeType2["TYPE_REMOVED"] = "TYPE_REMOVED";
  BreakingChangeType2["TYPE_CHANGED_KIND"] = "TYPE_CHANGED_KIND";
  BreakingChangeType2["TYPE_REMOVED_FROM_UNION"] = "TYPE_REMOVED_FROM_UNION";
  BreakingChangeType2["VALUE_REMOVED_FROM_ENUM"] = "VALUE_REMOVED_FROM_ENUM";
  BreakingChangeType2["REQUIRED_INPUT_FIELD_ADDED"] = "REQUIRED_INPUT_FIELD_ADDED";
  BreakingChangeType2["IMPLEMENTED_INTERFACE_REMOVED"] = "IMPLEMENTED_INTERFACE_REMOVED";
  BreakingChangeType2["FIELD_REMOVED"] = "FIELD_REMOVED";
  BreakingChangeType2["FIELD_CHANGED_KIND"] = "FIELD_CHANGED_KIND";
  BreakingChangeType2["REQUIRED_ARG_ADDED"] = "REQUIRED_ARG_ADDED";
  BreakingChangeType2["ARG_REMOVED"] = "ARG_REMOVED";
  BreakingChangeType2["ARG_CHANGED_KIND"] = "ARG_CHANGED_KIND";
  BreakingChangeType2["DIRECTIVE_REMOVED"] = "DIRECTIVE_REMOVED";
  BreakingChangeType2["DIRECTIVE_ARG_REMOVED"] = "DIRECTIVE_ARG_REMOVED";
  BreakingChangeType2["REQUIRED_DIRECTIVE_ARG_ADDED"] = "REQUIRED_DIRECTIVE_ARG_ADDED";
  BreakingChangeType2["DIRECTIVE_REPEATABLE_REMOVED"] = "DIRECTIVE_REPEATABLE_REMOVED";
  BreakingChangeType2["DIRECTIVE_LOCATION_REMOVED"] = "DIRECTIVE_LOCATION_REMOVED";
})(BreakingChangeType || (BreakingChangeType = {}));
var DangerousChangeType;
(function(DangerousChangeType2) {
  DangerousChangeType2["VALUE_ADDED_TO_ENUM"] = "VALUE_ADDED_TO_ENUM";
  DangerousChangeType2["TYPE_ADDED_TO_UNION"] = "TYPE_ADDED_TO_UNION";
  DangerousChangeType2["OPTIONAL_INPUT_FIELD_ADDED"] = "OPTIONAL_INPUT_FIELD_ADDED";
  DangerousChangeType2["OPTIONAL_ARG_ADDED"] = "OPTIONAL_ARG_ADDED";
  DangerousChangeType2["IMPLEMENTED_INTERFACE_ADDED"] = "IMPLEMENTED_INTERFACE_ADDED";
  DangerousChangeType2["ARG_DEFAULT_VALUE_CHANGE"] = "ARG_DEFAULT_VALUE_CHANGE";
})(DangerousChangeType || (DangerousChangeType = {}));

// node_modules/graphql-request/build/lib/http.js
var ACCEPT_HEADER = `Accept`;
var CONTENT_TYPE_HEADER = `Content-Type`;
var CONTENT_TYPE_JSON = `application/json`;
var CONTENT_TYPE_GQL = `application/graphql-response+json`;

// node_modules/graphql-request/build/legacy/lib/graphql.js
var cleanQuery = (str) => str.replace(/([\s,]|#[^\n\r]+)+/g, ` `).trim();
var isGraphQLContentType = (contentType) => {
  const contentTypeLower = contentType.toLowerCase();
  return contentTypeLower.includes(CONTENT_TYPE_GQL) || contentTypeLower.includes(CONTENT_TYPE_JSON);
};
var parseGraphQLExecutionResult = (result) => {
  try {
    if (Array.isArray(result)) {
      return {
        _tag: `Batch`,
        executionResults: result.map(parseExecutionResult)
      };
    } else if (isPlainObject(result)) {
      return {
        _tag: `Single`,
        executionResult: parseExecutionResult(result)
      };
    } else {
      throw new Error(`Invalid execution result: result is not object or array. 
Got:
${String(result)}`);
    }
  } catch (e10) {
    return e10;
  }
};
var parseExecutionResult = (result) => {
  if (typeof result !== `object` || result === null) {
    throw new Error(`Invalid execution result: result is not object`);
  }
  let errors2 = void 0;
  let data = void 0;
  let extensions = void 0;
  if (`errors` in result) {
    if (!isPlainObject(result.errors) && !Array.isArray(result.errors)) {
      throw new Error(`Invalid execution result: errors is not plain object OR array`);
    }
    errors2 = result.errors;
  }
  if (`data` in result) {
    if (!isPlainObject(result.data) && result.data !== null) {
      throw new Error(`Invalid execution result: data is not plain object`);
    }
    data = result.data;
  }
  if (`extensions` in result) {
    if (!isPlainObject(result.extensions))
      throw new Error(`Invalid execution result: extensions is not plain object`);
    extensions = result.extensions;
  }
  return {
    data,
    errors: errors2,
    extensions
  };
};
var isRequestResultHaveErrors = (result) => result._tag === `Batch` ? result.executionResults.some(isExecutionResultHaveErrors) : isExecutionResultHaveErrors(result.executionResult);
var isExecutionResultHaveErrors = (result) => Array.isArray(result.errors) ? result.errors.length > 0 : Boolean(result.errors);
var isOperationDefinitionNode = (definition) => {
  return typeof definition === `object` && definition !== null && `kind` in definition && definition.kind === Kind.OPERATION_DEFINITION;
};

// node_modules/graphql-request/build/legacy/helpers/analyzeDocument.js
var extractOperationName = (document2) => {
  var _a;
  let operationName = void 0;
  const defs = document2.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    operationName = (_a = defs[0].name) == null ? void 0 : _a.value;
  }
  return operationName;
};
var extractIsMutation = (document2) => {
  let isMutation = false;
  const defs = document2.definitions.filter(isOperationDefinitionNode);
  if (defs.length === 1) {
    isMutation = defs[0].operation === OperationTypeNode.MUTATION;
  }
  return isMutation;
};
var analyzeDocument = (document2, excludeOperationName) => {
  const expression = typeof document2 === `string` ? document2 : print(document2);
  let isMutation = false;
  let operationName = void 0;
  if (excludeOperationName) {
    return { expression, isMutation, operationName };
  }
  const docNode = tryCatch(() => typeof document2 === `string` ? parse(document2) : document2);
  if (docNode instanceof Error) {
    return { expression, isMutation, operationName };
  }
  operationName = extractOperationName(docNode);
  isMutation = extractIsMutation(docNode);
  return { expression, operationName, isMutation };
};

// node_modules/graphql-request/build/legacy/helpers/defaultJsonSerializer.js
var defaultJsonSerializer = JSON;

// node_modules/graphql-request/build/legacy/helpers/runRequest.js
var runRequest = async (input) => {
  const config = {
    ...input,
    method: input.request._tag === `Single` ? input.request.document.isMutation ? `POST` : uppercase(input.method ?? `post`) : input.request.hasMutations ? `POST` : uppercase(input.method ?? `post`),
    fetchOptions: {
      ...input.fetchOptions,
      errorPolicy: input.fetchOptions.errorPolicy ?? `none`
    }
  };
  const fetcher = createFetcher(config.method);
  const fetchResponse = await fetcher(config);
  if (!fetchResponse.ok) {
    return new ClientError({ status: fetchResponse.status, headers: fetchResponse.headers }, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  const result = await parseResultFromResponse(fetchResponse, input.fetchOptions.jsonSerializer ?? defaultJsonSerializer);
  if (result instanceof Error)
    throw result;
  const clientResponseBase = {
    status: fetchResponse.status,
    headers: fetchResponse.headers
  };
  if (isRequestResultHaveErrors(result) && config.fetchOptions.errorPolicy === `none`) {
    const clientResponse = result._tag === `Batch` ? { ...result.executionResults, ...clientResponseBase } : {
      ...result.executionResult,
      ...clientResponseBase
    };
    return new ClientError(clientResponse, {
      query: input.request._tag === `Single` ? input.request.document.expression : input.request.query,
      variables: input.request.variables
    });
  }
  switch (result._tag) {
    case `Single`:
      return {
        ...clientResponseBase,
        ...executionResultClientResponseFields(config)(result.executionResult)
      };
    case `Batch`:
      return {
        ...clientResponseBase,
        data: result.executionResults.map(executionResultClientResponseFields(config))
      };
    default:
      casesExhausted(result);
  }
};
var executionResultClientResponseFields = ($params) => (executionResult) => {
  return {
    extensions: executionResult.extensions,
    data: executionResult.data,
    errors: $params.fetchOptions.errorPolicy === `all` ? executionResult.errors : void 0
  };
};
var parseResultFromResponse = async (response, jsonSerializer) => {
  const contentType = response.headers.get(CONTENT_TYPE_HEADER);
  const text = await response.text();
  if (contentType && isGraphQLContentType(contentType)) {
    return parseGraphQLExecutionResult(jsonSerializer.parse(text));
  } else {
    return parseGraphQLExecutionResult(text);
  }
};
var createFetcher = (method) => async (params) => {
  const headers = new Headers(params.headers);
  let searchParams = null;
  let body = void 0;
  if (!headers.has(ACCEPT_HEADER)) {
    headers.set(ACCEPT_HEADER, [CONTENT_TYPE_GQL, CONTENT_TYPE_JSON].join(`, `));
  }
  if (method === `POST`) {
    const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;
    body = $jsonSerializer.stringify(buildBody(params));
    if (typeof body === `string` && !headers.has(CONTENT_TYPE_HEADER)) {
      headers.set(CONTENT_TYPE_HEADER, CONTENT_TYPE_JSON);
    }
  } else {
    searchParams = buildQueryParams(params);
  }
  const init = { method, headers, body, ...params.fetchOptions };
  let url = new URL(params.url);
  let initResolved = init;
  if (params.middleware) {
    const result = await Promise.resolve(params.middleware({
      ...init,
      url: params.url,
      operationName: params.request._tag === `Single` ? params.request.document.operationName : void 0,
      variables: params.request.variables
    }));
    const { url: urlNew, ...initNew } = result;
    url = new URL(urlNew);
    initResolved = initNew;
  }
  if (searchParams) {
    searchParams.forEach((value, name) => {
      url.searchParams.append(name, value);
    });
  }
  const $fetch = params.fetch ?? fetch;
  return await $fetch(url, initResolved);
};
var buildBody = (params) => {
  switch (params.request._tag) {
    case `Single`:
      return {
        query: params.request.document.expression,
        variables: params.request.variables,
        operationName: params.request.document.operationName
      };
    case `Batch`:
      return zip(params.request.query, params.request.variables ?? []).map(([query, variables]) => ({
        query,
        variables
      }));
    default:
      throw casesExhausted(params.request);
  }
};
var buildQueryParams = (params) => {
  var _a;
  const $jsonSerializer = params.fetchOptions.jsonSerializer ?? defaultJsonSerializer;
  const searchParams = new URLSearchParams();
  switch (params.request._tag) {
    case `Single`: {
      searchParams.append(`query`, cleanQuery(params.request.document.expression));
      if (params.request.variables) {
        searchParams.append(`variables`, $jsonSerializer.stringify(params.request.variables));
      }
      if (params.request.document.operationName) {
        searchParams.append(`operationName`, params.request.document.operationName);
      }
      return searchParams;
    }
    case `Batch`: {
      const variablesSerialized = ((_a = params.request.variables) == null ? void 0 : _a.map((v) => $jsonSerializer.stringify(v))) ?? [];
      const queriesCleaned = params.request.query.map(cleanQuery);
      const payload = zip(queriesCleaned, variablesSerialized).map(([query, variables]) => ({
        query,
        variables
      }));
      searchParams.append(`query`, $jsonSerializer.stringify(payload));
      return searchParams;
    }
    default:
      throw casesExhausted(params.request);
  }
};

// node_modules/graphql-request/build/legacy/classes/GraphQLClient.js
var GraphQLClient = class {
  constructor(url, requestConfig = {}) {
    __publicField(this, "url");
    __publicField(this, "requestConfig");
    /**
     * Send a GraphQL query to the server.
     */
    __publicField(this, "rawRequest", async (...args) => {
      const [queryOrOptions, variables, requestHeaders] = args;
      const rawRequestOptions = parseRawRequestArgs(queryOrOptions, variables, requestHeaders);
      const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
      const { url } = this;
      if (rawRequestOptions.signal !== void 0) {
        fetchOptions.signal = rawRequestOptions.signal;
      }
      const document2 = analyzeDocument(rawRequestOptions.query, excludeOperationName);
      const response = await runRequest({
        url,
        request: {
          _tag: `Single`,
          document: document2,
          variables: rawRequestOptions.variables
        },
        headers: {
          ...HeadersInitToPlainObject(callOrIdentity(headers)),
          ...HeadersInitToPlainObject(rawRequestOptions.requestHeaders)
        },
        fetch: fetch2,
        method,
        fetchOptions,
        middleware: requestMiddleware
      });
      if (responseMiddleware) {
        await responseMiddleware(response, {
          operationName: document2.operationName,
          variables,
          url: this.url
        });
      }
      if (response instanceof Error) {
        throw response;
      }
      return response;
    });
    this.url = url;
    this.requestConfig = requestConfig;
  }
  async request(documentOrOptions, ...variablesAndRequestHeaders) {
    const [variables, requestHeaders] = variablesAndRequestHeaders;
    const requestOptions = parseRequestArgs(documentOrOptions, variables, requestHeaders);
    const { headers, fetch: fetch2 = globalThis.fetch, method = `POST`, requestMiddleware, responseMiddleware, excludeOperationName, ...fetchOptions } = this.requestConfig;
    const { url } = this;
    if (requestOptions.signal !== void 0) {
      fetchOptions.signal = requestOptions.signal;
    }
    const analyzedDocument = analyzeDocument(requestOptions.document, excludeOperationName);
    const response = await runRequest({
      url,
      request: {
        _tag: `Single`,
        document: analyzedDocument,
        variables: requestOptions.variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(requestOptions.requestHeaders)
      },
      fetch: fetch2,
      method,
      fetchOptions,
      middleware: requestMiddleware
    });
    if (responseMiddleware) {
      await responseMiddleware(response, {
        operationName: analyzedDocument.operationName,
        variables: requestOptions.variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  async batchRequests(documentsOrOptions, requestHeaders) {
    const batchRequestOptions = parseBatchRequestArgs(documentsOrOptions, requestHeaders);
    const { headers, excludeOperationName, ...fetchOptions } = this.requestConfig;
    if (batchRequestOptions.signal !== void 0) {
      fetchOptions.signal = batchRequestOptions.signal;
    }
    const analyzedDocuments = batchRequestOptions.documents.map(({ document: document2 }) => analyzeDocument(document2, excludeOperationName));
    const expressions = analyzedDocuments.map(({ expression }) => expression);
    const hasMutations = analyzedDocuments.some(({ isMutation }) => isMutation);
    const variables = batchRequestOptions.documents.map(({ variables: variables2 }) => variables2);
    const response = await runRequest({
      url: this.url,
      request: {
        _tag: `Batch`,
        operationName: void 0,
        query: expressions,
        hasMutations,
        variables
      },
      headers: {
        ...HeadersInitToPlainObject(callOrIdentity(headers)),
        ...HeadersInitToPlainObject(batchRequestOptions.requestHeaders)
      },
      fetch: this.requestConfig.fetch ?? globalThis.fetch,
      method: this.requestConfig.method || `POST`,
      fetchOptions,
      middleware: this.requestConfig.requestMiddleware
    });
    if (this.requestConfig.responseMiddleware) {
      await this.requestConfig.responseMiddleware(response, {
        operationName: void 0,
        variables,
        url: this.url
      });
    }
    if (response instanceof Error) {
      throw response;
    }
    return response.data;
  }
  setHeaders(headers) {
    this.requestConfig.headers = headers;
    return this;
  }
  /**
   * Attach a header to the client. All subsequent requests will have this header.
   */
  setHeader(key, value) {
    const { headers } = this.requestConfig;
    if (headers) {
      headers[key] = value;
    } else {
      this.requestConfig.headers = { [key]: value };
    }
    return this;
  }
  /**
   * Change the client endpoint. All subsequent requests will send to this endpoint.
   */
  setEndpoint(value) {
    this.url = value;
    return this;
  }
};

// node_modules/graphql-request/build/legacy/functions/request.js
async function request2(urlOrOptions, document2, ...variablesAndRequestHeaders) {
  const requestOptions = parseRequestExtendedArgs(urlOrOptions, document2, ...variablesAndRequestHeaders);
  const client = new GraphQLClient(requestOptions.url);
  return client.request({
    ...requestOptions
  });
}
var parseRequestArgs = (documentOrOptions, variables, requestHeaders) => {
  return documentOrOptions.document ? documentOrOptions : {
    document: documentOrOptions,
    variables,
    requestHeaders,
    signal: void 0
  };
};
var parseRequestExtendedArgs = (urlOrOptions, document2, ...variablesAndRequestHeaders) => {
  const [variables, requestHeaders] = variablesAndRequestHeaders;
  return typeof urlOrOptions === `string` ? {
    url: urlOrOptions,
    document: document2,
    variables,
    requestHeaders,
    signal: void 0
  } : urlOrOptions;
};

// node_modules/graphql-request/build/legacy/functions/gql.js
var gql = (chunks, ...variables) => {
  return chunks.reduce((acc, chunk, index) => `${acc}${chunk}${index in variables ? String(variables[index]) : ``}`, ``);
};

// node_modules/graphql-request/build/entrypoints/main.js
var main_default = request2;

// node_modules/@mizuwallet-sdk/core/dist/index.js
var k = Object.defineProperty;
var y2 = (r7, e10, t14) => e10 in r7 ? k(r7, e10, { enumerable: true, configurable: true, writable: true, value: t14 }) : r7[e10] = t14;
var s2 = (r7, e10, t14) => y2(r7, typeof e10 != "symbol" ? e10 + "" : e10, t14);
var $ = (r7) => {
  var t14;
  if (!r7) return new Error("JWT Token not found. ");
  const e10 = jwtDecode(r7);
  if ((e10 == null ? void 0 : e10.exp) < Date.now() / 1e3)
    throw new Error("JWT Token expired. Please login again! ");
  if ((t14 = e10 == null ? void 0 : e10["https://hasura.io/jwt/claims"]) != null && t14["x-hasura-user-id"])
    return [e10["https://hasura.io/jwt/claims"]["x-hasura-user-id"], r7];
  throw new Error("User id not found in JWT Token");
};
var p3 = (r7) => r7.arguments ? {
  function: r7.function,
  functionArguments: r7.arguments,
  typeArguments: r7.type_arguments
} : r7.functionArguments ? r7 : null;
var f4 = gql`
  mutation TGLoginMutation($appId: String = "", $initData: String = "") {
    tgLogin(appId: $appId, initData: $initData)
  }
`;
var T3 = gql`
  mutation TGLoginMutation($appId: String = "", $initData: String = "", $shortId: String = "") {
    tgLogin(appId: $appId, initData: $initData, shortId: $shortId)
  }
`;
var E = gql`
  mutation tgWidgetLoginMutation($appId: String = "", $authData: String = "") {
    tgWidgetLogin(appId: $appId, authData: $authData)
  }
`;
var q = gql`
  mutation tgWidgetLoginMutation(
    $appId: String = ""
    $authData: String = ""
    $shortId: String = ""
  ) {
    tgWidgetLogin(appId: $appId, authData: $authData, shortId: $shortId)
  }
`;
var S = gql`
  query CheckUserIsExistQueryByTgId {
    telegramUser {
      walletUserId
      tgId
    }
  }
`;
var g = gql`
  query UserWalletAddressQuery($id: uuid = "") {
    walletUserByPk(id: $id) {
      sub_wallets {
        address
        publicKey
      }
      google_user {
        email
      }
      telegram_user {
        firstName
        lastName
        photoUrl
        userName
      }
      twitter_user {
        name
        userName
      }
    }
  }
`;
var W2 = gql`
  mutation CreateOrderQuery($appId: String = "", $payload: String = "") {
    createOrder(appId: $appId, payload: $payload)
  }
`;
var z = gql`
  mutation createSignatureMutation($appId: String = "", $transactionHex: String = "") {
    createSignature(appId: $appId, transactionHex: $transactionHex)
  }
`;
var P = gql`
  mutation createSignMessageMutation(
    $appId: String = ""
    $message: String = ""
    $nonce: String = ""
  ) {
    createSignMessage(appId: $appId, nonce: $nonce, message: $message) {
      fullMessage
      message
      nonce
      prefix
      signature
    }
  }
`;
var C2 = gql`
  query simulateOrderQuery($payload: String = "") {
    simulateOrder(payload: $payload)
  }
`;
var O = gql`
  mutation confirmOrderQuery($orderId: String = "") {
    confirmOrder(orderId: $orderId)
  }
`;
var L = gql`
  query fetchOrderQuery($id: uuid = "") {
    orderByPk(id: $id) {
      id
      createdAt
      payload
      status
      type
      updatedAt
      walletUserId
      applicationId
      hash
      type
      transactions {
        hash
        type
      }
    }
  }
`;
gql`
  query fetchOrderHashQuery($orderId: String = "") {
    getOrderHash(orderId: $orderId)
  }
`;
var b = gql`
  query fetchOrderListQuery(
    $walletUserId: uuid = ""
    $limit: Int = 10
    $offset: Int = 0
    $status: [Int] = []
  ) {
    order(
      where: { walletUserId: { _eq: $walletUserId } }
      limit: $limit
      offset: $offset
      orderBy: { createdAt: DESC }
    ) {
      applicationId
      createdAt
      id
      payload
      status
      transactionSeqNo
      type
      updatedAt
      walletUserId
      hash
      gasFee
      transactions {
        hash
        gasFee
        createdAt
        status
        type
      }
    }
    orderAggregate(where: { walletUserId: { _eq: $walletUserId } }) {
      aggregate {
        count
      }
    }
  }
`;
var A4 = gql`
  mutation bindGoogleQuery($address: String = "", $idToken: String = "") {
    googleBind(address: $address, idToken: $idToken)
  }
`;
var D2 = gql`
  mutation createOrderWithCodeMutation(
    $appId: String = ""
    $authCode: String = ""
    $payload: String = ""
  ) {
    createOrderWithCode(appId: $appId, authCode: $authCode, payload: $payload)
  }
`;
var d7 = ((r7) => (r7[r7.PENDING = 0] = "PENDING", r7[r7.CONFIRMED = 1] = "CONFIRMED", r7[r7.EXECUTED = 2] = "EXECUTED", r7[r7.SUCCESS = 3] = "SUCCESS", r7[r7.FAIL = 4] = "FAIL", r7[r7.CANCELED = 5] = "CANCELED", r7))(d7 || {});
var I = {
  testnet: "https://hasura-wallet.groupwar.xyz/v1/graphql",
  mainnet: "https://api.mz.xyz/v1/graphql/"
};
var J = "https://mizu.io/keyless_google";
var h3 = class _h {
  /**
   * Initialize MizuWallet SDK Core Client
   *
   * @param args.appId - Application ID
   * @param args.network - Network.MAINNET | Network.TESTNET
   */
  constructor(e10) {
    s2(this, "appId");
    s2(this, "network");
    s2(this, "graphqlEndPoint", "");
    s2(this, "userId", "");
    s2(this, "jwtToken", "");
    s2(this, "initialized", false);
    if (!e10.appId) throw new Error("appId is required");
    if (!e10.network) throw new Error("network is required");
    this.appId = e10.appId, this.network = e10.network, this.graphqlEndPoint = I[this.network], this.initialized = true;
  }
  /**
   * Check if MizuWallet SDK Core Client is initialized
   */
  checkInitialized() {
    if (!this.initialized) throw new Error("MizuWallet SDK Core Client not initialized");
  }
  /**
   * Check if JWT Token is available
   */
  checkJWTToken() {
    if (!this.jwtToken) throw new Error("JWT Token not found. Please login first.");
  }
  /**
   * Decode JWT Token
   */
  static decodeJWTToken(e10) {
    const [t14, n14] = $(e10);
    return [t14, n14];
  }
  /**
   * Clone MizuWallet SDK Core Client
   *
   * @param args.appId - Application ID
   * @param args.network - Network.MAINNET | Network.TESTNET
   * @param args.jwtToken - JWT Token
   */
  static clone(e10) {
    if (!e10.appId) throw new Error("appId is required");
    if (!e10.network) throw new Error("network is required");
    if (!e10.jwtToken) throw new Error("jwtToken is required");
    const t14 = new _h({ appId: e10.appId, network: e10.network });
    return [t14.userId, t14.jwtToken] = _h.decodeJWTToken(e10.jwtToken), t14;
  }
  /**
   * Update network
   * @param network - Network.MAINNET | Network.TESTNET
   */
  updateNetwork(e10) {
    this.checkInitialized(), this.network = e10, this.graphqlEndPoint = I[this.network];
  }
  /**
   * Get network info
   */
  get networkInfo() {
    return {
      name: this.network,
      chainId: this.network === e.MAINNET ? 1 : 2,
      url: this.network === e.MAINNET ? "https://fullnode.mainnet.aptoslabs.com/v1" : "https://fullnode.testnet.aptoslabs.com/v1"
    };
  }
  /**
   *
   *
   */
  login() {
    this.checkInitialized();
  }
  /**
   * Login in TG
   *
   * @param data - initial data of TG, or stringified widget user object
   * @param opt.isWidget - is from login widget
   */
  async loginInTG(e10, t14) {
    this.checkInitialized();
    let n14 = "";
    t14 != null && t14.isWidget ? n14 = (await main_default({
      url: this.graphqlEndPoint,
      document: t14 != null && t14.shortID ? q : E,
      variables: {
        appId: this.appId,
        authData: window.btoa(e10),
        ...t14 != null && t14.shortID ? { shortId: t14.shortID } : {}
      }
    })).tgWidgetLogin : n14 = (await main_default({
      url: this.graphqlEndPoint,
      document: t14 != null && t14.shortID ? T3 : f4,
      variables: {
        appId: this.appId,
        initData: e10,
        ...t14 != null && t14.shortID ? { shortId: t14.shortID } : {}
      }
    })).tgLogin;
    try {
      [this.userId, this.jwtToken] = _h.decodeJWTToken(n14);
    } catch {
      this.logout();
    }
  }
  /**
   * Check if user exist by TG ID
   *
   * @param tgId
   * @returns
   */
  async isUserExistByTgID(e10) {
    var n14;
    if (this.checkInitialized(), !e10) throw new Error("tgId is required");
    const t14 = await main_default({
      url: this.graphqlEndPoint,
      document: S,
      variables: {},
      requestHeaders: {
        "x-hasura-tg-id": e10
      }
    });
    return ((n14 = t14 == null ? void 0 : t14.telegramUser) == null ? void 0 : n14.length) > 0;
  }
  /**
   * fetch user wallet address
   *
   * @returns
   */
  async getUserWalletAddress() {
    return this.checkInitialized(), this.checkJWTToken(), (await main_default({
      url: this.graphqlEndPoint,
      document: g,
      variables: {
        id: this.userId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    })).walletUserByPk.sub_wallets[0].address;
  }
  /**
   * fetch user wallet address
   *
   * @returns
   */
  async getUserInfo() {
    return this.checkInitialized(), this.checkJWTToken(), (await main_default({
      url: this.graphqlEndPoint,
      document: g,
      variables: {
        id: this.userId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    })).walletUserByPk;
  }
  /**
   * Logout
   */
  logout() {
    this.userId = "", this.jwtToken = "";
  }
  /**
   *
   * @param args.redirect_uri
   */
  async startBindGoogle(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t14 = new URLSearchParams({
      token: this.jwtToken,
      appId: this.appId,
      ...e10
    });
    window.open(`${J}?${t14.toString()}`, "_blank");
  }
  /**
   *
   * @param args.address keyless address
   * @param args.idToken google jwt
   * @returns
   */
  async bindGoogleAccount(e10) {
    return this.checkInitialized(), this.checkJWTToken(), await main_default({
      url: this.graphqlEndPoint,
      document: A4,
      variables: {
        ...e10
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
  }
  /**
   * Simulate Order
   *
   * @param args.payload TransactionPayload
   */
  async simulateOrder(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t14 = await main_default({
      url: this.graphqlEndPoint,
      document: C2,
      variables: {
        payload: window.btoa(JSON.stringify(e10.payload))
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t14 == null ? void 0 : t14.simulateOrder;
  }
  /**
   * Create Order
   *
   * @param args.payload TransactionPayload
   * @returns
   */
  async createOrder(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t14 = await main_default({
      url: this.graphqlEndPoint,
      document: W2,
      variables: {
        appId: this.appId,
        payload: window.btoa(JSON.stringify(p3(e10.payload)))
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t14 == null ? void 0 : t14.createOrder;
  }
  /**
   * Create Order with Code
   *
   * @param args.payload
   * @param args.code
   * @returns
   */
  async createOrderWithCode(e10) {
    this.checkInitialized();
    const t14 = await main_default({
      url: this.graphqlEndPoint,
      document: D2,
      variables: {
        appId: this.appId,
        authCode: e10.code,
        payload: window.btoa(JSON.stringify(p3(e10.payload)))
      },
      requestHeaders: {}
    });
    return t14 == null ? void 0 : t14.createOrderWithCode;
  }
  /**
   * Create Signature
   *
   * @param args.transactionHex AnyRawTransaction.bscToHex().toStringWithoutPrefix()
   * @returns
   */
  async createSignature(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t14 = await main_default({
      url: this.graphqlEndPoint,
      document: z,
      variables: {
        appId: this.appId,
        transactionHex: e10.transactionHex
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t14 == null ? void 0 : t14.createSignature;
  }
  /**
   * Sign Message
   *
   * @param args.message message to sign
   * @param args.nonce nonce
   * @returns
   */
  async signMessage(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t14 = await main_default({
      url: this.graphqlEndPoint,
      document: P,
      variables: {
        appId: this.appId,
        ...e10
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t14 == null ? void 0 : t14.createSignMessage;
  }
  /**
   * User interactive
   *
   * @param args.orderId Order ID
   * return bool
   */
  async confirmOrder(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t14 = await main_default({
      url: this.graphqlEndPoint,
      document: O,
      variables: {
        orderId: e10.orderId
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return t14 == null ? void 0 : t14.confirmOrder;
  }
  /**
   * Fetch Order By ID
   *
   * @param args.id order.id
   * @returns
   */
  async fetchOrder(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const t14 = await main_default({
      url: this.graphqlEndPoint,
      document: L,
      variables: {
        id: e10.id
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    if (!t14.orderByPk) throw new Error("Order not found");
    return {
      ...t14.orderByPk,
      payload: JSON.parse(window.atob(t14.orderByPk.payload))
    };
  }
  /**
   * Wait for order
   *
   * @param args.orderId order.id
   * @returns
   */
  async waitForOrder(e10) {
    let t14 = await this.fetchOrder({
      id: e10.orderId
    }), n14 = 20;
    for (; n14-- > 0 && ![d7.SUCCESS, d7.FAIL, d7.CANCELED].includes(t14.status); )
      await new Promise((o12) => setTimeout(o12, 5e3)), t14 = await this.fetchOrder({
        id: e10.orderId
      });
    if (t14.status === d7.FAIL)
      throw new Error("Order failed");
    return t14;
  }
  /**
   * fetch order list
   *
   * @param args.walletUserId
   * @param args.limit
   * @param args.offset
   *
   * @returns
   */
  async fetchOrderList(e10) {
    this.checkInitialized(), this.checkJWTToken();
    const { limit: t14 = 10, offset: n14 = 0 } = e10 || {}, o12 = await main_default({
      url: this.graphqlEndPoint,
      document: b,
      variables: {
        walletUserId: this.userId,
        limit: t14,
        offset: n14
      },
      requestHeaders: {
        Authorization: `Bearer ${this.jwtToken}`
      }
    });
    return {
      data: o12 == null ? void 0 : o12.order.map((u4) => {
        let c = {};
        try {
          c = JSON.parse(window.atob(u4.payload));
        } catch (w) {
          console.error(w);
        }
        return {
          ...u4,
          payload: c
        };
      }),
      pagination: {
        total: o12 == null ? void 0 : o12.orderAggregate.aggregate.count,
        limit: t14,
        offset: n14
      }
    };
  }
};

// node_modules/@mizuwallet-sdk/aptos-wallet-adapter/dist/index.js
var we = Object.defineProperty;
var ye = (w, s3, h4) => s3 in w ? we(w, s3, { enumerable: true, configurable: true, writable: true, value: h4 }) : w[s3] = h4;
var xt = (w, s3, h4) => ye(w, typeof s3 != "symbol" ? s3 + "" : s3, h4);
var Be = "aptos:devnet";
var Ie = "aptos:testnet";
var Ue = "aptos:localnet";
var ve = "aptos:mainnet";
var Re = [Be, Ie, Ue, ve];
var qr = ((w) => (w[w.Unauthorized = 4100] = "Unauthorized", w[w.InternalError = -30001] = "InternalError", w))(qr || {});
var ee = Object.freeze({ 4100: { status: "Unauthorized", message: "The requested method and/or account has not been authorized by the user." }, [-30001]: { status: "Internal error", message: "Something went wrong within the wallet." } });
var ne = class he extends Error {
  constructor(s3, h4) {
    var x2, d8;
    super(h4 ?? ((x2 = ee[s3]) == null ? void 0 : x2.message) ?? "Unknown error occurred"), this.code = s3, this.status = ((d8 = ee[s3]) == null ? void 0 : d8.status) ?? "Unknown error", this.name = "AptosWalletError", Object.setPrototypeOf(this, he.prototype);
  }
};
var Gt = ((w) => (w.APPROVED = "Approved", w.REJECTED = "Rejected", w))(Gt || {});
var Ce = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Se(w) {
  return w && w.__esModule && Object.prototype.hasOwnProperty.call(w, "default") ? w.default : w;
}
function Te(w) {
  if (w.__esModule) return w;
  var s3 = w.default;
  if (typeof s3 == "function") {
    var h4 = function x2() {
      return this instanceof x2 ? Reflect.construct(s3, arguments, this.constructor) : s3.apply(this, arguments);
    };
    h4.prototype = s3.prototype;
  } else h4 = {};
  return Object.defineProperty(h4, "__esModule", { value: true }), Object.keys(w).forEach(function(x2) {
    var d8 = Object.getOwnPropertyDescriptor(w, x2);
    Object.defineProperty(h4, x2, d8.get ? d8 : {
      enumerable: true,
      get: function() {
        return w[x2];
      }
    });
  }), h4;
}
var ue = {};
var jr = {};
jr.byteLength = Le;
jr.toByteArray = ke;
jr.fromByteArray = De;
var _t = [];
var jt = [];
var Ne = typeof Uint8Array < "u" ? Uint8Array : Array;
var Jr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
for (mr = 0, Fe = Jr.length; mr < Fe; ++mr)
  _t[mr] = Jr[mr], jt[Jr.charCodeAt(mr)] = mr;
var mr;
var Fe;
jt[45] = 62;
jt[95] = 63;
function le(w) {
  var s3 = w.length;
  if (s3 % 4 > 0)
    throw new Error("Invalid string. Length must be a multiple of 4");
  var h4 = w.indexOf("=");
  h4 === -1 && (h4 = s3);
  var x2 = h4 === s3 ? 0 : 4 - h4 % 4;
  return [h4, x2];
}
function Le(w) {
  var s3 = le(w), h4 = s3[0], x2 = s3[1];
  return (h4 + x2) * 3 / 4 - x2;
}
function Oe(w, s3, h4) {
  return (s3 + h4) * 3 / 4 - h4;
}
function ke(w) {
  var s3, h4 = le(w), x2 = h4[0], d8 = h4[1], I2 = new Ne(Oe(w, x2, d8)), R = 0, l3 = d8 > 0 ? x2 - 4 : x2, j2;
  for (j2 = 0; j2 < l3; j2 += 4)
    s3 = jt[w.charCodeAt(j2)] << 18 | jt[w.charCodeAt(j2 + 1)] << 12 | jt[w.charCodeAt(j2 + 2)] << 6 | jt[w.charCodeAt(j2 + 3)], I2[R++] = s3 >> 16 & 255, I2[R++] = s3 >> 8 & 255, I2[R++] = s3 & 255;
  return d8 === 2 && (s3 = jt[w.charCodeAt(j2)] << 2 | jt[w.charCodeAt(j2 + 1)] >> 4, I2[R++] = s3 & 255), d8 === 1 && (s3 = jt[w.charCodeAt(j2)] << 10 | jt[w.charCodeAt(j2 + 1)] << 4 | jt[w.charCodeAt(j2 + 2)] >> 2, I2[R++] = s3 >> 8 & 255, I2[R++] = s3 & 255), I2;
}
function Me(w) {
  return _t[w >> 18 & 63] + _t[w >> 12 & 63] + _t[w >> 6 & 63] + _t[w & 63];
}
function Pe(w, s3, h4) {
  for (var x2, d8 = [], I2 = s3; I2 < h4; I2 += 3)
    x2 = (w[I2] << 16 & 16711680) + (w[I2 + 1] << 8 & 65280) + (w[I2 + 2] & 255), d8.push(Me(x2));
  return d8.join("");
}
function De(w) {
  for (var s3, h4 = w.length, x2 = h4 % 3, d8 = [], I2 = 16383, R = 0, l3 = h4 - x2; R < l3; R += I2)
    d8.push(Pe(w, R, R + I2 > l3 ? l3 : R + I2));
  return x2 === 1 ? (s3 = w[h4 - 1], d8.push(
    _t[s3 >> 2] + _t[s3 << 4 & 63] + "=="
  )) : x2 === 2 && (s3 = (w[h4 - 2] << 8) + w[h4 - 1], d8.push(
    _t[s3 >> 10] + _t[s3 >> 4 & 63] + _t[s3 << 2 & 63] + "="
  )), d8.join("");
}
var Vr = {};
Vr.read = function(w, s3, h4, x2, d8) {
  var I2, R, l3 = d8 * 8 - x2 - 1, j2 = (1 << l3) - 1, et = j2 >> 1, ct = -7, dt = h4 ? d8 - 1 : 0, vt = h4 ? -1 : 1, At = w[s3 + dt];
  for (dt += vt, I2 = At & (1 << -ct) - 1, At >>= -ct, ct += l3; ct > 0; I2 = I2 * 256 + w[s3 + dt], dt += vt, ct -= 8)
    ;
  for (R = I2 & (1 << -ct) - 1, I2 >>= -ct, ct += x2; ct > 0; R = R * 256 + w[s3 + dt], dt += vt, ct -= 8)
    ;
  if (I2 === 0)
    I2 = 1 - et;
  else {
    if (I2 === j2)
      return R ? NaN : (At ? -1 : 1) * (1 / 0);
    R = R + Math.pow(2, x2), I2 = I2 - et;
  }
  return (At ? -1 : 1) * R * Math.pow(2, I2 - x2);
};
Vr.write = function(w, s3, h4, x2, d8, I2) {
  var R, l3, j2, et = I2 * 8 - d8 - 1, ct = (1 << et) - 1, dt = ct >> 1, vt = d8 === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, At = x2 ? 0 : I2 - 1, Bt = x2 ? 1 : -1, Dt = s3 < 0 || s3 === 0 && 1 / s3 < 0 ? 1 : 0;
  for (s3 = Math.abs(s3), isNaN(s3) || s3 === 1 / 0 ? (l3 = isNaN(s3) ? 1 : 0, R = ct) : (R = Math.floor(Math.log(s3) / Math.LN2), s3 * (j2 = Math.pow(2, -R)) < 1 && (R--, j2 *= 2), R + dt >= 1 ? s3 += vt / j2 : s3 += vt * Math.pow(2, 1 - dt), s3 * j2 >= 2 && (R++, j2 /= 2), R + dt >= ct ? (l3 = 0, R = ct) : R + dt >= 1 ? (l3 = (s3 * j2 - 1) * Math.pow(2, d8), R = R + dt) : (l3 = s3 * Math.pow(2, dt - 1) * Math.pow(2, d8), R = 0)); d8 >= 8; w[h4 + At] = l3 & 255, At += Bt, l3 /= 256, d8 -= 8)
    ;
  for (R = R << d8 | l3, et += d8; et > 0; w[h4 + At] = R & 255, At += Bt, R /= 256, et -= 8)
    ;
  w[h4 + At - Bt] |= Dt * 128;
};
(function(w) {
  const s3 = jr, h4 = Vr, x2 = typeof Symbol == "function" && typeof Symbol.for == "function" ? Symbol.for("nodejs.util.inspect.custom") : null;
  w.Buffer = l3, w.SlowBuffer = nr, w.INSPECT_MAX_BYTES = 50;
  const d8 = 2147483647;
  w.kMaxLength = d8, l3.TYPED_ARRAY_SUPPORT = I2(), !l3.TYPED_ARRAY_SUPPORT && typeof console < "u" && typeof console.error == "function" && console.error(
    "This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support."
  );
  function I2() {
    try {
      const f5 = new Uint8Array(1), r7 = { foo: function() {
        return 42;
      } };
      return Object.setPrototypeOf(r7, Uint8Array.prototype), Object.setPrototypeOf(f5, r7), f5.foo() === 42;
    } catch {
      return false;
    }
  }
  Object.defineProperty(l3.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (l3.isBuffer(this))
        return this.buffer;
    }
  }), Object.defineProperty(l3.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (l3.isBuffer(this))
        return this.byteOffset;
    }
  });
  function R(f5) {
    if (f5 > d8)
      throw new RangeError('The value "' + f5 + '" is invalid for option "size"');
    const r7 = new Uint8Array(f5);
    return Object.setPrototypeOf(r7, l3.prototype), r7;
  }
  function l3(f5, r7, e10) {
    if (typeof f5 == "number") {
      if (typeof r7 == "string")
        throw new TypeError(
          'The "string" argument must be of type string. Received type number'
        );
      return dt(f5);
    }
    return j2(f5, r7, e10);
  }
  l3.poolSize = 8192;
  function j2(f5, r7, e10) {
    if (typeof f5 == "string")
      return vt(f5, r7);
    if (ArrayBuffer.isView(f5))
      return Bt(f5);
    if (f5 == null)
      throw new TypeError(
        "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof f5
      );
    if (kt(f5, ArrayBuffer) || f5 && kt(f5.buffer, ArrayBuffer) || typeof SharedArrayBuffer < "u" && (kt(f5, SharedArrayBuffer) || f5 && kt(f5.buffer, SharedArrayBuffer)))
      return Dt(f5, r7, e10);
    if (typeof f5 == "number")
      throw new TypeError(
        'The "value" argument must not be of type number. Received type number'
      );
    const c = f5.valueOf && f5.valueOf();
    if (c != null && c !== f5)
      return l3.from(c, r7, e10);
    const p4 = er(f5);
    if (p4) return p4;
    if (typeof Symbol < "u" && Symbol.toPrimitive != null && typeof f5[Symbol.toPrimitive] == "function")
      return l3.from(f5[Symbol.toPrimitive]("string"), r7, e10);
    throw new TypeError(
      "The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof f5
    );
  }
  l3.from = function(f5, r7, e10) {
    return j2(f5, r7, e10);
  }, Object.setPrototypeOf(l3.prototype, Uint8Array.prototype), Object.setPrototypeOf(l3, Uint8Array);
  function et(f5) {
    if (typeof f5 != "number")
      throw new TypeError('"size" argument must be of type number');
    if (f5 < 0)
      throw new RangeError('The value "' + f5 + '" is invalid for option "size"');
  }
  function ct(f5, r7, e10) {
    return et(f5), f5 <= 0 ? R(f5) : r7 !== void 0 ? typeof e10 == "string" ? R(f5).fill(r7, e10) : R(f5).fill(r7) : R(f5);
  }
  l3.alloc = function(f5, r7, e10) {
    return ct(f5, r7, e10);
  };
  function dt(f5) {
    return et(f5), R(f5 < 0 ? 0 : Kt(f5) | 0);
  }
  l3.allocUnsafe = function(f5) {
    return dt(f5);
  }, l3.allocUnsafeSlow = function(f5) {
    return dt(f5);
  };
  function vt(f5, r7) {
    if ((typeof r7 != "string" || r7 === "") && (r7 = "utf8"), !l3.isEncoding(r7))
      throw new TypeError("Unknown encoding: " + r7);
    const e10 = lr(f5, r7) | 0;
    let c = R(e10);
    const p4 = c.write(f5, r7);
    return p4 !== e10 && (c = c.slice(0, p4)), c;
  }
  function At(f5) {
    const r7 = f5.length < 0 ? 0 : Kt(f5.length) | 0, e10 = R(r7);
    for (let c = 0; c < r7; c += 1)
      e10[c] = f5[c] & 255;
    return e10;
  }
  function Bt(f5) {
    if (kt(f5, Uint8Array)) {
      const r7 = new Uint8Array(f5);
      return Dt(r7.buffer, r7.byteOffset, r7.byteLength);
    }
    return At(f5);
  }
  function Dt(f5, r7, e10) {
    if (r7 < 0 || f5.byteLength < r7)
      throw new RangeError('"offset" is outside of buffer bounds');
    if (f5.byteLength < r7 + (e10 || 0))
      throw new RangeError('"length" is outside of buffer bounds');
    let c;
    return r7 === void 0 && e10 === void 0 ? c = new Uint8Array(f5) : e10 === void 0 ? c = new Uint8Array(f5, r7) : c = new Uint8Array(f5, r7, e10), Object.setPrototypeOf(c, l3.prototype), c;
  }
  function er(f5) {
    if (l3.isBuffer(f5)) {
      const r7 = Kt(f5.length) | 0, e10 = R(r7);
      return e10.length === 0 || f5.copy(e10, 0, 0, r7), e10;
    }
    if (f5.length !== void 0)
      return typeof f5.length != "number" || cr(f5.length) ? R(0) : At(f5);
    if (f5.type === "Buffer" && Array.isArray(f5.data))
      return At(f5.data);
  }
  function Kt(f5) {
    if (f5 >= d8)
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + d8.toString(16) + " bytes");
    return f5 | 0;
  }
  function nr(f5) {
    return +f5 != f5 && (f5 = 0), l3.alloc(+f5);
  }
  l3.isBuffer = function(r7) {
    return r7 != null && r7._isBuffer === true && r7 !== l3.prototype;
  }, l3.compare = function(r7, e10) {
    if (kt(r7, Uint8Array) && (r7 = l3.from(r7, r7.offset, r7.byteLength)), kt(e10, Uint8Array) && (e10 = l3.from(e10, e10.offset, e10.byteLength)), !l3.isBuffer(r7) || !l3.isBuffer(e10))
      throw new TypeError(
        'The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array'
      );
    if (r7 === e10) return 0;
    let c = r7.length, p4 = e10.length;
    for (let g2 = 0, b2 = Math.min(c, p4); g2 < b2; ++g2)
      if (r7[g2] !== e10[g2]) {
        c = r7[g2], p4 = e10[g2];
        break;
      }
    return c < p4 ? -1 : p4 < c ? 1 : 0;
  }, l3.isEncoding = function(r7) {
    switch (String(r7).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  }, l3.concat = function(r7, e10) {
    if (!Array.isArray(r7))
      throw new TypeError('"list" argument must be an Array of Buffers');
    if (r7.length === 0)
      return l3.alloc(0);
    let c;
    if (e10 === void 0)
      for (e10 = 0, c = 0; c < r7.length; ++c)
        e10 += r7[c].length;
    const p4 = l3.allocUnsafe(e10);
    let g2 = 0;
    for (c = 0; c < r7.length; ++c) {
      let b2 = r7[c];
      if (kt(b2, Uint8Array))
        g2 + b2.length > p4.length ? (l3.isBuffer(b2) || (b2 = l3.from(b2)), b2.copy(p4, g2)) : Uint8Array.prototype.set.call(
          p4,
          b2,
          g2
        );
      else if (l3.isBuffer(b2))
        b2.copy(p4, g2);
      else
        throw new TypeError('"list" argument must be an Array of Buffers');
      g2 += b2.length;
    }
    return p4;
  };
  function lr(f5, r7) {
    if (l3.isBuffer(f5))
      return f5.length;
    if (ArrayBuffer.isView(f5) || kt(f5, ArrayBuffer))
      return f5.byteLength;
    if (typeof f5 != "string")
      throw new TypeError(
        'The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof f5
      );
    const e10 = f5.length, c = arguments.length > 2 && arguments[2] === true;
    if (!c && e10 === 0) return 0;
    let p4 = false;
    for (; ; )
      switch (r7) {
        case "ascii":
        case "latin1":
        case "binary":
          return e10;
        case "utf8":
        case "utf-8":
          return Ar(f5).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return e10 * 2;
        case "hex":
          return e10 >>> 1;
        case "base64":
          return ar(f5).length;
        default:
          if (p4)
            return c ? -1 : Ar(f5).length;
          r7 = ("" + r7).toLowerCase(), p4 = true;
      }
  }
  l3.byteLength = lr;
  function Vt(f5, r7, e10) {
    let c = false;
    if ((r7 === void 0 || r7 < 0) && (r7 = 0), r7 > this.length || ((e10 === void 0 || e10 > this.length) && (e10 = this.length), e10 <= 0) || (e10 >>>= 0, r7 >>>= 0, e10 <= r7))
      return "";
    for (f5 || (f5 = "utf8"); ; )
      switch (f5) {
        case "hex":
          return $t(this, r7, e10);
        case "utf8":
        case "utf-8":
          return pr(this, r7, e10);
        case "ascii":
          return Ir(this, r7, e10);
        case "latin1":
        case "binary":
          return Xt(this, r7, e10);
        case "base64":
          return Fr(this, r7, e10);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Lr(this, r7, e10);
        default:
          if (c) throw new TypeError("Unknown encoding: " + f5);
          f5 = (f5 + "").toLowerCase(), c = true;
      }
  }
  l3.prototype._isBuffer = true;
  function Rt(f5, r7, e10) {
    const c = f5[r7];
    f5[r7] = f5[e10], f5[e10] = c;
  }
  l3.prototype.swap16 = function() {
    const r7 = this.length;
    if (r7 % 2 !== 0)
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    for (let e10 = 0; e10 < r7; e10 += 2)
      Rt(this, e10, e10 + 1);
    return this;
  }, l3.prototype.swap32 = function() {
    const r7 = this.length;
    if (r7 % 4 !== 0)
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    for (let e10 = 0; e10 < r7; e10 += 4)
      Rt(this, e10, e10 + 3), Rt(this, e10 + 1, e10 + 2);
    return this;
  }, l3.prototype.swap64 = function() {
    const r7 = this.length;
    if (r7 % 8 !== 0)
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    for (let e10 = 0; e10 < r7; e10 += 8)
      Rt(this, e10, e10 + 7), Rt(this, e10 + 1, e10 + 6), Rt(this, e10 + 2, e10 + 5), Rt(this, e10 + 3, e10 + 4);
    return this;
  }, l3.prototype.toString = function() {
    const r7 = this.length;
    return r7 === 0 ? "" : arguments.length === 0 ? pr(this, 0, r7) : Vt.apply(this, arguments);
  }, l3.prototype.toLocaleString = l3.prototype.toString, l3.prototype.equals = function(r7) {
    if (!l3.isBuffer(r7)) throw new TypeError("Argument must be a Buffer");
    return this === r7 ? true : l3.compare(this, r7) === 0;
  }, l3.prototype.inspect = function() {
    let r7 = "";
    const e10 = w.INSPECT_MAX_BYTES;
    return r7 = this.toString("hex", 0, e10).replace(/(.{2})/g, "$1 ").trim(), this.length > e10 && (r7 += " ... "), "<Buffer " + r7 + ">";
  }, x2 && (l3.prototype[x2] = l3.prototype.inspect), l3.prototype.compare = function(r7, e10, c, p4, g2) {
    if (kt(r7, Uint8Array) && (r7 = l3.from(r7, r7.offset, r7.byteLength)), !l3.isBuffer(r7))
      throw new TypeError(
        'The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof r7
      );
    if (e10 === void 0 && (e10 = 0), c === void 0 && (c = r7 ? r7.length : 0), p4 === void 0 && (p4 = 0), g2 === void 0 && (g2 = this.length), e10 < 0 || c > r7.length || p4 < 0 || g2 > this.length)
      throw new RangeError("out of range index");
    if (p4 >= g2 && e10 >= c)
      return 0;
    if (p4 >= g2)
      return -1;
    if (e10 >= c)
      return 1;
    if (e10 >>>= 0, c >>>= 0, p4 >>>= 0, g2 >>>= 0, this === r7) return 0;
    let b2 = g2 - p4, W3 = c - e10;
    const ut = Math.min(b2, W3), ht = this.slice(p4, g2), pt = r7.slice(e10, c);
    for (let ft = 0; ft < ut; ++ft)
      if (ht[ft] !== pt[ft]) {
        b2 = ht[ft], W3 = pt[ft];
        break;
      }
    return b2 < W3 ? -1 : W3 < b2 ? 1 : 0;
  };
  function Ft(f5, r7, e10, c, p4) {
    if (f5.length === 0) return -1;
    if (typeof e10 == "string" ? (c = e10, e10 = 0) : e10 > 2147483647 ? e10 = 2147483647 : e10 < -2147483648 && (e10 = -2147483648), e10 = +e10, cr(e10) && (e10 = p4 ? 0 : f5.length - 1), e10 < 0 && (e10 = f5.length + e10), e10 >= f5.length) {
      if (p4) return -1;
      e10 = f5.length - 1;
    } else if (e10 < 0)
      if (p4) e10 = 0;
      else return -1;
    if (typeof r7 == "string" && (r7 = l3.from(r7, c)), l3.isBuffer(r7))
      return r7.length === 0 ? -1 : Ht(f5, r7, e10, c, p4);
    if (typeof r7 == "number")
      return r7 = r7 & 255, typeof Uint8Array.prototype.indexOf == "function" ? p4 ? Uint8Array.prototype.indexOf.call(f5, r7, e10) : Uint8Array.prototype.lastIndexOf.call(f5, r7, e10) : Ht(f5, [r7], e10, c, p4);
    throw new TypeError("val must be string, number or Buffer");
  }
  function Ht(f5, r7, e10, c, p4) {
    let g2 = 1, b2 = f5.length, W3 = r7.length;
    if (c !== void 0 && (c = String(c).toLowerCase(), c === "ucs2" || c === "ucs-2" || c === "utf16le" || c === "utf-16le")) {
      if (f5.length < 2 || r7.length < 2)
        return -1;
      g2 = 2, b2 /= 2, W3 /= 2, e10 /= 2;
    }
    function ut(pt, ft) {
      return g2 === 1 ? pt[ft] : pt.readUInt16BE(ft * g2);
    }
    let ht;
    if (p4) {
      let pt = -1;
      for (ht = e10; ht < b2; ht++)
        if (ut(f5, ht) === ut(r7, pt === -1 ? 0 : ht - pt)) {
          if (pt === -1 && (pt = ht), ht - pt + 1 === W3) return pt * g2;
        } else
          pt !== -1 && (ht -= ht - pt), pt = -1;
    } else
      for (e10 + W3 > b2 && (e10 = b2 - W3), ht = e10; ht >= 0; ht--) {
        let pt = true;
        for (let ft = 0; ft < W3; ft++)
          if (ut(f5, ht + ft) !== ut(r7, ft)) {
            pt = false;
            break;
          }
        if (pt) return ht;
      }
    return -1;
  }
  l3.prototype.includes = function(r7, e10, c) {
    return this.indexOf(r7, e10, c) !== -1;
  }, l3.prototype.indexOf = function(r7, e10, c) {
    return Ft(this, r7, e10, c, true);
  }, l3.prototype.lastIndexOf = function(r7, e10, c) {
    return Ft(this, r7, e10, c, false);
  };
  function Mt(f5, r7, e10, c) {
    e10 = Number(e10) || 0;
    const p4 = f5.length - e10;
    c ? (c = Number(c), c > p4 && (c = p4)) : c = p4;
    const g2 = r7.length;
    c > g2 / 2 && (c = g2 / 2);
    let b2;
    for (b2 = 0; b2 < c; ++b2) {
      const W3 = parseInt(r7.substr(b2 * 2, 2), 16);
      if (cr(W3)) return b2;
      f5[e10 + b2] = W3;
    }
    return b2;
  }
  function Nr(f5, r7, e10, c) {
    return sr(Ar(r7, f5.length - e10), f5, e10, c);
  }
  function br(f5, r7, e10, c) {
    return sr(kr(r7), f5, e10, c);
  }
  function xr(f5, r7, e10, c) {
    return sr(ar(r7), f5, e10, c);
  }
  function Br(f5, r7, e10, c) {
    return sr(Zt(r7, f5.length - e10), f5, e10, c);
  }
  l3.prototype.write = function(r7, e10, c, p4) {
    if (e10 === void 0)
      p4 = "utf8", c = this.length, e10 = 0;
    else if (c === void 0 && typeof e10 == "string")
      p4 = e10, c = this.length, e10 = 0;
    else if (isFinite(e10))
      e10 = e10 >>> 0, isFinite(c) ? (c = c >>> 0, p4 === void 0 && (p4 = "utf8")) : (p4 = c, c = void 0);
    else
      throw new Error(
        "Buffer.write(string, encoding, offset[, length]) is no longer supported"
      );
    const g2 = this.length - e10;
    if ((c === void 0 || c > g2) && (c = g2), r7.length > 0 && (c < 0 || e10 < 0) || e10 > this.length)
      throw new RangeError("Attempt to write outside buffer bounds");
    p4 || (p4 = "utf8");
    let b2 = false;
    for (; ; )
      switch (p4) {
        case "hex":
          return Mt(this, r7, e10, c);
        case "utf8":
        case "utf-8":
          return Nr(this, r7, e10, c);
        case "ascii":
        case "latin1":
        case "binary":
          return br(this, r7, e10, c);
        case "base64":
          return xr(this, r7, e10, c);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return Br(this, r7, e10, c);
        default:
          if (b2) throw new TypeError("Unknown encoding: " + p4);
          p4 = ("" + p4).toLowerCase(), b2 = true;
      }
  }, l3.prototype.toJSON = function() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function Fr(f5, r7, e10) {
    return r7 === 0 && e10 === f5.length ? s3.fromByteArray(f5) : s3.fromByteArray(f5.slice(r7, e10));
  }
  function pr(f5, r7, e10) {
    e10 = Math.min(f5.length, e10);
    const c = [];
    let p4 = r7;
    for (; p4 < e10; ) {
      const g2 = f5[p4];
      let b2 = null, W3 = g2 > 239 ? 4 : g2 > 223 ? 3 : g2 > 191 ? 2 : 1;
      if (p4 + W3 <= e10) {
        let ut, ht, pt, ft;
        switch (W3) {
          case 1:
            g2 < 128 && (b2 = g2);
            break;
          case 2:
            ut = f5[p4 + 1], (ut & 192) === 128 && (ft = (g2 & 31) << 6 | ut & 63, ft > 127 && (b2 = ft));
            break;
          case 3:
            ut = f5[p4 + 1], ht = f5[p4 + 2], (ut & 192) === 128 && (ht & 192) === 128 && (ft = (g2 & 15) << 12 | (ut & 63) << 6 | ht & 63, ft > 2047 && (ft < 55296 || ft > 57343) && (b2 = ft));
            break;
          case 4:
            ut = f5[p4 + 1], ht = f5[p4 + 2], pt = f5[p4 + 3], (ut & 192) === 128 && (ht & 192) === 128 && (pt & 192) === 128 && (ft = (g2 & 15) << 18 | (ut & 63) << 12 | (ht & 63) << 6 | pt & 63, ft > 65535 && ft < 1114112 && (b2 = ft));
        }
      }
      b2 === null ? (b2 = 65533, W3 = 1) : b2 > 65535 && (b2 -= 65536, c.push(b2 >>> 10 & 1023 | 55296), b2 = 56320 | b2 & 1023), c.push(b2), p4 += W3;
    }
    return Yt(c);
  }
  const dr = 4096;
  function Yt(f5) {
    const r7 = f5.length;
    if (r7 <= dr)
      return String.fromCharCode.apply(String, f5);
    let e10 = "", c = 0;
    for (; c < r7; )
      e10 += String.fromCharCode.apply(
        String,
        f5.slice(c, c += dr)
      );
    return e10;
  }
  function Ir(f5, r7, e10) {
    let c = "";
    e10 = Math.min(f5.length, e10);
    for (let p4 = r7; p4 < e10; ++p4)
      c += String.fromCharCode(f5[p4] & 127);
    return c;
  }
  function Xt(f5, r7, e10) {
    let c = "";
    e10 = Math.min(f5.length, e10);
    for (let p4 = r7; p4 < e10; ++p4)
      c += String.fromCharCode(f5[p4]);
    return c;
  }
  function $t(f5, r7, e10) {
    const c = f5.length;
    (!r7 || r7 < 0) && (r7 = 0), (!e10 || e10 < 0 || e10 > c) && (e10 = c);
    let p4 = "";
    for (let g2 = r7; g2 < e10; ++g2)
      p4 += wr[f5[g2]];
    return p4;
  }
  function Lr(f5, r7, e10) {
    const c = f5.slice(r7, e10);
    let p4 = "";
    for (let g2 = 0; g2 < c.length - 1; g2 += 2)
      p4 += String.fromCharCode(c[g2] + c[g2 + 1] * 256);
    return p4;
  }
  l3.prototype.slice = function(r7, e10) {
    const c = this.length;
    r7 = ~~r7, e10 = e10 === void 0 ? c : ~~e10, r7 < 0 ? (r7 += c, r7 < 0 && (r7 = 0)) : r7 > c && (r7 = c), e10 < 0 ? (e10 += c, e10 < 0 && (e10 = 0)) : e10 > c && (e10 = c), e10 < r7 && (e10 = r7);
    const p4 = this.subarray(r7, e10);
    return Object.setPrototypeOf(p4, l3.prototype), p4;
  };
  function mt(f5, r7, e10) {
    if (f5 % 1 !== 0 || f5 < 0) throw new RangeError("offset is not uint");
    if (f5 + r7 > e10) throw new RangeError("Trying to access beyond buffer length");
  }
  l3.prototype.readUintLE = l3.prototype.readUIntLE = function(r7, e10, c) {
    r7 = r7 >>> 0, e10 = e10 >>> 0, c || mt(r7, e10, this.length);
    let p4 = this[r7], g2 = 1, b2 = 0;
    for (; ++b2 < e10 && (g2 *= 256); )
      p4 += this[r7 + b2] * g2;
    return p4;
  }, l3.prototype.readUintBE = l3.prototype.readUIntBE = function(r7, e10, c) {
    r7 = r7 >>> 0, e10 = e10 >>> 0, c || mt(r7, e10, this.length);
    let p4 = this[r7 + --e10], g2 = 1;
    for (; e10 > 0 && (g2 *= 256); )
      p4 += this[r7 + --e10] * g2;
    return p4;
  }, l3.prototype.readUint8 = l3.prototype.readUInt8 = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 1, this.length), this[r7];
  }, l3.prototype.readUint16LE = l3.prototype.readUInt16LE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 2, this.length), this[r7] | this[r7 + 1] << 8;
  }, l3.prototype.readUint16BE = l3.prototype.readUInt16BE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 2, this.length), this[r7] << 8 | this[r7 + 1];
  }, l3.prototype.readUint32LE = l3.prototype.readUInt32LE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 4, this.length), (this[r7] | this[r7 + 1] << 8 | this[r7 + 2] << 16) + this[r7 + 3] * 16777216;
  }, l3.prototype.readUint32BE = l3.prototype.readUInt32BE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 4, this.length), this[r7] * 16777216 + (this[r7 + 1] << 16 | this[r7 + 2] << 8 | this[r7 + 3]);
  }, l3.prototype.readBigUInt64LE = Qt(function(r7) {
    r7 = r7 >>> 0, Wt(r7, "offset");
    const e10 = this[r7], c = this[r7 + 7];
    (e10 === void 0 || c === void 0) && or(r7, this.length - 8);
    const p4 = e10 + this[++r7] * 2 ** 8 + this[++r7] * 2 ** 16 + this[++r7] * 2 ** 24, g2 = this[++r7] + this[++r7] * 2 ** 8 + this[++r7] * 2 ** 16 + c * 2 ** 24;
    return BigInt(p4) + (BigInt(g2) << BigInt(32));
  }), l3.prototype.readBigUInt64BE = Qt(function(r7) {
    r7 = r7 >>> 0, Wt(r7, "offset");
    const e10 = this[r7], c = this[r7 + 7];
    (e10 === void 0 || c === void 0) && or(r7, this.length - 8);
    const p4 = e10 * 2 ** 24 + this[++r7] * 2 ** 16 + this[++r7] * 2 ** 8 + this[++r7], g2 = this[++r7] * 2 ** 24 + this[++r7] * 2 ** 16 + this[++r7] * 2 ** 8 + c;
    return (BigInt(p4) << BigInt(32)) + BigInt(g2);
  }), l3.prototype.readIntLE = function(r7, e10, c) {
    r7 = r7 >>> 0, e10 = e10 >>> 0, c || mt(r7, e10, this.length);
    let p4 = this[r7], g2 = 1, b2 = 0;
    for (; ++b2 < e10 && (g2 *= 256); )
      p4 += this[r7 + b2] * g2;
    return g2 *= 128, p4 >= g2 && (p4 -= Math.pow(2, 8 * e10)), p4;
  }, l3.prototype.readIntBE = function(r7, e10, c) {
    r7 = r7 >>> 0, e10 = e10 >>> 0, c || mt(r7, e10, this.length);
    let p4 = e10, g2 = 1, b2 = this[r7 + --p4];
    for (; p4 > 0 && (g2 *= 256); )
      b2 += this[r7 + --p4] * g2;
    return g2 *= 128, b2 >= g2 && (b2 -= Math.pow(2, 8 * e10)), b2;
  }, l3.prototype.readInt8 = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 1, this.length), this[r7] & 128 ? (255 - this[r7] + 1) * -1 : this[r7];
  }, l3.prototype.readInt16LE = function(r7, e10) {
    r7 = r7 >>> 0, e10 || mt(r7, 2, this.length);
    const c = this[r7] | this[r7 + 1] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, l3.prototype.readInt16BE = function(r7, e10) {
    r7 = r7 >>> 0, e10 || mt(r7, 2, this.length);
    const c = this[r7 + 1] | this[r7] << 8;
    return c & 32768 ? c | 4294901760 : c;
  }, l3.prototype.readInt32LE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 4, this.length), this[r7] | this[r7 + 1] << 8 | this[r7 + 2] << 16 | this[r7 + 3] << 24;
  }, l3.prototype.readInt32BE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 4, this.length), this[r7] << 24 | this[r7 + 1] << 16 | this[r7 + 2] << 8 | this[r7 + 3];
  }, l3.prototype.readBigInt64LE = Qt(function(r7) {
    r7 = r7 >>> 0, Wt(r7, "offset");
    const e10 = this[r7], c = this[r7 + 7];
    (e10 === void 0 || c === void 0) && or(r7, this.length - 8);
    const p4 = this[r7 + 4] + this[r7 + 5] * 2 ** 8 + this[r7 + 6] * 2 ** 16 + (c << 24);
    return (BigInt(p4) << BigInt(32)) + BigInt(e10 + this[++r7] * 2 ** 8 + this[++r7] * 2 ** 16 + this[++r7] * 2 ** 24);
  }), l3.prototype.readBigInt64BE = Qt(function(r7) {
    r7 = r7 >>> 0, Wt(r7, "offset");
    const e10 = this[r7], c = this[r7 + 7];
    (e10 === void 0 || c === void 0) && or(r7, this.length - 8);
    const p4 = (e10 << 24) + // Overflow
    this[++r7] * 2 ** 16 + this[++r7] * 2 ** 8 + this[++r7];
    return (BigInt(p4) << BigInt(32)) + BigInt(this[++r7] * 2 ** 24 + this[++r7] * 2 ** 16 + this[++r7] * 2 ** 8 + c);
  }), l3.prototype.readFloatLE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 4, this.length), h4.read(this, r7, true, 23, 4);
  }, l3.prototype.readFloatBE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 4, this.length), h4.read(this, r7, false, 23, 4);
  }, l3.prototype.readDoubleLE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 8, this.length), h4.read(this, r7, true, 52, 8);
  }, l3.prototype.readDoubleBE = function(r7, e10) {
    return r7 = r7 >>> 0, e10 || mt(r7, 8, this.length), h4.read(this, r7, false, 52, 8);
  };
  function It(f5, r7, e10, c, p4, g2) {
    if (!l3.isBuffer(f5)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (r7 > p4 || r7 < g2) throw new RangeError('"value" argument is out of bounds');
    if (e10 + c > f5.length) throw new RangeError("Index out of range");
  }
  l3.prototype.writeUintLE = l3.prototype.writeUIntLE = function(r7, e10, c, p4) {
    if (r7 = +r7, e10 = e10 >>> 0, c = c >>> 0, !p4) {
      const W3 = Math.pow(2, 8 * c) - 1;
      It(this, r7, e10, c, W3, 0);
    }
    let g2 = 1, b2 = 0;
    for (this[e10] = r7 & 255; ++b2 < c && (g2 *= 256); )
      this[e10 + b2] = r7 / g2 & 255;
    return e10 + c;
  }, l3.prototype.writeUintBE = l3.prototype.writeUIntBE = function(r7, e10, c, p4) {
    if (r7 = +r7, e10 = e10 >>> 0, c = c >>> 0, !p4) {
      const W3 = Math.pow(2, 8 * c) - 1;
      It(this, r7, e10, c, W3, 0);
    }
    let g2 = c - 1, b2 = 1;
    for (this[e10 + g2] = r7 & 255; --g2 >= 0 && (b2 *= 256); )
      this[e10 + g2] = r7 / b2 & 255;
    return e10 + c;
  }, l3.prototype.writeUint8 = l3.prototype.writeUInt8 = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 1, 255, 0), this[e10] = r7 & 255, e10 + 1;
  }, l3.prototype.writeUint16LE = l3.prototype.writeUInt16LE = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 2, 65535, 0), this[e10] = r7 & 255, this[e10 + 1] = r7 >>> 8, e10 + 2;
  }, l3.prototype.writeUint16BE = l3.prototype.writeUInt16BE = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 2, 65535, 0), this[e10] = r7 >>> 8, this[e10 + 1] = r7 & 255, e10 + 2;
  }, l3.prototype.writeUint32LE = l3.prototype.writeUInt32LE = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 4, 4294967295, 0), this[e10 + 3] = r7 >>> 24, this[e10 + 2] = r7 >>> 16, this[e10 + 1] = r7 >>> 8, this[e10] = r7 & 255, e10 + 4;
  }, l3.prototype.writeUint32BE = l3.prototype.writeUInt32BE = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 4, 4294967295, 0), this[e10] = r7 >>> 24, this[e10 + 1] = r7 >>> 16, this[e10 + 2] = r7 >>> 8, this[e10 + 3] = r7 & 255, e10 + 4;
  };
  function Lt(f5, r7, e10, c, p4) {
    fr(r7, c, p4, f5, e10, 7);
    let g2 = Number(r7 & BigInt(4294967295));
    f5[e10++] = g2, g2 = g2 >> 8, f5[e10++] = g2, g2 = g2 >> 8, f5[e10++] = g2, g2 = g2 >> 8, f5[e10++] = g2;
    let b2 = Number(r7 >> BigInt(32) & BigInt(4294967295));
    return f5[e10++] = b2, b2 = b2 >> 8, f5[e10++] = b2, b2 = b2 >> 8, f5[e10++] = b2, b2 = b2 >> 8, f5[e10++] = b2, e10;
  }
  function Ot(f5, r7, e10, c, p4) {
    fr(r7, c, p4, f5, e10, 7);
    let g2 = Number(r7 & BigInt(4294967295));
    f5[e10 + 7] = g2, g2 = g2 >> 8, f5[e10 + 6] = g2, g2 = g2 >> 8, f5[e10 + 5] = g2, g2 = g2 >> 8, f5[e10 + 4] = g2;
    let b2 = Number(r7 >> BigInt(32) & BigInt(4294967295));
    return f5[e10 + 3] = b2, b2 = b2 >> 8, f5[e10 + 2] = b2, b2 = b2 >> 8, f5[e10 + 1] = b2, b2 = b2 >> 8, f5[e10] = b2, e10 + 8;
  }
  l3.prototype.writeBigUInt64LE = Qt(function(r7, e10 = 0) {
    return Lt(this, r7, e10, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l3.prototype.writeBigUInt64BE = Qt(function(r7, e10 = 0) {
    return Ot(this, r7, e10, BigInt(0), BigInt("0xffffffffffffffff"));
  }), l3.prototype.writeIntLE = function(r7, e10, c, p4) {
    if (r7 = +r7, e10 = e10 >>> 0, !p4) {
      const ut = Math.pow(2, 8 * c - 1);
      It(this, r7, e10, c, ut - 1, -ut);
    }
    let g2 = 0, b2 = 1, W3 = 0;
    for (this[e10] = r7 & 255; ++g2 < c && (b2 *= 256); )
      r7 < 0 && W3 === 0 && this[e10 + g2 - 1] !== 0 && (W3 = 1), this[e10 + g2] = (r7 / b2 >> 0) - W3 & 255;
    return e10 + c;
  }, l3.prototype.writeIntBE = function(r7, e10, c, p4) {
    if (r7 = +r7, e10 = e10 >>> 0, !p4) {
      const ut = Math.pow(2, 8 * c - 1);
      It(this, r7, e10, c, ut - 1, -ut);
    }
    let g2 = c - 1, b2 = 1, W3 = 0;
    for (this[e10 + g2] = r7 & 255; --g2 >= 0 && (b2 *= 256); )
      r7 < 0 && W3 === 0 && this[e10 + g2 + 1] !== 0 && (W3 = 1), this[e10 + g2] = (r7 / b2 >> 0) - W3 & 255;
    return e10 + c;
  }, l3.prototype.writeInt8 = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 1, 127, -128), r7 < 0 && (r7 = 255 + r7 + 1), this[e10] = r7 & 255, e10 + 1;
  }, l3.prototype.writeInt16LE = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 2, 32767, -32768), this[e10] = r7 & 255, this[e10 + 1] = r7 >>> 8, e10 + 2;
  }, l3.prototype.writeInt16BE = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 2, 32767, -32768), this[e10] = r7 >>> 8, this[e10 + 1] = r7 & 255, e10 + 2;
  }, l3.prototype.writeInt32LE = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 4, 2147483647, -2147483648), this[e10] = r7 & 255, this[e10 + 1] = r7 >>> 8, this[e10 + 2] = r7 >>> 16, this[e10 + 3] = r7 >>> 24, e10 + 4;
  }, l3.prototype.writeInt32BE = function(r7, e10, c) {
    return r7 = +r7, e10 = e10 >>> 0, c || It(this, r7, e10, 4, 2147483647, -2147483648), r7 < 0 && (r7 = 4294967295 + r7 + 1), this[e10] = r7 >>> 24, this[e10 + 1] = r7 >>> 16, this[e10 + 2] = r7 >>> 8, this[e10 + 3] = r7 & 255, e10 + 4;
  }, l3.prototype.writeBigInt64LE = Qt(function(r7, e10 = 0) {
    return Lt(this, r7, e10, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  }), l3.prototype.writeBigInt64BE = Qt(function(r7, e10 = 0) {
    return Ot(this, r7, e10, -BigInt("0x8000000000000000"), BigInt("0x7fffffffffffffff"));
  });
  function rt(f5, r7, e10, c, p4, g2) {
    if (e10 + c > f5.length) throw new RangeError("Index out of range");
    if (e10 < 0) throw new RangeError("Index out of range");
  }
  function Nt(f5, r7, e10, c, p4) {
    return r7 = +r7, e10 = e10 >>> 0, p4 || rt(f5, r7, e10, 4), h4.write(f5, r7, e10, c, 23, 4), e10 + 4;
  }
  l3.prototype.writeFloatLE = function(r7, e10, c) {
    return Nt(this, r7, e10, true, c);
  }, l3.prototype.writeFloatBE = function(r7, e10, c) {
    return Nt(this, r7, e10, false, c);
  };
  function Ur(f5, r7, e10, c, p4) {
    return r7 = +r7, e10 = e10 >>> 0, p4 || rt(f5, r7, e10, 8), h4.write(f5, r7, e10, c, 52, 8), e10 + 8;
  }
  l3.prototype.writeDoubleLE = function(r7, e10, c) {
    return Ur(this, r7, e10, true, c);
  }, l3.prototype.writeDoubleBE = function(r7, e10, c) {
    return Ur(this, r7, e10, false, c);
  }, l3.prototype.copy = function(r7, e10, c, p4) {
    if (!l3.isBuffer(r7)) throw new TypeError("argument should be a Buffer");
    if (c || (c = 0), !p4 && p4 !== 0 && (p4 = this.length), e10 >= r7.length && (e10 = r7.length), e10 || (e10 = 0), p4 > 0 && p4 < c && (p4 = c), p4 === c || r7.length === 0 || this.length === 0) return 0;
    if (e10 < 0)
      throw new RangeError("targetStart out of bounds");
    if (c < 0 || c >= this.length) throw new RangeError("Index out of range");
    if (p4 < 0) throw new RangeError("sourceEnd out of bounds");
    p4 > this.length && (p4 = this.length), r7.length - e10 < p4 - c && (p4 = r7.length - e10 + c);
    const g2 = p4 - c;
    return this === r7 && typeof Uint8Array.prototype.copyWithin == "function" ? this.copyWithin(e10, c, p4) : Uint8Array.prototype.set.call(
      r7,
      this.subarray(c, p4),
      e10
    ), g2;
  }, l3.prototype.fill = function(r7, e10, c, p4) {
    if (typeof r7 == "string") {
      if (typeof e10 == "string" ? (p4 = e10, e10 = 0, c = this.length) : typeof c == "string" && (p4 = c, c = this.length), p4 !== void 0 && typeof p4 != "string")
        throw new TypeError("encoding must be a string");
      if (typeof p4 == "string" && !l3.isEncoding(p4))
        throw new TypeError("Unknown encoding: " + p4);
      if (r7.length === 1) {
        const b2 = r7.charCodeAt(0);
        (p4 === "utf8" && b2 < 128 || p4 === "latin1") && (r7 = b2);
      }
    } else typeof r7 == "number" ? r7 = r7 & 255 : typeof r7 == "boolean" && (r7 = Number(r7));
    if (e10 < 0 || this.length < e10 || this.length < c)
      throw new RangeError("Out of range index");
    if (c <= e10)
      return this;
    e10 = e10 >>> 0, c = c === void 0 ? this.length : c >>> 0, r7 || (r7 = 0);
    let g2;
    if (typeof r7 == "number")
      for (g2 = e10; g2 < c; ++g2)
        this[g2] = r7;
    else {
      const b2 = l3.isBuffer(r7) ? r7 : l3.from(r7, p4), W3 = b2.length;
      if (W3 === 0)
        throw new TypeError('The value "' + r7 + '" is invalid for argument "value"');
      for (g2 = 0; g2 < c - e10; ++g2)
        this[g2 + e10] = b2[g2 % W3];
    }
    return this;
  };
  const Jt = {};
  function tr(f5, r7, e10) {
    Jt[f5] = class extends e10 {
      constructor() {
        super(), Object.defineProperty(this, "message", {
          value: r7.apply(this, arguments),
          writable: true,
          configurable: true
        }), this.name = `${this.name} [${f5}]`, this.stack, delete this.name;
      }
      get code() {
        return f5;
      }
      set code(p4) {
        Object.defineProperty(this, "code", {
          configurable: true,
          enumerable: true,
          value: p4,
          writable: true
        });
      }
      toString() {
        return `${this.name} [${f5}]: ${this.message}`;
      }
    };
  }
  tr(
    "ERR_BUFFER_OUT_OF_BOUNDS",
    function(f5) {
      return f5 ? `${f5} is outside of buffer bounds` : "Attempt to access memory outside buffer bounds";
    },
    RangeError
  ), tr(
    "ERR_INVALID_ARG_TYPE",
    function(f5, r7) {
      return `The "${f5}" argument must be of type number. Received type ${typeof r7}`;
    },
    TypeError
  ), tr(
    "ERR_OUT_OF_RANGE",
    function(f5, r7, e10) {
      let c = `The value of "${f5}" is out of range.`, p4 = e10;
      return Number.isInteger(e10) && Math.abs(e10) > 2 ** 32 ? p4 = ir(String(e10)) : typeof e10 == "bigint" && (p4 = String(e10), (e10 > BigInt(2) ** BigInt(32) || e10 < -(BigInt(2) ** BigInt(32))) && (p4 = ir(p4)), p4 += "n"), c += ` It must be ${r7}. Received ${p4}`, c;
    },
    RangeError
  );
  function ir(f5) {
    let r7 = "", e10 = f5.length;
    const c = f5[0] === "-" ? 1 : 0;
    for (; e10 >= c + 4; e10 -= 3)
      r7 = `_${f5.slice(e10 - 3, e10)}${r7}`;
    return `${f5.slice(0, e10)}${r7}`;
  }
  function Or(f5, r7, e10) {
    Wt(r7, "offset"), (f5[r7] === void 0 || f5[r7 + e10] === void 0) && or(r7, f5.length - (e10 + 1));
  }
  function fr(f5, r7, e10, c, p4, g2) {
    if (f5 > e10 || f5 < r7) {
      const b2 = typeof r7 == "bigint" ? "n" : "";
      let W3;
      throw r7 === 0 || r7 === BigInt(0) ? W3 = `>= 0${b2} and < 2${b2} ** ${(g2 + 1) * 8}${b2}` : W3 = `>= -(2${b2} ** ${(g2 + 1) * 8 - 1}${b2}) and < 2 ** ${(g2 + 1) * 8 - 1}${b2}`, new Jt.ERR_OUT_OF_RANGE("value", W3, f5);
    }
    Or(c, p4, g2);
  }
  function Wt(f5, r7) {
    if (typeof f5 != "number")
      throw new Jt.ERR_INVALID_ARG_TYPE(r7, "number", f5);
  }
  function or(f5, r7, e10) {
    throw Math.floor(f5) !== f5 ? (Wt(f5, e10), new Jt.ERR_OUT_OF_RANGE("offset", "an integer", f5)) : r7 < 0 ? new Jt.ERR_BUFFER_OUT_OF_BOUNDS() : new Jt.ERR_OUT_OF_RANGE(
      "offset",
      `>= 0 and <= ${r7}`,
      f5
    );
  }
  const zr = /[^+/0-9A-Za-z-_]/g;
  function Kr(f5) {
    if (f5 = f5.split("=")[0], f5 = f5.trim().replace(zr, ""), f5.length < 2) return "";
    for (; f5.length % 4 !== 0; )
      f5 = f5 + "=";
    return f5;
  }
  function Ar(f5, r7) {
    r7 = r7 || 1 / 0;
    let e10;
    const c = f5.length;
    let p4 = null;
    const g2 = [];
    for (let b2 = 0; b2 < c; ++b2) {
      if (e10 = f5.charCodeAt(b2), e10 > 55295 && e10 < 57344) {
        if (!p4) {
          if (e10 > 56319) {
            (r7 -= 3) > -1 && g2.push(239, 191, 189);
            continue;
          } else if (b2 + 1 === c) {
            (r7 -= 3) > -1 && g2.push(239, 191, 189);
            continue;
          }
          p4 = e10;
          continue;
        }
        if (e10 < 56320) {
          (r7 -= 3) > -1 && g2.push(239, 191, 189), p4 = e10;
          continue;
        }
        e10 = (p4 - 55296 << 10 | e10 - 56320) + 65536;
      } else p4 && (r7 -= 3) > -1 && g2.push(239, 191, 189);
      if (p4 = null, e10 < 128) {
        if ((r7 -= 1) < 0) break;
        g2.push(e10);
      } else if (e10 < 2048) {
        if ((r7 -= 2) < 0) break;
        g2.push(
          e10 >> 6 | 192,
          e10 & 63 | 128
        );
      } else if (e10 < 65536) {
        if ((r7 -= 3) < 0) break;
        g2.push(
          e10 >> 12 | 224,
          e10 >> 6 & 63 | 128,
          e10 & 63 | 128
        );
      } else if (e10 < 1114112) {
        if ((r7 -= 4) < 0) break;
        g2.push(
          e10 >> 18 | 240,
          e10 >> 12 & 63 | 128,
          e10 >> 6 & 63 | 128,
          e10 & 63 | 128
        );
      } else
        throw new Error("Invalid code point");
    }
    return g2;
  }
  function kr(f5) {
    const r7 = [];
    for (let e10 = 0; e10 < f5.length; ++e10)
      r7.push(f5.charCodeAt(e10) & 255);
    return r7;
  }
  function Zt(f5, r7) {
    let e10, c, p4;
    const g2 = [];
    for (let b2 = 0; b2 < f5.length && !((r7 -= 2) < 0); ++b2)
      e10 = f5.charCodeAt(b2), c = e10 >> 8, p4 = e10 % 256, g2.push(p4), g2.push(c);
    return g2;
  }
  function ar(f5) {
    return s3.toByteArray(Kr(f5));
  }
  function sr(f5, r7, e10, c) {
    let p4;
    for (p4 = 0; p4 < c && !(p4 + e10 >= r7.length || p4 >= f5.length); ++p4)
      r7[p4 + e10] = f5[p4];
    return p4;
  }
  function kt(f5, r7) {
    return f5 instanceof r7 || f5 != null && f5.constructor != null && f5.constructor.name != null && f5.constructor.name === r7.name;
  }
  function cr(f5) {
    return f5 !== f5;
  }
  const wr = function() {
    const f5 = "0123456789abcdef", r7 = new Array(256);
    for (let e10 = 0; e10 < 16; ++e10) {
      const c = e10 * 16;
      for (let p4 = 0; p4 < 16; ++p4)
        r7[c + p4] = f5[e10] + f5[p4];
    }
    return r7;
  }();
  function Qt(f5) {
    return typeof BigInt > "u" ? yr : f5;
  }
  function yr() {
    throw new Error("BigInt not supported");
  }
})(ue);
var Qe = "https://t.me/mizuwallet_bot/mizuwallet";
var je = "https://t.me/mizuwallet_bot/mizuwallet_testnet";
var ze = (w) => w === e.TESTNET ? je : Qe;
var Sr = {
  CONNECT: "[Mizu Wallet Connection] ",
  TRANSACTION: "[Mizu Wallet Transaction] "
};
var Ke = "07418a1b-9574-4449-bd34-2146db60b05c";
var Ye = "0c460c1a-5175-4383-b1c2-35b934f5aa71";
var He = (w) => w === e.TESTNET ? Ye : Ke;
var _e = "Mizu Wallet";
var Je = "https://mizu.io";
var We = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAAAXNSR0IArs4c6QAAAIRlWElmTU0AKgAAAAgABQESAAMAAAABAAEAAAEaAAUAAAABAAAASgEbAAUAAAABAAAAUgEoAAMAAAABAAIAAIdpAAQAAAABAAAAWgAAAAAAAABIAAAAAQAAAEgAAAABAAOgAQADAAAAAQABAACgAgAEAAAAAQAAAQCgAwAEAAAAAQAAAQAAAAAAlNB3SgAAAAlwSFlzAAALEwAACxMBAJqcGAAAAVlpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IlhNUCBDb3JlIDYuMC4wIj4KICAgPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4KICAgICAgPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIKICAgICAgICAgICAgeG1sbnM6dGlmZj0iaHR0cDovL25zLmFkb2JlLmNvbS90aWZmLzEuMC8iPgogICAgICAgICA8dGlmZjpPcmllbnRhdGlvbj4xPC90aWZmOk9yaWVudGF0aW9uPgogICAgICA8L3JkZjpEZXNjcmlwdGlvbj4KICAgPC9yZGY6UkRGPgo8L3g6eG1wbWV0YT4KGV7hBwAALERJREFUeAHtnXm0XUd15rc1z7OeJmu0ZEs2HnFs4yGriWmbxstM6ZA0fyQNTvdqOgSymIIXEBscOg6GhKzQCc2CBuIE0pB0O2YycQx4CBgIOAFPYMlPsgZrtObZRv376px6vnrS0xt0qu559+xa77w7V9X+qvZXu3btqnOG3XTsmHlyBByBRiIwopFSu9COgCMQEHAC8I7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R0BJwDvA45AgxFwAmhw47vojoATgPcBR6DBCDgBNLjxXXRHwAnA+4Aj0GAEnAAa3PguuiPgBOB9wBFoMAJOAA1ufBfdEXAC8D7gCDQYASeABje+i+4IOAF4H3AEGoyAE0CDG99FdwScALwPOAINRsAJoMGN76I7Ak4A3gccgQYj4ATQ4MZ30R2BUQ5BXgRGnmE2G9qdKOrlOX/HpWPHzPg7/tIbpCM8HuV6nud6PMT1i/CJ/3MEhoaAE8DQcBvSr6TsL6C9m3fz5Lkyi9G9siqJITCDnsfXetR31WLlNYvHcbw/hivkzUciif2wwn4RBZcnR+BUCDgBnAqdCj8bi4YeRvl/5UyzX3212Yp5KO5IFPZIUcgIlFij/8GjvPcC3+XxIJ/pOnIYZeb11r2Qxz6z3Vzref5vu/gtz+0Ql8wCEcRYrvFmE8aZnUnryuI4TL57IIW9XM4J4OOpBwEngB4o0j7RyDwChX9km9mcx8xmTIQMLjPrmja4co9CDsdQZBHDvgPoPsq/DYtiJ9d68l632ewnm8y+utFsLY8GedgErslmCyAGWQwH+P12Lk0jPDUbgTPsJo07nrIhILQPcm3hmmL28f9k9luvMps2iUEc5R4hW75MZ7Q811u9X8fv9X48hLWwGwthyw6zbkjg0W6zB35u9o+r+aamH5DBqKlmi8cUlsE2yvXUTAScANrQ7hNR7C5sr+cZhdevN7t4ldlfv9Xs3KXFNGAgih5pO7B3pHDyZYA/0bPIW7IYNm01ewIyeOhRsz/+MW8+wzXdbBmXrILNTgQA0qzkBNDm9l7BKPyU5vGMzA9+0OzqiwZOAn1VPZJCfBSh9CaVbfgPHnnS7EsPmH3mQXLCZ3DWLKYGkMBuyICfuL+gL4A76H0ngDY2ZlSyOfgGpG1bmLff/4dmv3wxy3sooRyDVSWRQbAaeNKa7wu8fpSpwee/afanX+NLXWZL8Rl0M43w1PkIOAHUpI2nouzy1T3LnP3HH2NacE71JNAqqshAVysZfJ+pwds+b/YDLIPlrFZ0s7IggvDUuQg4AdSobWdhCWzXyItp8OxHzObOhASkpDIVEqZWa2MvDspP/T+zd91pNn9R4STc5ySQEP32Zl2hkdleQTqhdM2/F2sdH3/AbX+VR/mFW7QCRASTWSp85xtZRnx/4TTUOvEU7yWCqSOTN22NmlUD/Tq89SvnmP0F8/Gv/3NROSlmjiQiiFODG65iteBWs13bg3/Qxie2QnLI52WciIATwImYtO0dWdry1ndDAqMXm934VwT54K2PipmjYnHFQKRz1YXED/wBEYj4JbrkqCQ5DxQ4dMp/J4CataRIQKG7i1getA1md32nqGDw4BdPs/wX6YgErmFF4v/8HpbJWsKXqZPqdzpJocnzIJPl5NV6nUUY8zKupVxLuBZzLWL+oXBm+UamUZ8J/NY77Omgf+Jv3Ql4IiZtf0ejrBx/BAfabvwCz95ROARFAr3X81NWtrW8mz9pdvs/mi1kmXA9qwNDSZLrmIKN8HEYYcsmqwJFDykIzbP4KE3XczkhRIZ65LuzeRzP70bzmWZGCrHexxPtc9BrT4NDwAlgcHhl/bZGxKfXmv3v/272phuLETk67HJVJK5CbNkJCb0HYkLLRqOcUrzBWAPyIRyEOF61yOy1l5itWliQwQH2KoxCobVRSiHMug4wBTrAHofnedx7gIBFCGP7HvY28PgT7aIkzDmEU4skcFoa+ypmEsg0DXIQN4k0dzkbgET/yQmgf4za9o2oNKvYM/C9/2E2lY7eOirnqpimAiKef7gf5f0jTPdlZqtRzsEkDebS18ko+39A+X/9GrN/fwVmvVY9+kna1vwLNDtugNJuyK0QwUasiJ+tN/uXdWbf4ApWhSyFaVgqYDWKArfwuwP8XuUPhrD6qVLHfOwEUPOm1Dx59Rqzb3/Y7N9d2h4rIJKORuvrP8DqADsOJzPiyuweUmJUt01cS83u/W9mr7i8ILZobUhRpbAx9TftOQQZ7cA6WEee//oUm55+ClkR1BSsBFZUlmMlbJB14UQQIe15HGmX3Hprzyt/UjsE0P8wx9XhH9ddhmK0akam2qpMWQFjNAdH8b94DyPsDLYgD5EAJiDUkrmY6vz+818mr+lml6ws/B4SSf4PlRmvKKaISEkPeh5fjwabKYz4C8nzl841e93VZr95ldlFWBprIIWf/ZypAQ6VRdRfZXp6EQG3AF7EopbPsJhtCsqwk1FuEyHC82YVHT83EUQrYCfz77N/nzn5Ic4e0dy9VMqhgKddkUsgg8c4H+HP8HO87Q1DyaUgBLFCrGMrNrv3m33rB2Zv/BIWwLNYA/Pwq2ANOA8UWGta5qnGCLxA3WZqXrsZBxjmrVIc+YpXef5LqVTudM4SuJkR1ggQCpuYTqN4HVv2GNOK884ze/snzf7uviIzWRuDSVQtWAvyU4R68lrTCeUjv8nrXs7Kxe1mH3wN06lunJkQl8jHU+GXcRxqjsBBOrM83d9lpFRqHeGKd/L8j8Sj3YoGM42qSImegASWnW32ax9nZ+IaOiWKPFgSaEVA1dI0Qvmozspr1lSzP3iT2d3vK0KcmQ3YpIrq31r2cHvuFsAwaLHnZAbQgf8ex5ZM2jga5656JJ7lCzHdl2JKMw0YV4ESacAPG46Q8d2fxVRnuhOV93RlVJ0DoYhEuW68hnMXbilCnCfzWVUkdrr1bNfvnQDahfwgypUFsIjlsseeYSaA6a2k/pw7RQLQ8WVvwNmm9fjpFfWgrZDcOSx33sN8/WsPFZJFi6MKOWURHOOSNaBDV77xHgKsWEJcrOkViY8amSpqvkZil1VoRb4Zo/86HFkhtYMBKDia5pcs58U+4nAq6kESby3OOTuToKe/49R0yKUqK4BcQ1IZMc9XvozzGP8zqwQbLIQftwnOomJt/F9R8+WVQMqg+Zu84/GaWr6neHEdwS3TblgK1weUmgUoFPbpjeUXkK+dadkCSq8QYCmgVhRWsMy4dw2bkH5USFelFdAbr5tebXYFy4/dxCVMRpY2Q9q7ellelwZQlrIqKUQVPspIcZR5YuiArZ1QLajXPGpuqkZV2Ko2oIg09JHmm1ImHYmtgzAVJaaw1rqnw6o4yrFmc1FTmbTtSHEaMJflSB0oug8wVZWqINxK5J6OJfv0fWavvAqRIT3lXaW4kkGWzCQChD7862bXvo8VjWWnEdhE/YZrGlYEoMrqJN1LCUI5h86nm2VswSxWyKcUfR+dZzfXZq6tEMQhvMvhXHyRhS51LvUkuYBZfw5x5MyttfNMFoM+3kuHVhy59K1OSUSl+j4BAeimIWMTKMZg5J3OfP1yAm++j09iIlhqSa+KpECdZfgYvvaI2ZPdBPOwOiArIBJPFWUojzM0GpC05fk1VxA5uIYI4gnN20MwrAhAI7mUdBJK+8s03CsJIV1EqOcRFOIFFFdrvyIIna+vG2iIIH7Bo7zKmlMePEhADY8b6bRbiCV/lPn0P2xhXs1lmIGBFFjnnsWSmzaWSOnknKrDLbYUxiri+g511waZsXjMKx8aybK/FBVRdx66YB4EsJF4fp7vB6eqUjiHkLZ+ABIQAYizq07KU1aAiPSma+kHDxNvgRXQtE1Ew4oANEccTRDHdzZxfY7Qz2+a3fFas9f/CoMjDTnYdAQ22YMFsX0ngSKQwJPr2HTzc0Jdn+S9beTGSDQZS6OLvJ/luyIEdRzpYu4k2efRWs9S1wMQmZYF25U0ImsKsgLyVbz9eDbfVJmek/kF7ndBAL9N+2rDUBIrQI1JulQrGpDZdtqY7hWmiHq/Cak0hIaPqJq7j8XkXMA8cT2d7zdu5/owwR1SWJIsAXWW1itGhYnxdekzpTEolAJEVi5hZ9rlZr/7BmLTbybfPzH7p9vM3n99MSVY043S0Tm0Pbf8afh97n+6CagUTrvhlNpVl4ifwpI1tZJlVmXSJqNFmOPfhozXby5yTiFrtGbkz/idC8F1N1aAGKBBadgRgNpGo+FGFFLWwKqVZv/3pxDCBzDl6SwjeU8dVI0brxgVpiUgXbHhlZe+GwlCz5XnmZDLtZdxMOd/ZcT9KDfPeBd37YEonl7HZ3w+s0St4n6v6pwyhaCVcjoTvkh925nmz6R0CBdIKk9x2VPLdCElklUDgtrxSlkBTA8nDUuNKCAayv9hLa7m5k8QjbZMI9E+s/M/hAOQub2UXEo9kCQyiAQRiSGQQmkp6GjuX3sFYbhYGZ95C9tKd7D1lDK1sywQzUAKqeg7gXBQuCNYAXVIk5giGdYYVao8Bb8Lea8uCSC2TeUFlRmevZAnuRk9lTCDyHdYE4B0XB3jaUbFZTjv9jINeMdfoiBYB1JqKehQUiAFkNFjJANtKnnzjWaP38GW09mcUoMzbikdNCcJBEVjuN3K6ThtTaWizMYq0tLkEciy6hT2PzANeHJjQeapCCDmO482Nch+j/pO1cLUOL9hL2srCazCdP/i/WZ/c0+B+BD1/7jmUgeJ0WMyF1ctJVz1FraXEk7aDQksyUgCQc/wWzyHtaMUO2/xKt//Uv9tDLJrk5JiFKruSAclLOTyONO6sJzLy6ES+kCQmcYAcs1cHIEMJgoma0qqut3aglskAe0qW4SCvvlzRcScrICBTgX6q3gkghfomDNYA/9f7+R4rPMIX92J/yGTczAoAC12hClIHdLE8YVvRN5zRV9WmTTLmQCu9zOl23OgypyPzyuS6DhWGlbN4TOwrSq8+fiS6vmqIwhA0MbRXhs+NCn9/DcKwCvulzYSxEQCkxidPvk2ymAJbCPEk2NraZwC6PZdbU0lqONRmmWQoYIzxlQMtHwA0+VdxDN/qCS82MZVyy5i1UrG8kgAFctSdX2rzK9jCCCCoiOrF9OQH/o6R0GtK8zkqqyAWEYkgTlEJD78Vt7dRqwApnnqpCVQBQNtZQogmeLolbrc3vlH/dDUaDJTABFAspUAlF/BWylTJJbZtKcRPCbLsSmp4whADRcalOHyrgeKZkzRniIBjRyXv8Tsg69jysFcVTexSJmCZxxN24UFICuk3UlLpovkCFRocgKQQ3wB5KJgrZCippYvK3so810gAqC8xM1YWbWryKgjCWATyj8er+57IYCtzNE1UqZwIMX++Fs30BRMCY6ilCkBDTpPAfsYFeWQbGeKeM6aRC0ggLBuX3GFgoVDWx5lipUjTZA1g/a3GdocovaUkbK/9hSS+4lGygXyUD9j9uMnitJjh62yLnGpcfFcs1tewf4CVgUUrpsqBcKBzF5glIpOj0hCqcrsL98xOAKlMSmmI2HqRg/dFS2A/ioz1M9L62UGKwGKawiW1lDzGma/60gCUBtom6rhoLrvkaJFNF9NkSKx3PAycmdkTmEKx3pHhdCdc3qmAG1igFjsFNbq5XRNMAMoRmKmGc+VBJCCZIRtrLu2B0dLTu83ISVSi/ZDt4NRaQQE8NF/Y213V1GfqKxV1i52ypVLCBBahS+A+XmqE2c18GuOsQUCULBTW1PJADM1BYAAUjgBQ3sh70GINUcaiYPVIDSdE1H1/oYc9R9KGR1LAPKYK0hHd9hdu6mAJhUBKN/JdJzXX0g5kM2MFNpA1jJqNFw9wZz7aLsJQHUhTcT3oelIJMLwZkX/AsfQQ7WtO0eSLBcyDdC9BVnhbETqWAJQ64UOxL+n1qdty0gsF5xFOVgAVa+Jx9rLOTVBLYZC9EwB4odtegyjJoQXMaiyGqH9ILzkBFDOAXT60IJyWTOFU7NKbKrKq6MJIKybw+prNhZwpRilQs5lB1oyn1fMI1M5kaRk4RhuRv+6EEAIB6YXBWWtqleW+QSLB3LZU64CpGq/svlMpwSNk0Wj6WPFstQ1u46WU3M5KeRjTAF0QlDqDtQ1nfLmsC2ZETqFFSAlQx/CXOCYZGtnKrUmTAFY+Qin+FRcn5BnSQA5xJWjeBr9Jfg0IitULFPdsutoAgjHaDGZe2wbjp3SkZTCVI1uZEXF3QgB6BxC3dq76hQIQPlCZknkGEKFdTybWCmM1kP4/al+EvKkhx6EUHPIq7Mlu+TUxMKS+6gJqeMJYDaj00+fY6twwrXkqOs6X+5cYgK0HJhqR1koCybIoRCnUoAo8yjFPXBVHW6tsoOMFHQYhUyRf6t8Ec/psgAoryl3DOpoApDZOE42M8ofl5JSzFXVkWIHmq/DSbAAUk0BwjSmRhZAOF0X4pO5HklBeFSRQluRqZY8I75V5HuqPEZp6M8x3zhVJTJ+1tEEIBzjMVo74oaSRAwQO+j8ckNJqnXkHiVLJMdg+56OYJO9rENBqt5EEwkgODwzyTsaMku1rDlYbHN8v+MJQP1Ty2Y6EjxHmqnNMXTWVMD26EEPE+SQqu8ywhQAAtiTQ+a+q1HZJzoXIIQ2V5ZjvTNK1U9rI3VQGP7lOkRjotaRZRInQiDovTKviZk6CobV0WgapQPZVih3EBGBFfQULawKsz8uq5j/+HIKUBN+Pa6OKV50PAGEToSTalt5jFYKEEOeZY+ZVW4oCTEIKQqrWc8cC7Znlkojf2CVqR2ihlUNOk07yq4Su4Hm1QwCQMp4rFTqWIDRMiEJC9bW4BSdKOSJRaO4BqVg4RRP8/4vhZMFMKmcN1ft9wiyUU5r0FNqeSeWU4Cq/Rl5G2fgpXU8AQTTDikPl9FkA4dmaN8cI2VgGrADBU2xlBQaDHKJBDC0Wlb7qzNk+yfUzGMiu4T5t6IxQrKI3DKV11p2O553PAEEUDWK4AjMkRQZdxXBJM8zb9VgUnWKBNDu3YClARDCZ3s85xULG8ibgnSvxzhHr7iIE7LrIYATPunMNzqeAAKRI6XuqJsyxanFaCbCIZiEUbpqk1j1D+UgVA8BtHukQkHlB0jhOQ+zHNpuR+v258TyhmVNykxcTMquOKi8O54A4jl6u8tQ4Kiog0JpEF9WPLmOyw7x5IP43UC/GkZeTQGwMOqQNFeeUDoBqya8ICJ46sYvPYSXWOhgzTgBJEY5Y/ZxFNmPBYDeJE86LHRGeUpOCh9AJABNMeqQwsnApeOs6mVAtd1E8NwFAWgakCMpnFtBHKlDj3PIMpAyELWzU1B6pNSGktQHaWqeqhGxS7EAlJdiT3kPAWRSiFP2DsnLF6ZpCy31qZrwpIThdCUcuMktngAs1ozIDCbLMVicEttMH3Y8AURHUs54ct00JNUUIHio6Z3HamABxHny5ETySgm1Q0+3IA8rAQmVotR/C4FA+DRSbG9OWP0hZ93xBBAtAO0oy+ZJLtfFh9wqp/hhJLTUTs1TVOGEj0aUTsATPqjgjbAejzV1lEspkk7xqvr/YXMTPg1ZH5EUqi+lPjl2PAFEqFN3nFiOHsfGcNIEPSgQGibqzoT3y2uVZSDPR0teKUwCecUtmk7tjns5EjfkSBXINEBnSTRBOTpexthfUs//1U9jWeOiQujNilMkgHh/wBRKN9gqp9xAE1YWsN72RQIYbOUG+X05AXU8+M4EPo1BViXL15tBAIxMWYJJSgYIjiQ0NcGAWLAMrRZvmJmll/RRSJxSBR9AInkDhijj85kiOdV2l5arOOLxTk8dTwBJlLCfXhE3lKQAN3AMQh3JpBD9iBo+jsueVccBKPNg8QDkzkybuRQIFG4QAuk0YT9Aij46kD6T7TtRYV6gQaONHk31VJXo2VKagH3iHYJ3JL5bzmCwCT4A/SABsGo2HTm2uby5S6opT2yqENcgCwDmqTquQaLULXU8AQTAad2cp+gGT7J6VAKFOKI8madu2oNvLAyP7e9S4RgttCWBuEVADgSwL7UFUMKoOx4v1KEuLD2mvM1b+1utqEHHE0CI6EIZw8GSUWFS9NSWFg0bSkA2RTFhRKST7sYCSL023iLSKZ+OTxg8E092fpobr4ZzB+NQfcoaDe3D6NPo0pkOiQK5hlazdL/qeAIICoOUW2F0kUCOFI7JStRRw94GRsRtEMCRuDaegmkGAlQp41SZzFglKW6IEiwevHHrOdk5VyzAhPJ+h6mmGwOBNtd3Op4Ags7TUR+FAJKHk5atlnJDifY0TYYAHt7NUeeZlsb66oyR48KyJ0qaInruoMiNvL+BBbA3xj4kIrxoASwoD3YF5o5PHU8AsvqnSEoIIPmGklIjdI+5EE+eoKNqlJ0s7xRz4qPIVIcU7g/I2vkhwK66Q8kCOFOa2HJvhwSwHgfjVFkAkd2O+6TzXlTdXrVDSKPSeEnJslmuHXThdlkoaZh+JEAkbDLCFIjHnKVWiP5E0Nr5cubNz2FupXCcjVH7QXhbdpQ1SSVwqfQz5AREphRTmv6wzP15xxOA+kpYn2a0TL0SEAeNcEAGo1aqLaVh1x2E9hwrASGlUogy+z4fSoFFACs0akIAKW6IEmXcsLXPmlTyQWy/aXICIo8smvheJQXUMJOOJwBhHggAh9nh0mROrS/hjDzmrRpBknUg8t4bb3bSpo4VZZO8k0QAmDwpOlRwBDLFePKZQtDUzrkpyHLBbCwO+kuKezy2qblOWmyK9jppQe18MzhzGJ12JXYiRRl7NpRoThy1JH5YwWNwbOJnWLe9yCy1QvRX5TEQwDLdGRmFCbcv7+8Hg/x8rxw5KOUPuhmVKUPypiDxiONkVjUuX0CZTLN0IEknpw4Xr2i6oIRoTbxDcOoGlRNwIZ1oNx1X/sCqU5ibYmFsi3PiqgsYRH7Rc95VBs+kOARFBNCFBfDVNci8s6xcCgYga8mj/nLhEl6w1DqhwzWkw8UrOksYhDFPj2aKn1dgzEqtjWtOXFSh0v8HNCKiEI9vRibkiiNXpYUMMLOoh9NFAJoCJLB4JG5Y+YDwnnqmqFgkngFWc8Bfi/met5SfMG3s9KXARhAA/TIsy22PTrMBd4fBfTEqos4FHI+CKp48hUKE6DiY5RGcYvvLaU3suIOrcQXfLhkg9dp5kBlSfeinRZ0j1hVIcFwWMd8Vi3m7i2kjJN7JStLJsvU0rEYQUfk2gmeUYiMXr6r/r1DgEB0H86TYIafgmAUQwFNb6KClIzCOxNVLM7Acp0zhe8x3AtYD+8mgvrUVLEcRoHPLw7QjG4PUhilIL/aNeTgB33IRR5IzaMyiPTs1NYMApB004t4cG0ooS+fYLZ5GmTisUqyLqzOOVcshz+boB2gXA5Qmf5fkxerRbcJTJO2CXKz51Dqzf/7XooQUBKCcdXiM4L3hMv7tIpDMCUCwDN8Uwkk5uHI1XvPnadzI8ikkino4Ha918jkksqx7NoUUA8+z1H+bLHlnmm2Q3yO+OfBsBvTNLeRt88xuu7sIgtLW3RQkEPvH5edT3mIwhsjl3Ewk1oBkT/UlEV3Hp7ihZEPGDSU96+KJes1hMQ1z4sfXFc0XO23uxozlTuUo9NfOpXQcrRMSybwPmZdhZfz4SbMv3VtImooAlO8sHJufehU8vslsCdMbQd5pqREEIAtAN+28Fwsghs+mas3YIc9kvioLIJX1GNfGv9fN8iZKJ0VsVweVzML3goXIjFMy1dq5eOVpMF20yOy/fNbsRxCBrIBw2EsizfyP1+LPWYK/Bblmp2rMRHUfSLaNIADNH+fQQcOGktIPkFpZggWQEF0RwFymNfc+jVMMyyak1EKVxfR+iKR3LoopAkjl94ji7UJ2I/Do0o9inrMUqmO8qiYBEap8AdMnm933u5RHOaOowNSEbdob1xyvO0ycviEL81I6Z3KnWWn+ynw0FDQc4dV3tYb8iZRhokYkAmNWry+yiYo45ExP84fLZQFkGCX3oJhz5RDE8nn5h5F/Q0ECMoGqPP05+hheusrswdvNnmXVRSQwrYO0poNEOXXvlcIoracRU6ZS/y1sKWX0OMjyVSqQgx+AOfHDjxcSxfl4SvlOlncsd/F8PoUEdDPPFBGBrWVvxiE4H79DN0u7K95r9q0f8ingR6UVEVRBiGFqRee5+iJWHz7EsiCxF6N5PSNVo7YKmeF5h4jRP1JRWXJuKLm8C/McZUi1oWQ75CJT+DM/YrWKqU3srP2jUe03IgHI6nnX+eSNUs5M3LNU5ib8AbMhQN2K7dpbzG7+JOSzscBBRBDxiGQwVEJQPsrjygshgdtoU6YD2im4QGGCkEEk/WpRzZNb4mbKI8RASpHZqA0lD61pcZrReFWnqAyT8NC/dAG5H0rnFFN03Fl0/u6nOPFodSHJUDv56eIQTe9rLyYngpNSOQJjPUPToXnbIMGjPJ612Oz2e3l8B8FCnzb7IVbRfrBXe0QyiG2jbdqqb7h4Lsz6w015BBK4wOz7TAcOQLgbCRJaCf6prZ0oc4rHxhDAPhp8Ho31rbWcDxidZikQJc94X7kLlvAi8YYSyWVMNf7+AR5J6qjtSFG5Ljyb0ufimsBEz1UVWXdrsAYWEL03n4CkD33d7LJ3m133AbOPfcHs2/9itpalPBGCksKzhVO4eK66x/oX33iRFCI5RIKQs/Gy88x+9hGzaxayRfknBD+1+Wi2WOehPHb6XoceTOgjNqF0mv18Heu684pG7t3wPT84nScqjE517lIeUYSUfrEtdMjFBOB8/D6Wxm4sytRIlZsIAo7IPW+W2fuvMvvDb6KMKOQm5M+VNlIWsNsCpl5aifgu8/Xv/i1v4CzUVOlKFPaKRWZLIaglc5jHQxazubRvYwKDw0Q2celId60qnCyEu7WvnE0+D/yx2d0PmH0O7O/fzMyHthAfq/mHS2oMAahBQkQgjqMHYe3rrjiR9atqtNhRVtBJFLm2ldFJJED/SJJioNOnv2b2J2/Nr/xRKFk+Gl1ffTUEcBcKJW3MnKR8IgKlSawUzMAxKRP9AOAHQljLB7IE8M2ERkHxjT6xGP/FuVhSE5m6zWKqOI9LR7uNYPlYMQ664au2eY9BY3Tik6ybKfouv3ntZfSth83u2QCZ8FnoZ3w+HNIZdlM0boZDdU+vjjpKaxw9ZB+dYfPHiA2YkdAKKKv6jj83+1NGibmUtTkVA1DWWXTONWsZlf4I0/QiyIahSLsS25EUbv1mRsc7IdquKRBgQrkHKp+4SIQ0CUy0jwI9DSO1lmkPUb9tIg3VU5eeQ9rhuRglDuutz3k7fEffw9IxLAlZXfrqcErCoTFJB2l0oSj7Nhbzwt+4Lh0BRDP8lb8EAXyFaTqdJCUBhDh5TNtXf4qoNUhAHvlYh5wNrDK1Gertr4MAHsDyxvQWAUgBpT/tSipbocQi/96mGNW1cWiC7gys57IYFDei50qy6FT/eIX3yvf1fD95SkZlPdxSoywANY6OrBLj6462axmlZmDCyQaKZntVDRjz3IlH/PybMUsP0MGYB8hcV2dMkRbSiddvN3srJvjH317MY6NZnqK8vvKMsn/0b8ze/ddmq5aZPYHZLYxTyd5XXfz9UyMQSe7U3+qgT7V0tgRnz971Zl/EUaWUYhKkzq7RUKGkd9xIIRsol3lkKgXQ6LQec3Q5DrBP3Gf2kTslGaNYWY/iVd7/b/lVLJLLUf7N1AvMAzHkrYKX1g8CI+2SW2/t5zsd97FiyZcwZ/vCg2bXn8/mEkxnLe+k8JyLCBQhdzfz4Sf34HeABPYnYgGVpbP5V+Bv+PJDmLHIdCXr1vIFyCeQ4nSik3WOQH7IKJP6+pdCAKuJVlyLn4Jpieqnzz3VA4HGWQARds3ZRjBaXnnHi7HkUpIqU1AE8pS3+Au/Q86Y5ypjeiLUxSsq8yk83CuWmL3vy2a/92fFqTbBIcgXZJXkSNHy0BTrzveYveYlOClZlnNLIAf6Ay8jUVcceAXa9c0DKMPMUZSOwqy4zeyx7he95lUqSfAMU9aFK1iGwjm3HRKQKZyUBBBLJKDNOZ/AyrnsfWbfwwKRrNHKkYwppj6t7RlkpxydFfDZd7L0uhKy3eYk0IpRu583lgAEvJZ+5uAM1LrwS3DU3fO9ojnUcaUcVSlJHA1fhjn+MGSzi5FQu8pSxcuTtXTdVh9mesPqw9M4Iq98r9l7/gJzvPtFGWUtVClnkfPx/yMJyBfyxd+HBM6hXvgEzgF3la16emofAo30AUS4pQBaGprJXHU8c/NPf4XXu5izEyU2Cx+BPo9K0jpa6r3BJv1GhLKQvK87z+zP72a5manBPMrey3RkKHn2VwflqXsT6G7Ci1iO++pjZv/zHg5FYRSeQvTbNNboNU/X92L5kjNcZebx/f7KOtXnykOyK9ruBpZFu9cRr0BdVhE1KH8Mf57ahEDjlgH7wllrv4tQlDUoh3rkzdcT4XU1nXQpCoSi9k5RUcL7/Ja/IrU+j++1PEoRNCrqNJtLsQa0LLAS5ezGZA87Flu+W/XT+ciHvtu6HfxjM8slq8x+8zLuggMhLV1QkF5fwUN9yltWciBEEWU/iKy330nM/hcocxlkRL3WY42lOjuhahw7KT8ngF6tKSUZiVJqPd0Oml280uyNeLIvPpvz6Eol0U6/HoXv9fvjXmo0Pe6NYnTV2vyokYXz8bc/QRz5Q3xpCRcjZI40l7K1W28N8umUpBDRNt/sTch46Vn4RPAdyFKZiRU0ZWJhJQymXiKL3klvCTM5QSW7Xt/1HbPX/yVPhDXl6468nvIi4ATQB97z6KS6LVRQkp18CT+Bwj0vPdPsZSjICsggbChhaUtHYmtDyXgUOMSP87u+NpScrLivPMiGkn8iOnEz5jnTAZnEJ9Ghk/30tN7T4Z06817Wz8ajiLif7PAXBEKQ1TMbkx0iOHcuG2ww13XNZNqgE4BnMqcfzbRpLEqrTTRS6riRBvEHnHZT5leR/28hwe9ife1CfsmeQ/4BV7KDv+gE0E/jSklm0rkVGnoQzdyEY03n3sk6CBtK1Ns1cjNSzoMMLkAxZCFoQ8kcLs21R2BVjJGycJ2woYTPpUhrNrFU+HD7NpRon4SOupJlQHXDnY0VWPQLySvy0yOvg2ZS33DPM5EEMr6cazJyTOKawXtdYKFbhp9BRqOZc2gDTdhQo9dgGW6fTnnjeC6/gIjjZxuIXfhh++RHkkYmJ4BBNDt9Nhx5rQ0l40pF0c8V3nsYctjKPDZsJGEUG+qGEilDXUY/WQYiQF1jqBf6GuLjJd5R5NVNQMJGH73Reoko+KxnKJdAvV/zVngPf0D4XhePWBd1kl9V7PQEJ3saKALqx4ri0+aP3js/RA4a0TTaSVE0ospq0HMlOcn0nXiF98r39byOG0rklNutSxWUzL2SZNGtwbXHQfvn4YgwnRBx6LlSlDs81+vyCq/1okxaCdERZycpJn7FHxMg4ARQEagiB+0zCDexrCjPumcjmWX9aBCvjdlSd9BqVr9I1DWrllfHEXAEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAk4AOVD2MhyBmiLgBFDThvFqOQI5EHACyIGyl+EI1BQBJ4CaNoxXyxHIgYATQA6UvQxHoKYIOAHUtGG8Wo5ADgScAHKg7GU4AjVFwAmgpg3j1XIEciDgBJADZS/DEagpAk4ANW0Yr5YjkAMBJ4AcKHsZjkBNEXACqGnDeLUcgRwIOAHkQNnLcARqioATQE0bxqvlCORAwAkgB8pehiNQUwScAGraMF4tRyAHAv8fTRTpSk+HEsQAAAAASUVORK5CYII=";
var Ze = { exports: {} };
(function(w) {
  (function(s3, h4) {
    w.exports ? w.exports = h4() : (s3.nacl || (s3.nacl = {}), s3.nacl.util = h4());
  })(Ce, function() {
    var s3 = {};
    function h4(x2) {
      if (!/^(?:[A-Za-z0-9+\/]{2}[A-Za-z0-9+\/]{2})*(?:[A-Za-z0-9+\/]{2}==|[A-Za-z0-9+\/]{3}=)?$/.test(x2))
        throw new TypeError("invalid encoding");
    }
    return s3.decodeUTF8 = function(x2) {
      if (typeof x2 != "string") throw new TypeError("expected string");
      var d8, I2 = unescape(encodeURIComponent(x2)), R = new Uint8Array(I2.length);
      for (d8 = 0; d8 < I2.length; d8++) R[d8] = I2.charCodeAt(d8);
      return R;
    }, s3.encodeUTF8 = function(x2) {
      var d8, I2 = [];
      for (d8 = 0; d8 < x2.length; d8++) I2.push(String.fromCharCode(x2[d8]));
      return decodeURIComponent(escape(I2.join("")));
    }, typeof atob > "u" ? typeof Buffer.from < "u" ? (s3.encodeBase64 = function(x2) {
      return Buffer.from(x2).toString("base64");
    }, s3.decodeBase64 = function(x2) {
      return h4(x2), new Uint8Array(Array.prototype.slice.call(Buffer.from(x2, "base64"), 0));
    }) : (s3.encodeBase64 = function(x2) {
      return new Buffer(x2).toString("base64");
    }, s3.decodeBase64 = function(x2) {
      return h4(x2), new Uint8Array(Array.prototype.slice.call(new Buffer(x2, "base64"), 0));
    }) : (s3.encodeBase64 = function(x2) {
      var d8, I2 = [], R = x2.length;
      for (d8 = 0; d8 < R; d8++) I2.push(String.fromCharCode(x2[d8]));
      return btoa(I2.join(""));
    }, s3.decodeBase64 = function(x2) {
      h4(x2);
      var d8, I2 = atob(x2), R = new Uint8Array(I2.length);
      for (d8 = 0; d8 < I2.length; d8++) R[d8] = I2.charCodeAt(d8);
      return R;
    }), s3;
  });
})(Ze);
function qe(w) {
  throw new Error('Could not dynamically require "' + w + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var xe = { exports: {} };
var Ge = {};
var Ve = Object.freeze(Object.defineProperty({
  __proto__: null,
  default: Ge
}, Symbol.toStringTag, { value: "Module" }));
var Xe = Te(Ve);
(function(w) {
  (function(s3) {
    var h4 = function(n14) {
      var o12, i4 = new Float64Array(16);
      if (n14) for (o12 = 0; o12 < n14.length; o12++) i4[o12] = n14[o12];
      return i4;
    }, x2 = function() {
      throw new Error("no PRNG");
    }, d8 = new Uint8Array(16), I2 = new Uint8Array(32);
    I2[0] = 9;
    var R = h4(), l3 = h4([1]), j2 = h4([56129, 1]), et = h4([30883, 4953, 19914, 30187, 55467, 16705, 2637, 112, 59544, 30585, 16505, 36039, 65139, 11119, 27886, 20995]), ct = h4([61785, 9906, 39828, 60374, 45398, 33411, 5274, 224, 53552, 61171, 33010, 6542, 64743, 22239, 55772, 9222]), dt = h4([54554, 36645, 11616, 51542, 42930, 38181, 51040, 26924, 56412, 64982, 57905, 49316, 21502, 52590, 14035, 8553]), vt = h4([26200, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214, 26214]), At = h4([41136, 18958, 6951, 50414, 58488, 44335, 6150, 12099, 55207, 15867, 153, 11085, 57099, 20417, 9344, 11139]);
    function Bt(n14, o12, i4, t14) {
      n14[o12] = i4 >> 24 & 255, n14[o12 + 1] = i4 >> 16 & 255, n14[o12 + 2] = i4 >> 8 & 255, n14[o12 + 3] = i4 & 255, n14[o12 + 4] = t14 >> 24 & 255, n14[o12 + 5] = t14 >> 16 & 255, n14[o12 + 6] = t14 >> 8 & 255, n14[o12 + 7] = t14 & 255;
    }
    function Dt(n14, o12, i4, t14, a2) {
      var A5, y3 = 0;
      for (A5 = 0; A5 < a2; A5++) y3 |= n14[o12 + A5] ^ i4[t14 + A5];
      return (1 & y3 - 1 >>> 8) - 1;
    }
    function er(n14, o12, i4, t14) {
      return Dt(n14, o12, i4, t14, 16);
    }
    function Kt(n14, o12, i4, t14) {
      return Dt(n14, o12, i4, t14, 32);
    }
    function nr(n14, o12, i4, t14) {
      for (var a2 = t14[0] & 255 | (t14[1] & 255) << 8 | (t14[2] & 255) << 16 | (t14[3] & 255) << 24, A5 = i4[0] & 255 | (i4[1] & 255) << 8 | (i4[2] & 255) << 16 | (i4[3] & 255) << 24, y3 = i4[4] & 255 | (i4[5] & 255) << 8 | (i4[6] & 255) << 16 | (i4[7] & 255) << 24, U = i4[8] & 255 | (i4[9] & 255) << 8 | (i4[10] & 255) << 16 | (i4[11] & 255) << 24, T4 = i4[12] & 255 | (i4[13] & 255) << 8 | (i4[14] & 255) << 16 | (i4[15] & 255) << 24, D3 = t14[4] & 255 | (t14[5] & 255) << 8 | (t14[6] & 255) << 16 | (t14[7] & 255) << 24, F = o12[0] & 255 | (o12[1] & 255) << 8 | (o12[2] & 255) << 16 | (o12[3] & 255) << 24, ot = o12[4] & 255 | (o12[5] & 255) << 8 | (o12[6] & 255) << 16 | (o12[7] & 255) << 24, O2 = o12[8] & 255 | (o12[9] & 255) << 8 | (o12[10] & 255) << 16 | (o12[11] & 255) << 24, K = o12[12] & 255 | (o12[13] & 255) << 8 | (o12[14] & 255) << 16 | (o12[15] & 255) << 24, Y = t14[8] & 255 | (t14[9] & 255) << 8 | (t14[10] & 255) << 16 | (t14[11] & 255) << 24, q2 = i4[16] & 255 | (i4[17] & 255) << 8 | (i4[18] & 255) << 16 | (i4[19] & 255) << 24, Z = i4[20] & 255 | (i4[21] & 255) << 8 | (i4[22] & 255) << 16 | (i4[23] & 255) << 24, H = i4[24] & 255 | (i4[25] & 255) << 8 | (i4[26] & 255) << 16 | (i4[27] & 255) << 24, J2 = i4[28] & 255 | (i4[29] & 255) << 8 | (i4[30] & 255) << 16 | (i4[31] & 255) << 24, _ = t14[12] & 255 | (t14[13] & 255) << 8 | (t14[14] & 255) << 16 | (t14[15] & 255) << 24, k2 = a2, Q = A5, L2 = y3, M = U, P2 = T4, N = D3, m3 = F, E2 = ot, C3 = O2, B2 = K, v = Y, S2 = q2, z2 = Z, G = H, X = J2, V = _, u4, tt = 0; tt < 20; tt += 2)
        u4 = k2 + z2 | 0, P2 ^= u4 << 7 | u4 >>> 25, u4 = P2 + k2 | 0, C3 ^= u4 << 9 | u4 >>> 23, u4 = C3 + P2 | 0, z2 ^= u4 << 13 | u4 >>> 19, u4 = z2 + C3 | 0, k2 ^= u4 << 18 | u4 >>> 14, u4 = N + Q | 0, B2 ^= u4 << 7 | u4 >>> 25, u4 = B2 + N | 0, G ^= u4 << 9 | u4 >>> 23, u4 = G + B2 | 0, Q ^= u4 << 13 | u4 >>> 19, u4 = Q + G | 0, N ^= u4 << 18 | u4 >>> 14, u4 = v + m3 | 0, X ^= u4 << 7 | u4 >>> 25, u4 = X + v | 0, L2 ^= u4 << 9 | u4 >>> 23, u4 = L2 + X | 0, m3 ^= u4 << 13 | u4 >>> 19, u4 = m3 + L2 | 0, v ^= u4 << 18 | u4 >>> 14, u4 = V + S2 | 0, M ^= u4 << 7 | u4 >>> 25, u4 = M + V | 0, E2 ^= u4 << 9 | u4 >>> 23, u4 = E2 + M | 0, S2 ^= u4 << 13 | u4 >>> 19, u4 = S2 + E2 | 0, V ^= u4 << 18 | u4 >>> 14, u4 = k2 + M | 0, Q ^= u4 << 7 | u4 >>> 25, u4 = Q + k2 | 0, L2 ^= u4 << 9 | u4 >>> 23, u4 = L2 + Q | 0, M ^= u4 << 13 | u4 >>> 19, u4 = M + L2 | 0, k2 ^= u4 << 18 | u4 >>> 14, u4 = N + P2 | 0, m3 ^= u4 << 7 | u4 >>> 25, u4 = m3 + N | 0, E2 ^= u4 << 9 | u4 >>> 23, u4 = E2 + m3 | 0, P2 ^= u4 << 13 | u4 >>> 19, u4 = P2 + E2 | 0, N ^= u4 << 18 | u4 >>> 14, u4 = v + B2 | 0, S2 ^= u4 << 7 | u4 >>> 25, u4 = S2 + v | 0, C3 ^= u4 << 9 | u4 >>> 23, u4 = C3 + S2 | 0, B2 ^= u4 << 13 | u4 >>> 19, u4 = B2 + C3 | 0, v ^= u4 << 18 | u4 >>> 14, u4 = V + X | 0, z2 ^= u4 << 7 | u4 >>> 25, u4 = z2 + V | 0, G ^= u4 << 9 | u4 >>> 23, u4 = G + z2 | 0, X ^= u4 << 13 | u4 >>> 19, u4 = X + G | 0, V ^= u4 << 18 | u4 >>> 14;
      k2 = k2 + a2 | 0, Q = Q + A5 | 0, L2 = L2 + y3 | 0, M = M + U | 0, P2 = P2 + T4 | 0, N = N + D3 | 0, m3 = m3 + F | 0, E2 = E2 + ot | 0, C3 = C3 + O2 | 0, B2 = B2 + K | 0, v = v + Y | 0, S2 = S2 + q2 | 0, z2 = z2 + Z | 0, G = G + H | 0, X = X + J2 | 0, V = V + _ | 0, n14[0] = k2 >>> 0 & 255, n14[1] = k2 >>> 8 & 255, n14[2] = k2 >>> 16 & 255, n14[3] = k2 >>> 24 & 255, n14[4] = Q >>> 0 & 255, n14[5] = Q >>> 8 & 255, n14[6] = Q >>> 16 & 255, n14[7] = Q >>> 24 & 255, n14[8] = L2 >>> 0 & 255, n14[9] = L2 >>> 8 & 255, n14[10] = L2 >>> 16 & 255, n14[11] = L2 >>> 24 & 255, n14[12] = M >>> 0 & 255, n14[13] = M >>> 8 & 255, n14[14] = M >>> 16 & 255, n14[15] = M >>> 24 & 255, n14[16] = P2 >>> 0 & 255, n14[17] = P2 >>> 8 & 255, n14[18] = P2 >>> 16 & 255, n14[19] = P2 >>> 24 & 255, n14[20] = N >>> 0 & 255, n14[21] = N >>> 8 & 255, n14[22] = N >>> 16 & 255, n14[23] = N >>> 24 & 255, n14[24] = m3 >>> 0 & 255, n14[25] = m3 >>> 8 & 255, n14[26] = m3 >>> 16 & 255, n14[27] = m3 >>> 24 & 255, n14[28] = E2 >>> 0 & 255, n14[29] = E2 >>> 8 & 255, n14[30] = E2 >>> 16 & 255, n14[31] = E2 >>> 24 & 255, n14[32] = C3 >>> 0 & 255, n14[33] = C3 >>> 8 & 255, n14[34] = C3 >>> 16 & 255, n14[35] = C3 >>> 24 & 255, n14[36] = B2 >>> 0 & 255, n14[37] = B2 >>> 8 & 255, n14[38] = B2 >>> 16 & 255, n14[39] = B2 >>> 24 & 255, n14[40] = v >>> 0 & 255, n14[41] = v >>> 8 & 255, n14[42] = v >>> 16 & 255, n14[43] = v >>> 24 & 255, n14[44] = S2 >>> 0 & 255, n14[45] = S2 >>> 8 & 255, n14[46] = S2 >>> 16 & 255, n14[47] = S2 >>> 24 & 255, n14[48] = z2 >>> 0 & 255, n14[49] = z2 >>> 8 & 255, n14[50] = z2 >>> 16 & 255, n14[51] = z2 >>> 24 & 255, n14[52] = G >>> 0 & 255, n14[53] = G >>> 8 & 255, n14[54] = G >>> 16 & 255, n14[55] = G >>> 24 & 255, n14[56] = X >>> 0 & 255, n14[57] = X >>> 8 & 255, n14[58] = X >>> 16 & 255, n14[59] = X >>> 24 & 255, n14[60] = V >>> 0 & 255, n14[61] = V >>> 8 & 255, n14[62] = V >>> 16 & 255, n14[63] = V >>> 24 & 255;
    }
    function lr(n14, o12, i4, t14) {
      for (var a2 = t14[0] & 255 | (t14[1] & 255) << 8 | (t14[2] & 255) << 16 | (t14[3] & 255) << 24, A5 = i4[0] & 255 | (i4[1] & 255) << 8 | (i4[2] & 255) << 16 | (i4[3] & 255) << 24, y3 = i4[4] & 255 | (i4[5] & 255) << 8 | (i4[6] & 255) << 16 | (i4[7] & 255) << 24, U = i4[8] & 255 | (i4[9] & 255) << 8 | (i4[10] & 255) << 16 | (i4[11] & 255) << 24, T4 = i4[12] & 255 | (i4[13] & 255) << 8 | (i4[14] & 255) << 16 | (i4[15] & 255) << 24, D3 = t14[4] & 255 | (t14[5] & 255) << 8 | (t14[6] & 255) << 16 | (t14[7] & 255) << 24, F = o12[0] & 255 | (o12[1] & 255) << 8 | (o12[2] & 255) << 16 | (o12[3] & 255) << 24, ot = o12[4] & 255 | (o12[5] & 255) << 8 | (o12[6] & 255) << 16 | (o12[7] & 255) << 24, O2 = o12[8] & 255 | (o12[9] & 255) << 8 | (o12[10] & 255) << 16 | (o12[11] & 255) << 24, K = o12[12] & 255 | (o12[13] & 255) << 8 | (o12[14] & 255) << 16 | (o12[15] & 255) << 24, Y = t14[8] & 255 | (t14[9] & 255) << 8 | (t14[10] & 255) << 16 | (t14[11] & 255) << 24, q2 = i4[16] & 255 | (i4[17] & 255) << 8 | (i4[18] & 255) << 16 | (i4[19] & 255) << 24, Z = i4[20] & 255 | (i4[21] & 255) << 8 | (i4[22] & 255) << 16 | (i4[23] & 255) << 24, H = i4[24] & 255 | (i4[25] & 255) << 8 | (i4[26] & 255) << 16 | (i4[27] & 255) << 24, J2 = i4[28] & 255 | (i4[29] & 255) << 8 | (i4[30] & 255) << 16 | (i4[31] & 255) << 24, _ = t14[12] & 255 | (t14[13] & 255) << 8 | (t14[14] & 255) << 16 | (t14[15] & 255) << 24, k2 = a2, Q = A5, L2 = y3, M = U, P2 = T4, N = D3, m3 = F, E2 = ot, C3 = O2, B2 = K, v = Y, S2 = q2, z2 = Z, G = H, X = J2, V = _, u4, tt = 0; tt < 20; tt += 2)
        u4 = k2 + z2 | 0, P2 ^= u4 << 7 | u4 >>> 25, u4 = P2 + k2 | 0, C3 ^= u4 << 9 | u4 >>> 23, u4 = C3 + P2 | 0, z2 ^= u4 << 13 | u4 >>> 19, u4 = z2 + C3 | 0, k2 ^= u4 << 18 | u4 >>> 14, u4 = N + Q | 0, B2 ^= u4 << 7 | u4 >>> 25, u4 = B2 + N | 0, G ^= u4 << 9 | u4 >>> 23, u4 = G + B2 | 0, Q ^= u4 << 13 | u4 >>> 19, u4 = Q + G | 0, N ^= u4 << 18 | u4 >>> 14, u4 = v + m3 | 0, X ^= u4 << 7 | u4 >>> 25, u4 = X + v | 0, L2 ^= u4 << 9 | u4 >>> 23, u4 = L2 + X | 0, m3 ^= u4 << 13 | u4 >>> 19, u4 = m3 + L2 | 0, v ^= u4 << 18 | u4 >>> 14, u4 = V + S2 | 0, M ^= u4 << 7 | u4 >>> 25, u4 = M + V | 0, E2 ^= u4 << 9 | u4 >>> 23, u4 = E2 + M | 0, S2 ^= u4 << 13 | u4 >>> 19, u4 = S2 + E2 | 0, V ^= u4 << 18 | u4 >>> 14, u4 = k2 + M | 0, Q ^= u4 << 7 | u4 >>> 25, u4 = Q + k2 | 0, L2 ^= u4 << 9 | u4 >>> 23, u4 = L2 + Q | 0, M ^= u4 << 13 | u4 >>> 19, u4 = M + L2 | 0, k2 ^= u4 << 18 | u4 >>> 14, u4 = N + P2 | 0, m3 ^= u4 << 7 | u4 >>> 25, u4 = m3 + N | 0, E2 ^= u4 << 9 | u4 >>> 23, u4 = E2 + m3 | 0, P2 ^= u4 << 13 | u4 >>> 19, u4 = P2 + E2 | 0, N ^= u4 << 18 | u4 >>> 14, u4 = v + B2 | 0, S2 ^= u4 << 7 | u4 >>> 25, u4 = S2 + v | 0, C3 ^= u4 << 9 | u4 >>> 23, u4 = C3 + S2 | 0, B2 ^= u4 << 13 | u4 >>> 19, u4 = B2 + C3 | 0, v ^= u4 << 18 | u4 >>> 14, u4 = V + X | 0, z2 ^= u4 << 7 | u4 >>> 25, u4 = z2 + V | 0, G ^= u4 << 9 | u4 >>> 23, u4 = G + z2 | 0, X ^= u4 << 13 | u4 >>> 19, u4 = X + G | 0, V ^= u4 << 18 | u4 >>> 14;
      n14[0] = k2 >>> 0 & 255, n14[1] = k2 >>> 8 & 255, n14[2] = k2 >>> 16 & 255, n14[3] = k2 >>> 24 & 255, n14[4] = N >>> 0 & 255, n14[5] = N >>> 8 & 255, n14[6] = N >>> 16 & 255, n14[7] = N >>> 24 & 255, n14[8] = v >>> 0 & 255, n14[9] = v >>> 8 & 255, n14[10] = v >>> 16 & 255, n14[11] = v >>> 24 & 255, n14[12] = V >>> 0 & 255, n14[13] = V >>> 8 & 255, n14[14] = V >>> 16 & 255, n14[15] = V >>> 24 & 255, n14[16] = m3 >>> 0 & 255, n14[17] = m3 >>> 8 & 255, n14[18] = m3 >>> 16 & 255, n14[19] = m3 >>> 24 & 255, n14[20] = E2 >>> 0 & 255, n14[21] = E2 >>> 8 & 255, n14[22] = E2 >>> 16 & 255, n14[23] = E2 >>> 24 & 255, n14[24] = C3 >>> 0 & 255, n14[25] = C3 >>> 8 & 255, n14[26] = C3 >>> 16 & 255, n14[27] = C3 >>> 24 & 255, n14[28] = B2 >>> 0 & 255, n14[29] = B2 >>> 8 & 255, n14[30] = B2 >>> 16 & 255, n14[31] = B2 >>> 24 & 255;
    }
    function Vt(n14, o12, i4, t14) {
      nr(n14, o12, i4, t14);
    }
    function Rt(n14, o12, i4, t14) {
      lr(n14, o12, i4, t14);
    }
    var Ft = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
    function Ht(n14, o12, i4, t14, a2, A5, y3) {
      var U = new Uint8Array(16), T4 = new Uint8Array(64), D3, F;
      for (F = 0; F < 16; F++) U[F] = 0;
      for (F = 0; F < 8; F++) U[F] = A5[F];
      for (; a2 >= 64; ) {
        for (Vt(T4, U, y3, Ft), F = 0; F < 64; F++) n14[o12 + F] = i4[t14 + F] ^ T4[F];
        for (D3 = 1, F = 8; F < 16; F++)
          D3 = D3 + (U[F] & 255) | 0, U[F] = D3 & 255, D3 >>>= 8;
        a2 -= 64, o12 += 64, t14 += 64;
      }
      if (a2 > 0)
        for (Vt(T4, U, y3, Ft), F = 0; F < a2; F++) n14[o12 + F] = i4[t14 + F] ^ T4[F];
      return 0;
    }
    function Mt(n14, o12, i4, t14, a2) {
      var A5 = new Uint8Array(16), y3 = new Uint8Array(64), U, T4;
      for (T4 = 0; T4 < 16; T4++) A5[T4] = 0;
      for (T4 = 0; T4 < 8; T4++) A5[T4] = t14[T4];
      for (; i4 >= 64; ) {
        for (Vt(y3, A5, a2, Ft), T4 = 0; T4 < 64; T4++) n14[o12 + T4] = y3[T4];
        for (U = 1, T4 = 8; T4 < 16; T4++)
          U = U + (A5[T4] & 255) | 0, A5[T4] = U & 255, U >>>= 8;
        i4 -= 64, o12 += 64;
      }
      if (i4 > 0)
        for (Vt(y3, A5, a2, Ft), T4 = 0; T4 < i4; T4++) n14[o12 + T4] = y3[T4];
      return 0;
    }
    function Nr(n14, o12, i4, t14, a2) {
      var A5 = new Uint8Array(32);
      Rt(A5, t14, a2, Ft);
      for (var y3 = new Uint8Array(8), U = 0; U < 8; U++) y3[U] = t14[U + 16];
      return Mt(n14, o12, i4, y3, A5);
    }
    function br(n14, o12, i4, t14, a2, A5, y3) {
      var U = new Uint8Array(32);
      Rt(U, A5, y3, Ft);
      for (var T4 = new Uint8Array(8), D3 = 0; D3 < 8; D3++) T4[D3] = A5[D3 + 16];
      return Ht(n14, o12, i4, t14, a2, T4, U);
    }
    var xr = function(n14) {
      this.buffer = new Uint8Array(16), this.r = new Uint16Array(10), this.h = new Uint16Array(10), this.pad = new Uint16Array(8), this.leftover = 0, this.fin = 0;
      var o12, i4, t14, a2, A5, y3, U, T4;
      o12 = n14[0] & 255 | (n14[1] & 255) << 8, this.r[0] = o12 & 8191, i4 = n14[2] & 255 | (n14[3] & 255) << 8, this.r[1] = (o12 >>> 13 | i4 << 3) & 8191, t14 = n14[4] & 255 | (n14[5] & 255) << 8, this.r[2] = (i4 >>> 10 | t14 << 6) & 7939, a2 = n14[6] & 255 | (n14[7] & 255) << 8, this.r[3] = (t14 >>> 7 | a2 << 9) & 8191, A5 = n14[8] & 255 | (n14[9] & 255) << 8, this.r[4] = (a2 >>> 4 | A5 << 12) & 255, this.r[5] = A5 >>> 1 & 8190, y3 = n14[10] & 255 | (n14[11] & 255) << 8, this.r[6] = (A5 >>> 14 | y3 << 2) & 8191, U = n14[12] & 255 | (n14[13] & 255) << 8, this.r[7] = (y3 >>> 11 | U << 5) & 8065, T4 = n14[14] & 255 | (n14[15] & 255) << 8, this.r[8] = (U >>> 8 | T4 << 8) & 8191, this.r[9] = T4 >>> 5 & 127, this.pad[0] = n14[16] & 255 | (n14[17] & 255) << 8, this.pad[1] = n14[18] & 255 | (n14[19] & 255) << 8, this.pad[2] = n14[20] & 255 | (n14[21] & 255) << 8, this.pad[3] = n14[22] & 255 | (n14[23] & 255) << 8, this.pad[4] = n14[24] & 255 | (n14[25] & 255) << 8, this.pad[5] = n14[26] & 255 | (n14[27] & 255) << 8, this.pad[6] = n14[28] & 255 | (n14[29] & 255) << 8, this.pad[7] = n14[30] & 255 | (n14[31] & 255) << 8;
    };
    xr.prototype.blocks = function(n14, o12, i4) {
      for (var t14 = this.fin ? 0 : 2048, a2, A5, y3, U, T4, D3, F, ot, O2, K, Y, q2, Z, H, J2, _, k2, Q, L2, M = this.h[0], P2 = this.h[1], N = this.h[2], m3 = this.h[3], E2 = this.h[4], C3 = this.h[5], B2 = this.h[6], v = this.h[7], S2 = this.h[8], z2 = this.h[9], G = this.r[0], X = this.r[1], V = this.r[2], u4 = this.r[3], tt = this.r[4], at = this.r[5], st = this.r[6], $2 = this.r[7], nt = this.r[8], it = this.r[9]; i4 >= 16; )
        a2 = n14[o12 + 0] & 255 | (n14[o12 + 1] & 255) << 8, M += a2 & 8191, A5 = n14[o12 + 2] & 255 | (n14[o12 + 3] & 255) << 8, P2 += (a2 >>> 13 | A5 << 3) & 8191, y3 = n14[o12 + 4] & 255 | (n14[o12 + 5] & 255) << 8, N += (A5 >>> 10 | y3 << 6) & 8191, U = n14[o12 + 6] & 255 | (n14[o12 + 7] & 255) << 8, m3 += (y3 >>> 7 | U << 9) & 8191, T4 = n14[o12 + 8] & 255 | (n14[o12 + 9] & 255) << 8, E2 += (U >>> 4 | T4 << 12) & 8191, C3 += T4 >>> 1 & 8191, D3 = n14[o12 + 10] & 255 | (n14[o12 + 11] & 255) << 8, B2 += (T4 >>> 14 | D3 << 2) & 8191, F = n14[o12 + 12] & 255 | (n14[o12 + 13] & 255) << 8, v += (D3 >>> 11 | F << 5) & 8191, ot = n14[o12 + 14] & 255 | (n14[o12 + 15] & 255) << 8, S2 += (F >>> 8 | ot << 8) & 8191, z2 += ot >>> 5 | t14, O2 = 0, K = O2, K += M * G, K += P2 * (5 * it), K += N * (5 * nt), K += m3 * (5 * $2), K += E2 * (5 * st), O2 = K >>> 13, K &= 8191, K += C3 * (5 * at), K += B2 * (5 * tt), K += v * (5 * u4), K += S2 * (5 * V), K += z2 * (5 * X), O2 += K >>> 13, K &= 8191, Y = O2, Y += M * X, Y += P2 * G, Y += N * (5 * it), Y += m3 * (5 * nt), Y += E2 * (5 * $2), O2 = Y >>> 13, Y &= 8191, Y += C3 * (5 * st), Y += B2 * (5 * at), Y += v * (5 * tt), Y += S2 * (5 * u4), Y += z2 * (5 * V), O2 += Y >>> 13, Y &= 8191, q2 = O2, q2 += M * V, q2 += P2 * X, q2 += N * G, q2 += m3 * (5 * it), q2 += E2 * (5 * nt), O2 = q2 >>> 13, q2 &= 8191, q2 += C3 * (5 * $2), q2 += B2 * (5 * st), q2 += v * (5 * at), q2 += S2 * (5 * tt), q2 += z2 * (5 * u4), O2 += q2 >>> 13, q2 &= 8191, Z = O2, Z += M * u4, Z += P2 * V, Z += N * X, Z += m3 * G, Z += E2 * (5 * it), O2 = Z >>> 13, Z &= 8191, Z += C3 * (5 * nt), Z += B2 * (5 * $2), Z += v * (5 * st), Z += S2 * (5 * at), Z += z2 * (5 * tt), O2 += Z >>> 13, Z &= 8191, H = O2, H += M * tt, H += P2 * u4, H += N * V, H += m3 * X, H += E2 * G, O2 = H >>> 13, H &= 8191, H += C3 * (5 * it), H += B2 * (5 * nt), H += v * (5 * $2), H += S2 * (5 * st), H += z2 * (5 * at), O2 += H >>> 13, H &= 8191, J2 = O2, J2 += M * at, J2 += P2 * tt, J2 += N * u4, J2 += m3 * V, J2 += E2 * X, O2 = J2 >>> 13, J2 &= 8191, J2 += C3 * G, J2 += B2 * (5 * it), J2 += v * (5 * nt), J2 += S2 * (5 * $2), J2 += z2 * (5 * st), O2 += J2 >>> 13, J2 &= 8191, _ = O2, _ += M * st, _ += P2 * at, _ += N * tt, _ += m3 * u4, _ += E2 * V, O2 = _ >>> 13, _ &= 8191, _ += C3 * X, _ += B2 * G, _ += v * (5 * it), _ += S2 * (5 * nt), _ += z2 * (5 * $2), O2 += _ >>> 13, _ &= 8191, k2 = O2, k2 += M * $2, k2 += P2 * st, k2 += N * at, k2 += m3 * tt, k2 += E2 * u4, O2 = k2 >>> 13, k2 &= 8191, k2 += C3 * V, k2 += B2 * X, k2 += v * G, k2 += S2 * (5 * it), k2 += z2 * (5 * nt), O2 += k2 >>> 13, k2 &= 8191, Q = O2, Q += M * nt, Q += P2 * $2, Q += N * st, Q += m3 * at, Q += E2 * tt, O2 = Q >>> 13, Q &= 8191, Q += C3 * u4, Q += B2 * V, Q += v * X, Q += S2 * G, Q += z2 * (5 * it), O2 += Q >>> 13, Q &= 8191, L2 = O2, L2 += M * it, L2 += P2 * nt, L2 += N * $2, L2 += m3 * st, L2 += E2 * at, O2 = L2 >>> 13, L2 &= 8191, L2 += C3 * tt, L2 += B2 * u4, L2 += v * V, L2 += S2 * X, L2 += z2 * G, O2 += L2 >>> 13, L2 &= 8191, O2 = (O2 << 2) + O2 | 0, O2 = O2 + K | 0, K = O2 & 8191, O2 = O2 >>> 13, Y += O2, M = K, P2 = Y, N = q2, m3 = Z, E2 = H, C3 = J2, B2 = _, v = k2, S2 = Q, z2 = L2, o12 += 16, i4 -= 16;
      this.h[0] = M, this.h[1] = P2, this.h[2] = N, this.h[3] = m3, this.h[4] = E2, this.h[5] = C3, this.h[6] = B2, this.h[7] = v, this.h[8] = S2, this.h[9] = z2;
    }, xr.prototype.finish = function(n14, o12) {
      var i4 = new Uint16Array(10), t14, a2, A5, y3;
      if (this.leftover) {
        for (y3 = this.leftover, this.buffer[y3++] = 1; y3 < 16; y3++) this.buffer[y3] = 0;
        this.fin = 1, this.blocks(this.buffer, 0, 16);
      }
      for (t14 = this.h[1] >>> 13, this.h[1] &= 8191, y3 = 2; y3 < 10; y3++)
        this.h[y3] += t14, t14 = this.h[y3] >>> 13, this.h[y3] &= 8191;
      for (this.h[0] += t14 * 5, t14 = this.h[0] >>> 13, this.h[0] &= 8191, this.h[1] += t14, t14 = this.h[1] >>> 13, this.h[1] &= 8191, this.h[2] += t14, i4[0] = this.h[0] + 5, t14 = i4[0] >>> 13, i4[0] &= 8191, y3 = 1; y3 < 10; y3++)
        i4[y3] = this.h[y3] + t14, t14 = i4[y3] >>> 13, i4[y3] &= 8191;
      for (i4[9] -= 8192, a2 = (t14 ^ 1) - 1, y3 = 0; y3 < 10; y3++) i4[y3] &= a2;
      for (a2 = ~a2, y3 = 0; y3 < 10; y3++) this.h[y3] = this.h[y3] & a2 | i4[y3];
      for (this.h[0] = (this.h[0] | this.h[1] << 13) & 65535, this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535, this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535, this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535, this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535, this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535, this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535, this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535, A5 = this.h[0] + this.pad[0], this.h[0] = A5 & 65535, y3 = 1; y3 < 8; y3++)
        A5 = (this.h[y3] + this.pad[y3] | 0) + (A5 >>> 16) | 0, this.h[y3] = A5 & 65535;
      n14[o12 + 0] = this.h[0] >>> 0 & 255, n14[o12 + 1] = this.h[0] >>> 8 & 255, n14[o12 + 2] = this.h[1] >>> 0 & 255, n14[o12 + 3] = this.h[1] >>> 8 & 255, n14[o12 + 4] = this.h[2] >>> 0 & 255, n14[o12 + 5] = this.h[2] >>> 8 & 255, n14[o12 + 6] = this.h[3] >>> 0 & 255, n14[o12 + 7] = this.h[3] >>> 8 & 255, n14[o12 + 8] = this.h[4] >>> 0 & 255, n14[o12 + 9] = this.h[4] >>> 8 & 255, n14[o12 + 10] = this.h[5] >>> 0 & 255, n14[o12 + 11] = this.h[5] >>> 8 & 255, n14[o12 + 12] = this.h[6] >>> 0 & 255, n14[o12 + 13] = this.h[6] >>> 8 & 255, n14[o12 + 14] = this.h[7] >>> 0 & 255, n14[o12 + 15] = this.h[7] >>> 8 & 255;
    }, xr.prototype.update = function(n14, o12, i4) {
      var t14, a2;
      if (this.leftover) {
        for (a2 = 16 - this.leftover, a2 > i4 && (a2 = i4), t14 = 0; t14 < a2; t14++)
          this.buffer[this.leftover + t14] = n14[o12 + t14];
        if (i4 -= a2, o12 += a2, this.leftover += a2, this.leftover < 16)
          return;
        this.blocks(this.buffer, 0, 16), this.leftover = 0;
      }
      if (i4 >= 16 && (a2 = i4 - i4 % 16, this.blocks(n14, o12, a2), o12 += a2, i4 -= a2), i4) {
        for (t14 = 0; t14 < i4; t14++)
          this.buffer[this.leftover + t14] = n14[o12 + t14];
        this.leftover += i4;
      }
    };
    function Br(n14, o12, i4, t14, a2, A5) {
      var y3 = new xr(A5);
      return y3.update(i4, t14, a2), y3.finish(n14, o12), 0;
    }
    function Fr(n14, o12, i4, t14, a2, A5) {
      var y3 = new Uint8Array(16);
      return Br(y3, 0, i4, t14, a2, A5), er(n14, o12, y3, 0);
    }
    function pr(n14, o12, i4, t14, a2) {
      var A5;
      if (i4 < 32) return -1;
      for (br(n14, 0, o12, 0, i4, t14, a2), Br(n14, 16, n14, 32, i4 - 32, n14), A5 = 0; A5 < 16; A5++) n14[A5] = 0;
      return 0;
    }
    function dr(n14, o12, i4, t14, a2) {
      var A5, y3 = new Uint8Array(32);
      if (i4 < 32 || (Nr(y3, 0, 32, t14, a2), Fr(o12, 16, o12, 32, i4 - 32, y3) !== 0)) return -1;
      for (br(n14, 0, o12, 0, i4, t14, a2), A5 = 0; A5 < 32; A5++) n14[A5] = 0;
      return 0;
    }
    function Yt(n14, o12) {
      var i4;
      for (i4 = 0; i4 < 16; i4++) n14[i4] = o12[i4] | 0;
    }
    function Ir(n14) {
      var o12, i4, t14 = 1;
      for (o12 = 0; o12 < 16; o12++)
        i4 = n14[o12] + t14 + 65535, t14 = Math.floor(i4 / 65536), n14[o12] = i4 - t14 * 65536;
      n14[0] += t14 - 1 + 37 * (t14 - 1);
    }
    function Xt(n14, o12, i4) {
      for (var t14, a2 = ~(i4 - 1), A5 = 0; A5 < 16; A5++)
        t14 = a2 & (n14[A5] ^ o12[A5]), n14[A5] ^= t14, o12[A5] ^= t14;
    }
    function $t(n14, o12) {
      var i4, t14, a2, A5 = h4(), y3 = h4();
      for (i4 = 0; i4 < 16; i4++) y3[i4] = o12[i4];
      for (Ir(y3), Ir(y3), Ir(y3), t14 = 0; t14 < 2; t14++) {
        for (A5[0] = y3[0] - 65517, i4 = 1; i4 < 15; i4++)
          A5[i4] = y3[i4] - 65535 - (A5[i4 - 1] >> 16 & 1), A5[i4 - 1] &= 65535;
        A5[15] = y3[15] - 32767 - (A5[14] >> 16 & 1), a2 = A5[15] >> 16 & 1, A5[14] &= 65535, Xt(y3, A5, 1 - a2);
      }
      for (i4 = 0; i4 < 16; i4++)
        n14[2 * i4] = y3[i4] & 255, n14[2 * i4 + 1] = y3[i4] >> 8;
    }
    function Lr(n14, o12) {
      var i4 = new Uint8Array(32), t14 = new Uint8Array(32);
      return $t(i4, n14), $t(t14, o12), Kt(i4, 0, t14, 0);
    }
    function mt(n14) {
      var o12 = new Uint8Array(32);
      return $t(o12, n14), o12[0] & 1;
    }
    function It(n14, o12) {
      var i4;
      for (i4 = 0; i4 < 16; i4++) n14[i4] = o12[2 * i4] + (o12[2 * i4 + 1] << 8);
      n14[15] &= 32767;
    }
    function Lt(n14, o12, i4) {
      for (var t14 = 0; t14 < 16; t14++) n14[t14] = o12[t14] + i4[t14];
    }
    function Ot(n14, o12, i4) {
      for (var t14 = 0; t14 < 16; t14++) n14[t14] = o12[t14] - i4[t14];
    }
    function rt(n14, o12, i4) {
      var t14, a2, A5 = 0, y3 = 0, U = 0, T4 = 0, D3 = 0, F = 0, ot = 0, O2 = 0, K = 0, Y = 0, q2 = 0, Z = 0, H = 0, J2 = 0, _ = 0, k2 = 0, Q = 0, L2 = 0, M = 0, P2 = 0, N = 0, m3 = 0, E2 = 0, C3 = 0, B2 = 0, v = 0, S2 = 0, z2 = 0, G = 0, X = 0, V = 0, u4 = i4[0], tt = i4[1], at = i4[2], st = i4[3], $2 = i4[4], nt = i4[5], it = i4[6], Et = i4[7], lt = i4[8], wt = i4[9], yt = i4[10], gt = i4[11], bt = i4[12], Ct = i4[13], St = i4[14], Tt = i4[15];
      t14 = o12[0], A5 += t14 * u4, y3 += t14 * tt, U += t14 * at, T4 += t14 * st, D3 += t14 * $2, F += t14 * nt, ot += t14 * it, O2 += t14 * Et, K += t14 * lt, Y += t14 * wt, q2 += t14 * yt, Z += t14 * gt, H += t14 * bt, J2 += t14 * Ct, _ += t14 * St, k2 += t14 * Tt, t14 = o12[1], y3 += t14 * u4, U += t14 * tt, T4 += t14 * at, D3 += t14 * st, F += t14 * $2, ot += t14 * nt, O2 += t14 * it, K += t14 * Et, Y += t14 * lt, q2 += t14 * wt, Z += t14 * yt, H += t14 * gt, J2 += t14 * bt, _ += t14 * Ct, k2 += t14 * St, Q += t14 * Tt, t14 = o12[2], U += t14 * u4, T4 += t14 * tt, D3 += t14 * at, F += t14 * st, ot += t14 * $2, O2 += t14 * nt, K += t14 * it, Y += t14 * Et, q2 += t14 * lt, Z += t14 * wt, H += t14 * yt, J2 += t14 * gt, _ += t14 * bt, k2 += t14 * Ct, Q += t14 * St, L2 += t14 * Tt, t14 = o12[3], T4 += t14 * u4, D3 += t14 * tt, F += t14 * at, ot += t14 * st, O2 += t14 * $2, K += t14 * nt, Y += t14 * it, q2 += t14 * Et, Z += t14 * lt, H += t14 * wt, J2 += t14 * yt, _ += t14 * gt, k2 += t14 * bt, Q += t14 * Ct, L2 += t14 * St, M += t14 * Tt, t14 = o12[4], D3 += t14 * u4, F += t14 * tt, ot += t14 * at, O2 += t14 * st, K += t14 * $2, Y += t14 * nt, q2 += t14 * it, Z += t14 * Et, H += t14 * lt, J2 += t14 * wt, _ += t14 * yt, k2 += t14 * gt, Q += t14 * bt, L2 += t14 * Ct, M += t14 * St, P2 += t14 * Tt, t14 = o12[5], F += t14 * u4, ot += t14 * tt, O2 += t14 * at, K += t14 * st, Y += t14 * $2, q2 += t14 * nt, Z += t14 * it, H += t14 * Et, J2 += t14 * lt, _ += t14 * wt, k2 += t14 * yt, Q += t14 * gt, L2 += t14 * bt, M += t14 * Ct, P2 += t14 * St, N += t14 * Tt, t14 = o12[6], ot += t14 * u4, O2 += t14 * tt, K += t14 * at, Y += t14 * st, q2 += t14 * $2, Z += t14 * nt, H += t14 * it, J2 += t14 * Et, _ += t14 * lt, k2 += t14 * wt, Q += t14 * yt, L2 += t14 * gt, M += t14 * bt, P2 += t14 * Ct, N += t14 * St, m3 += t14 * Tt, t14 = o12[7], O2 += t14 * u4, K += t14 * tt, Y += t14 * at, q2 += t14 * st, Z += t14 * $2, H += t14 * nt, J2 += t14 * it, _ += t14 * Et, k2 += t14 * lt, Q += t14 * wt, L2 += t14 * yt, M += t14 * gt, P2 += t14 * bt, N += t14 * Ct, m3 += t14 * St, E2 += t14 * Tt, t14 = o12[8], K += t14 * u4, Y += t14 * tt, q2 += t14 * at, Z += t14 * st, H += t14 * $2, J2 += t14 * nt, _ += t14 * it, k2 += t14 * Et, Q += t14 * lt, L2 += t14 * wt, M += t14 * yt, P2 += t14 * gt, N += t14 * bt, m3 += t14 * Ct, E2 += t14 * St, C3 += t14 * Tt, t14 = o12[9], Y += t14 * u4, q2 += t14 * tt, Z += t14 * at, H += t14 * st, J2 += t14 * $2, _ += t14 * nt, k2 += t14 * it, Q += t14 * Et, L2 += t14 * lt, M += t14 * wt, P2 += t14 * yt, N += t14 * gt, m3 += t14 * bt, E2 += t14 * Ct, C3 += t14 * St, B2 += t14 * Tt, t14 = o12[10], q2 += t14 * u4, Z += t14 * tt, H += t14 * at, J2 += t14 * st, _ += t14 * $2, k2 += t14 * nt, Q += t14 * it, L2 += t14 * Et, M += t14 * lt, P2 += t14 * wt, N += t14 * yt, m3 += t14 * gt, E2 += t14 * bt, C3 += t14 * Ct, B2 += t14 * St, v += t14 * Tt, t14 = o12[11], Z += t14 * u4, H += t14 * tt, J2 += t14 * at, _ += t14 * st, k2 += t14 * $2, Q += t14 * nt, L2 += t14 * it, M += t14 * Et, P2 += t14 * lt, N += t14 * wt, m3 += t14 * yt, E2 += t14 * gt, C3 += t14 * bt, B2 += t14 * Ct, v += t14 * St, S2 += t14 * Tt, t14 = o12[12], H += t14 * u4, J2 += t14 * tt, _ += t14 * at, k2 += t14 * st, Q += t14 * $2, L2 += t14 * nt, M += t14 * it, P2 += t14 * Et, N += t14 * lt, m3 += t14 * wt, E2 += t14 * yt, C3 += t14 * gt, B2 += t14 * bt, v += t14 * Ct, S2 += t14 * St, z2 += t14 * Tt, t14 = o12[13], J2 += t14 * u4, _ += t14 * tt, k2 += t14 * at, Q += t14 * st, L2 += t14 * $2, M += t14 * nt, P2 += t14 * it, N += t14 * Et, m3 += t14 * lt, E2 += t14 * wt, C3 += t14 * yt, B2 += t14 * gt, v += t14 * bt, S2 += t14 * Ct, z2 += t14 * St, G += t14 * Tt, t14 = o12[14], _ += t14 * u4, k2 += t14 * tt, Q += t14 * at, L2 += t14 * st, M += t14 * $2, P2 += t14 * nt, N += t14 * it, m3 += t14 * Et, E2 += t14 * lt, C3 += t14 * wt, B2 += t14 * yt, v += t14 * gt, S2 += t14 * bt, z2 += t14 * Ct, G += t14 * St, X += t14 * Tt, t14 = o12[15], k2 += t14 * u4, Q += t14 * tt, L2 += t14 * at, M += t14 * st, P2 += t14 * $2, N += t14 * nt, m3 += t14 * it, E2 += t14 * Et, C3 += t14 * lt, B2 += t14 * wt, v += t14 * yt, S2 += t14 * gt, z2 += t14 * bt, G += t14 * Ct, X += t14 * St, V += t14 * Tt, A5 += 38 * Q, y3 += 38 * L2, U += 38 * M, T4 += 38 * P2, D3 += 38 * N, F += 38 * m3, ot += 38 * E2, O2 += 38 * C3, K += 38 * B2, Y += 38 * v, q2 += 38 * S2, Z += 38 * z2, H += 38 * G, J2 += 38 * X, _ += 38 * V, a2 = 1, t14 = A5 + a2 + 65535, a2 = Math.floor(t14 / 65536), A5 = t14 - a2 * 65536, t14 = y3 + a2 + 65535, a2 = Math.floor(t14 / 65536), y3 = t14 - a2 * 65536, t14 = U + a2 + 65535, a2 = Math.floor(t14 / 65536), U = t14 - a2 * 65536, t14 = T4 + a2 + 65535, a2 = Math.floor(t14 / 65536), T4 = t14 - a2 * 65536, t14 = D3 + a2 + 65535, a2 = Math.floor(t14 / 65536), D3 = t14 - a2 * 65536, t14 = F + a2 + 65535, a2 = Math.floor(t14 / 65536), F = t14 - a2 * 65536, t14 = ot + a2 + 65535, a2 = Math.floor(t14 / 65536), ot = t14 - a2 * 65536, t14 = O2 + a2 + 65535, a2 = Math.floor(t14 / 65536), O2 = t14 - a2 * 65536, t14 = K + a2 + 65535, a2 = Math.floor(t14 / 65536), K = t14 - a2 * 65536, t14 = Y + a2 + 65535, a2 = Math.floor(t14 / 65536), Y = t14 - a2 * 65536, t14 = q2 + a2 + 65535, a2 = Math.floor(t14 / 65536), q2 = t14 - a2 * 65536, t14 = Z + a2 + 65535, a2 = Math.floor(t14 / 65536), Z = t14 - a2 * 65536, t14 = H + a2 + 65535, a2 = Math.floor(t14 / 65536), H = t14 - a2 * 65536, t14 = J2 + a2 + 65535, a2 = Math.floor(t14 / 65536), J2 = t14 - a2 * 65536, t14 = _ + a2 + 65535, a2 = Math.floor(t14 / 65536), _ = t14 - a2 * 65536, t14 = k2 + a2 + 65535, a2 = Math.floor(t14 / 65536), k2 = t14 - a2 * 65536, A5 += a2 - 1 + 37 * (a2 - 1), a2 = 1, t14 = A5 + a2 + 65535, a2 = Math.floor(t14 / 65536), A5 = t14 - a2 * 65536, t14 = y3 + a2 + 65535, a2 = Math.floor(t14 / 65536), y3 = t14 - a2 * 65536, t14 = U + a2 + 65535, a2 = Math.floor(t14 / 65536), U = t14 - a2 * 65536, t14 = T4 + a2 + 65535, a2 = Math.floor(t14 / 65536), T4 = t14 - a2 * 65536, t14 = D3 + a2 + 65535, a2 = Math.floor(t14 / 65536), D3 = t14 - a2 * 65536, t14 = F + a2 + 65535, a2 = Math.floor(t14 / 65536), F = t14 - a2 * 65536, t14 = ot + a2 + 65535, a2 = Math.floor(t14 / 65536), ot = t14 - a2 * 65536, t14 = O2 + a2 + 65535, a2 = Math.floor(t14 / 65536), O2 = t14 - a2 * 65536, t14 = K + a2 + 65535, a2 = Math.floor(t14 / 65536), K = t14 - a2 * 65536, t14 = Y + a2 + 65535, a2 = Math.floor(t14 / 65536), Y = t14 - a2 * 65536, t14 = q2 + a2 + 65535, a2 = Math.floor(t14 / 65536), q2 = t14 - a2 * 65536, t14 = Z + a2 + 65535, a2 = Math.floor(t14 / 65536), Z = t14 - a2 * 65536, t14 = H + a2 + 65535, a2 = Math.floor(t14 / 65536), H = t14 - a2 * 65536, t14 = J2 + a2 + 65535, a2 = Math.floor(t14 / 65536), J2 = t14 - a2 * 65536, t14 = _ + a2 + 65535, a2 = Math.floor(t14 / 65536), _ = t14 - a2 * 65536, t14 = k2 + a2 + 65535, a2 = Math.floor(t14 / 65536), k2 = t14 - a2 * 65536, A5 += a2 - 1 + 37 * (a2 - 1), n14[0] = A5, n14[1] = y3, n14[2] = U, n14[3] = T4, n14[4] = D3, n14[5] = F, n14[6] = ot, n14[7] = O2, n14[8] = K, n14[9] = Y, n14[10] = q2, n14[11] = Z, n14[12] = H, n14[13] = J2, n14[14] = _, n14[15] = k2;
    }
    function Nt(n14, o12) {
      rt(n14, o12, o12);
    }
    function Ur(n14, o12) {
      var i4 = h4(), t14;
      for (t14 = 0; t14 < 16; t14++) i4[t14] = o12[t14];
      for (t14 = 253; t14 >= 0; t14--)
        Nt(i4, i4), t14 !== 2 && t14 !== 4 && rt(i4, i4, o12);
      for (t14 = 0; t14 < 16; t14++) n14[t14] = i4[t14];
    }
    function Jt(n14, o12) {
      var i4 = h4(), t14;
      for (t14 = 0; t14 < 16; t14++) i4[t14] = o12[t14];
      for (t14 = 250; t14 >= 0; t14--)
        Nt(i4, i4), t14 !== 1 && rt(i4, i4, o12);
      for (t14 = 0; t14 < 16; t14++) n14[t14] = i4[t14];
    }
    function tr(n14, o12, i4) {
      var t14 = new Uint8Array(32), a2 = new Float64Array(80), A5, y3, U = h4(), T4 = h4(), D3 = h4(), F = h4(), ot = h4(), O2 = h4();
      for (y3 = 0; y3 < 31; y3++) t14[y3] = o12[y3];
      for (t14[31] = o12[31] & 127 | 64, t14[0] &= 248, It(a2, i4), y3 = 0; y3 < 16; y3++)
        T4[y3] = a2[y3], F[y3] = U[y3] = D3[y3] = 0;
      for (U[0] = F[0] = 1, y3 = 254; y3 >= 0; --y3)
        A5 = t14[y3 >>> 3] >>> (y3 & 7) & 1, Xt(U, T4, A5), Xt(D3, F, A5), Lt(ot, U, D3), Ot(U, U, D3), Lt(D3, T4, F), Ot(T4, T4, F), Nt(F, ot), Nt(O2, U), rt(U, D3, U), rt(D3, T4, ot), Lt(ot, U, D3), Ot(U, U, D3), Nt(T4, U), Ot(D3, F, O2), rt(U, D3, j2), Lt(U, U, F), rt(D3, D3, U), rt(U, F, O2), rt(F, T4, a2), Nt(T4, ot), Xt(U, T4, A5), Xt(D3, F, A5);
      for (y3 = 0; y3 < 16; y3++)
        a2[y3 + 16] = U[y3], a2[y3 + 32] = D3[y3], a2[y3 + 48] = T4[y3], a2[y3 + 64] = F[y3];
      var K = a2.subarray(32), Y = a2.subarray(16);
      return Ur(K, K), rt(Y, Y, K), $t(n14, Y), 0;
    }
    function ir(n14, o12) {
      return tr(n14, o12, I2);
    }
    function Or(n14, o12) {
      return x2(o12, 32), ir(n14, o12);
    }
    function fr(n14, o12, i4) {
      var t14 = new Uint8Array(32);
      return tr(t14, i4, o12), Rt(n14, d8, t14, Ft);
    }
    var Wt = pr, or = dr;
    function zr(n14, o12, i4, t14, a2, A5) {
      var y3 = new Uint8Array(32);
      return fr(y3, a2, A5), Wt(n14, o12, i4, t14, y3);
    }
    function Kr(n14, o12, i4, t14, a2, A5) {
      var y3 = new Uint8Array(32);
      return fr(y3, a2, A5), or(n14, o12, i4, t14, y3);
    }
    var Ar = [
      1116352408,
      3609767458,
      1899447441,
      602891725,
      3049323471,
      3964484399,
      3921009573,
      2173295548,
      961987163,
      4081628472,
      1508970993,
      3053834265,
      2453635748,
      2937671579,
      2870763221,
      3664609560,
      3624381080,
      2734883394,
      310598401,
      1164996542,
      607225278,
      1323610764,
      1426881987,
      3590304994,
      1925078388,
      4068182383,
      2162078206,
      991336113,
      2614888103,
      633803317,
      3248222580,
      3479774868,
      3835390401,
      2666613458,
      4022224774,
      944711139,
      264347078,
      2341262773,
      604807628,
      2007800933,
      770255983,
      1495990901,
      1249150122,
      1856431235,
      1555081692,
      3175218132,
      1996064986,
      2198950837,
      2554220882,
      3999719339,
      2821834349,
      766784016,
      2952996808,
      2566594879,
      3210313671,
      3203337956,
      3336571891,
      1034457026,
      3584528711,
      2466948901,
      113926993,
      3758326383,
      338241895,
      168717936,
      666307205,
      1188179964,
      773529912,
      1546045734,
      1294757372,
      1522805485,
      1396182291,
      2643833823,
      1695183700,
      2343527390,
      1986661051,
      1014477480,
      2177026350,
      1206759142,
      2456956037,
      344077627,
      2730485921,
      1290863460,
      2820302411,
      3158454273,
      3259730800,
      3505952657,
      3345764771,
      106217008,
      3516065817,
      3606008344,
      3600352804,
      1432725776,
      4094571909,
      1467031594,
      275423344,
      851169720,
      430227734,
      3100823752,
      506948616,
      1363258195,
      659060556,
      3750685593,
      883997877,
      3785050280,
      958139571,
      3318307427,
      1322822218,
      3812723403,
      1537002063,
      2003034995,
      1747873779,
      3602036899,
      1955562222,
      1575990012,
      2024104815,
      1125592928,
      2227730452,
      2716904306,
      2361852424,
      442776044,
      2428436474,
      593698344,
      2756734187,
      3733110249,
      3204031479,
      2999351573,
      3329325298,
      3815920427,
      3391569614,
      3928383900,
      3515267271,
      566280711,
      3940187606,
      3454069534,
      4118630271,
      4000239992,
      116418474,
      1914138554,
      174292421,
      2731055270,
      289380356,
      3203993006,
      460393269,
      320620315,
      685471733,
      587496836,
      852142971,
      1086792851,
      1017036298,
      365543100,
      1126000580,
      2618297676,
      1288033470,
      3409855158,
      1501505948,
      4234509866,
      1607167915,
      987167468,
      1816402316,
      1246189591
    ];
    function kr(n14, o12, i4, t14) {
      for (var a2 = new Int32Array(16), A5 = new Int32Array(16), y3, U, T4, D3, F, ot, O2, K, Y, q2, Z, H, J2, _, k2, Q, L2, M, P2, N, m3, E2, C3, B2, v, S2, z2 = n14[0], G = n14[1], X = n14[2], V = n14[3], u4 = n14[4], tt = n14[5], at = n14[6], st = n14[7], $2 = o12[0], nt = o12[1], it = o12[2], Et = o12[3], lt = o12[4], wt = o12[5], yt = o12[6], gt = o12[7], bt = 0; t14 >= 128; ) {
        for (P2 = 0; P2 < 16; P2++)
          N = 8 * P2 + bt, a2[P2] = i4[N + 0] << 24 | i4[N + 1] << 16 | i4[N + 2] << 8 | i4[N + 3], A5[P2] = i4[N + 4] << 24 | i4[N + 5] << 16 | i4[N + 6] << 8 | i4[N + 7];
        for (P2 = 0; P2 < 80; P2++)
          if (y3 = z2, U = G, T4 = X, D3 = V, F = u4, ot = tt, O2 = at, K = st, Y = $2, q2 = nt, Z = it, H = Et, J2 = lt, _ = wt, k2 = yt, Q = gt, m3 = st, E2 = gt, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = (u4 >>> 14 | lt << 18) ^ (u4 >>> 18 | lt << 14) ^ (lt >>> 9 | u4 << 23), E2 = (lt >>> 14 | u4 << 18) ^ (lt >>> 18 | u4 << 14) ^ (u4 >>> 9 | lt << 23), C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, m3 = u4 & tt ^ ~u4 & at, E2 = lt & wt ^ ~lt & yt, C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, m3 = Ar[P2 * 2], E2 = Ar[P2 * 2 + 1], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, m3 = a2[P2 % 16], E2 = A5[P2 % 16], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, L2 = v & 65535 | S2 << 16, M = C3 & 65535 | B2 << 16, m3 = L2, E2 = M, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = (z2 >>> 28 | $2 << 4) ^ ($2 >>> 2 | z2 << 30) ^ ($2 >>> 7 | z2 << 25), E2 = ($2 >>> 28 | z2 << 4) ^ (z2 >>> 2 | $2 << 30) ^ (z2 >>> 7 | $2 << 25), C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, m3 = z2 & G ^ z2 & X ^ G & X, E2 = $2 & nt ^ $2 & it ^ nt & it, C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, K = v & 65535 | S2 << 16, Q = C3 & 65535 | B2 << 16, m3 = D3, E2 = H, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = L2, E2 = M, C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, D3 = v & 65535 | S2 << 16, H = C3 & 65535 | B2 << 16, G = y3, X = U, V = T4, u4 = D3, tt = F, at = ot, st = O2, z2 = K, nt = Y, it = q2, Et = Z, lt = H, wt = J2, yt = _, gt = k2, $2 = Q, P2 % 16 === 15)
            for (N = 0; N < 16; N++)
              m3 = a2[N], E2 = A5[N], C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = a2[(N + 9) % 16], E2 = A5[(N + 9) % 16], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, L2 = a2[(N + 1) % 16], M = A5[(N + 1) % 16], m3 = (L2 >>> 1 | M << 31) ^ (L2 >>> 8 | M << 24) ^ L2 >>> 7, E2 = (M >>> 1 | L2 << 31) ^ (M >>> 8 | L2 << 24) ^ (M >>> 7 | L2 << 25), C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, L2 = a2[(N + 14) % 16], M = A5[(N + 14) % 16], m3 = (L2 >>> 19 | M << 13) ^ (M >>> 29 | L2 << 3) ^ L2 >>> 6, E2 = (M >>> 19 | L2 << 13) ^ (L2 >>> 29 | M << 3) ^ (M >>> 6 | L2 << 26), C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, a2[N] = v & 65535 | S2 << 16, A5[N] = C3 & 65535 | B2 << 16;
        m3 = z2, E2 = $2, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = n14[0], E2 = o12[0], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, n14[0] = z2 = v & 65535 | S2 << 16, o12[0] = $2 = C3 & 65535 | B2 << 16, m3 = G, E2 = nt, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = n14[1], E2 = o12[1], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, n14[1] = G = v & 65535 | S2 << 16, o12[1] = nt = C3 & 65535 | B2 << 16, m3 = X, E2 = it, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = n14[2], E2 = o12[2], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, n14[2] = X = v & 65535 | S2 << 16, o12[2] = it = C3 & 65535 | B2 << 16, m3 = V, E2 = Et, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = n14[3], E2 = o12[3], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, n14[3] = V = v & 65535 | S2 << 16, o12[3] = Et = C3 & 65535 | B2 << 16, m3 = u4, E2 = lt, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = n14[4], E2 = o12[4], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, n14[4] = u4 = v & 65535 | S2 << 16, o12[4] = lt = C3 & 65535 | B2 << 16, m3 = tt, E2 = wt, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = n14[5], E2 = o12[5], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, n14[5] = tt = v & 65535 | S2 << 16, o12[5] = wt = C3 & 65535 | B2 << 16, m3 = at, E2 = yt, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = n14[6], E2 = o12[6], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, n14[6] = at = v & 65535 | S2 << 16, o12[6] = yt = C3 & 65535 | B2 << 16, m3 = st, E2 = gt, C3 = E2 & 65535, B2 = E2 >>> 16, v = m3 & 65535, S2 = m3 >>> 16, m3 = n14[7], E2 = o12[7], C3 += E2 & 65535, B2 += E2 >>> 16, v += m3 & 65535, S2 += m3 >>> 16, B2 += C3 >>> 16, v += B2 >>> 16, S2 += v >>> 16, n14[7] = st = v & 65535 | S2 << 16, o12[7] = gt = C3 & 65535 | B2 << 16, bt += 128, t14 -= 128;
      }
      return t14;
    }
    function Zt(n14, o12, i4) {
      var t14 = new Int32Array(8), a2 = new Int32Array(8), A5 = new Uint8Array(256), y3, U = i4;
      for (t14[0] = 1779033703, t14[1] = 3144134277, t14[2] = 1013904242, t14[3] = 2773480762, t14[4] = 1359893119, t14[5] = 2600822924, t14[6] = 528734635, t14[7] = 1541459225, a2[0] = 4089235720, a2[1] = 2227873595, a2[2] = 4271175723, a2[3] = 1595750129, a2[4] = 2917565137, a2[5] = 725511199, a2[6] = 4215389547, a2[7] = 327033209, kr(t14, a2, o12, i4), i4 %= 128, y3 = 0; y3 < i4; y3++) A5[y3] = o12[U - i4 + y3];
      for (A5[i4] = 128, i4 = 256 - 128 * (i4 < 112 ? 1 : 0), A5[i4 - 9] = 0, Bt(A5, i4 - 8, U / 536870912 | 0, U << 3), kr(t14, a2, A5, i4), y3 = 0; y3 < 8; y3++) Bt(n14, 8 * y3, t14[y3], a2[y3]);
      return 0;
    }
    function ar(n14, o12) {
      var i4 = h4(), t14 = h4(), a2 = h4(), A5 = h4(), y3 = h4(), U = h4(), T4 = h4(), D3 = h4(), F = h4();
      Ot(i4, n14[1], n14[0]), Ot(F, o12[1], o12[0]), rt(i4, i4, F), Lt(t14, n14[0], n14[1]), Lt(F, o12[0], o12[1]), rt(t14, t14, F), rt(a2, n14[3], o12[3]), rt(a2, a2, ct), rt(A5, n14[2], o12[2]), Lt(A5, A5, A5), Ot(y3, t14, i4), Ot(U, A5, a2), Lt(T4, A5, a2), Lt(D3, t14, i4), rt(n14[0], y3, U), rt(n14[1], D3, T4), rt(n14[2], T4, U), rt(n14[3], y3, D3);
    }
    function sr(n14, o12, i4) {
      var t14;
      for (t14 = 0; t14 < 4; t14++)
        Xt(n14[t14], o12[t14], i4);
    }
    function kt(n14, o12) {
      var i4 = h4(), t14 = h4(), a2 = h4();
      Ur(a2, o12[2]), rt(i4, o12[0], a2), rt(t14, o12[1], a2), $t(n14, t14), n14[31] ^= mt(i4) << 7;
    }
    function cr(n14, o12, i4) {
      var t14, a2;
      for (Yt(n14[0], R), Yt(n14[1], l3), Yt(n14[2], l3), Yt(n14[3], R), a2 = 255; a2 >= 0; --a2)
        t14 = i4[a2 / 8 | 0] >> (a2 & 7) & 1, sr(n14, o12, t14), ar(o12, n14), ar(n14, n14), sr(n14, o12, t14);
    }
    function wr(n14, o12) {
      var i4 = [h4(), h4(), h4(), h4()];
      Yt(i4[0], dt), Yt(i4[1], vt), Yt(i4[2], l3), rt(i4[3], dt, vt), cr(n14, i4, o12);
    }
    function Qt(n14, o12, i4) {
      var t14 = new Uint8Array(64), a2 = [h4(), h4(), h4(), h4()], A5;
      for (i4 || x2(o12, 32), Zt(t14, o12, 32), t14[0] &= 248, t14[31] &= 127, t14[31] |= 64, wr(a2, t14), kt(n14, a2), A5 = 0; A5 < 32; A5++) o12[A5 + 32] = n14[A5];
      return 0;
    }
    var yr = new Float64Array([237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16]);
    function f5(n14, o12) {
      var i4, t14, a2, A5;
      for (t14 = 63; t14 >= 32; --t14) {
        for (i4 = 0, a2 = t14 - 32, A5 = t14 - 12; a2 < A5; ++a2)
          o12[a2] += i4 - 16 * o12[t14] * yr[a2 - (t14 - 32)], i4 = Math.floor((o12[a2] + 128) / 256), o12[a2] -= i4 * 256;
        o12[a2] += i4, o12[t14] = 0;
      }
      for (i4 = 0, a2 = 0; a2 < 32; a2++)
        o12[a2] += i4 - (o12[31] >> 4) * yr[a2], i4 = o12[a2] >> 8, o12[a2] &= 255;
      for (a2 = 0; a2 < 32; a2++) o12[a2] -= i4 * yr[a2];
      for (t14 = 0; t14 < 32; t14++)
        o12[t14 + 1] += o12[t14] >> 8, n14[t14] = o12[t14] & 255;
    }
    function r7(n14) {
      var o12 = new Float64Array(64), i4;
      for (i4 = 0; i4 < 64; i4++) o12[i4] = n14[i4];
      for (i4 = 0; i4 < 64; i4++) n14[i4] = 0;
      f5(n14, o12);
    }
    function e10(n14, o12, i4, t14) {
      var a2 = new Uint8Array(64), A5 = new Uint8Array(64), y3 = new Uint8Array(64), U, T4, D3 = new Float64Array(64), F = [h4(), h4(), h4(), h4()];
      Zt(a2, t14, 32), a2[0] &= 248, a2[31] &= 127, a2[31] |= 64;
      var ot = i4 + 64;
      for (U = 0; U < i4; U++) n14[64 + U] = o12[U];
      for (U = 0; U < 32; U++) n14[32 + U] = a2[32 + U];
      for (Zt(y3, n14.subarray(32), i4 + 32), r7(y3), wr(F, y3), kt(n14, F), U = 32; U < 64; U++) n14[U] = t14[U];
      for (Zt(A5, n14, i4 + 64), r7(A5), U = 0; U < 64; U++) D3[U] = 0;
      for (U = 0; U < 32; U++) D3[U] = y3[U];
      for (U = 0; U < 32; U++)
        for (T4 = 0; T4 < 32; T4++)
          D3[U + T4] += A5[U] * a2[T4];
      return f5(n14.subarray(32), D3), ot;
    }
    function c(n14, o12) {
      var i4 = h4(), t14 = h4(), a2 = h4(), A5 = h4(), y3 = h4(), U = h4(), T4 = h4();
      return Yt(n14[2], l3), It(n14[1], o12), Nt(a2, n14[1]), rt(A5, a2, et), Ot(a2, a2, n14[2]), Lt(A5, n14[2], A5), Nt(y3, A5), Nt(U, y3), rt(T4, U, y3), rt(i4, T4, a2), rt(i4, i4, A5), Jt(i4, i4), rt(i4, i4, a2), rt(i4, i4, A5), rt(i4, i4, A5), rt(n14[0], i4, A5), Nt(t14, n14[0]), rt(t14, t14, A5), Lr(t14, a2) && rt(n14[0], n14[0], At), Nt(t14, n14[0]), rt(t14, t14, A5), Lr(t14, a2) ? -1 : (mt(n14[0]) === o12[31] >> 7 && Ot(n14[0], R, n14[0]), rt(n14[3], n14[0], n14[1]), 0);
    }
    function p4(n14, o12, i4, t14) {
      var a2, A5 = new Uint8Array(32), y3 = new Uint8Array(64), U = [h4(), h4(), h4(), h4()], T4 = [h4(), h4(), h4(), h4()];
      if (i4 < 64 || c(T4, t14)) return -1;
      for (a2 = 0; a2 < i4; a2++) n14[a2] = o12[a2];
      for (a2 = 0; a2 < 32; a2++) n14[a2 + 32] = t14[a2];
      if (Zt(y3, n14, i4), r7(y3), cr(U, T4, y3), wr(T4, o12.subarray(32)), ar(U, T4), kt(A5, U), i4 -= 64, Kt(o12, 0, A5, 0)) {
        for (a2 = 0; a2 < i4; a2++) n14[a2] = 0;
        return -1;
      }
      for (a2 = 0; a2 < i4; a2++) n14[a2] = o12[a2 + 64];
      return i4;
    }
    var g2 = 32, b2 = 24, W3 = 32, ut = 16, ht = 32, pt = 32, ft = 32, vr = 32, Yr = 32, $r = b2, pe = W3, de = ut, qt = 64, hr = 32, gr = 64, Hr = 32, _r = 64;
    s3.lowlevel = {
      crypto_core_hsalsa20: Rt,
      crypto_stream_xor: br,
      crypto_stream: Nr,
      crypto_stream_salsa20_xor: Ht,
      crypto_stream_salsa20: Mt,
      crypto_onetimeauth: Br,
      crypto_onetimeauth_verify: Fr,
      crypto_verify_16: er,
      crypto_verify_32: Kt,
      crypto_secretbox: pr,
      crypto_secretbox_open: dr,
      crypto_scalarmult: tr,
      crypto_scalarmult_base: ir,
      crypto_box_beforenm: fr,
      crypto_box_afternm: Wt,
      crypto_box: zr,
      crypto_box_open: Kr,
      crypto_box_keypair: Or,
      crypto_hash: Zt,
      crypto_sign: e10,
      crypto_sign_keypair: Qt,
      crypto_sign_open: p4,
      crypto_secretbox_KEYBYTES: g2,
      crypto_secretbox_NONCEBYTES: b2,
      crypto_secretbox_ZEROBYTES: W3,
      crypto_secretbox_BOXZEROBYTES: ut,
      crypto_scalarmult_BYTES: ht,
      crypto_scalarmult_SCALARBYTES: pt,
      crypto_box_PUBLICKEYBYTES: ft,
      crypto_box_SECRETKEYBYTES: vr,
      crypto_box_BEFORENMBYTES: Yr,
      crypto_box_NONCEBYTES: $r,
      crypto_box_ZEROBYTES: pe,
      crypto_box_BOXZEROBYTES: de,
      crypto_sign_BYTES: qt,
      crypto_sign_PUBLICKEYBYTES: hr,
      crypto_sign_SECRETKEYBYTES: gr,
      crypto_sign_SEEDBYTES: Hr,
      crypto_hash_BYTES: _r,
      gf: h4,
      D: et,
      L: yr,
      pack25519: $t,
      unpack25519: It,
      M: rt,
      A: Lt,
      S: Nt,
      Z: Ot,
      pow2523: Jt,
      add: ar,
      set25519: Yt,
      modL: f5,
      scalarmult: cr,
      scalarbase: wr
    };
    function te(n14, o12) {
      if (n14.length !== g2) throw new Error("bad key size");
      if (o12.length !== b2) throw new Error("bad nonce size");
    }
    function Ae(n14, o12) {
      if (n14.length !== ft) throw new Error("bad public key size");
      if (o12.length !== vr) throw new Error("bad secret key size");
    }
    function Pt() {
      for (var n14 = 0; n14 < arguments.length; n14++)
        if (!(arguments[n14] instanceof Uint8Array))
          throw new TypeError("unexpected type, use Uint8Array");
    }
    function re(n14) {
      for (var o12 = 0; o12 < n14.length; o12++) n14[o12] = 0;
    }
    s3.randomBytes = function(n14) {
      var o12 = new Uint8Array(n14);
      return x2(o12, n14), o12;
    }, s3.secretbox = function(n14, o12, i4) {
      Pt(n14, o12, i4), te(i4, o12);
      for (var t14 = new Uint8Array(W3 + n14.length), a2 = new Uint8Array(t14.length), A5 = 0; A5 < n14.length; A5++) t14[A5 + W3] = n14[A5];
      return pr(a2, t14, t14.length, o12, i4), a2.subarray(ut);
    }, s3.secretbox.open = function(n14, o12, i4) {
      Pt(n14, o12, i4), te(i4, o12);
      for (var t14 = new Uint8Array(ut + n14.length), a2 = new Uint8Array(t14.length), A5 = 0; A5 < n14.length; A5++) t14[A5 + ut] = n14[A5];
      return t14.length < 32 || dr(a2, t14, t14.length, o12, i4) !== 0 ? null : a2.subarray(W3);
    }, s3.secretbox.keyLength = g2, s3.secretbox.nonceLength = b2, s3.secretbox.overheadLength = ut, s3.scalarMult = function(n14, o12) {
      if (Pt(n14, o12), n14.length !== pt) throw new Error("bad n size");
      if (o12.length !== ht) throw new Error("bad p size");
      var i4 = new Uint8Array(ht);
      return tr(i4, n14, o12), i4;
    }, s3.scalarMult.base = function(n14) {
      if (Pt(n14), n14.length !== pt) throw new Error("bad n size");
      var o12 = new Uint8Array(ht);
      return ir(o12, n14), o12;
    }, s3.scalarMult.scalarLength = pt, s3.scalarMult.groupElementLength = ht, s3.box = function(n14, o12, i4, t14) {
      var a2 = s3.box.before(i4, t14);
      return s3.secretbox(n14, o12, a2);
    }, s3.box.before = function(n14, o12) {
      Pt(n14, o12), Ae(n14, o12);
      var i4 = new Uint8Array(Yr);
      return fr(i4, n14, o12), i4;
    }, s3.box.after = s3.secretbox, s3.box.open = function(n14, o12, i4, t14) {
      var a2 = s3.box.before(i4, t14);
      return s3.secretbox.open(n14, o12, a2);
    }, s3.box.open.after = s3.secretbox.open, s3.box.keyPair = function() {
      var n14 = new Uint8Array(ft), o12 = new Uint8Array(vr);
      return Or(n14, o12), { publicKey: n14, secretKey: o12 };
    }, s3.box.keyPair.fromSecretKey = function(n14) {
      if (Pt(n14), n14.length !== vr)
        throw new Error("bad secret key size");
      var o12 = new Uint8Array(ft);
      return ir(o12, n14), { publicKey: o12, secretKey: new Uint8Array(n14) };
    }, s3.box.publicKeyLength = ft, s3.box.secretKeyLength = vr, s3.box.sharedKeyLength = Yr, s3.box.nonceLength = $r, s3.box.overheadLength = s3.secretbox.overheadLength, s3.sign = function(n14, o12) {
      if (Pt(n14, o12), o12.length !== gr)
        throw new Error("bad secret key size");
      var i4 = new Uint8Array(qt + n14.length);
      return e10(i4, n14, n14.length, o12), i4;
    }, s3.sign.open = function(n14, o12) {
      if (Pt(n14, o12), o12.length !== hr)
        throw new Error("bad public key size");
      var i4 = new Uint8Array(n14.length), t14 = p4(i4, n14, n14.length, o12);
      if (t14 < 0) return null;
      for (var a2 = new Uint8Array(t14), A5 = 0; A5 < a2.length; A5++) a2[A5] = i4[A5];
      return a2;
    }, s3.sign.detached = function(n14, o12) {
      for (var i4 = s3.sign(n14, o12), t14 = new Uint8Array(qt), a2 = 0; a2 < t14.length; a2++) t14[a2] = i4[a2];
      return t14;
    }, s3.sign.detached.verify = function(n14, o12, i4) {
      if (Pt(n14, o12, i4), o12.length !== qt)
        throw new Error("bad signature size");
      if (i4.length !== hr)
        throw new Error("bad public key size");
      var t14 = new Uint8Array(qt + n14.length), a2 = new Uint8Array(qt + n14.length), A5;
      for (A5 = 0; A5 < qt; A5++) t14[A5] = o12[A5];
      for (A5 = 0; A5 < n14.length; A5++) t14[A5 + qt] = n14[A5];
      return p4(a2, t14, t14.length, i4) >= 0;
    }, s3.sign.keyPair = function() {
      var n14 = new Uint8Array(hr), o12 = new Uint8Array(gr);
      return Qt(n14, o12), { publicKey: n14, secretKey: o12 };
    }, s3.sign.keyPair.fromSecretKey = function(n14) {
      if (Pt(n14), n14.length !== gr)
        throw new Error("bad secret key size");
      for (var o12 = new Uint8Array(hr), i4 = 0; i4 < o12.length; i4++) o12[i4] = n14[32 + i4];
      return { publicKey: o12, secretKey: new Uint8Array(n14) };
    }, s3.sign.keyPair.fromSeed = function(n14) {
      if (Pt(n14), n14.length !== Hr)
        throw new Error("bad seed size");
      for (var o12 = new Uint8Array(hr), i4 = new Uint8Array(gr), t14 = 0; t14 < 32; t14++) i4[t14] = n14[t14];
      return Qt(o12, i4, true), { publicKey: o12, secretKey: i4 };
    }, s3.sign.publicKeyLength = hr, s3.sign.secretKeyLength = gr, s3.sign.seedLength = Hr, s3.sign.signatureLength = qt, s3.hash = function(n14) {
      Pt(n14);
      var o12 = new Uint8Array(_r);
      return Zt(o12, n14, n14.length), o12;
    }, s3.hash.hashLength = _r, s3.verify = function(n14, o12) {
      return Pt(n14, o12), n14.length === 0 || o12.length === 0 || n14.length !== o12.length ? false : Dt(n14, 0, o12, 0, n14.length) === 0;
    }, s3.setPRNG = function(n14) {
      x2 = n14;
    }, function() {
      var n14 = typeof self < "u" ? self.crypto || self.msCrypto : null;
      if (n14 && n14.getRandomValues) {
        var o12 = 65536;
        s3.setPRNG(function(i4, t14) {
          var a2, A5 = new Uint8Array(t14);
          for (a2 = 0; a2 < t14; a2 += o12)
            n14.getRandomValues(A5.subarray(a2, a2 + Math.min(t14 - a2, o12)));
          for (a2 = 0; a2 < t14; a2++) i4[a2] = A5[a2];
          re(A5);
        });
      } else typeof qe < "u" && (n14 = Xe, n14 && n14.randomBytes && s3.setPRNG(function(i4, t14) {
        var a2, A5 = n14.randomBytes(t14);
        for (a2 = 0; a2 < t14; a2++) i4[a2] = A5[a2];
        re(A5);
      }));
    }();
  })(w.exports ? w.exports : self.nacl = self.nacl || {});
})(xe);
var $e = xe.exports;
var Mr = Se($e);
var tn = Object.defineProperty;
var rn = (w, s3, h4) => s3 in w ? tn(w, s3, { enumerable: true, configurable: true, writable: true, value: h4 }) : w[s3] = h4;
var Wr = (w, s3, h4) => rn(w, typeof s3 != "symbol" ? s3 + "" : s3, h4);
async function en(w, s3) {
  const h4 = w.getReader();
  let x2;
  for (; !(x2 = await h4.read()).done; )
    s3(x2.value);
}
function nn(w) {
  let s3, h4, x2, d8 = false;
  return function(I2) {
    s3 === void 0 ? (s3 = I2, h4 = 0, x2 = -1) : s3 = on2(s3, I2);
    const R = s3.length;
    let l3 = 0;
    for (; h4 < R; ) {
      d8 && (s3[h4] === 10 && (l3 = ++h4), d8 = false);
      let j2 = -1;
      for (; h4 < R && j2 === -1; ++h4)
        switch (s3[h4]) {
          case 58:
            x2 === -1 && (x2 = h4 - l3);
            break;
          case 13:
            d8 = true;
          case 10:
            j2 = h4;
            break;
        }
      if (j2 === -1)
        break;
      w(s3.subarray(l3, j2), x2), l3 = h4, x2 = -1;
    }
    l3 === R ? s3 = void 0 : l3 !== 0 && (s3 = s3.subarray(l3), h4 -= l3);
  };
}
function fn2(w, s3, h4) {
  let x2 = ie();
  const d8 = new TextDecoder();
  return function(I2, R) {
    if (I2.length === 0)
      h4 == null || h4(x2), x2 = ie();
    else if (R > 0) {
      const l3 = d8.decode(I2.subarray(0, R)), j2 = R + (I2[R + 1] === 32 ? 2 : 1), et = d8.decode(I2.subarray(j2));
      switch (l3) {
        case "data":
          x2.data = x2.data ? x2.data + `
` + et : et;
          break;
        case "event":
          x2.event = et;
          break;
        case "id":
          w(x2.id = et);
          break;
        case "retry":
          const ct = parseInt(et, 10);
          isNaN(ct) || s3(x2.retry = ct);
          break;
      }
    }
  };
}
function on2(w, s3) {
  const h4 = new Uint8Array(w.length + s3.length);
  return h4.set(w), h4.set(s3, w.length), h4;
}
function ie() {
  return {
    data: "",
    event: "",
    id: "",
    retry: void 0
  };
}
var an = function(w, s3) {
  var h4 = {};
  for (var x2 in w) Object.prototype.hasOwnProperty.call(w, x2) && s3.indexOf(x2) < 0 && (h4[x2] = w[x2]);
  if (w != null && typeof Object.getOwnPropertySymbols == "function")
    for (var d8 = 0, x2 = Object.getOwnPropertySymbols(w); d8 < x2.length; d8++)
      s3.indexOf(x2[d8]) < 0 && Object.prototype.propertyIsEnumerable.call(w, x2[d8]) && (h4[x2[d8]] = w[x2[d8]]);
  return h4;
};
var Gr = "text/event-stream";
var sn = 1e3;
var fe = "last-event-id";
function cn(w, s3) {
  var { signal: h4, headers: x2, onopen: d8, onmessage: I2, onclose: R, onerror: l3, openWhenHidden: j2, fetch: et } = s3, ct = an(s3, ["signal", "headers", "onopen", "onmessage", "onclose", "onerror", "openWhenHidden", "fetch"]);
  return new Promise((dt, vt) => {
    const At = Object.assign({}, x2);
    At.accept || (At.accept = Gr);
    let Bt;
    function Dt() {
      Bt.abort(), document.hidden || Rt();
    }
    j2 || document.addEventListener("visibilitychange", Dt);
    let er = sn, Kt = 0;
    function nr() {
      document.removeEventListener("visibilitychange", Dt), window.clearTimeout(Kt), Bt.abort();
    }
    h4 == null || h4.addEventListener("abort", () => {
      nr(), dt();
    });
    const lr = et ?? window.fetch, Vt = d8 ?? hn;
    async function Rt() {
      var Ft;
      Bt = new AbortController();
      try {
        const Ht = await lr(w, Object.assign(Object.assign({}, ct), { headers: At, signal: Bt.signal }));
        await Vt(Ht), await en(Ht.body, nn(fn2((Mt) => {
          Mt ? At[fe] = Mt : delete At[fe];
        }, (Mt) => {
          er = Mt;
        }, I2))), R == null || R(), nr(), dt();
      } catch (Ht) {
        if (!Bt.signal.aborted)
          try {
            const Mt = (Ft = l3 == null ? void 0 : l3(Ht)) !== null && Ft !== void 0 ? Ft : er;
            window.clearTimeout(Kt), Kt = window.setTimeout(Rt, Mt);
          } catch (Mt) {
            nr(), vt(Mt);
          }
      }
    }
    Rt();
  });
}
function hn(w) {
  const s3 = w.headers.get("content-type");
  if (!(s3 != null && s3.startsWith(Gr)))
    throw new Error(`Expected content-type to be ${Gr}, Actual: ${s3}`);
}
function un(w, s3) {
  const h4 = new Uint8Array(w.length + s3.length);
  return h4.set(w), h4.set(s3, w.length), h4;
}
function ln(w, s3) {
  if (s3 >= w.length)
    throw new Error("Index is out of buffer");
  const h4 = w.slice(0, s3), x2 = w.slice(s3);
  return [h4, x2];
}
function Zr(w) {
  let s3 = "";
  return w.forEach((h4) => {
    s3 += ("0" + (h4 & 255).toString(16)).slice(-2);
  }), s3;
}
function Qr(w) {
  if (w.length % 2 !== 0)
    throw new Error(`Cannot convert ${w} to bytesArray`);
  const s3 = new Uint8Array(w.length / 2);
  for (let h4 = 0; h4 < w.length; h4 += 2)
    s3[h4 / 2] = parseInt(w.slice(h4, h4 + 2), 16);
  return s3;
}
var Tr = class {
  constructor(s3) {
    Wr(this, "nonceLength", 24), Wr(this, "keyPair"), Wr(this, "sessionId"), this.keyPair = s3 ? this.createKeypairFromString(s3) : this.createKeypair(), this.sessionId = Zr(this.keyPair.publicKey);
  }
  createKeypair() {
    return Mr.box.keyPair();
  }
  createKeypairFromString(s3) {
    return {
      publicKey: Qr(s3.publicKey),
      secretKey: Qr(s3.secretKey)
    };
  }
  createNonce() {
    return Mr.randomBytes(this.nonceLength);
  }
  encrypt(s3, h4) {
    const x2 = new TextEncoder().encode(s3), d8 = this.createNonce(), I2 = Mr.box(x2, d8, h4, this.keyPair.secretKey);
    return un(d8, I2);
  }
  decrypt(s3, h4) {
    const [x2, d8] = ln(s3, this.nonceLength), I2 = Mr.box.open(
      d8,
      x2,
      h4,
      this.keyPair.secretKey
    );
    if (!I2)
      throw new Error(
        `Decryption error: 
 message: ${s3.toString()} 
 sender pubkey: ${h4.toString()} 
 keypair pubkey: ${this.keyPair.publicKey.toString()} 
 keypair secretkey: ${this.keyPair.secretKey.toString()}`
      );
    return new TextDecoder().decode(I2);
  }
  stringifyKeypair() {
    return {
      publicKey: Zr(this.keyPair.publicKey),
      secretKey: Zr(this.keyPair.secretKey)
    };
  }
};
new AbortController();
var xn = "https://bridge.mz.xyz";
var oe = {
  CONNECT: "[MizuWallet SSE Connect]"
};
var Pr = async (w) => {
  const s3 = new URLSearchParams();
  return s3.append("client_id", w.keypair.publicKey.toString()), new Promise(async (h4, x2) => {
    await cn(`${xn}/bridge/events?${s3.toString()}`, {
      openWhenHidden: false,
      onopen(d8) {
        return d8.status === 200 ? (console.info(`${oe.CONNECT} Opened`), Promise.resolve()) : (console.error(`${oe.CONNECT} Failed to open`), Promise.reject());
      },
      onmessage(d8) {
        try {
          if (d8.data && d8.data.startsWith("{")) {
            const I2 = JSON.parse(d8.data);
            if (I2.message) {
              const R = new Tr({
                ...w.keypair
              }), l3 = I2.message, j2 = Qr(l3), et = R.decrypt(
                j2,
                Qr(I2.from.toString())
              ), ct = JSON.parse(et);
              h4(ct);
            }
          }
        } catch (I2) {
          console.error(I2), x2(I2);
        }
      }
    });
  });
};
var Rr = typeof window < "u" && !!(window != null && window.TelegramWebviewProxy);
var ae;
var se;
typeof window < "u" && ((se = (ae = window == null ? void 0 : window.Telegram) == null ? void 0 : ae.WebApp) != null && se.openTelegramLink);
var pn = typeof window < "u" && (window == null ? void 0 : window.parent) != null && window != (window == null ? void 0 : window.parent);
function dn(w, s3, h4) {
  if (s3 || (s3 = function() {
  }), h4 === void 0 && (h4 = ""), console.log("[Telegram.WebView] > postEvent", w, h4), (window == null ? void 0 : window.TelegramWebviewProxy) !== void 0)
    window == null || window.TelegramWebviewProxy.postEvent(w, JSON.stringify(h4)), s3();
  else if (pn)
    try {
      var x2 = "https://web.telegram.org";
      x2 = "*", window == null || window.parent.postMessage(
        JSON.stringify({ eventType: w, eventData: h4 }),
        x2
      ), s3();
    } catch (d8) {
      s3(d8);
    }
  else
    s3({ notAvailable: true });
}
var Dr = function(w) {
  var x2, d8, I2, R;
  if (typeof window < "u" && ((d8 = (x2 = window == null ? void 0 : window.Telegram) == null ? void 0 : x2.WebApp) != null && d8.openTelegramLink)) {
    (R = (I2 = window == null ? void 0 : window.Telegram) == null ? void 0 : I2.WebApp) == null || R.openTelegramLink(w);
    return;
  }
  let s3 = document.createElement("A");
  if (s3.href = w, s3.protocol != "http:" && s3.protocol != "https:")
    throw console.error("[Telegram.WebApp] Url protocol is not supported", w), Error("WebAppTgUrlInvalid");
  if (s3.hostname != "t.me")
    throw console.error("[Telegram.WebApp] Url host is not supported", w), Error("WebAppTgUrlInvalid");
  var h4 = s3.pathname + s3.search;
  dn("web_app_open_tg_link", false, { path_full: h4 });
};
var Er = class _Er {
  static buildAction(s3) {
    return `${s3.prefix}${s3.action}_${s3.params.map((h4) => _Er.actionParamsEncode(h4)).join("_")}`;
  }
  static actionParamsEncode(s3) {
    return encodeURIComponent(s3).replace(/\./g, "%2E").replace(/%/g, "--");
  }
  static actionParamsDecode(s3) {
    return decodeURIComponent(s3.replace(/--/g, "%"));
  }
};
var rr = "mizuwallet-address";
var Cr = "mizuwallet-publickey";
var An = class {
  /**
   *
   * @param args.manifestURL Manifest URL
   */
  constructor(s3) {
    xt(this, "manifestURL");
    xt(this, "miniAppURL");
    if (!s3.manifestURL) throw new Error("manifestURL is required");
    this.manifestURL = s3.manifestURL, this.miniAppURL = ze(s3.network);
  }
  /**
   * Connect
   *
   * Open MizuWallet MiniApp to connect
   * Try to get Address info back
   *
   *
   * @returns
   */
  async connect() {
    var d8, I2, R, l3;
    if (window != null && window.localStorage && ((d8 = window.localStorage) != null && d8.getItem(rr)) && ((I2 = window.localStorage) != null && I2.getItem(Cr)))
      return {
        address: ((R = window.localStorage.getItem(rr)) == null ? void 0 : R.toString()) || "",
        publicKey: ((l3 = window.localStorage.getItem(Cr)) == null ? void 0 : l3.toString()) || ""
      };
    const s3 = new Tr(), h4 = Er.buildAction({
      prefix: "R_",
      action: "miniapp-connect",
      params: [s3.sessionId, this.manifestURL]
    });
    Dr(`${this.miniAppURL}?startapp=${h4}`);
    const x2 = await Pr({
      keypair: s3.stringifyKeypair()
    });
    if (window != null && window.localStorage && d.isValid({
      input: x2 == null ? void 0 : x2.address,
      strict: true
    }))
      return window.localStorage.setItem(rr, x2 == null ? void 0 : x2.address), window.localStorage.setItem(Cr, x2 == null ? void 0 : x2.publicKey), {
        address: x2 == null ? void 0 : x2.address,
        publicKey: x2 == null ? void 0 : x2.publicKey
      };
    throw new Error(`${Sr.CONNECT} Error`);
  }
  disconnect() {
    window != null && window.localStorage.getItem(rr) && (window == null || window.localStorage.removeItem(rr)), window != null && window.localStorage.getItem(Cr) && (window == null || window.localStorage.removeItem(Cr));
  }
  async signAndSubmitTransaction(s3) {
    if (window != null && window.localStorage.getItem(rr)) {
      const h4 = new Tr(), x2 = Er.buildAction({
        prefix: "R_",
        action: "miniapp-transaction",
        params: [h4.sessionId, this.manifestURL, window == null ? void 0 : window.btoa(JSON.stringify(s3))]
      });
      Dr(`${this.miniAppURL}?startapp=${x2}`);
      const d8 = await Pr({
        keypair: h4.stringifyKeypair()
      });
      if (d8.cancel)
        throw new Error("User Canceled");
      return {
        hash: d8.hash
      };
    } else
      throw new Error(`${Sr.TRANSACTION} No address found`);
  }
  async signTransaction(s3) {
    if (window != null && window.localStorage.getItem(rr)) {
      const h4 = new Tr(), x2 = Er.buildAction({
        prefix: "R_",
        action: "miniapp-signtransaction",
        params: [h4.sessionId, this.manifestURL, s3.bcsToHex().toStringWithoutPrefix()]
      });
      Dr(`${this.miniAppURL}?startapp=${x2}`);
      const d8 = await Pr({
        keypair: h4.stringifyKeypair()
      });
      if (d8.cancel)
        throw new Error("User Canceled");
      return {
        signature: d8
      };
    } else
      throw new Error(`${Sr.TRANSACTION} No address found`);
  }
  async signMessage(s3) {
    if (window != null && window.localStorage.getItem(rr)) {
      const h4 = new Tr(), x2 = Er.buildAction({
        prefix: "R_",
        action: "miniapp-signmessage",
        params: [h4.sessionId, this.manifestURL, window == null ? void 0 : window.btoa(JSON.stringify(s3))]
      });
      Dr(`${this.miniAppURL}?startapp=${x2}`);
      const d8 = await Pr({
        keypair: h4.stringifyKeypair()
      });
      if (d8.cancel)
        throw new Error("User Canceled");
      return {
        data: d8
      };
    } else
      throw new Error(`${Sr.TRANSACTION} No address found`);
  }
};
var ur = "application/x-postmate-v1+json";
var wn = 5;
var yn = 0;
var gn = function() {
  return ++yn;
};
var Ut = function() {
  var s3;
  return zt.debug ? (s3 = console).log.apply(s3, arguments) : null;
};
var mn2 = function(s3) {
  var h4 = document.createElement("a");
  h4.href = s3;
  var x2 = h4.protocol.length > 4 ? h4.protocol : window.location.protocol, d8 = h4.host.length ? h4.port === "80" || h4.port === "443" ? h4.hostname : h4.host : window.location.host;
  return h4.origin || x2 + "//" + d8;
};
var En = {
  handshake: 1,
  "handshake-reply": 1,
  call: 1,
  emit: 1,
  reply: 1,
  request: 1
  /**
   * Ensures that a message is safe to interpret
   * @param  {Object} message The postmate message being sent
   * @param  {String|Boolean} allowedOrigin The whitelisted origin or false to skip origin check
   * @return {Boolean}
   */
};
var Xr = function(s3, h4) {
  return !(typeof h4 == "string" && s3.origin !== h4 || !s3.data || typeof s3.data == "object" && !("postmate" in s3.data) || s3.data.type !== ur || !En[s3.data.postmate]);
};
var bn = function(s3, h4) {
  var x2 = typeof s3[h4] == "function" ? s3[h4]() : s3[h4];
  return zt.Promise.resolve(x2);
};
var Bn = function() {
  function w(h4) {
    var x2 = this;
    this.parent = h4.parent, this.frame = h4.frame, this.child = h4.child, this.childOrigin = h4.childOrigin, this.events = {}, Ut("Parent: Registering API"), Ut("Parent: Awaiting messages..."), this.listener = function(d8) {
      if (!Xr(d8, x2.childOrigin)) return false;
      var I2 = ((d8 || {}).data || {}).value || {}, R = I2.data, l3 = I2.name;
      d8.data.postmate === "emit" && (Ut("Parent: Received event emission: " + l3), l3 in x2.events && x2.events[l3].call(x2, R));
    }, this.parent.addEventListener("message", this.listener, false), Ut("Parent: Awaiting event emissions from Child");
  }
  var s3 = w.prototype;
  return s3.get = function(x2) {
    var d8 = this;
    return new zt.Promise(function(I2) {
      var R = gn(), l3 = function j2(et) {
        et.data.uid === R && et.data.postmate === "reply" && (d8.parent.removeEventListener("message", j2, false), I2(et.data.value));
      };
      d8.parent.addEventListener("message", l3, false), d8.child.postMessage({
        postmate: "request",
        type: ur,
        property: x2,
        uid: R
      }, d8.childOrigin);
    });
  }, s3.call = function(x2, d8) {
    this.child.postMessage({
      postmate: "call",
      type: ur,
      property: x2,
      data: d8
    }, this.childOrigin);
  }, s3.on = function(x2, d8) {
    this.events[x2] = d8;
  }, s3.destroy = function() {
    Ut("Parent: Destroying Postmate instance"), window.removeEventListener("message", this.listener, false), this.frame.parentNode.removeChild(this.frame);
  }, w;
}();
var In = function() {
  function w(h4) {
    var x2 = this;
    this.model = h4.model, this.parent = h4.parent, this.parentOrigin = h4.parentOrigin, this.child = h4.child, Ut("Child: Registering API"), Ut("Child: Awaiting messages..."), this.child.addEventListener("message", function(d8) {
      if (Xr(d8, x2.parentOrigin)) {
        Ut("Child: Received request", d8.data);
        var I2 = d8.data, R = I2.property, l3 = I2.uid, j2 = I2.data;
        if (d8.data.postmate === "call") {
          R in x2.model && typeof x2.model[R] == "function" && x2.model[R](j2);
          return;
        }
        bn(x2.model, R).then(function(et) {
          return d8.source.postMessage({
            property: R,
            postmate: "reply",
            type: ur,
            uid: l3,
            value: et
          }, d8.origin);
        });
      }
    });
  }
  var s3 = w.prototype;
  return s3.emit = function(x2, d8) {
    Ut('Child: Emitting Event "' + x2 + '"', d8), this.parent.postMessage({
      postmate: "emit",
      type: ur,
      value: {
        name: x2,
        data: d8
      }
    }, this.parentOrigin);
  }, w;
}();
var zt = function() {
  function w(h4) {
    var x2 = h4.container, d8 = x2 === void 0 ? typeof d8 < "u" ? d8 : document.body : x2, I2 = h4.model, R = h4.url, l3 = h4.name, j2 = h4.classListArray, et = j2 === void 0 ? [] : j2;
    return this.parent = window, this.frame = document.createElement("iframe"), this.frame.name = l3 || "", this.frame.classList.add.apply(this.frame.classList, et), d8.appendChild(this.frame), this.child = this.frame.contentWindow || this.frame.contentDocument.parentWindow, this.model = I2 || {}, this.sendHandshake(R);
  }
  var s3 = w.prototype;
  return s3.sendHandshake = function(x2) {
    var d8 = this, I2 = mn2(x2), R = 0, l3;
    return new w.Promise(function(j2, et) {
      var ct = function At(Bt) {
        return Xr(Bt, I2) ? Bt.data.postmate === "handshake-reply" ? (clearInterval(l3), Ut("Parent: Received handshake reply from Child"), d8.parent.removeEventListener("message", At, false), d8.childOrigin = Bt.origin, Ut("Parent: Saving Child origin", d8.childOrigin), j2(new Bn(d8))) : (Ut("Parent: Invalid handshake reply"), et("Failed handshake")) : false;
      };
      d8.parent.addEventListener("message", ct, false);
      var dt = function() {
        R++, Ut("Parent: Sending handshake attempt " + R, {
          childOrigin: I2
        }), d8.child.postMessage({
          postmate: "handshake",
          type: ur,
          model: d8.model
        }, I2), R === wn && clearInterval(l3);
      }, vt = function() {
        dt(), l3 = setInterval(dt, 500);
      };
      d8.frame.attachEvent ? d8.frame.attachEvent("onload", vt) : d8.frame.onload = vt, Ut("Parent: Loading frame", {
        url: x2
      }), d8.frame.src = x2;
    });
  }, w;
}();
zt.debug = false;
zt.Promise = function() {
  try {
    return window ? window.Promise : Promise;
  } catch {
    return null;
  }
}();
zt.Model = function() {
  function w(h4) {
    return this.child = window, this.model = h4, this.parent = this.child.parent, this.sendHandshakeReply();
  }
  var s3 = w.prototype;
  return s3.sendHandshakeReply = function() {
    var x2 = this;
    return new zt.Promise(function(d8, I2) {
      var R = function l3(j2) {
        if (j2.data.postmate) {
          if (j2.data.postmate === "handshake") {
            Ut("Child: Received handshake from Parent"), x2.child.removeEventListener("message", l3, false), Ut("Child: Sending handshake reply to Parent"), j2.source.postMessage({
              postmate: "handshake-reply",
              type: ur
            }, j2.origin), x2.parentOrigin = j2.origin;
            var et = j2.data.model;
            return et && (Object.keys(et).forEach(function(ct) {
              x2.model[ct] = et[ct];
            }), Ut("Child: Inherited and extended model from Parent")), Ut("Child: Saving Parent origin", x2.parentOrigin), d8(new In(x2));
          }
          return I2("Handshake Reply Failed");
        }
      };
      x2.child.addEventListener("message", R, false);
    });
  }, w;
}();
var Un = "https://mizu.io";
var vn2 = () => {
  const w = document.createElement("style");
  w.innerHTML = `
	  .mizu-wallet-frame {
		position: fixed;
		top: 0;
		left: 0;
		width: 100vw;
		height: 100vh;
		border: none;
		z-index: 999999999;
		inset: 0px;
		color-scheme: light;
	  }
	`, document.head.appendChild(w);
};
var Rn = class {
  /**
   *
   * @param args.manifestURL Manifest URL
   */
  constructor(s3) {
    xt(this, "authCode");
    xt(this, "manifestURL");
    xt(this, "network");
    xt(this, "mizuClient");
    xt(this, "provider");
    xt(this, "origin");
    if (!s3.manifestURL) throw new Error("manifestURL is required");
    this.authCode = "", this.manifestURL = s3.manifestURL, this.network = s3.network, this.mizuClient = s3.mizuClient, this.origin = Un, vn2();
  }
  async connect() {
    const s3 = await new zt({
      container: document.body,
      // Element to inject frame into
      url: `${this.origin}/wallet/checkLogin?network=${this.network}`,
      name: "mizu-wallet-login",
      classListArray: ["mizu-wallet-frame", "mizu-wallet-login-frame"],
      model: {
        manifestURL: this.manifestURL,
        network: this.network,
        appId: this.mizuClient.appId
      }
    });
    return s3.on("close-frame", () => {
      s3.destroy();
    }), new Promise((h4, x2) => {
      s3.on("login", (d8) => {
        this.authCode = d8.code, h4({
          address: d8.address,
          publicKey: ""
        });
      });
    });
  }
  async disconnect() {
    var h4;
    const s3 = await new zt({
      container: document.body,
      // Element to inject frame into
      url: `${this.origin}/wallet/logout?network=${this.network}`,
      name: "mizu-wallet-logout",
      classListArray: ["mizu-wallet-frame", "mizu-wallet-logout-frame"],
      model: {
        manifestURL: this.manifestURL,
        network: this.network,
        appId: this.mizuClient.appId
      }
    });
    s3.on("close-frame", () => {
      s3.destroy();
    }), await ((h4 = this.mizuClient) == null ? void 0 : h4.logout());
  }
  async signAndSubmitTransaction(s3) {
    var h4;
    try {
      const x2 = await ((h4 = this.mizuClient) == null ? void 0 : h4.createOrderWithCode({
        code: this.authCode,
        payload: s3
      }));
      if (!x2) throw new Error("Transaction creation failed");
      const d8 = await new zt({
        container: document.body,
        // Element to inject frame into
        url: `${this.origin}/wallet/checkLogin?redirect_url=${encodeURIComponent("/wallet/transaction")}&network=${this.network}`,
        name: "mizu-wallet-login",
        classListArray: ["mizu-wallet-frame", "mizu-wallet-sign-frame"],
        model: {
          manifestURL: this.manifestURL,
          network: this.network,
          appId: this.mizuClient.appId,
          transactionInfo: {
            orderId: x2,
            payload: s3
          }
        }
      });
      return d8.on("close-frame", () => {
        d8.destroy();
      }), d8.on("cancel", () => {
        throw new Error("User Canceled");
      }), new Promise((I2, R) => {
        d8.on("submitted", (l3) => {
          if (l3.error)
            return R(l3.error);
          I2({
            // hash: data.transactions?.filter((tx: any) => tx.type === 2)?.[0]?.hash || '',
            hash: l3.hash
          });
        });
      });
    } catch (x2) {
      throw console.error(x2), x2;
    }
  }
  async signTransaction(s3) {
    try {
      const h4 = await new zt({
        container: document.body,
        // Element to inject frame into
        url: `${this.origin}/wallet/checkLogin?redirect_url=${encodeURIComponent("/wallet/sign_transaction")}&network=${this.network}`,
        name: "mizu-wallet-login",
        classListArray: ["mizu-wallet-frame", "mizu-wallet-sign-frame"],
        model: {
          manifestURL: this.manifestURL,
          network: this.network,
          appId: this.mizuClient.appId,
          transactionInfo: {
            transaction: s3.bcsToHex().toStringWithoutPrefix()
          }
        }
      });
      return h4.on("close-frame", () => {
        h4.destroy();
      }), h4.on("cancel", () => {
        throw new Error("User Canceled");
      }), new Promise((x2, d8) => {
        h4.on("sign_transaction", (I2) => {
          if (I2.error)
            return d8(I2.error);
          x2({
            ...I2.result
          });
        });
      });
    } catch (h4) {
      throw console.error(h4), h4;
    }
  }
  async signMessage(s3) {
    try {
      const h4 = await new zt({
        container: document.body,
        // Element to inject frame into
        url: `${this.origin}/wallet/checkLogin?redirect_url=${encodeURIComponent("/wallet/sign_message")}&network=${this.network}`,
        name: "mizu-wallet-login",
        classListArray: ["mizu-wallet-frame", "mizu-wallet-sign-frame"],
        model: {
          manifestURL: this.manifestURL,
          network: this.network,
          appId: this.mizuClient.appId,
          messageInfo: {
            message: s3.message,
            nonce: s3.nonce
          }
        }
      });
      return h4.on("close-frame", () => {
        h4.destroy();
      }), h4.on("cancel", () => {
        throw new Error("User Canceled");
      }), new Promise((x2, d8) => {
        h4.on("sign_message", (I2) => {
          if (I2.error)
            return d8(I2.error);
          x2({
            data: I2.result
          });
        });
      });
    } catch (h4) {
      throw console.error(h4), h4;
    }
  }
};
var Fn = class {
  constructor(s3) {
    xt(this, "url", Je);
    xt(this, "version", "1.0.0");
    xt(this, "name", _e);
    xt(this, "icon", We);
    xt(this, "chains", Re);
    xt(this, "accounts", []);
    xt(this, "provider");
    xt(this, "mizuClient");
    xt(this, "telegramMiniAppHelper");
    xt(this, "websiteHelper");
    xt(this, "accountInfo");
    xt(this, "account", async () => this.accountInfo || {
      address: "",
      publicKey: ""
    });
    xt(this, "connect", async () => {
      var s4;
      try {
        if (Rr)
          if (this.telegramMiniAppHelper)
            this.accountInfo = await this.telegramMiniAppHelper.connect();
          else
            throw new Error(`${Sr.CONNECT} Please pass a valid manifestURL`);
        else
          this.accountInfo = await ((s4 = this.websiteHelper) == null ? void 0 : s4.connect());
        return {
          args: {
            ...this.accountInfo
          },
          status: Gt.APPROVED
        };
      } catch {
        return {
          status: Gt.REJECTED
        };
      }
    });
    xt(this, "network", async () => ({
      name: this.provider.network,
      chainId: this.provider.network === "mainnet" ? 1 : 2
    }));
    xt(this, "disconnect", async () => {
      var s4, h4;
      try {
        Rr ? await ((s4 = this.telegramMiniAppHelper) == null ? void 0 : s4.disconnect()) : await ((h4 = this.websiteHelper) == null ? void 0 : h4.disconnect());
      } catch (x2) {
        throw x2;
      }
    });
    xt(this, "signTransaction", async (s4, h4) => {
      var d8, I2;
      console.log(h4);
      let x2 = {};
      if (Rr ? x2 = await ((d8 = this.telegramMiniAppHelper) == null ? void 0 : d8.signTransaction(s4)) : x2 = await ((I2 = this.websiteHelper) == null ? void 0 : I2.signTransaction(s4)), x2.signature) {
        const R = new n2(ue.Buffer.from(x2.signature, "hex"));
        return {
          args: r.deserialize(R),
          status: Gt.APPROVED
        };
      } else
        return {
          status: Gt.REJECTED
        };
    });
    xt(this, "signAndSubmitTransaction", async (s4) => {
      var h4, x2;
      try {
        let d8 = {};
        return Rr ? d8 = await ((h4 = this.telegramMiniAppHelper) == null ? void 0 : h4.signAndSubmitTransaction(s4.payload)) : d8 = await ((x2 = this.websiteHelper) == null ? void 0 : x2.signAndSubmitTransaction(s4.payload)), d8 != null && d8.hash ? {
          args: d8,
          status: Gt.APPROVED
        } : {
          status: Gt.REJECTED
        };
      } catch (d8) {
        throw console.error(d8.message || d8), new ne(qr.InternalError);
      }
    });
    xt(this, "signMessage", async (s4) => {
      var h4, x2;
      try {
        const { message: d8, nonce: I2, ...R } = s4;
        let l3 = {};
        return Rr ? l3 = await ((h4 = this.telegramMiniAppHelper) == null ? void 0 : h4.signMessage({
          message: d8,
          nonce: I2
        })) : l3 = await ((x2 = this.websiteHelper) == null ? void 0 : x2.signMessage({
          message: d8,
          nonce: I2
        })), l3 != null && l3.data ? {
          args: {
            ...l3 == null ? void 0 : l3.data,
            ...R
          },
          status: Gt.APPROVED
        } : {
          status: Gt.REJECTED
        };
      } catch (d8) {
        throw console.error(d8.message || d8), new ne(qr.InternalError);
      }
    });
    xt(this, "onAccountChange", async () => Promise.resolve());
    xt(this, "onNetworkChange", async () => Promise.resolve());
    if (!s3.network) throw new Error("MizuWallet: network is required");
    this.mizuClient = new h3({
      appId: s3.appId || He(s3.network),
      network: s3.network
    }), this.provider = {
      network: s3.network,
      address: ""
    }, s3 != null && s3.manifestURL && (this.telegramMiniAppHelper = new An({
      manifestURL: s3 == null ? void 0 : s3.manifestURL,
      network: s3.network
    })), this.websiteHelper = new Rn({
      manifestURL: s3.manifestURL,
      network: s3.network,
      mizuClient: this.mizuClient
    });
  }
  get features() {
    return {
      "aptos:connect": {
        version: "1.0.0",
        connect: this.connect
      },
      "aptos:network": {
        version: "1.0.0",
        network: this.network
      },
      "aptos:disconnect": {
        version: "1.0.0",
        disconnect: this.disconnect
      },
      "aptos:signTransaction": {
        version: "1.0.0",
        signTransaction: this.signTransaction
      },
      "aptos:signAndSubmitTransaction": {
        version: "1.1.0",
        signAndSubmitTransaction: this.signAndSubmitTransaction
      },
      "aptos:signMessage": {
        version: "1.0.0",
        signMessage: this.signMessage
      },
      "aptos:onAccountChange": {
        version: "1.0.0",
        onAccountChange: this.onAccountChange
      },
      "aptos:onNetworkChange": {
        version: "1.0.0",
        onNetworkChange: this.onNetworkChange
      },
      "aptos:account": {
        version: "1.0.0",
        account: this.account
      }
    };
  }
};

// node_modules/@aptos-labs/wallet-adapter-core/dist/index.mjs
var import_eventemitter33 = __toESM(require_eventemitter3(), 1);
var import_buffer = __toESM(require_buffer(), 1);
var import_tweetnacl5 = __toESM(require_nacl_fast(), 1);
var WALLET_ADAPTER_CORE_VERSION = "4.15.0";
function getSDKWallets(dappConfig) {
  const sdkWallets = [];
  if (typeof window !== "undefined") {
    sdkWallets.push(
      new AptosConnectWallet({
        network: dappConfig == null ? void 0 : dappConfig.network,
        dappId: dappConfig == null ? void 0 : dappConfig.aptosConnectDappId
      })
    );
    if ((dappConfig == null ? void 0 : dappConfig.mizuwallet) && (dappConfig == null ? void 0 : dappConfig.network) && [e.MAINNET, e.TESTNET].includes(dappConfig.network)) {
      sdkWallets.push(
        new Fn({
          network: dappConfig.network,
          manifestURL: dappConfig.mizuwallet.manifestURL,
          appId: dappConfig.mizuwallet.appId
        })
      );
    }
  }
  if ((dappConfig == null ? void 0 : dappConfig.network) === e.MAINNET) {
    sdkWallets.push(new h2());
  } else {
    sdkWallets.push(new W());
  }
  return sdkWallets;
}
var WalletReadyState = ((WalletReadyState2) => {
  WalletReadyState2["Installed"] = "Installed";
  WalletReadyState2["NotDetected"] = "NotDetected";
  WalletReadyState2["Loadable"] = "Loadable";
  WalletReadyState2["Unsupported"] = "Unsupported";
  return WalletReadyState2;
})(WalletReadyState || {});
var NetworkName2 = ((NetworkName22) => {
  NetworkName22["Mainnet"] = "mainnet";
  NetworkName22["Testnet"] = "testnet";
  NetworkName22["Devnet"] = "devnet";
  return NetworkName22;
})(NetworkName2 || {});
var ChainIdToAnsSupportedNetworkMap = {
  "1": "mainnet",
  "2": "testnet"
};
var APTOS_CONNECT_BASE_URL = "https://aptosconnect.app";
var APTOS_CONNECT_ACCOUNT_URL = "https://aptosconnect.app/dashboard/main-account";
var WalletError = class extends Error {
  constructor(message, error) {
    super(message);
    this.error = error;
  }
};
var WalletNotSelectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSelectedError";
  }
};
var WalletNotReadyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotReadyError";
  }
};
var WalletConnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletConnectionError";
  }
};
var WalletDisconnectionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletDisconnectionError";
  }
};
var WalletAccountError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountError";
  }
};
var WalletGetNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletGetNetworkError";
  }
};
var WalletAccountChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletAccountChangeError";
  }
};
var WalletNetworkChangeError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNetworkChangeError";
  }
};
var WalletNotConnectedError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotConnectedError";
  }
};
var WalletSignMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageError";
  }
};
var WalletSignMessageAndVerifyError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignMessageAndVerifyError";
  }
};
var WalletSignAndSubmitMessageError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignAndSubmitMessageError";
  }
};
var WalletSignTransactionError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletSignTransactionError";
  }
};
var WalletNotSupportedMethod = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletNotSupportedMethod";
  }
};
var WalletChangeNetworkError = class extends WalletError {
  constructor() {
    super(...arguments);
    this.name = "WalletChangeNetworkError";
  }
};
function convertNetwork(networkInfo) {
  switch (networkInfo == null ? void 0 : networkInfo.name) {
    case "mainnet":
      return e.MAINNET;
    case "testnet":
      return e.TESTNET;
    case "devnet":
      return e.DEVNET;
    case "local":
      return e.LOCAL;
    default:
      throw new Error("Invalid Aptos network name");
  }
}
function convertV2TransactionPayloadToV1BCSPayload(payload) {
  const deserializer = new bcs_exports.Deserializer(payload.bcsToBytes());
  return aptos_types_exports.TransactionPayload.deserialize(deserializer);
}
function convertV2PayloadToV1JSONPayload(payload) {
  var _a, _b;
  if ("bytecode" in payload) {
    throw new Error("script payload not supported");
  } else if ("multisigAddress" in payload) {
    const stringTypeTags = (_a = payload.typeArguments) == null ? void 0 : _a.map(
      (typeTag) => {
        if (typeTag instanceof t2) {
          return typeTag.toString();
        }
        return typeTag;
      }
    );
    const newPayload = {
      type: "multisig_payload",
      multisig_address: payload.multisigAddress.toString(),
      function: payload.function,
      type_arguments: stringTypeTags || [],
      arguments: payload.functionArguments
    };
    return newPayload;
  } else {
    const stringTypeTags = (_b = payload.typeArguments) == null ? void 0 : _b.map(
      (typeTag) => {
        if (typeTag instanceof t2) {
          return typeTag.toString();
        }
        return typeTag;
      }
    );
    const newPayload = {
      type: "entry_function_payload",
      function: payload.function,
      type_arguments: stringTypeTags || [],
      arguments: payload.functionArguments
    };
    return newPayload;
  }
}
async function generateTransactionPayloadFromV1Input(aptosConfig, inputV1) {
  if ("function" in inputV1) {
    const inputV2 = {
      function: inputV1.function,
      functionArguments: inputV1.arguments,
      typeArguments: inputV1.type_arguments
    };
    return vn({ ...inputV2, aptosConfig });
  }
  throw new Error("Payload type not supported");
}
function isMobile() {
  return /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/i.test(
    navigator.userAgent
  );
}
function isInAppBrowser() {
  const isIphone = /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(
    navigator.userAgent
  );
  const isAndroid = /(Android).*Version\/[\d.]+.*Chrome\/[^\s]+ Mobile/i.test(
    navigator.userAgent
  );
  return isIphone || isAndroid;
}
function isRedirectable() {
  if (typeof navigator === "undefined" || !navigator)
    return false;
  return isMobile() && !isInAppBrowser();
}
function generalizedErrorMessage(error) {
  return typeof error === "object" && "message" in error ? error.message : error;
}
var areBCSArguments = (args) => {
  if (args.length === 0)
    return false;
  return args.every(
    (arg) => arg instanceof B
  );
};
var getAptosConfig = (networkInfo) => {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  if (isAptosNetwork(networkInfo)) {
    return new l2({
      network: convertNetwork(networkInfo)
    });
  }
  return new l2({
    network: e.CUSTOM,
    fullnode: networkInfo.url
  });
};
var isAptosNetwork = (networkInfo) => {
  if (!networkInfo) {
    throw new Error("Undefined network");
  }
  return o3[networkInfo.name] !== void 0;
};
var fetchDevnetChainId = async () => {
  const aptos = new t4();
  return await aptos.getChainId();
};
var LOCAL_STORAGE_ITEM_KEY = "AptosWalletName";
function setLocalStorage(walletName2) {
  localStorage.setItem(LOCAL_STORAGE_ITEM_KEY, walletName2);
}
function removeLocalStorage() {
  localStorage.removeItem(LOCAL_STORAGE_ITEM_KEY);
}
function getLocalStorage() {
  localStorage.getItem(LOCAL_STORAGE_ITEM_KEY);
}
function scopePollingDetectionStrategy(detect) {
  if (typeof window === "undefined" || typeof document === "undefined")
    return;
  const disposers = [];
  function detectAndDispose() {
    const detected = detect();
    if (detected) {
      for (const dispose of disposers) {
        dispose();
      }
    }
  }
  const interval = setInterval(detectAndDispose, 1e3);
  disposers.push(() => clearInterval(interval));
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", detectAndDispose, {
      once: true
    });
    disposers.push(
      () => document.removeEventListener("DOMContentLoaded", detectAndDispose)
    );
  }
  if (document.readyState !== "complete") {
    window.addEventListener("load", detectAndDispose, { once: true });
    disposers.push(() => window.removeEventListener("load", detectAndDispose));
  }
  detectAndDispose();
}
function partitionWallets(wallets2, partitionFunction = isInstalledOrLoadable) {
  const defaultWallets = [];
  const moreWallets = [];
  for (const wallet of wallets2) {
    if (partitionFunction(wallet))
      defaultWallets.push(wallet);
    else
      moreWallets.push(wallet);
  }
  return { defaultWallets, moreWallets };
}
function isInstalledOrLoadable(wallet) {
  return wallet.readyState === "Installed" || wallet.readyState === "Loadable";
}
function isInstallRequired(wallet) {
  const isWalletReady = isInstalledOrLoadable(wallet);
  const isMobile2 = !isWalletReady && isRedirectable();
  return !isMobile2 && !isWalletReady;
}
function truncateAddress(address) {
  if (!address)
    return;
  return `${address.slice(0, 6)}...${address.slice(-5)}`;
}
function isAptosConnectWallet(wallet) {
  if (!wallet.url)
    return false;
  return wallet.url.startsWith(APTOS_CONNECT_BASE_URL);
}
function getAptosConnectWallets(wallets2) {
  const { defaultWallets, moreWallets } = partitionWallets(
    wallets2,
    isAptosConnectWallet
  );
  return { aptosConnectWallets: defaultWallets, otherWallets: moreWallets };
}
function groupAndSortWallets(wallets2, options) {
  const { aptosConnectWallets, otherWallets } = getAptosConnectWallets(wallets2);
  const { defaultWallets, moreWallets } = partitionWallets(otherWallets);
  if (options == null ? void 0 : options.sortAptosConnectWallets) {
    aptosConnectWallets.sort(options.sortAptosConnectWallets);
  }
  if (options == null ? void 0 : options.sortAvailableWallets) {
    defaultWallets.sort(options.sortAvailableWallets);
  }
  if (options == null ? void 0 : options.sortInstallableWallets) {
    moreWallets.sort(options.sortInstallableWallets);
  }
  return {
    aptosConnectWallets,
    availableWallets: defaultWallets,
    installableWallets: moreWallets
  };
}
var WalletCoreV1 = class extends import_eventemitter33.default {
  async connect(wallet) {
    const account = await wallet.connect();
    return account;
  }
  async resolveSignAndSubmitTransaction(payloadData, network, wallet, transactionInput) {
    var _a, _b, _c, _d, _e2, _f, _g, _h;
    if (areBCSArguments(payloadData.functionArguments)) {
      const aptosConfig = getAptosConfig(network);
      const newPayload = await vn({
        ...payloadData,
        aptosConfig
      });
      const oldTransactionPayload2 = convertV2TransactionPayloadToV1BCSPayload(newPayload);
      return await this.signAndSubmitBCSTransaction(
        oldTransactionPayload2,
        wallet,
        {
          max_gas_amount: ((_a = transactionInput.options) == null ? void 0 : _a.maxGasAmount) ? BigInt((_b = transactionInput.options) == null ? void 0 : _b.maxGasAmount) : void 0,
          gas_unit_price: ((_c = transactionInput.options) == null ? void 0 : _c.gasUnitPrice) ? BigInt((_d = transactionInput.options) == null ? void 0 : _d.gasUnitPrice) : void 0
        }
      );
    }
    const oldTransactionPayload = convertV2PayloadToV1JSONPayload(payloadData);
    return await this.signAndSubmitTransaction(oldTransactionPayload, wallet, {
      max_gas_amount: ((_e2 = transactionInput.options) == null ? void 0 : _e2.maxGasAmount) ? BigInt((_f = transactionInput.options) == null ? void 0 : _f.maxGasAmount) : void 0,
      gas_unit_price: ((_g = transactionInput.options) == null ? void 0 : _g.gasUnitPrice) ? BigInt((_h = transactionInput.options) == null ? void 0 : _h.gasUnitPrice) : void 0
    });
  }
  async signAndSubmitTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signAndSubmitTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signAndSubmitBCSTransaction(transaction, wallet, options) {
    if (!("signAndSubmitBCSTransaction" in wallet)) {
      throw new WalletNotSupportedMethod(
        `Submit a BCS Transaction is not supported by ${wallet.name}`
      ).message;
    }
    try {
      const response = await wallet.signAndSubmitBCSTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, wallet, options) {
    try {
      const response = await wallet.signTransaction(
        transaction,
        options
      );
      return response;
    } catch (error) {
      const errMsg = typeof error == "object" && "message" in error ? error.message : error;
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessageAndVerify(message, wallet, account) {
    try {
      const response = await wallet.signMessage(message);
      if (!response)
        throw new WalletSignMessageAndVerifyError("Failed to sign a message").message;
      console.log("signMessageAndVerify signMessage response", response);
      let verified = false;
      if (Array.isArray(response.signature)) {
        const { fullMessage, signature, bitmap } = response;
        if (bitmap) {
          const minKeysRequired = account.minKeysRequired;
          if (signature.length < minKeysRequired) {
            verified = false;
          } else {
            const bits = Array.from(bitmap).flatMap(
              (n14) => Array.from({ length: 8 }).map((_, i4) => n14 >> i4 & 1)
            );
            const index = bits.map((_, i4) => i4).filter((i4) => bits[i4]);
            const publicKeys = account.publicKey;
            const matchedPublicKeys = publicKeys.filter(
              (_, i4) => index.includes(i4)
            );
            verified = true;
            for (let i4 = 0; i4 < signature.length; i4++) {
              const isSigVerified = import_tweetnacl5.default.sign.detached.verify(
                import_buffer.Buffer.from(fullMessage),
                import_buffer.Buffer.from(signature[i4], "hex"),
                import_buffer.Buffer.from(matchedPublicKeys[i4], "hex")
              );
              if (!isSigVerified) {
                verified = false;
                break;
              }
            }
          }
        } else {
          throw new WalletSignMessageAndVerifyError("Failed to get a bitmap").message;
        }
      } else {
        const currentAccountPublicKey = new HexString(
          account.publicKey
        );
        const signature = new HexString(
          response.signature
        );
        verified = import_tweetnacl5.default.sign.detached.verify(
          import_buffer.Buffer.from(response.fullMessage),
          import_buffer.Buffer.from(signature.noPrefix(), "hex"),
          import_buffer.Buffer.from(currentAccountPublicKey.noPrefix(), "hex")
        );
      }
      return verified;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
var WalletStandardCore = class {
  async connect(wallet) {
    const response = await wallet.connect();
    if (response.status === r4.REJECTED) {
      throw new WalletConnectionError("User has rejected the request").message;
    }
    return response.args;
  }
  async signAndSubmitTransaction(transactionInput, aptos, account, wallet, standardWallets) {
    var _a, _b, _c;
    try {
      const standardWallet = standardWallets.find(
        (standardWallet2) => wallet.name === standardWallet2.name
      );
      if (((_a = standardWallet == null ? void 0 : standardWallet.features["aptos:signAndSubmitTransaction"]) == null ? void 0 : _a.version) !== "1.1.0") {
        const transaction2 = await aptos.transaction.build.simple({
          sender: account.address.toString(),
          data: transactionInput.data,
          options: transactionInput.options
        });
        const response2 = await wallet.signAndSubmitTransaction(
          transaction2
        );
        if (response2.status === r4.REJECTED) {
          throw new WalletConnectionError("User has rejected the request").message;
        }
        return response2.args;
      }
      const transaction = {
        gasUnitPrice: (_b = transactionInput.options) == null ? void 0 : _b.gasUnitPrice,
        maxGasAmount: (_c = transactionInput.options) == null ? void 0 : _c.maxGasAmount,
        payload: transactionInput.data
      };
      const response = await wallet.signAndSubmitTransaction(
        transaction
      );
      if (response.status === r4.REJECTED) {
        throw new WalletConnectionError("User has rejected the request").message;
      }
      return response.args;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transaction, wallet, asFeePayer) {
    const response = await wallet.signTransaction(
      transaction,
      asFeePayer
    );
    if (response.status === r4.REJECTED) {
      throw new WalletConnectionError("User has rejected the request").message;
    }
    return response.args;
  }
  async signMessage(message, wallet) {
    try {
      const response = await wallet.signMessage(
        message
      );
      if (response.status === r4.REJECTED) {
        throw new WalletConnectionError("User has rejected the request").message;
      }
      return response.args;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async signMessageAndVerify(message, wallet) {
    try {
      const response = await wallet.signMessage(
        message
      );
      const account = await wallet.account();
      if (response.status === r4.REJECTED) {
        throw new WalletConnectionError("Failed to sign a message").message;
      }
      if (account.publicKey instanceof f && account.publicKey.variant === x.Keyless) {
        return true;
      }
      let verified = false;
      if (response.args.signature instanceof y) {
        if (!(account.publicKey instanceof d2)) {
          throw new WalletSignMessageAndVerifyError(
            "Public key and Signature type mismatch"
          ).message;
        }
        const { fullMessage, signature } = response.args;
        const bitmap = signature.bitmap;
        if (bitmap) {
          const minKeysRequired = account.publicKey.threshold;
          if (signature.signatures.length < minKeysRequired) {
            verified = false;
          } else {
            verified = account.publicKey.verifySignature({
              message: new TextEncoder().encode(fullMessage),
              signature
            });
          }
        }
      } else {
        verified = account.publicKey.verifySignature({
          message: new TextEncoder().encode(response.args.fullMessage),
          signature: response.args.signature
        });
      }
      return verified;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
var GA4 = class {
  constructor() {
    this.aptosGAID = true;
    this.injectGA(this.aptosGAID);
  }
  gtag(a2, b2, c) {
    let dataLayer = window.dataLayer || [];
    dataLayer.push(arguments);
  }
  injectGA(gaID) {
    if (typeof window === "undefined")
      return;
    if (!gaID)
      return;
    const head = document.getElementsByTagName("head")[0];
    var myScript = document.createElement("script");
    myScript.setAttribute(
      "src",
      `https://www.googletagmanager.com/gtag/js?id=${gaID}`
    );
    const that = this;
    myScript.onload = function() {
      that.gtag("js", /* @__PURE__ */ new Date());
      that.gtag("config", `${gaID}`, {
        send_page_view: false
      });
    };
    head.insertBefore(myScript, head.children[1]);
  }
};
var aptosStandardSupportedWalletList = [
  {
    name: "Nightly",
    url: "https://chromewebstore.google.com/detail/nightly/fiikommddbeccaoicoejoniammnalkfa?hl=en",
    icon: "data:image/svg+xml;base64,PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0idXRmLTgiPz4NCjwhLS0gR2VuZXJhdG9yOiBBZG9iZSBJbGx1c3RyYXRvciAyOC4wLjAsIFNWRyBFeHBvcnQgUGx1Zy1JbiAuIFNWRyBWZXJzaW9uOiA2LjAwIEJ1aWxkIDApICAtLT4NCjxzdmcgdmVyc2lvbj0iMS4xIiBpZD0iV2Fyc3R3YV8xIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rIiB4PSIwcHgiIHk9IjBweCINCgkgdmlld0JveD0iMCAwIDg1MS41IDg1MS41IiBzdHlsZT0iZW5hYmxlLWJhY2tncm91bmQ6bmV3IDAgMCA4NTEuNSA4NTEuNTsiIHhtbDpzcGFjZT0icHJlc2VydmUiPg0KPHN0eWxlIHR5cGU9InRleHQvY3NzIj4NCgkuc3Qwe2ZpbGw6IzYwNjdGOTt9DQoJLnN0MXtmaWxsOiNGN0Y3Rjc7fQ0KPC9zdHlsZT4NCjxnPg0KCTxnIGlkPSJXYXJzdHdhXzJfMDAwMDAwMTQ2MDk2NTQyNTMxODA5NDY0NjAwMDAwMDg2NDc4NTIwMDIxMTY5MTg2ODhfIj4NCgkJPHBhdGggY2xhc3M9InN0MCIgZD0iTTEyNCwwaDYwMy42YzY4LjUsMCwxMjQsNTUuNSwxMjQsMTI0djYwMy42YzAsNjguNS01NS41LDEyNC0xMjQsMTI0SDEyNGMtNjguNSwwLTEyNC01NS41LTEyNC0xMjRWMTI0DQoJCQlDMCw1NS41LDU1LjUsMCwxMjQsMHoiLz4NCgk8L2c+DQoJPGcgaWQ9IldhcnN0d2FfMyI+DQoJCTxwYXRoIGNsYXNzPSJzdDEiIGQ9Ik02MjMuNSwxNzAuM2MtMzcuNCw1Mi4yLTg0LjIsODguNC0xMzkuNSwxMTIuNmMtMTkuMi01LjMtMzguOS04LTU4LjMtNy44Yy0xOS40LTAuMi0zOS4xLDIuNi01OC4zLDcuOA0KCQkJYy01NS4zLTI0LjMtMTAyLjEtNjAuMy0xMzkuNS0xMTIuNmMtMTEuMywyOC40LTU0LjgsMTI2LjQtMi42LDI2My40YzAsMC0xNi43LDcxLjUsMTQsMTMyLjljMCwwLDQ0LjQtMjAuMSw3OS43LDguMg0KCQkJYzM2LjksMjkuOSwyNS4xLDU4LjcsNTEuMSw4My41YzIyLjQsMjIuOSw1NS43LDIyLjksNTUuNywyMi45czMzLjMsMCw1NS43LTIyLjhjMjYtMjQuNywxNC4zLTUzLjUsNTEuMS04My41DQoJCQljMzUuMi0yOC4zLDc5LjctOC4yLDc5LjctOC4yYzMwLjYtNjEuNCwxNC0xMzIuOSwxNC0xMzIuOUM2NzguMywyOTYuNyw2MzQuOSwxOTguNyw2MjMuNSwxNzAuM3ogTTI1My4xLDQxNC44DQoJCQljLTI4LjQtNTguMy0zNi4yLTEzOC4zLTE4LjMtMjAxLjVjMjMuNyw2MCw1NS45LDg2LjksOTQuMiwxMTUuM0MzMTIuOCwzNjIuMywyODIuMywzOTQuMSwyNTMuMSw0MTQuOHogTTMzNC44LDUxNy41DQoJCQljLTIyLjQtOS45LTI3LjEtMjkuNC0yNy4xLTI5LjRjMzAuNS0xOS4yLDc1LjQtNC41LDc2LjgsNDAuOUMzNjAuOSw1MTQuNywzNTMsNTI1LjQsMzM0LjgsNTE3LjV6IE00MjUuNyw2NzguNw0KCQkJYy0xNiwwLTI5LTExLjUtMjktMjUuNnMxMy0yNS42LDI5LTI1LjZzMjksMTEuNSwyOSwyNS42QzQ1NC43LDY2Ny4zLDQ0MS43LDY3OC43LDQyNS43LDY3OC43eiBNNTE2LjcsNTE3LjUNCgkJCWMtMTguMiw4LTI2LTIuOC00OS43LDExLjVjMS41LTQ1LjQsNDYuMi02MC4xLDc2LjgtNDAuOUM1NDMuOCw0ODgsNTM5LDUwNy42LDUxNi43LDUxNy41eiBNNTk4LjMsNDE0LjgNCgkJCWMtMjkuMS0yMC43LTU5LjctNTIuNC03Ni04Ni4yYzM4LjMtMjguNCw3MC42LTU1LjQsOTQuMi0xMTUuM0M2MzQuNiwyNzYuNSw2MjYuOCwzNTYuNiw1OTguMyw0MTQuOHoiLz4NCgk8L2c+DQo8L2c+DQo8L3N2Zz4NCg==",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Petra",
    url: "https://chromewebstore.google.com/detail/petra-aptos-wallet/ejjladinnckdgjemekebdpeokbikhfci?hl=en",
    icon: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAYAAADDPmHLAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAWbSURBVHgB7Z09c9NYFIaPlFSpUqQNK6rQhbSkWJghLZP9BesxfwAqytg1xe7+AY+3go5ACzObBkpwSqrVQkuRCiqkva8UZW1je22wpHPveZ8ZRU6wwwznueee+6FLJCuSdzrb7nZTNjaOJc9/ctdNiaJESPPkeeq+phLH5/L162k0HJ7JikTLvtEFPnFBf+D+0l/dt9tCNJK6xnjmZOg7GdJlPvC/AhQtPo5P3MsHQvwhiobLiLBQABf82y74z4Qt3ldSybKHToLTeW+I5/1B3u2euOD/JQy+zyRowEUs5zAzA1x+oCckJHrRYNCf/uE3AjD4QfONBBMC5PfvY2j3TEi4ZNmd8eHilQDFMK/s8xMhIXPhJLjuJLjAN/8VgRsbPWHwLbAtm5tXRWGRAS5b/99C7FBmgbTMAGXrJ5aIomJir8wA3S5afyLEEkUtEBezfQy+RYpFvdilgmMhNnGxRw2wL8QqScy1fMNE0T4yQCLEKkksxDQUwDj2BNjbK69pdndn/zxwNsUCCOyNGyJ374psbYkMBiLv30++59o1kW5X5NMnkdFI5OXL8nXghCsAAn10NL/Fz2NnpxQFFyR5/bq8BypDWAIg6AcHIoeH60nn4/K8e1deECIgwhAAQULQEXxIUAf43bju3ZvMDJ7jrwDT/XpToIvABeECqBf8EuB7+/W6CKBe0C/Auvv1uvC0XtArQBP9el14VC/oEqCtfr0uPKgX2hdAW79eF0rrhfYFQPCRKi1RyY4ZyZYF4GKQcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcSiAcShAm3z+LG1DAdqEAhjn40dpGwrQFtgIwgxgGAWtH1CAtsC2cQVQgLZQsk2cArSBoqeHKEAbKHpiiAI0DVq+kv4fUICmQetXMPyroABNgtb/5o1oggI0icJzBChAUyDwr16JNihAUzx+LBqhAE3w5InaU0MoQN08f64y9VdQgDrBkO/FC9EMBagLBB/P/yvHxlGxTYPh3tOn4gMUYN2g4FPc509DAdYFqvxZh1ArhwKsg6rSVzTHvywU4EeoqnyPTxKnAKuCVo4iD4s6ARwhTwGWoTrk8e3bIE4IH4cCVCDI1U6dL1/K73Eh4B727ctCASoQ6MBa9zJwJtA4FMA4FMA4FMA4FMA4FMA4FMA4FMA47Qtg4P/n1Uz7AgQ8zeoD7Qug5KQMq+joApgFWkNHEWhwEUYLFMA4OgRQdGCCNXQIUG28II2jZyKIWaAV9Aig7OgUK+gRAMH36ImaUNC1FoDt1swCjaJLAAQfT9mQxtC3GohugCOCxtC5HIyHLNkVNIJOATAv4Mnz9b6jd0MIhoWsB2pH944gPHmLkQGpDf1bwtAVUILa8GNPICRgd1AL/mwKRXfA0cHa8WtXMArDfp8bSdeIf9vCEfxHj8psQBF+GH/PB0A2wIzhrVsih4ciOztCVsfvAyKQAVAbYPr44EDk6Ehkd1fI8oRxQggKQ2QEXMgEe3ulELhvbQmZT3hHxFRn+1Tn/UAAZAWIUXUTHz4IKQn/jCBkB6Pn/ywDHw41DgUwDgRIhVgljSWKzoXYJM+dAFmWCrHKeewsOBViExd71AAjd10IsUYaDYdnsfty4Uz4U4g1zvClHAbm+e9CbJFlfdwKAVwWSJ0EfwixwrCIuYxPBOV5T1gLWCCtWj+4EqCoBbLsFyFhk2UPq9YPJqaCURW6W19IqPRdjCeG/dGsd+Xdbs/dToSERD8aDHrTP4zmvZsSBMXM4INo0afyTudY4vg39zIR4iNFXXfZtc9k4XJw0V9k2R1OFHkIhvVZdn1R8MHCDDDx+zqdxK0c9tz1szAjaKWc1XUTe+OV/iKWFmAcJ8NtJ8Kxe7kvkCGKEiHN45Zz3b/9yN3/uVzUGxXD+RX4F56985hsqA6SAAAAAElFTkSuQmCC",
    readyState: "NotDetected",
    isAIP62Standard: true
  },
  {
    name: "Pontem Wallet",
    url: "https://pontem.network/pontem-wallet",
    icon: "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzYiIGhlaWdodD0iMzYiIHZpZXdCb3g9IjAgMCAzNiAzNiIgZmlsbD0ibm9uZSIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj4KPHBhdGggZD0iTTE4IDBDOC4wNzMwNCAwIDAgOC4wNzEzOSAwIDE3Ljk5NjNDMCAyNS4xMjk4IDQuMTczMTYgMzEuMzEwOCAxMC4yMDc2IDM0LjIyMDNWMzQuMjM1MUgxMC4yMzcyQzEyLjU4NiAzNS4zNjQ5IDE1LjIyMjggMzYgMTggMzZDMjcuOTI3IDM2IDM2IDI3LjkyODYgMzYgMTguMDAzN0MzNiA4LjA3MTM4IDI3LjkyNyAwIDE4IDBaTTE4IDEuNDc2OTJDMjcuMTA3MSAxLjQ3NjkyIDM0LjUyMjggOC44OTEwOCAzNC41MjI4IDE3Ljk5NjNDMzQuNTIyOCAyMC42MTA1IDMzLjkwOTcgMjMuMDkxNyAzMi44MjQgMjUuMjkyM0MzMC40NDU2IDI0LjE0MDMgMjguMDMwNCAyMy4yODM3IDI1LjU5MjkgMjIuNzAwM1Y4LjkyMDYyQzI1LjU5MjkgOC40NDA2MiAyNS4yMTYyIDguMDU2NjIgMjQuNzQzNSA4LjA1NjYySDIxLjcxNTJIMTQuMDg1NEgxMS4wNTdDMTAuNTkxNyA4LjA1NjYyIDEwLjIwNzYgOC40NDA2MiAxMC4yMDc2IDguOTIwNjJWMjIuNzY2OEM3Ljg0NDA3IDIzLjM1MDIgNS40OTUyOCAyNC4xOTIgMy4xODM0MiAyNS4yOTk3QzIuMDkwMjcgMjMuMDkxNyAxLjQ3NzIzIDIwLjYxNzggMS40NzcyMyAxNy45OTYzQzEuNDc3MjMgOC44OTEwOCA4Ljg5MjkgMS40NzY5MiAxOCAxLjQ3NjkyWk00LjEzNjIzIDI2Ljk2MTJDNi4wOTM1NiAyNS45OTM4IDguMTI0NzQgMjUuMjQ4IDEwLjIxNSAyNC43MzExVjMyLjU1ODhDNy43NDA2NiAzMS4yMzY5IDUuNjUwMzkgMjkuMzAyMiA0LjEzNjIzIDI2Ljk2MTJaTTE0LjA4NTQgMzQuMDQzMVYxNS42MDM3QzE0LjA4NTQgMTMuNDY5NSAxNS44MzU5IDExLjcwNDYgMTcuOTI2MSAxMS43MDQ2QzIwLjAxNjQgMTEuNzA0NiAyMS43MTUyIDEzLjQzMjYgMjEuNzE1MiAxNS41NTk0QzIxLjcxNTIgMTUuNTc0MiAyMS43MDc4IDE1LjU4ODkgMjEuNzA3OCAxNS42MDM3SDIxLjcxNTJWMjIuMDIwOUMxOS45MzUyIDIxLjgxNDIgMTguMTQ3NyAyMS43NDc3IDE2LjM2MDMgMjEuODQzN0wxNC44OTA0IDIzLjk3NzhDMTcuMTgwMSAyMy43ODU4IDE5LjQxMDcgMjMuODAwNiAyMS42MTE4IDI0LjA1MTdDMjEuNjM0IDI0LjA1MTcgMjEuNjQ4NyAyNC4wNTE3IDIxLjY3MDkgMjQuMDU5MUMyMS42ODU3IDI0LjA1OTEgMjEuNzAwNSAyNC4wNTkxIDIxLjcyMjYgMjQuMDY2NUMyMi4xMDY3IDI0LjExMDggMjMuNTAyNyAyNC4yODggMjQuNzgwNSAyNC42MDU1TDIxLjcyMjYgMjUuNjQ2OFYzNC4xMDIyQzIwLjUyNjEgMzQuMzc1NCAxOS4yODUyIDM0LjUzMDUgMTguMDE0OCAzNC41MzA1QzE2LjY0ODMgMzQuNTE1NyAxNS4zNDEgMzQuMzQ1OCAxNC4wODU0IDM0LjA0MzFaTTI1LjU4NTYgMzIuNjYyMlYyNC43NjhDMjcuNjY4NCAyNS4yOTIzIDI5LjcyOTIgMjYuMDYwMyAzMS43OTczIDI3LjA2NDZDMzAuMjQ2MiAyOS40MjAzIDI4LjEwNDIgMzEuMzU1MSAyNS41ODU2IDMyLjY2MjJaIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfMjIyXzE2NzApIi8+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfMjIyXzE2NzAiIHgxPSIxNy45OTk3IiB5MT0iMzYuNzc4OSIgeDI9IjE3Ljk5OTciIHkyPSItNS41MTk3OCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBvZmZzZXQ9IjAuMDg1OCIgc3RvcC1jb2xvcj0iIzhEMjlDMSIvPgo8c3RvcCBvZmZzZXQ9IjAuMjM4MyIgc3RvcC1jb2xvcj0iIzk0MkJCQiIvPgo8c3RvcCBvZmZzZXQ9IjAuNDY2NyIgc3RvcC1jb2xvcj0iI0E5MkZBQyIvPgo8c3RvcCBvZmZzZXQ9IjAuNzQxMyIgc3RvcC1jb2xvcj0iI0NBMzc5MyIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGMDNGNzciLz4KPC9saW5lYXJHcmFkaWVudD4KPC9kZWZzPgo8L3N2Zz4K",
    readyState: "NotDetected",
    isAIP62Standard: true
  }
];
var WalletCore = class extends import_eventemitter32.default {
  constructor(plugins, optInWallets, dappConfig, disableTelemetry) {
    super();
    this._wallets = [];
    this._optInWallets = [];
    this._standard_wallets = [];
    this._all_wallets = [];
    this._wallet = null;
    this._account = null;
    this._network = null;
    this.walletCoreV1 = new WalletCoreV1();
    this.walletStandardCore = new WalletStandardCore();
    this._connecting = false;
    this._connected = false;
    this.ga4 = null;
    this._disableTelemetry = false;
    this.standardizeStandardWalletToPluginWalletType = (standardWallet) => {
      var _a, _b, _c;
      let standardWalletConvertedToWallet = {
        name: standardWallet.name,
        url: standardWallet.url,
        icon: standardWallet.icon,
        provider: standardWallet,
        connect: standardWallet.features["aptos:connect"].connect,
        disconnect: standardWallet.features["aptos:disconnect"].disconnect,
        network: standardWallet.features["aptos:network"].network,
        account: standardWallet.features["aptos:account"].account,
        signAndSubmitTransaction: (_a = standardWallet.features["aptos:signAndSubmitTransaction"]) == null ? void 0 : _a.signAndSubmitTransaction,
        signMessage: standardWallet.features["aptos:signMessage"].signMessage,
        onAccountChange: standardWallet.features["aptos:onAccountChange"].onAccountChange,
        onNetworkChange: standardWallet.features["aptos:onNetworkChange"].onNetworkChange,
        signTransaction: standardWallet.features["aptos:signTransaction"].signTransaction,
        openInMobileApp: (_b = standardWallet.features["aptos:openInMobileApp"]) == null ? void 0 : _b.openInMobileApp,
        changeNetwork: (_c = standardWallet.features["aptos:changeNetwork"]) == null ? void 0 : _c.changeNetwork,
        readyState: "Installed",
        isAIP62Standard: true
      };
      this._all_wallets = this._all_wallets.filter(
        (item) => item.name !== standardWalletConvertedToWallet.name
      );
      this._all_wallets.push(standardWalletConvertedToWallet);
      this.emit("standardWalletsAdded", standardWalletConvertedToWallet);
    };
    this._wallets = plugins;
    this._optInWallets = optInWallets;
    this._dappConfig = dappConfig;
    this._disableTelemetry = disableTelemetry;
    this._sdkWallets = getSDKWallets(this._dappConfig);
    if (!this._disableTelemetry) {
      this.ga4 = new GA4();
    }
    this.fetchExtensionAIP62AptosWallets();
    this.fetchSDKAIP62AptosWallets();
    this.scopePollingDetectionStrategy();
    this.appendNotDetectedStandardSupportedWallets();
  }
  scopePollingDetectionStrategy() {
    var _a;
    (_a = this._wallets) == null ? void 0 : _a.forEach((wallet) => {
      const existingStandardPontemWallet = this._standard_wallets.find(
        (wallet2) => wallet2.name == "Pontem Wallet"
      );
      if (wallet.name === "Pontem" && existingStandardPontemWallet) {
        return;
      }
      const existingWalletIndex = this._standard_wallets.findIndex(
        (standardWallet) => standardWallet.name == wallet.name
      );
      if (existingWalletIndex !== -1)
        return;
      this._all_wallets.push(wallet);
      if (!wallet.readyState) {
        wallet.readyState = typeof window === "undefined" || typeof document === "undefined" ? "Unsupported" : "NotDetected";
      }
      if (typeof window !== "undefined") {
        scopePollingDetectionStrategy(() => {
          const providerName = wallet.providerName || wallet.name.toLowerCase();
          if (Object.keys(window).includes(providerName)) {
            wallet.readyState = "Installed";
            wallet.provider = window[providerName];
            this.emit("readyStateChange", wallet);
            return true;
          }
          return false;
        });
      }
    });
  }
  fetchExtensionAIP62AptosWallets() {
    let { aptosWallets, on: on3 } = d4();
    this.setExtensionAIP62Wallets(aptosWallets);
    if (typeof window === "undefined")
      return;
    const that = this;
    const removeRegisterListener = on3("register", function() {
      let { aptosWallets: aptosWallets2 } = d4();
      that.setExtensionAIP62Wallets(aptosWallets2);
    });
    const removeUnregisterListener = on3("unregister", function() {
      let { aptosWallets: aptosWallets2 } = d4();
      that.setExtensionAIP62Wallets(aptosWallets2);
    });
  }
  appendNotDetectedStandardSupportedWallets() {
    aptosStandardSupportedWalletList.map((supportedWallet) => {
      const existingPluginWalletIndex = this.wallets.findIndex(
        (wallet) => wallet.name === supportedWallet.name
      );
      if (existingPluginWalletIndex !== -1)
        return;
      const existingStandardPontemWallet = this.wallets.find(
        (wallet) => wallet.name == "Pontem"
      );
      if (supportedWallet.name === "Pontem Wallet" && existingStandardPontemWallet) {
        return;
      }
      const existingStandardWallet = this._standard_wallets.find(
        (wallet) => wallet.name == supportedWallet.name
      );
      if (existingStandardWallet && this.excludeWallet(existingStandardWallet)) {
        return;
      }
      if (!existingStandardWallet) {
        this._all_wallets.push(supportedWallet);
        this.emit("standardWalletsAdded", supportedWallet);
      }
    });
  }
  fetchSDKAIP62AptosWallets() {
    this._sdkWallets.map((wallet) => {
      this.standardizeAIP62WalletType(wallet);
    });
  }
  setExtensionAIP62Wallets(extensionwWallets) {
    const wallets2 = extensionwWallets.filter(
      (wallet) => wallet.name !== "Dev T wallet" && wallet.name !== "T wallet"
    );
    wallets2.map((wallet) => {
      this.standardizeAIP62WalletType(wallet);
      this._standard_wallets.push(wallet);
    });
  }
  excludeWallet(wallet) {
    if (this._optInWallets.length > 0 && !this._optInWallets.includes(wallet.name)) {
      return true;
    }
    return false;
  }
  standardizeAIP62WalletType(wallet) {
    if (this.excludeWallet(wallet)) {
      return;
    }
    const isValid = i2(wallet);
    if (isValid) {
      wallet.readyState = "Installed";
      this.standardizeStandardWalletToPluginWalletType(wallet);
      this._standard_wallets.push(wallet);
    }
  }
  recordEvent(eventName, additionalInfo) {
    var _a, _b, _c, _d;
    (_d = this.ga4) == null ? void 0 : _d.gtag("event", `wallet_adapter_${eventName}`, {
      wallet: (_a = this._wallet) == null ? void 0 : _a.name,
      network: (_b = this._network) == null ? void 0 : _b.name,
      network_url: (_c = this._network) == null ? void 0 : _c.url,
      adapter_core_version: WALLET_ADAPTER_CORE_VERSION,
      send_to: true,
      ...additionalInfo
    });
  }
  ensureWalletExists(wallet) {
    if (!wallet) {
      throw new WalletNotConnectedError().name;
    }
    if (!(wallet.readyState === "Loadable" || wallet.readyState === "Installed"))
      throw new WalletNotReadyError("Wallet is not set").name;
  }
  ensureAccountExists(account) {
    if (!account) {
      throw new WalletAccountError("Account is not set").name;
    }
  }
  doesWalletExist() {
    if (!this._connected || this._connecting || !this._wallet)
      throw new WalletNotConnectedError().name;
    if (!(this._wallet.readyState === "Loadable" || this._wallet.readyState === "Installed"))
      throw new WalletNotReadyError().name;
    return true;
  }
  clearData() {
    this._connected = false;
    this.setWallet(null);
    this.setAccount(null);
    this.setNetwork(null);
    removeLocalStorage();
  }
  async setAnsName() {
    var _a;
    if (((_a = this._network) == null ? void 0 : _a.chainId) && this._account) {
      if (!ChainIdToAnsSupportedNetworkMap[this._network.chainId] || !isAptosNetwork(this._network)) {
        this._account.ansName = void 0;
        return;
      }
      const aptosConfig = new l2({
        network: convertNetwork(this._network)
      });
      const aptos = new t4(aptosConfig);
      const name = await aptos.ans.getPrimaryName({
        address: this._account.address.toString()
      });
      this._account.ansName = name;
    }
  }
  setWallet(wallet) {
    this._wallet = wallet;
  }
  setAccount(account) {
    var _a;
    if (account === null) {
      this._account = null;
      return;
    }
    if ((_a = this._wallet) == null ? void 0 : _a.isAIP62Standard) {
      if ("status" in account) {
        const connectStandardAccount = account;
        if (connectStandardAccount.status === r4.REJECTED) {
          this._connecting = false;
          throw new WalletConnectionError("User has rejected the request").message;
        }
        this._account = {
          address: connectStandardAccount.args.address.toString(),
          publicKey: connectStandardAccount.args.publicKey.toString(),
          ansName: connectStandardAccount.args.ansName
        };
        return;
      } else {
        const standardAccount = account;
        this._account = {
          address: standardAccount.address.toString(),
          publicKey: standardAccount.publicKey.toString(),
          ansName: standardAccount.ansName
        };
        return;
      }
    }
    this._account = { ...account };
    return;
  }
  setNetwork(network) {
    var _a, _b, _c;
    if (network === null) {
      this._network = null;
      return;
    }
    if ((_a = this._wallet) == null ? void 0 : _a.isAIP62Standard) {
      const standardizeNetwork = network;
      this.recordEvent("network_change", {
        from: (_b = this._network) == null ? void 0 : _b.name,
        to: standardizeNetwork.name
      });
      this._network = {
        name: standardizeNetwork.name.toLowerCase(),
        chainId: standardizeNetwork.chainId.toString(),
        url: standardizeNetwork.url
      };
      return;
    }
    this.recordEvent("network_change", {
      from: (_c = this._network) == null ? void 0 : _c.name,
      to: network.name
    });
    this._network = {
      ...network,
      name: network.name.toLowerCase()
    };
  }
  isConnected() {
    return this._connected;
  }
  get wallets() {
    return this._all_wallets;
  }
  get pluginWallets() {
    return this._wallets;
  }
  get standardWallets() {
    return this._standard_wallets;
  }
  get wallet() {
    try {
      if (!this._wallet)
        return null;
      return {
        name: this._wallet.name,
        icon: this._wallet.icon,
        url: this._wallet.url
      };
    } catch (error) {
      throw new WalletNotSelectedError(error).message;
    }
  }
  get account() {
    try {
      return this._account;
    } catch (error) {
      throw new WalletAccountError(error).message;
    }
  }
  get network() {
    try {
      return this._network;
    } catch (error) {
      throw new WalletGetNetworkError(error).message;
    }
  }
  async connect(walletName2) {
    var _a;
    const allDetectedWallets = this._all_wallets;
    const selectedWallet = allDetectedWallets.find(
      (wallet) => wallet.name === walletName2
    );
    if (!selectedWallet)
      return;
    if (this._connected) {
      if (((_a = this._wallet) == null ? void 0 : _a.name) === walletName2)
        throw new WalletConnectionError(
          `${walletName2} wallet is already connected`
        ).message;
    }
    if (isRedirectable() && selectedWallet.readyState !== "Installed") {
      if (selectedWallet.isAIP62Standard && selectedWallet.openInMobileApp) {
        selectedWallet.openInMobileApp();
        return;
      }
      if (selectedWallet.deeplinkProvider) {
        const url = encodeURIComponent(window.location.href);
        const location = selectedWallet.deeplinkProvider({ url });
        window.location.href = location;
      }
      return;
    }
    if (selectedWallet.readyState !== "Installed" && selectedWallet.readyState !== "Loadable") {
      return;
    }
    await this.connectWallet(selectedWallet);
  }
  async connectWallet(selectedWallet) {
    try {
      this._connecting = true;
      this.setWallet(selectedWallet);
      let account;
      if (selectedWallet.isAIP62Standard) {
        account = await this.walletStandardCore.connect(selectedWallet);
      } else {
        account = await this.walletCoreV1.connect(selectedWallet);
      }
      this.setAccount(account);
      const network = await selectedWallet.network();
      this.setNetwork(network);
      await this.setAnsName();
      setLocalStorage(selectedWallet.name);
      this._connected = true;
      this.recordEvent("wallet_connect");
      this.emit("connect", account);
    } catch (error) {
      this.clearData();
      const errMsg = generalizedErrorMessage(error);
      throw new WalletConnectionError(errMsg).message;
    } finally {
      this._connecting = false;
    }
  }
  async disconnect() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.disconnect();
      this.clearData();
      this.recordEvent("wallet_disconnect");
      this.emit("disconnect");
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletDisconnectionError(errMsg).message;
    }
  }
  async signAndSubmitTransaction(transactionInput) {
    try {
      if ("function" in transactionInput.data) {
        if (transactionInput.data.function === "0x1::account::rotate_authentication_key_call") {
          throw new WalletSignAndSubmitMessageError("SCAM SITE DETECTED").message;
        }
      }
      this.ensureWalletExists(this._wallet);
      this.ensureAccountExists(this._account);
      this.recordEvent("sign_and_submit_transaction");
      const payloadData = transactionInput.data;
      const aptosConfig = getAptosConfig(this._network);
      const aptos = new t4(aptosConfig);
      if (this._wallet.signAndSubmitTransaction) {
        if (this._wallet.isAIP62Standard) {
          const { hash: hash2, ...output2 } = await this.walletStandardCore.signAndSubmitTransaction(
            transactionInput,
            aptos,
            this._account,
            this._wallet,
            this._standard_wallets
          );
          return { hash: hash2, output: output2 };
        } else {
          const { hash: hash2, ...output2 } = await this.walletCoreV1.resolveSignAndSubmitTransaction(
            payloadData,
            this._network,
            this._wallet,
            transactionInput
          );
          return { hash: hash2, output: output2 };
        }
      }
      const transaction = await aptos.transaction.build.simple({
        sender: this._account.address,
        data: transactionInput.data,
        options: transactionInput.options
      });
      const senderAuthenticator = await this.signTransaction(transaction);
      const response = await this.submitTransaction({
        transaction,
        senderAuthenticator
      });
      return response;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignAndSubmitMessageError(errMsg).message;
    }
  }
  async signTransaction(transactionOrPayload, asFeePayer, options) {
    var _a, _b, _c, _d;
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("sign_transaction");
      if (this._wallet.signTransaction) {
        if (this._wallet.isAIP62Standard) {
          if ("rawTransaction" in transactionOrPayload) {
            return await this.walletStandardCore.signTransaction(
              transactionOrPayload,
              this._wallet,
              asFeePayer
            );
          } else {
            const aptosConfig = getAptosConfig(this._network);
            this.ensureAccountExists(this._account);
            const sender = this._account.address;
            const payload = await generateTransactionPayloadFromV1Input(
              aptosConfig,
              transactionOrPayload
            );
            const optionsV1 = options;
            const optionsV2 = {
              accountSequenceNumber: optionsV1 == null ? void 0 : optionsV1.sequenceNumber,
              expireTimestamp: (_a = optionsV1 == null ? void 0 : optionsV1.expireTimestamp) != null ? _a : optionsV1 == null ? void 0 : optionsV1.expirationTimestamp,
              gasUnitPrice: (_b = optionsV1 == null ? void 0 : optionsV1.gasUnitPrice) != null ? _b : optionsV1 == null ? void 0 : optionsV1.gas_unit_price,
              maxGasAmount: (_c = optionsV1 == null ? void 0 : optionsV1.maxGasAmount) != null ? _c : optionsV1 == null ? void 0 : optionsV1.max_gas_amount
            };
            const rawTransaction = await fn({
              aptosConfig,
              payload,
              sender,
              options: optionsV2
            });
            return await this.walletStandardCore.signTransaction(
              new o2(rawTransaction),
              this._wallet,
              false
            );
          }
        }
        if ("rawTransaction" in transactionOrPayload) {
          const accountAuthenticator = await this._wallet.signTransaction(
            transactionOrPayload,
            asFeePayer
          );
          return accountAuthenticator;
        } else {
          const response = await this.walletCoreV1.signTransaction(
            transactionOrPayload,
            this._wallet,
            {
              max_gas_amount: (options == null ? void 0 : options.maxGasAmount) ? BigInt(options == null ? void 0 : options.maxGasAmount) : void 0,
              gas_unit_price: (options == null ? void 0 : options.gasUnitPrice) ? BigInt(options == null ? void 0 : options.gasUnitPrice) : void 0
            }
          );
          if (!response) {
            throw new Error("error");
          }
          const deserializer1 = new bcs_exports.Deserializer(response);
          const deserializedSignature = aptos_types_exports.SignedTransaction.deserialize(deserializer1);
          const transactionAuthenticator = deserializedSignature.authenticator;
          const publicKey = transactionAuthenticator.public_key.value;
          const signature = transactionAuthenticator.signature.value;
          const accountAuthenticator = new u2(
            new m(publicKey),
            new h(signature)
          );
          return accountAuthenticator;
        }
      }
      throw new WalletNotSupportedMethod(
        `Sign Transaction is not supported by ${(_d = this.wallet) == null ? void 0 : _d.name}`
      ).message;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async signMessage(message) {
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("sign_message");
      if (this._wallet.isAIP62Standard) {
        return await this.walletStandardCore.signMessage(message, this._wallet);
      }
      const response = await this._wallet.signMessage(message);
      return response;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageError(errMsg).message;
    }
  }
  async submitTransaction(transaction) {
    try {
      this.ensureWalletExists(this._wallet);
      const { additionalSignersAuthenticators } = transaction;
      const transactionType = additionalSignersAuthenticators !== void 0 ? "multi-agent" : "simple";
      this.recordEvent("submit_transaction", {
        transaction_type: transactionType
      });
      if (this._wallet.submitTransaction) {
        const pendingTransaction = await this._wallet.submitTransaction(transaction);
        return pendingTransaction;
      }
      const aptosConfig = new l2({
        network: convertNetwork(this.network)
      });
      const aptos = new t4(aptosConfig);
      if (additionalSignersAuthenticators !== void 0) {
        const multiAgentTxn = {
          ...transaction,
          additionalSignersAuthenticators
        };
        return aptos.transaction.submit.multiAgent(multiAgentTxn);
      } else {
        return aptos.transaction.submit.simple(transaction);
      }
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignTransactionError(errMsg).message;
    }
  }
  async onAccountChange() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.onAccountChange(
        async (data) => {
          this.setAccount(data);
          await this.setAnsName();
          this.recordEvent("account_change");
          this.emit("accountChange", this._account);
        }
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletAccountChangeError(errMsg).message;
    }
  }
  async onNetworkChange() {
    try {
      this.ensureWalletExists(this._wallet);
      await this._wallet.onNetworkChange(
        async (data) => {
          this.setNetwork(data);
          await this.setAnsName();
          this.emit("networkChange", this._network);
        }
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletNetworkChangeError(errMsg).message;
    }
  }
  async changeNetwork(network) {
    var _a;
    try {
      this.ensureWalletExists(this._wallet);
      this.recordEvent("change_network_request", {
        from: (_a = this._network) == null ? void 0 : _a.name,
        to: network
      });
      const chainId = network === e.DEVNET ? await fetchDevnetChainId() : r2[network];
      if (this._wallet.changeNetwork) {
        const networkInfo = {
          name: network,
          chainId
        };
        const response = await this._wallet.changeNetwork(networkInfo);
        if (response.status === r4.REJECTED) {
          throw new WalletConnectionError("User has rejected the request").message;
        }
        return response.args;
      }
      throw new WalletChangeNetworkError(
        `${this._wallet.name} does not support changing network request`
      ).message;
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletChangeNetworkError(errMsg).message;
    }
  }
  async signMessageAndVerify(message) {
    try {
      this.ensureWalletExists(this._wallet);
      this.ensureAccountExists(this._account);
      this.recordEvent("sign_message_and_verify");
      if (this._wallet.isAIP62Standard) {
        return this.walletStandardCore.signMessageAndVerify(
          message,
          this._wallet
        );
      }
      return await this.walletCoreV1.signMessageAndVerify(
        message,
        this._wallet,
        this._account
      );
    } catch (error) {
      const errMsg = generalizedErrorMessage(error);
      throw new WalletSignMessageAndVerifyError(errMsg).message;
    }
  }
};
if (typeof window !== "undefined") {
  window.WALLET_ADAPTER_CORE_VERSION = WALLET_ADAPTER_CORE_VERSION;
}

// node_modules/@aptos-labs/wallet-adapter-react/dist/index.mjs
var import_react = __toESM(require_react(), 1);
var import_react2 = __toESM(require_react(), 1);
var import_jsx_runtime = __toESM(require_jsx_runtime(), 1);
var import_react3 = __toESM(require_react(), 1);
var import_react4 = __toESM(require_react(), 1);
var import_jsx_runtime2 = __toESM(require_jsx_runtime(), 1);
var import_react5 = __toESM(require_react(), 1);
var import_jsx_runtime3 = __toESM(require_jsx_runtime(), 1);
var import_react6 = __toESM(require_react(), 1);
var import_jsx_runtime4 = __toESM(require_jsx_runtime(), 1);
var import_react7 = __toESM(require_react(), 1);
var import_jsx_runtime5 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime6 = __toESM(require_jsx_runtime(), 1);
var import_react8 = __toESM(require_react(), 1);
var import_react9 = __toESM(require_react(), 1);
var import_jsx_runtime7 = __toESM(require_jsx_runtime(), 1);
var import_jsx_runtime8 = __toESM(require_jsx_runtime(), 1);
var import_react10 = __toESM(require_react(), 1);
var import_jsx_runtime9 = __toESM(require_jsx_runtime(), 1);
var DEFAULT_CONTEXT = {
  connected: false
};
var WalletContext = (0, import_react2.createContext)(
  DEFAULT_CONTEXT
);
function useWallet() {
  const context = (0, import_react2.useContext)(WalletContext);
  if (!context) {
    throw new Error("useWallet must be used within a WalletContextState");
  }
  return context;
}
var initialState = {
  connected: false,
  account: null,
  network: null,
  wallet: null
};
var AptosWalletAdapterProvider = ({
  children,
  plugins,
  optInWallets,
  autoConnect = false,
  dappConfig,
  disableTelemetry = false,
  onError
}) => {
  const [{ connected, account, network, wallet }, setState2] = (0, import_react.useState)(initialState);
  const [isLoading, setIsLoading] = (0, import_react.useState)(true);
  const [walletCore, setWalletCore] = (0, import_react.useState)();
  const [wallets2, setWallets] = (0, import_react.useState)(plugins != null ? plugins : []);
  (0, import_react.useEffect)(() => {
    const walletCore2 = new WalletCore(
      plugins != null ? plugins : [],
      optInWallets != null ? optInWallets : [],
      dappConfig,
      disableTelemetry
    );
    setWalletCore(walletCore2);
  }, []);
  (0, import_react.useEffect)(() => {
    var _a;
    setWallets((_a = walletCore == null ? void 0 : walletCore.wallets) != null ? _a : []);
  }, [walletCore]);
  const connect = async (walletName2) => {
    try {
      setIsLoading(true);
      await (walletCore == null ? void 0 : walletCore.connect(walletName2));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    } finally {
      setIsLoading(false);
    }
  };
  const disconnect = async () => {
    try {
      await (walletCore == null ? void 0 : walletCore.disconnect());
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signTransaction = async (transaction, asFeePayer, options) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.signTransaction(
        transaction,
        asFeePayer,
        options
      ));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signMessage = async (message) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.signMessage(message));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signMessageAndVerify = async (message) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.signMessageAndVerify(message));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const submitTransaction = async (transaction) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.submitTransaction(transaction));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const signAndSubmitTransaction = async (transaction) => {
    try {
      return await (walletCore == null ? void 0 : walletCore.signAndSubmitTransaction(transaction));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  const changeNetwork = async (network2) => {
    if (!walletCore) {
      throw new Error("WalletCore is not initialized");
    }
    try {
      return await (walletCore == null ? void 0 : walletCore.changeNetwork(network2));
    } catch (error) {
      if (onError)
        onError(error);
      return Promise.reject(error);
    }
  };
  (0, import_react.useEffect)(() => {
    if (autoConnect) {
      if (localStorage.getItem("AptosWalletName") && !connected) {
        connect(localStorage.getItem("AptosWalletName"));
      } else {
        setIsLoading(false);
      }
    }
  }, [autoConnect, wallets2]);
  (0, import_react.useEffect)(() => {
    if (connected) {
      walletCore == null ? void 0 : walletCore.onAccountChange();
      walletCore == null ? void 0 : walletCore.onNetworkChange();
    }
  }, [connected]);
  const handleConnect = () => {
    setState2((state) => {
      return {
        ...state,
        connected: true,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: (walletCore == null ? void 0 : walletCore.wallet) || null
      };
    });
  };
  const handleDisconnect = () => {
    if (!connected)
      return;
    setState2((state) => {
      return {
        ...state,
        connected: false,
        account: (walletCore == null ? void 0 : walletCore.account) || null,
        network: (walletCore == null ? void 0 : walletCore.network) || null,
        wallet: null
      };
    });
  };
  const handleAccountChange = (0, import_react.useCallback)(() => {
    if (!connected)
      return;
    if (!(walletCore == null ? void 0 : walletCore.wallet))
      return;
    setState2((state) => {
      return {
        ...state,
        account: (walletCore == null ? void 0 : walletCore.account) || null
      };
    });
  }, [connected]);
  const handleNetworkChange = (0, import_react.useCallback)(() => {
    if (!connected)
      return;
    if (!(walletCore == null ? void 0 : walletCore.wallet))
      return;
    setState2((state) => {
      return {
        ...state,
        network: (walletCore == null ? void 0 : walletCore.network) || null
      };
    });
  }, [connected]);
  const handleReadyStateChange = (updatedWallet) => {
    const updatedWallets = wallets2 == null ? void 0 : wallets2.map((wallet2) => {
      if (wallet2.name === updatedWallet.name) {
        return { ...wallet2, readyState: updatedWallet.readyState };
      }
      return wallet2;
    });
    setWallets(updatedWallets);
  };
  const handleStandardWalletsAdded = (standardWallet) => {
    const existingWalletIndex = wallets2.findIndex(
      (wallet2) => wallet2.name == standardWallet.name
    );
    if (existingWalletIndex !== -1) {
      setWallets((wallets22) => [
        ...wallets22.slice(0, existingWalletIndex),
        standardWallet,
        ...wallets22.slice(existingWalletIndex + 1)
      ]);
    } else {
      setWallets((wallets22) => [...wallets22, standardWallet]);
    }
  };
  (0, import_react.useEffect)(() => {
    walletCore == null ? void 0 : walletCore.on("connect", handleConnect);
    walletCore == null ? void 0 : walletCore.on("disconnect", handleDisconnect);
    walletCore == null ? void 0 : walletCore.on("accountChange", handleAccountChange);
    walletCore == null ? void 0 : walletCore.on("networkChange", handleNetworkChange);
    walletCore == null ? void 0 : walletCore.on("readyStateChange", handleReadyStateChange);
    walletCore == null ? void 0 : walletCore.on("standardWalletsAdded", handleStandardWalletsAdded);
    return () => {
      walletCore == null ? void 0 : walletCore.off("connect", handleConnect);
      walletCore == null ? void 0 : walletCore.off("disconnect", handleDisconnect);
      walletCore == null ? void 0 : walletCore.off("accountChange", handleAccountChange);
      walletCore == null ? void 0 : walletCore.off("networkChange", handleNetworkChange);
      walletCore == null ? void 0 : walletCore.off("readyStateChange", handleReadyStateChange);
      walletCore == null ? void 0 : walletCore.off("standardWalletsAdded", handleStandardWalletsAdded);
    };
  }, [wallets2, account]);
  return (0, import_jsx_runtime.jsx)(WalletContext.Provider, {
    value: {
      connect,
      account,
      network,
      connected,
      disconnect,
      wallet,
      wallets: wallets2,
      signAndSubmitTransaction,
      signTransaction,
      signMessage,
      signMessageAndVerify,
      isLoading,
      submitTransaction,
      changeNetwork
    },
    children
  });
};
var LinkGraphic = (0, import_react4.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime2.jsx)("svg", {
      ref,
      width: "102",
      height: "132",
      viewBox: "0 0 102 132",
      fill: "none",
      ...props,
      children: (0, import_jsx_runtime2.jsxs)("g", {
        stroke: "currentColor",
        strokeMiterlimit: "10",
        children: [
          (0, import_jsx_runtime2.jsx)("path", {
            d: "M59.633 80.66c11.742-2.814 17.48-7.018 20.925-13.254l17.518-31.69c6.257-11.317 2.142-25.55-9.189-31.798C82.737.53 75.723.188 69.593 2.398M60.7 69.565a14.09 14.09 0 0 1-6.907-1.767l-.228-.108"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "m52.365 41.075 12.507-22.627a14.146 14.146 0 0 1 4.727-5.062M32.407 118.619a14.139 14.139 0 0 1-7.034-1.768c-6.857-3.78-9.353-12.402-5.561-19.25l16.634-30.1a14.097 14.097 0 0 1 4.518-4.923"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "M41.211 78.85c11.332 6.248 25.583 2.14 31.84-9.177l17.518-31.691c6.256-11.317 2.142-25.55-9.19-31.798-6.085-3.357-13.018-3.724-19.104-1.59A23.31 23.31 0 0 0 49.541 15.36L36.863 38.298l7.989 5.036 12.506-22.627c3.786-6.848 12.419-9.34 19.276-5.554 6.856 3.78 9.353 12.402 5.561 19.25l-16.634 30.1c-3.785 6.848-12.418 9.341-19.275 5.555l-5.075 8.791ZM29.5 130.447c12.361-1.37 19.2-6.994 22.966-13.804l12.678-22.936-8.305-5.239"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "m55.72 61.947-.442.764 5.511-9.55c-6.901-3.806-18.65-3.124-27.105.814M44.85 43.523l7.635-2.486m-4.221 23.264 7.217-1.723m-9.316 7.517 7.59-2.405m-.562-12.156 7.508-2.221m10.136-51.32L62.761 4.43M49.642 90.778l7.514-2.26m.474 7.448 7.514-2.26m-50.306-60.13c7.135 0 12.918-5.776 12.918-12.9 0-7.126-5.783-12.902-12.918-12.902-7.134 0-12.917 5.776-12.917 12.901s5.783 12.901 12.918 12.901Z"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "M15.724 7.774h3.197c7.135 0 12.918 5.776 12.918 12.901 0 7.126-5.783 12.901-12.918 12.901h-3.425m65.112 66.935h3.198c7.135 0 12.918 5.775 12.918 12.901 0 7.125-5.783 12.9-12.918 12.9h-3.425"
          }),
          (0, import_jsx_runtime2.jsx)("path", {
            d: "M79.717 126.312c7.135 0 12.918-5.775 12.918-12.9s-5.783-12.901-12.918-12.901c-7.134 0-12.917 5.776-12.917 12.901s5.783 12.9 12.917 12.9ZM53.281 55.414c-11.33-6.248-25.582-2.14-31.839 9.177L3.924 96.281c-6.257 11.318-2.142 25.55 9.189 31.799 11.331 6.248 25.582 2.139 31.839-9.177l12.677-22.937-7.988-5.036-12.507 22.627c-3.785 6.848-12.418 9.341-19.275 5.554-6.857-3.781-9.353-12.402-5.561-19.25l16.633-30.1c3.786-6.848 12.419-9.341 19.276-5.555l5.074-8.792Z"
          })
        ]
      })
    });
  }
);
LinkGraphic.displayName = "LinkGraphic";
var WalletGraphic = (0, import_react5.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime3.jsxs)("svg", {
      ref,
      width: "128",
      height: "102",
      viewBox: "0 0 128 102",
      fill: "none",
      ...props,
      children: [
        (0, import_jsx_runtime3.jsx)("path", {
          fill: "currentColor",
          d: "m.96 25.93-.36-.35.36.85v-.5Zm7.79-7.81v-.5h-.21l-.15.15.36.35ZM1.3 26.28l7.79-7.8-.7-.71-7.8 7.8.7.71Zm7.44-7.66H10v-1H8.75v1Zm29.22 6.8h-37v1h37.01v-1Z"
        }),
        (0, import_jsx_runtime3.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M82.25 26.08c0 12.25-9.92 22.2-22.14 22.2a22.17 22.17 0 0 1-22.14-22.2H1.1v74.82h118.02V26.08H82.25Zm44.33 67.02h.33V18.27h-5.7"
        }),
        (0, import_jsx_runtime3.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M74.52 42.92a22.4 22.4 0 0 1-11.43 3.3 22.5 22.5 0 0 1-22.46-22.53H9.52M119.22 101l7.78-7.82m-7.88-67.1 7.79-7.81m-44.78 7.72 2.73-2.3m-46.89 2.39 2.39-2.4"
        }),
        (0, import_jsx_runtime3.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M9.86 23.69V5.72h107.97v18.04H84.65"
        }),
        (0, import_jsx_runtime3.jsx)("path", {
          stroke: "currentColor",
          strokeMiterlimit: "10",
          d: "M117.83 20.46h3.39V1H13.25v4.72M9.36 23.69h31.78"
        })
      ]
    });
  }
);
WalletGraphic.displayName = "WalletGraphic";
var Web3Graphic = (0, import_react6.forwardRef)(
  (props, ref) => {
    return (0, import_jsx_runtime4.jsx)("svg", {
      ref,
      width: "142",
      height: "108",
      viewBox: "0 0 142 108",
      fill: "none",
      ...props,
      children: (0, import_jsx_runtime4.jsxs)("g", {
        stroke: "currentColor",
        strokeLinejoin: "round",
        children: [
          (0, import_jsx_runtime4.jsx)("path", {
            d: "m91.26 35.8.06-10.46L71.3 1v10.53L87 30.5m-36.11 5.24-.06-10.45L71.3 1v10.53L55 30.5"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71 59.55V49.17L50.83 25.3l.06 10.45L57 42.5m14 17.05V49.18l20.33-23.84-.07 10.45L86 42M1 59.68l.22-9.07 35.33-19.8-.1 9L9 55"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M36.55 30.8s-.08 5.92-.1 9l.1-9ZM71 59.51v-9.07L36.55 30.8l-.1 9L63.5 55"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71 59.51v-9.07L36.44 70.78l-.1 9.14L55.5 68.5"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M1.22 50.6a77387.2 77387.2 0 0 0 35.22 20.18l-.1 9.14L1 59.68l.23-9.07h-.01ZM141 59.68l-.23-9.07-35.33-19.8.11 9L133 55"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "m105.44 30.8.11 9-.1-9Z"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71 59.51v-9.07l34.44-19.64.11 9L78.5 55"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71 59.51v-9.07l34.56 20.34.1 9.14L87 69"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M140.78 50.6a78487.3 78487.3 0 0 1-35.23 20.18l.11 9.14L141 59.68l-.23-9.07ZM50.83 80.15l.06-6.33 20.1-23.38H71v9.26L55 79"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "M71.3 97.6 50.89 73.81l-.06 9.33L71.3 107v-9.4Zm20.03-14.5-.07-9.33L71 50.44v9.26l16 18.8"
          }),
          (0, import_jsx_runtime4.jsx)("path", {
            d: "m71.3 97.6 19.96-23.83.06 9.33L71.3 107v-9.4Z"
          })
        ]
      })
    });
  }
);
Web3Graphic.displayName = "Web3Graphic";
function createHeadlessComponent(displayName, elementType, props) {
  const component = (0, import_react7.forwardRef)(({ className, asChild, children }, ref) => {
    const Component = asChild ? Slot : elementType;
    const { children: defaultChildren, ...resolvedProps } = typeof props === "function" ? props(displayName) : props != null ? props : {};
    return (0, import_jsx_runtime5.jsx)(Component, {
      ref,
      className,
      children: children != null ? children : defaultChildren,
      ...resolvedProps
    });
  });
  component.displayName = displayName;
  return component;
}
var EXPLORE_ECOSYSTEM_URL = "https://aptosfoundation.org/ecosystem/projects/all";
var AboutAptosConnectContext = (0, import_react3.createContext)(null);
function useAboutAptosConnectContext(displayName) {
  const context = (0, import_react3.useContext)(AboutAptosConnectContext);
  if (!context) {
    throw new Error(
      `\`${displayName}\` must be used within \`AboutAptosConnect\``
    );
  }
  return context;
}
var educationScreens = [
  {
    Graphic: LinkGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h3", {
      children: "A better way to login."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Aptos Connect is a web3 wallet that uses a Social Login to create accounts on the Aptos blockchain."
    })
  },
  {
    Graphic: WalletGraphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "What is a wallet?"
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: "Wallets are a secure way to send, receive, and interact with digital assets like cryptocurrencies & NFTs."
    })
  },
  {
    Graphic: Web3Graphic,
    Title: createHeadlessComponent("EducationScreen.Title", "h2", {
      children: "Explore more of web3."
    }),
    Description: createHeadlessComponent("EducationScreen.Description", "p", {
      children: (0, import_jsx_runtime6.jsxs)(import_jsx_runtime6.Fragment, {
        children: [
          "Aptos Connect lets you take one account across any application built on Aptos.",
          " ",
          (0, import_jsx_runtime6.jsx)("a", {
            href: EXPLORE_ECOSYSTEM_URL,
            target: "_blank",
            rel: "noopener noreferrer",
            children: "Explore the ecosystem"
          }),
          "."
        ]
      })
    })
  }
];
var educationScreenIndicators = Array(educationScreens.length).fill(null).map(
  (_, index) => createHeadlessComponent(
    "AboutAptosConnect.ScreenIndicator",
    "button",
    (displayName) => {
      const context = useAboutAptosConnectContext(displayName);
      const isActive = context.screenIndex - 1 === index;
      return {
        "aria-label": `Go to screen ${index + 1}`,
        "aria-current": isActive ? "step" : void 0,
        "data-active": isActive || void 0,
        onClick: () => {
          context.setScreenIndex(index + 1);
        }
      };
    }
  )
);
var Root = ({ renderEducationScreen, children }) => {
  const [screenIndex, setScreenIndex] = (0, import_react3.useState)(0);
  const currentEducationScreen = (0, import_react3.useMemo)(
    () => educationScreens.map((screen, i4) => ({
      ...screen,
      screenIndex: i4,
      totalScreens: educationScreens.length,
      screenIndicators: educationScreenIndicators,
      back: () => {
        setScreenIndex(screenIndex - 1);
      },
      next: () => {
        setScreenIndex(
          screenIndex === educationScreens.length ? 0 : screenIndex + 1
        );
      },
      cancel: () => {
        setScreenIndex(0);
      }
    }))[screenIndex - 1],
    [screenIndex]
  );
  return (0, import_jsx_runtime6.jsx)(AboutAptosConnectContext.Provider, {
    value: { screenIndex, setScreenIndex },
    children: screenIndex === 0 ? children : renderEducationScreen(currentEducationScreen)
  });
};
Root.displayName = "AboutAptosConnect";
var Trigger = createHeadlessComponent(
  "AboutAptosConnect.Trigger",
  "button",
  (displayName) => {
    const context = useAboutAptosConnectContext(displayName);
    return {
      onClick: () => {
        context.setScreenIndex(1);
      }
    };
  }
);
var AboutAptosConnect = Object.assign(Root, {
  Trigger
});
var SmallAptosLogo = (0, import_react9.forwardRef)((props, ref) => {
  return (0, import_jsx_runtime7.jsx)("svg", {
    ref,
    width: "12",
    height: "12",
    viewBox: "0 0 12 12",
    fill: "none",
    ...props,
    children: (0, import_jsx_runtime7.jsx)("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M6 12C9.31371 12 12 9.31371 12 6C12 2.68629 9.31371 0 6 0C2.68629 0 0 2.68629 0 6C0 9.31371 2.68629 12 6 12ZM7.17547 3.67976C7.13401 3.72309 7.07649 3.74757 7.01648 3.74757H3.00775C3.69185 2.83824 4.77995 2.25 6.00569 2.25C7.23142 2.25 8.31953 2.83824 9.00362 3.74757H8.28524C8.20824 3.74757 8.13498 3.71468 8.08401 3.65701L7.81608 3.35416C7.77618 3.30896 7.71882 3.28308 7.6585 3.28308H7.6454C7.58805 3.28308 7.53318 3.30646 7.49343 3.34792L7.17547 3.67976ZM8.05656 4.75897H7.39569C7.31869 4.75897 7.24543 4.72593 7.19447 4.66842L6.92638 4.36557C6.88647 4.32036 6.82896 4.29465 6.7688 4.29465C6.70863 4.29465 6.65112 4.32052 6.61121 4.36557L6.38131 4.6254C6.30603 4.71034 6.19801 4.75913 6.08454 4.75913H2.46703C2.36401 5.05278 2.29683 5.36296 2.27002 5.68467H5.68505C5.74506 5.68467 5.80258 5.66019 5.84404 5.61686L6.16201 5.28502C6.20175 5.24356 6.25662 5.22018 6.31398 5.22018H6.32707C6.38739 5.22018 6.44475 5.24606 6.48465 5.29126L6.75258 5.59411C6.80355 5.65178 6.87681 5.68467 6.95381 5.68467H9.74133C9.71452 5.3628 9.64734 5.05263 9.54431 4.75913H8.05641L8.05656 4.75897ZM4.33651 7.63095C4.39652 7.63095 4.45404 7.60648 4.4955 7.56315L4.81347 7.23131C4.85321 7.18985 4.90808 7.16647 4.96544 7.16647H4.97853C5.03885 7.16647 5.09621 7.19234 5.13611 7.23739L5.40404 7.54024C5.45501 7.59791 5.52827 7.6308 5.60527 7.6308H9.38285C9.52438 7.33839 9.62803 7.02463 9.68975 6.69591H6.06383C5.98683 6.69591 5.91357 6.66287 5.8626 6.60535L5.59467 6.3025C5.55477 6.2573 5.49725 6.23158 5.43709 6.23158C5.37692 6.23158 5.31941 6.25746 5.27951 6.3025L5.0496 6.56233C4.97432 6.64728 4.86631 6.69606 4.75268 6.69606H2.32147C2.3832 7.02479 2.487 7.33855 2.62837 7.63095H4.33651ZM5.57359 8.55745H4.59116C4.51417 8.55745 4.44091 8.52441 4.38994 8.46689L4.12201 8.16404C4.0821 8.11884 4.02459 8.09312 3.96442 8.09312C3.90426 8.09312 3.84675 8.119 3.80684 8.16404L3.57694 8.42387C3.50166 8.50882 3.39364 8.55761 3.28001 8.55761H3.26474C3.94915 9.29096 4.92378 9.74998 6.00596 9.74998C7.08815 9.74998 8.06262 9.29096 8.74719 8.55761H5.57359V8.55745Z",
      fill: "currentColor"
    })
  });
});
SmallAptosLogo.displayName = "SmallAptosLogo";
var APTOS_PRIVACY_POLICY_URL = "https://aptoslabs.com/privacy";
var Root2 = createHeadlessComponent("AptosPrivacyPolicy.Root", "div");
var Disclaimer = createHeadlessComponent(
  "AptosPrivacyPolicy.Disclaimer",
  "span",
  { children: "By continuing, you agree to Aptos Labs'" }
);
var Link = createHeadlessComponent("AptosPrivacyPolicy.Disclaimer", "a", {
  href: APTOS_PRIVACY_POLICY_URL,
  target: "_blank",
  rel: "noopener noreferrer",
  children: "Privacy Policy"
});
var PoweredBy = (0, import_react8.forwardRef)(({ className }, ref) => {
  return (0, import_jsx_runtime8.jsxs)("div", {
    ref,
    className,
    children: [
      (0, import_jsx_runtime8.jsx)("span", {
        children: "Powered by"
      }),
      (0, import_jsx_runtime8.jsx)(SmallAptosLogo, {}),
      (0, import_jsx_runtime8.jsx)("span", {
        children: "Aptos Labs"
      })
    ]
  });
});
PoweredBy.displayName = "AptosPrivacyPolicy.PoweredBy";
var AptosPrivacyPolicy = Object.assign(Root2, {
  Disclaimer,
  Link,
  PoweredBy
});
function useWalletItemContext(displayName) {
  const context = (0, import_react10.useContext)(WalletItemContext);
  if (!context) {
    throw new Error(`\`${displayName}\` must be used within \`WalletItem\``);
  }
  return context;
}
var WalletItemContext = (0, import_react10.createContext)(null);
var Root3 = (0, import_react10.forwardRef)(
  ({ wallet, onConnect, className, asChild, children }, ref) => {
    const { connect } = useWallet();
    const connectWallet = (0, import_react10.useCallback)(() => {
      connect(wallet.name);
      onConnect == null ? void 0 : onConnect();
    }, [connect, wallet.name, onConnect]);
    const isWalletReady = wallet.readyState === WalletReadyState.Installed || wallet.readyState === WalletReadyState.Loadable;
    const mobileSupport = "deeplinkProvider" in wallet && wallet.deeplinkProvider;
    if (!isWalletReady && isRedirectable() && !mobileSupport)
      return null;
    const Component = asChild ? Slot : "div";
    return (0, import_jsx_runtime9.jsx)(WalletItemContext.Provider, {
      value: { wallet, connectWallet },
      children: (0, import_jsx_runtime9.jsx)(Component, {
        ref,
        className,
        children
      })
    });
  }
);
Root3.displayName = "WalletItem";
var Icon = createHeadlessComponent(
  "WalletItem.Icon",
  "img",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      src: context.wallet.icon,
      alt: `${context.wallet.name} icon`
    };
  }
);
var Name = createHeadlessComponent(
  "WalletItem.Name",
  "div",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      children: context.wallet.name
    };
  }
);
var ConnectButton = createHeadlessComponent(
  "WalletItem.ConnectButton",
  "button",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      onClick: context.connectWallet,
      children: "Connect"
    };
  }
);
var InstallLink = createHeadlessComponent(
  "WalletItem.InstallLink",
  "a",
  (displayName) => {
    const context = useWalletItemContext(displayName);
    return {
      href: context.wallet.url,
      target: "_blank",
      rel: "noopener noreferrer",
      children: "Install"
    };
  }
);
var WalletItem = Object.assign(Root3, {
  Icon,
  Name,
  ConnectButton,
  InstallLink
});

export {
  aptos_types_exports,
  generated_exports,
  WalletReadyState,
  NetworkName2 as NetworkName,
  ChainIdToAnsSupportedNetworkMap,
  APTOS_CONNECT_BASE_URL,
  APTOS_CONNECT_ACCOUNT_URL,
  convertNetwork,
  convertV2TransactionPayloadToV1BCSPayload,
  convertV2PayloadToV1JSONPayload,
  generateTransactionPayloadFromV1Input,
  isMobile,
  isInAppBrowser,
  isRedirectable,
  generalizedErrorMessage,
  areBCSArguments,
  getAptosConfig,
  isAptosNetwork,
  fetchDevnetChainId,
  setLocalStorage,
  removeLocalStorage,
  getLocalStorage,
  scopePollingDetectionStrategy,
  partitionWallets,
  isInstalledOrLoadable,
  isInstallRequired,
  truncateAddress,
  isAptosConnectWallet,
  getAptosConnectWallets,
  groupAndSortWallets,
  WalletCoreV1,
  WalletStandardCore,
  WalletCore,
  WalletContext,
  useWallet,
  AptosWalletAdapterProvider,
  EXPLORE_ECOSYSTEM_URL,
  AboutAptosConnect,
  APTOS_PRIVACY_POLICY_URL,
  AptosPrivacyPolicy,
  WalletItem
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@mizuwallet-sdk/aptos-wallet-adapter/dist/index.js:
  (*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> *)
  (*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   *)
  (**
    postmate - A powerful, simple, promise-based postMessage library
    @version v1.5.2
    @link https://github.com/dollarshaveclub/postmate
    @author Jacob Kelley <jakie8@gmail.com>
    @license MIT
  **)
*/
//# sourceMappingURL=chunk-FIVBHCCZ.js.map
