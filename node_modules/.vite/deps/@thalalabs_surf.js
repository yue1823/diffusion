import {
  j2 as j
} from "./chunk-QK5H62YW.js";
import "./chunk-HLYV2BFP.js";
import "./chunk-KEMPSE3P.js";
import "./chunk-OL46QLBJ.js";

// node_modules/@thalalabs/surf/build/esm/ensureTypes.js
function assertType(val, types, message) {
  if (!(types == null ? void 0 : types.includes(typeof val))) {
    throw new Error(message || `Invalid arg: ${val} type should be ${types instanceof Array ? types.join(" or ") : types}`);
  }
}
function ensureNumber(val) {
  assertType(val, ["number", "string"]);
  if (typeof val === "number") {
    return val;
  }
  const res = Number.parseInt(val, 10);
  if (Number.isNaN(res)) {
    throw new Error("Invalid number string.");
  }
  return res;
}

// node_modules/@thalalabs/surf/build/esm/core/createViewPayload.js
function createViewPayload(abi, payload) {
  const fnAbi = abi.exposed_functions.filter((f) => f.name === payload.function)[0];
  const type_arguments = payload.typeArguments;
  const val_arguments = payload.functionArguments;
  if (fnAbi === void 0)
    throw new Error(`Function ${payload.function} not found in ABI`);
  if (fnAbi.params.length !== val_arguments.length)
    throw new Error(`Function ${payload.function} expects ${fnAbi.params.length} arguments, but ${payload.functionArguments.length} were provided`);
  if (fnAbi.generic_type_params.length !== type_arguments.length)
    throw new Error(`Function ${payload.function} expects ${fnAbi.generic_type_params.length} type arguments, but ${payload.functionArguments.length} were provided`);
  const args = fnAbi.params.map((type, i) => {
    const arg = payload.functionArguments[i];
    if (["u8", "u16", "u32"].includes(type)) {
      return ensureNumber(arg);
    } else if (["u64", "u128", "u256"].includes(type)) {
      if (!(arg == null ? void 0 : arg.toString)) {
        throw new Error(`Expecting a bigint, but got ${arg}`);
      }
      return arg.toString();
    } else if (type.includes("vector")) {
      return encodeVector(type, arg);
    } else {
      return arg;
    }
  });
  return {
    function: `${payload.address ?? abi.address}::${abi.name}::${payload.function}`,
    functionArguments: args,
    typeArguments: payload.typeArguments,
    abi: constructViewAbiObj(fnAbi)
  };
}
function constructViewAbiObj(abi) {
  if (!abi.is_view) {
    throw new Error(`not an view function`);
  }
  const params = [];
  for (let i = 0; i < abi.params.length; i += 1) {
    params.push(j(abi.params[i], { allowGenerics: true }));
  }
  const returnTypes = [];
  for (let i = 0; i < abi.return.length; i += 1) {
    returnTypes.push(j(abi.return[i], { allowGenerics: true }));
  }
  return {
    typeParameters: abi.generic_type_params,
    parameters: params,
    returnTypes
  };
}
function encodeVector(type, value) {
  const regex = /vector<([^]+)>/;
  const match = type.match(regex);
  if (!match) {
    throw new Error(`Unsupported type: ${type}`);
  }
  const innerType = match[1];
  if (!innerType) {
    throw new Error(`Unsupported type: ${type}`);
  }
  if (innerType === "u8") {
    if (typeof value === "string" || value instanceof Uint8Array)
      return value;
    if (Array.isArray(value)) {
      return value;
    }
    throw new Error(`Invalid u8 value: ${value}`);
  } else if (["bool", "u16", "u32"].includes(innerType)) {
    return value;
  } else if (["u64", "u128", "u256"].includes(innerType)) {
    return value.map((v) => v.toString());
  } else {
    return value;
  }
}

// node_modules/@thalalabs/surf/build/esm/core/createEntryPayload.js
function createEntryPayload(abi, payload) {
  const fnAbi = abi.exposed_functions.filter((f) => f.name === payload.function)[0];
  if (fnAbi === void 0)
    throw new Error(`Function ${payload.function} not found in ABI`);
  const typeArguments = payload.typeArguments;
  const valArguments = payload.functionArguments;
  const abiArgs = fnAbi.params[0] === "&signer" ? fnAbi.params.slice(1) : fnAbi.params;
  if (fnAbi === void 0)
    throw new Error(`Function ${payload.function} not found in ABI`);
  if (abiArgs.length !== valArguments.length)
    throw new Error(`Function ${payload.function} expects ${fnAbi.params.length} arguments, but ${payload.functionArguments.length} were provided`);
  if (fnAbi.generic_type_params.length !== typeArguments.length)
    throw new Error(`Function ${payload.function} expects ${fnAbi.generic_type_params.length} type arguments, but ${payload.typeArguments.length} were provided`);
  return {
    typeArguments: payload.typeArguments,
    functionArguments: payload.functionArguments,
    function: `${payload.address ?? abi.address}::${abi.name}::${payload.function}`
  };
}

// node_modules/@thalalabs/surf/build/esm/core/Client.js
function createSurfClient(aptosClient) {
  return new Client(aptosClient);
}
var Client = class {
  constructor(client) {
    Object.defineProperty(this, "client", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.client = client;
  }
  async view(args) {
    return await this.client.view(args);
  }
  async submitTransaction(args) {
    const transaction = await this.client.transaction.build.simple({
      sender: args.signer.accountAddress.toString(),
      data: args.payload
    });
    const transactionRes = await this.client.transaction.signAndSubmitTransaction({
      signer: args.signer,
      transaction
    });
    return await this.client.waitForTransaction({
      transactionHash: transactionRes.hash,
      options: args.options ?? {}
    });
  }
  async simulateTransaction(args) {
    const transaction = await this.client.transaction.build.simple({
      sender: args.sender,
      data: args.payload
    });
    return (await this.client.transaction.simulate.simple({
      signerPublicKey: args.publicKey,
      transaction
    }))[0];
  }
  async fetchABI(address, moduleName) {
    return (await this.client.getAccountModule({
      accountAddress: address,
      moduleName
    })).abi;
  }
  useABI(abi, address) {
    return {
      view: new Proxy({}, {
        get: (_, prop) => {
          const functionName = prop.toString();
          return (...args) => {
            const payload = createViewPayload(abi, {
              address: address ?? abi.address,
              function: functionName,
              typeArguments: args[0].typeArguments,
              functionArguments: args[0].functionArguments
            });
            return this.view({
              payload,
              options: {
                ledgerVersion: args[0].ledgerVersion
              }
            });
          };
        }
      }),
      entry: new Proxy({}, {
        get: (_, prop) => {
          const functionName = prop.toString();
          return (...args) => {
            const payload = createEntryPayload(abi, {
              address: address ?? abi.address,
              function: functionName,
              typeArguments: args[0].typeArguments,
              functionArguments: args[0].functionArguments
            });
            const account = args[0].account;
            return args[0].isSimulation ? this.simulateTransaction({
              publicKey: account.publicKey,
              sender: account.accountAddress.toString(),
              payload
            }) : this.submitTransaction({
              signer: args[0].account,
              payload
            });
          };
        }
      }),
      resource: new Proxy({}, {
        get: (_, prop) => {
          let structName = prop.toString();
          return (...args) => {
            if (args[0].typeArguments.length !== 0) {
              structName += `<${args[0].typeArguments.join(",")}>`;
            }
            const account = args[0].account;
            return this.client.getAccountResource({
              accountAddress: account,
              resourceType: `${address ?? abi.address}::${abi.name}::${structName}`,
              options: {
                ledgerVersion: args[0].ledgerVersion
              }
            });
          };
        }
      })
    };
  }
};
export {
  createEntryPayload,
  createSurfClient,
  createViewPayload
};
//# sourceMappingURL=@thalalabs_surf.js.map
