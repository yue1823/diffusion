import {
  require_buffer
} from "./chunk-GKCZKDEA.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-OL46QLBJ.js";

// node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read,
  __rest: () => __rest,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values,
  default: () => tslib_es6_default
});
function __extends(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
function __rest(s, e) {
  var t = {};
  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
    t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f) {
    if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
    return f;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _, done = false;
  for (var i = decorators.length - 1; i >= 0; i--) {
    var context = {};
    for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
    for (var p in contextIn.access) context.access[p] = contextIn.access[p];
    context.addInitializer = function(f) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f || null));
    };
    var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_ = accept(result.get)) descriptor.get = _;
      if (_ = accept(result.set)) descriptor.set = _;
      if (_ = accept(result.init)) initializers.unshift(_);
    } else if (_ = accept(result)) {
      if (kind === "field") initializers.unshift(_);
      else descriptor[key] = _;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i = 0; i < initializers.length; i++) {
    value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x) {
  return typeof x === "symbol" ? x : "".concat(x);
}
function __setFunctionName(f, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1) throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f) throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _) try {
      if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
      if (y = 0, t) op = [op[0] & 2, t.value];
      switch (op[0]) {
        case 0:
        case 1:
          t = op;
          break;
        case 4:
          _.label++;
          return { value: op[1], done: false };
        case 5:
          _.label++;
          y = op[1];
          op = [0];
          continue;
        case 7:
          op = _.ops.pop();
          _.trys.pop();
          continue;
        default:
          if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _ = 0;
            continue;
          }
          if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
            _.label = op[1];
            break;
          }
          if (op[0] === 6 && _.label < t[1]) {
            _.label = t[1];
            t = op;
            break;
          }
          if (t && _.label < t[2]) {
            _.label = t[2];
            _.ops.push(op);
            break;
          }
          if (t[2]) _.ops.pop();
          _.trys.pop();
          continue;
      }
      op = body.call(thisArg, _);
    } catch (e) {
      op = [6, e];
      y = 0;
    } finally {
      f = t = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m, o) {
  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
}
function __spread() {
  for (var ar = [], i = 0; i < arguments.length; i++)
    ar = ar.concat(__read(arguments[i]));
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
}
function __await(v) {
  return this instanceof __await ? (this.v = v, this) : new __await(v);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g = generator.apply(thisArg, _arguments || []), i, q = [];
  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function() {
    return this;
  }, i;
  function awaitReturn(f) {
    return function(v) {
      return Promise.resolve(v).then(f, reject);
    };
  }
  function verb(n, f) {
    if (g[n]) {
      i[n] = function(v) {
        return new Promise(function(a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
      if (f) i[n] = f(i[n]);
    }
  }
  function resume(n, v) {
    try {
      step(g[n](v));
    } catch (e) {
      settle(q[0][3], e);
    }
  }
  function step(r) {
    r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle(f, v) {
    if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
  }
}
function __asyncDelegator(o) {
  var i, p;
  return i = {}, verb("next"), verb("throw", function(e) {
    throw e;
  }), verb("return"), i[Symbol.iterator] = function() {
    return this;
  }, i;
  function verb(n, f) {
    i[n] = o[n] ? function(v) {
      return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v;
    } : f;
  }
}
function __asyncValues(o) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m = o[Symbol.asyncIterator], i;
  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function() {
    return this;
  }, i);
  function verb(n) {
    i[n] = o[n] && function(v) {
      return new Promise(function(resolve, reject) {
        v = o[n](v), settle(resolve, reject, v.done, v.value);
      });
    };
  }
  function settle(resolve, reject, d, v) {
    Promise.resolve(v).then(function(v2) {
      resolve({ value: v2, done: d });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod) {
  if (mod && mod.__esModule) return mod;
  var result = {};
  if (mod != null) {
    for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
  }
  __setModuleDefault(result, mod);
  return result;
}
function __importDefault(mod) {
  return mod && mod.__esModule ? mod : { default: mod };
}
function __classPrivateFieldGet(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e) {
        return Promise.reject(e);
      }
    };
    env.stack.push({ value, dispose, async });
  } else if (async) {
    env.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env) {
  function fail(e) {
    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;
    env.hasError = true;
  }
  var r, s = 0;
  function next() {
    while (r = env.stack.pop()) {
      try {
        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);
        if (r.dispose) {
          var result = r.dispose.call(r.value);
          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) {
            fail(e);
            return next();
          });
        } else s |= 1;
      } catch (e) {
        fail(e);
      }
    }
    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();
    if (env.hasError) throw env.error;
  }
  return next();
}
var extendStatics, __assign, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es6 = __esm({
  "node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d, b) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
        d2.__proto__ = b2;
      } || function(d2, b2) {
        for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
      };
      return extendStatics(d, b);
    };
    __assign = function() {
      __assign = Object.assign || function __assign2(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    };
    __setModuleDefault = Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e = new Error(message);
      return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
    };
    tslib_es6_default = {
      __extends,
      __assign,
      __rest,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values,
      __read,
      __spread,
      __spreadArrays,
      __spreadArray,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// node_modules/decimal.js/decimal.js
var require_decimal = __commonJS({
  "node_modules/decimal.js/decimal.js"(exports, module) {
    (function(globalScope) {
      "use strict";
      var EXP_LIMIT = 9e15, MAX_DIGITS = 1e9, NUMERALS = "0123456789abcdef", LN10 = "2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058", PI = "3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789", DEFAULTS = {
        // These values must be integers within the stated ranges (inclusive).
        // Most of these values can be changed at run-time using the `Decimal.config` method.
        // The maximum number of significant digits of the result of a calculation or base conversion.
        // E.g. `Decimal.config({ precision: 20 });`
        precision: 20,
        // 1 to MAX_DIGITS
        // The rounding mode used when rounding to `precision`.
        //
        // ROUND_UP         0 Away from zero.
        // ROUND_DOWN       1 Towards zero.
        // ROUND_CEIL       2 Towards +Infinity.
        // ROUND_FLOOR      3 Towards -Infinity.
        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.
        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.
        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.
        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.
        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.
        //
        // E.g.
        // `Decimal.rounding = 4;`
        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`
        rounding: 4,
        // 0 to 8
        // The modulo mode used when calculating the modulus: a mod n.
        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.
        // The remainder (r) is calculated as: r = a - n * q.
        //
        // UP         0 The remainder is positive if the dividend is negative, else is negative.
        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).
        // FLOOR      3 The remainder has the same sign as the divisor (Python %).
        // HALF_EVEN  6 The IEEE 754 remainder function.
        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.
        //
        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian
        // division (9) are commonly used for the modulus operation. The other rounding modes can also
        // be used, but they may not give useful results.
        modulo: 1,
        // 0 to 9
        // The exponent value at and beneath which `toString` returns exponential notation.
        // JavaScript numbers: -7
        toExpNeg: -7,
        // 0 to -EXP_LIMIT
        // The exponent value at and above which `toString` returns exponential notation.
        // JavaScript numbers: 21
        toExpPos: 21,
        // 0 to EXP_LIMIT
        // The minimum exponent value, beneath which underflow to zero occurs.
        // JavaScript numbers: -324  (5e-324)
        minE: -EXP_LIMIT,
        // -1 to -EXP_LIMIT
        // The maximum exponent value, above which overflow to Infinity occurs.
        // JavaScript numbers: 308  (1.7976931348623157e+308)
        maxE: EXP_LIMIT,
        // 1 to EXP_LIMIT
        // Whether to use cryptographically-secure random number generation, if available.
        crypto: false
        // true/false
      }, Decimal, inexact, noConflict, quadrant, external = true, decimalError = "[DecimalError] ", invalidArgument = decimalError + "Invalid argument: ", precisionLimitExceeded = decimalError + "Precision limit exceeded", cryptoUnavailable = decimalError + "crypto unavailable", tag = "[object Decimal]", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\.[01]*)?|\.[01]+)(p[+-]?\d+)?$/i, isHex = /^0x([0-9a-f]+(\.[0-9a-f]*)?|\.[0-9a-f]+)(p[+-]?\d+)?$/i, isOctal = /^0o([0-7]+(\.[0-7]*)?|\.[0-7]+)(p[+-]?\d+)?$/i, isDecimal = /^(\d+(\.\d*)?|\.\d+)(e[+-]?\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, P = { toStringTag: tag };
      P.absoluteValue = P.abs = function() {
        var x = new this.constructor(this);
        if (x.s < 0) x.s = 1;
        return finalise(x);
      };
      P.ceil = function() {
        return finalise(new this.constructor(this), this.e + 1, 2);
      };
      P.clampedTo = P.clamp = function(min2, max2) {
        var k, x = this, Ctor = x.constructor;
        min2 = new Ctor(min2);
        max2 = new Ctor(max2);
        if (!min2.s || !max2.s) return new Ctor(NaN);
        if (min2.gt(max2)) throw Error(invalidArgument + max2);
        k = x.cmp(min2);
        return k < 0 ? min2 : x.cmp(max2) > 0 ? max2 : new Ctor(x);
      };
      P.comparedTo = P.cmp = function(y) {
        var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;
        if (!xd || !yd) {
          return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;
        }
        if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;
        if (xs !== ys) return xs;
        if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;
        xdL = xd.length;
        ydL = yd.length;
        for (i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i) {
          if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;
        }
        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;
      };
      P.cosine = P.cos = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.d) return new Ctor(NaN);
        if (!x.d[0]) return new Ctor(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = cosine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);
      };
      P.cubeRoot = P.cbrt = function() {
        var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        external = false;
        s = x.s * mathpow(x.s * x, 1 / 3);
        if (!s || Math.abs(s) == 1 / 0) {
          n = digitsToString(x.d);
          e = x.e;
          if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? "0" : "00";
          s = mathpow(n, 1 / 3);
          e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
          r.s = x.s;
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          t3 = t.times(t).times(t);
          t3plusx = t3.plus(x);
          r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e + 1, 0);
                if (t.times(t).times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e + 1, 1);
                m = !r.times(r).times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      P.decimalPlaces = P.dp = function() {
        var w, d = this.d, n = NaN;
        if (d) {
          w = d.length - 1;
          n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;
          w = d[w];
          if (w) for (; w % 10 == 0; w /= 10) n--;
          if (n < 0) n = 0;
        }
        return n;
      };
      P.dividedBy = P.div = function(y) {
        return divide(this, new this.constructor(y));
      };
      P.dividedToIntegerBy = P.divToInt = function(y) {
        var x = this, Ctor = x.constructor;
        return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);
      };
      P.equals = P.eq = function(y) {
        return this.cmp(y) === 0;
      };
      P.floor = function() {
        return finalise(new this.constructor(this), this.e + 1, 3);
      };
      P.greaterThan = P.gt = function(y) {
        return this.cmp(y) > 0;
      };
      P.greaterThanOrEqualTo = P.gte = function(y) {
        var k = this.cmp(y);
        return k == 1 || k === 0;
      };
      P.hyperbolicCosine = P.cosh = function() {
        var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);
        if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);
        if (x.isZero()) return one;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          n = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          n = "2.3283064365386962890625e-10";
        }
        x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);
        var cosh2_x, i = k, d8 = new Ctor(8);
        for (; i--; ) {
          cosh2_x = x.times(x);
          x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));
        }
        return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P.hyperbolicSine = P.sinh = function() {
        var k, pr, rm, len, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;
        Ctor.rounding = 1;
        len = x.d.length;
        if (len < 3) {
          x = taylorSeries(Ctor, 2, x, x, true);
        } else {
          k = 1.4 * Math.sqrt(len);
          k = k > 16 ? 16 : k | 0;
          x = x.times(1 / tinyPow(5, k));
          x = taylorSeries(Ctor, 2, x, x, true);
          var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
          for (; k--; ) {
            sinh2_x = x.times(x);
            x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));
          }
        }
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(x, pr, rm, true);
      };
      P.hyperbolicTangent = P.tanh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(x.s);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 7;
        Ctor.rounding = 1;
        return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);
      };
      P.inverseCosine = P.acos = function() {
        var halfPi, x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;
        if (k !== -1) {
          return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);
        }
        if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.asin();
        halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return halfPi.minus(x);
      };
      P.inverseHyperbolicCosine = P.acosh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);
        if (!x.isFinite()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).minus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P.inverseHyperbolicSine = P.asinh = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite() || x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;
        Ctor.rounding = 1;
        external = false;
        x = x.times(x).plus(1).sqrt().plus(x);
        external = true;
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.ln();
      };
      P.inverseHyperbolicTangent = P.atanh = function() {
        var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        xsd = x.sd();
        if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);
        Ctor.precision = wpr = xsd - x.e;
        x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);
        Ctor.precision = pr + 4;
        Ctor.rounding = 1;
        x = x.ln();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(0.5);
      };
      P.inverseSine = P.asin = function() {
        var halfPi, k, pr, rm, x = this, Ctor = x.constructor;
        if (x.isZero()) return new Ctor(x);
        k = x.abs().cmp(1);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (k !== -1) {
          if (k === 0) {
            halfPi = getPi(Ctor, pr + 4, rm).times(0.5);
            halfPi.s = x.s;
            return halfPi;
          }
          return new Ctor(NaN);
        }
        Ctor.precision = pr + 6;
        Ctor.rounding = 1;
        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return x.times(2);
      };
      P.inverseTangent = P.atan = function() {
        var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;
        if (!x.isFinite()) {
          if (!x.s) return new Ctor(NaN);
          if (pr + 4 <= PI_PRECISION) {
            r = getPi(Ctor, pr + 4, rm).times(0.5);
            r.s = x.s;
            return r;
          }
        } else if (x.isZero()) {
          return new Ctor(x);
        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {
          r = getPi(Ctor, pr + 4, rm).times(0.25);
          r.s = x.s;
          return r;
        }
        Ctor.precision = wpr = pr + 10;
        Ctor.rounding = 1;
        k = Math.min(28, wpr / LOG_BASE + 2 | 0);
        for (i = k; i; --i) x = x.div(x.times(x).plus(1).sqrt().plus(1));
        external = false;
        j = Math.ceil(wpr / LOG_BASE);
        n = 1;
        x2 = x.times(x);
        r = new Ctor(x);
        px = x;
        for (; i !== -1; ) {
          px = px.times(x2);
          t = r.minus(px.div(n += 2));
          px = px.times(x2);
          r = t.plus(px.div(n += 2));
          if (r.d[j] !== void 0) for (i = j; r.d[i] === t.d[i] && i--; ) ;
        }
        if (k) r = r.times(2 << k - 1);
        external = true;
        return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);
      };
      P.isFinite = function() {
        return !!this.d;
      };
      P.isInteger = P.isInt = function() {
        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = P.isNeg = function() {
        return this.s < 0;
      };
      P.isPositive = P.isPos = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.d && this.d[0] === 0;
      };
      P.lessThan = P.lt = function(y) {
        return this.cmp(y) < 0;
      };
      P.lessThanOrEqualTo = P.lte = function(y) {
        return this.cmp(y) < 1;
      };
      P.logarithm = P.log = function(base) {
        var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;
        if (base == null) {
          base = new Ctor(10);
          isBase10 = true;
        } else {
          base = new Ctor(base);
          d = base.d;
          if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);
          isBase10 = base.eq(10);
        }
        d = arg.d;
        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {
          return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);
        }
        if (isBase10) {
          if (d.length > 1) {
            inf = true;
          } else {
            for (k = d[0]; k % 10 === 0; ) k /= 10;
            inf = k !== 1;
          }
        }
        external = false;
        sd = pr + guard;
        num = naturalLogarithm(arg, sd);
        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
        r = divide(num, denominator, sd, 1);
        if (checkRoundingDigits(r.d, k = pr, rm)) {
          do {
            sd += 10;
            num = naturalLogarithm(arg, sd);
            denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);
            r = divide(num, denominator, sd, 1);
            if (!inf) {
              if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {
                r = finalise(r, pr + 1, 0);
              }
              break;
            }
          } while (checkRoundingDigits(r.d, k += 10, rm));
        }
        external = true;
        return finalise(r, pr, rm);
      };
      P.minus = P.sub = function(y) {
        var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s) y = new Ctor(NaN);
          else if (x.d) y.s = -y.s;
          else y = new Ctor(y.d || x.s !== y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.plus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (yd[0]) y.s = -y.s;
          else if (xd[0]) y = new Ctor(x);
          else return new Ctor(rm === 3 ? -0 : 0);
          return external ? finalise(y, pr, rm) : y;
        }
        e = mathfloor(y.e / LOG_BASE);
        xe = mathfloor(x.e / LOG_BASE);
        xd = xd.slice();
        k = xe - e;
        if (k) {
          xLTy = k < 0;
          if (xLTy) {
            d = xd;
            k = -k;
            len = yd.length;
          } else {
            d = yd;
            e = xe;
            len = xd.length;
          }
          i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;
          if (k > i) {
            k = i;
            d.length = 1;
          }
          d.reverse();
          for (i = k; i--; ) d.push(0);
          d.reverse();
        } else {
          i = xd.length;
          len = yd.length;
          xLTy = i < len;
          if (xLTy) len = i;
          for (i = 0; i < len; i++) {
            if (xd[i] != yd[i]) {
              xLTy = xd[i] < yd[i];
              break;
            }
          }
          k = 0;
        }
        if (xLTy) {
          d = xd;
          xd = yd;
          yd = d;
          y.s = -y.s;
        }
        len = xd.length;
        for (i = yd.length - len; i > 0; --i) xd[len++] = 0;
        for (i = yd.length; i > k; ) {
          if (xd[--i] < yd[i]) {
            for (j = i; j && xd[--j] === 0; ) xd[j] = BASE - 1;
            --xd[j];
            xd[i] += BASE;
          }
          xd[i] -= yd[i];
        }
        for (; xd[--len] === 0; ) xd.pop();
        for (; xd[0] === 0; xd.shift()) --e;
        if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);
        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      P.modulo = P.mod = function(y) {
        var q, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);
        if (!y.d || x.d && !x.d[0]) {
          return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);
        }
        external = false;
        if (Ctor.modulo == 9) {
          q = divide(x, y.abs(), 0, 3, 1);
          q.s *= y.s;
        } else {
          q = divide(x, y, 0, Ctor.modulo, 1);
        }
        q = q.times(y);
        external = true;
        return x.minus(q);
      };
      P.naturalExponential = P.exp = function() {
        return naturalExponential(this);
      };
      P.naturalLogarithm = P.ln = function() {
        return naturalLogarithm(this);
      };
      P.negated = P.neg = function() {
        var x = new this.constructor(this);
        x.s = -x.s;
        return finalise(x);
      };
      P.plus = P.add = function(y) {
        var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;
        y = new Ctor(y);
        if (!x.d || !y.d) {
          if (!x.s || !y.s) y = new Ctor(NaN);
          else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);
          return y;
        }
        if (x.s != y.s) {
          y.s = -y.s;
          return x.minus(y);
        }
        xd = x.d;
        yd = y.d;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (!xd[0] || !yd[0]) {
          if (!yd[0]) y = new Ctor(x);
          return external ? finalise(y, pr, rm) : y;
        }
        k = mathfloor(x.e / LOG_BASE);
        e = mathfloor(y.e / LOG_BASE);
        xd = xd.slice();
        i = k - e;
        if (i) {
          if (i < 0) {
            d = xd;
            i = -i;
            len = yd.length;
          } else {
            d = yd;
            e = k;
            len = xd.length;
          }
          k = Math.ceil(pr / LOG_BASE);
          len = k > len ? k + 1 : len + 1;
          if (i > len) {
            i = len;
            d.length = 1;
          }
          d.reverse();
          for (; i--; ) d.push(0);
          d.reverse();
        }
        len = xd.length;
        i = yd.length;
        if (len - i < 0) {
          i = len;
          d = yd;
          yd = xd;
          xd = d;
        }
        for (carry = 0; i; ) {
          carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;
          xd[i] %= BASE;
        }
        if (carry) {
          xd.unshift(carry);
          ++e;
        }
        for (len = xd.length; xd[--len] == 0; ) xd.pop();
        y.d = xd;
        y.e = getBase10Exponent(xd, e);
        return external ? finalise(y, pr, rm) : y;
      };
      P.precision = P.sd = function(z) {
        var k, x = this;
        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);
        if (x.d) {
          k = getPrecision(x.d);
          if (z && x.e + 1 > k) k = x.e + 1;
        } else {
          k = NaN;
        }
        return k;
      };
      P.round = function() {
        var x = this, Ctor = x.constructor;
        return finalise(new Ctor(x), x.e + 1, Ctor.rounding);
      };
      P.sine = P.sin = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;
        Ctor.rounding = 1;
        x = sine(Ctor, toLessThanHalfPi(Ctor, x));
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;
        if (s !== 1 || !d || !d[0]) {
          return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);
        }
        external = false;
        s = Math.sqrt(+x);
        if (s == 0 || s == 1 / 0) {
          n = digitsToString(d);
          if ((n.length + e) % 2 == 0) n += "0";
          s = Math.sqrt(n);
          e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new Ctor(n);
        } else {
          r = new Ctor(s.toString());
        }
        sd = (e = Ctor.precision) + 3;
        for (; ; ) {
          t = r;
          r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);
          if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {
            n = n.slice(sd - 3, sd + 1);
            if (n == "9999" || !rep && n == "4999") {
              if (!rep) {
                finalise(t, e + 1, 0);
                if (t.times(t).eq(x)) {
                  r = t;
                  break;
                }
              }
              sd += 4;
              rep = 1;
            } else {
              if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                finalise(r, e + 1, 1);
                m = !r.times(r).eq(x);
              }
              break;
            }
          }
        }
        external = true;
        return finalise(r, e, Ctor.rounding, m);
      };
      P.tangent = P.tan = function() {
        var pr, rm, x = this, Ctor = x.constructor;
        if (!x.isFinite()) return new Ctor(NaN);
        if (x.isZero()) return new Ctor(x);
        pr = Ctor.precision;
        rm = Ctor.rounding;
        Ctor.precision = pr + 10;
        Ctor.rounding = 1;
        x = x.sin();
        x.s = 1;
        x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);
        Ctor.precision = pr;
        Ctor.rounding = rm;
        return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);
      };
      P.times = P.mul = function(y) {
        var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;
        y.s *= x.s;
        if (!xd || !xd[0] || !yd || !yd[0]) {
          return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);
        }
        e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);
        xdL = xd.length;
        ydL = yd.length;
        if (xdL < ydL) {
          r = xd;
          xd = yd;
          yd = r;
          rL = xdL;
          xdL = ydL;
          ydL = rL;
        }
        r = [];
        rL = xdL + ydL;
        for (i = rL; i--; ) r.push(0);
        for (i = ydL; --i >= 0; ) {
          carry = 0;
          for (k = xdL + i; k > i; ) {
            t = r[k] + yd[i] * xd[k - i - 1] + carry;
            r[k--] = t % BASE | 0;
            carry = t / BASE | 0;
          }
          r[k] = (r[k] + carry) % BASE | 0;
        }
        for (; !r[--rL]; ) r.pop();
        if (carry) ++e;
        else r.shift();
        y.d = r;
        y.e = getBase10Exponent(r, e);
        return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;
      };
      P.toBinary = function(sd, rm) {
        return toStringBinary(this, 2, sd, rm);
      };
      P.toDecimalPlaces = P.toDP = function(dp, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (dp === void 0) return x;
        checkInt32(dp, 0, MAX_DIGITS);
        if (rm === void 0) rm = Ctor.rounding;
        else checkInt32(rm, 0, 8);
        return finalise(x, dp + x.e + 1, rm);
      };
      P.toExponential = function(dp, rm) {
        var str, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x, true);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), dp + 1, rm);
          str = finiteToString(x, true, dp + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toFixed = function(dp, rm) {
        var str, y, x = this, Ctor = x.constructor;
        if (dp === void 0) {
          str = finiteToString(x);
        } else {
          checkInt32(dp, 0, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          y = finalise(new Ctor(x), dp + x.e + 1, rm);
          str = finiteToString(y, false, dp + y.e + 1);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toFraction = function(maxD) {
        var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;
        if (!xd) return new Ctor(x);
        n1 = d0 = new Ctor(1);
        d1 = n0 = new Ctor(0);
        d = new Ctor(d1);
        e = d.e = getPrecision(xd) - x.e - 1;
        k = e % LOG_BASE;
        d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);
        if (maxD == null) {
          maxD = e > 0 ? d : n1;
        } else {
          n = new Ctor(maxD);
          if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);
          maxD = n.gt(d) ? e > 0 ? d : n1 : n;
        }
        external = false;
        n = new Ctor(digitsToString(xd));
        pr = Ctor.precision;
        Ctor.precision = e = xd.length * LOG_BASE * 2;
        for (; ; ) {
          q = divide(n, d, 0, 1, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.cmp(maxD) == 1) break;
          d0 = d1;
          d1 = d2;
          d2 = n1;
          n1 = n0.plus(q.times(d2));
          n0 = d2;
          d2 = d;
          d = n.minus(q.times(d2));
          n = d2;
        }
        d2 = divide(maxD.minus(d0), d1, 0, 1, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        Ctor.precision = pr;
        external = true;
        return r;
      };
      P.toHexadecimal = P.toHex = function(sd, rm) {
        return toStringBinary(this, 16, sd, rm);
      };
      P.toNearest = function(y, rm) {
        var x = this, Ctor = x.constructor;
        x = new Ctor(x);
        if (y == null) {
          if (!x.d) return x;
          y = new Ctor(1);
          rm = Ctor.rounding;
        } else {
          y = new Ctor(y);
          if (rm === void 0) {
            rm = Ctor.rounding;
          } else {
            checkInt32(rm, 0, 8);
          }
          if (!x.d) return y.s ? x : y;
          if (!y.d) {
            if (y.s) y.s = x.s;
            return y;
          }
        }
        if (y.d[0]) {
          external = false;
          x = divide(x, y, 0, rm, 1).times(y);
          external = true;
          finalise(x);
        } else {
          y.s = x.s;
          x = y;
        }
        return x;
      };
      P.toNumber = function() {
        return +this;
      };
      P.toOctal = function(sd, rm) {
        return toStringBinary(this, 8, sd, rm);
      };
      P.toPower = P.pow = function(y) {
        var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));
        if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));
        x = new Ctor(x);
        if (x.eq(1)) return x;
        pr = Ctor.precision;
        rm = Ctor.rounding;
        if (y.eq(1)) return finalise(x, pr, rm);
        e = mathfloor(y.e / LOG_BASE);
        if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {
          r = intPow(Ctor, x, k, pr);
          return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);
        }
        s = x.s;
        if (s < 0) {
          if (e < y.d.length - 1) return new Ctor(NaN);
          if ((y.d[e] & 1) == 0) s = 1;
          if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {
            x.s = s;
            return x;
          }
        }
        k = mathpow(+x, yn);
        e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log("0." + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + "").e;
        if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);
        external = false;
        Ctor.rounding = x.s = 1;
        k = Math.min(12, (e + "").length);
        r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);
        if (r.d) {
          r = finalise(r, pr + 5, 1);
          if (checkRoundingDigits(r.d, pr, rm)) {
            e = pr + 10;
            r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);
            if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {
              r = finalise(r, pr + 1, 0);
            }
          }
        }
        r.s = s;
        external = true;
        Ctor.rounding = rm;
        return finalise(r, pr, rm);
      };
      P.toPrecision = function(sd, rm) {
        var str, x = this, Ctor = x.constructor;
        if (sd === void 0) {
          str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
          x = finalise(new Ctor(x), sd, rm);
          str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);
        }
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.toSignificantDigits = P.toSD = function(sd, rm) {
        var x = this, Ctor = x.constructor;
        if (sd === void 0) {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        } else {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        }
        return finalise(new Ctor(x), sd, rm);
      };
      P.toString = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() && !x.isZero() ? "-" + str : str;
      };
      P.truncated = P.trunc = function() {
        return finalise(new this.constructor(this), this.e + 1, 1);
      };
      P.valueOf = P.toJSON = function() {
        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);
        return x.isNeg() ? "-" + str : str;
      };
      function digitsToString(d) {
        var i, k, ws, indexOfLastWord = d.length - 1, str = "", w = d[0];
        if (indexOfLastWord > 0) {
          str += w;
          for (i = 1; i < indexOfLastWord; i++) {
            ws = d[i] + "";
            k = LOG_BASE - ws.length;
            if (k) str += getZeroString(k);
            str += ws;
          }
          w = d[i];
          ws = w + "";
          k = LOG_BASE - ws.length;
          if (k) str += getZeroString(k);
        } else if (w === 0) {
          return "0";
        }
        for (; w % 10 === 0; ) w /= 10;
        return str + w;
      }
      function checkInt32(i, min2, max2) {
        if (i !== ~~i || i < min2 || i > max2) {
          throw Error(invalidArgument + i);
        }
      }
      function checkRoundingDigits(d, i, rm, repeating) {
        var di, k, r, rd;
        for (k = d[0]; k >= 10; k /= 10) --i;
        if (--i < 0) {
          i += LOG_BASE;
          di = 0;
        } else {
          di = Math.ceil((i + 1) / LOG_BASE);
          i %= LOG_BASE;
        }
        k = mathpow(10, LOG_BASE - i);
        rd = d[di] % k | 0;
        if (repeating == null) {
          if (i < 3) {
            if (i == 0) rd = rd / 100 | 0;
            else if (i == 1) rd = rd / 10 | 0;
            r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 5e4 || rd == 0;
          } else {
            r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;
          }
        } else {
          if (i < 4) {
            if (i == 0) rd = rd / 1e3 | 0;
            else if (i == 1) rd = rd / 100 | 0;
            else if (i == 2) rd = rd / 10 | 0;
            r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;
          } else {
            r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1e3 | 0) == mathpow(10, i - 3) - 1;
          }
        }
        return r;
      }
      function convertBase(str, baseIn, baseOut) {
        var j, arr = [0], arrL, i = 0, strL = str.length;
        for (; i < strL; ) {
          for (arrL = arr.length; arrL--; ) arr[arrL] *= baseIn;
          arr[0] += NUMERALS.indexOf(str.charAt(i++));
          for (j = 0; j < arr.length; j++) {
            if (arr[j] > baseOut - 1) {
              if (arr[j + 1] === void 0) arr[j + 1] = 0;
              arr[j + 1] += arr[j] / baseOut | 0;
              arr[j] %= baseOut;
            }
          }
        }
        return arr.reverse();
      }
      function cosine(Ctor, x) {
        var k, len, y;
        if (x.isZero()) return x;
        len = x.d.length;
        if (len < 32) {
          k = Math.ceil(len / 3);
          y = (1 / tinyPow(4, k)).toString();
        } else {
          k = 16;
          y = "2.3283064365386962890625e-10";
        }
        Ctor.precision += k;
        x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));
        for (var i = k; i--; ) {
          var cos2x = x.times(x);
          x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);
        }
        Ctor.precision -= k;
        return x;
      }
      var divide = /* @__PURE__ */ function() {
        function multiplyInteger(x, k, base) {
          var temp, carry = 0, i = x.length;
          for (x = x.slice(); i--; ) {
            temp = x[i] * k + carry;
            x[i] = temp % base | 0;
            carry = temp / base | 0;
          }
          if (carry) x.unshift(carry);
          return x;
        }
        function compare(a, b, aL, bL) {
          var i, r;
          if (aL != bL) {
            r = aL > bL ? 1 : -1;
          } else {
            for (i = r = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                r = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return r;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; ) a.shift();
        }
        return function(x, y, pr, rm, dp, base) {
          var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign2 = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;
          if (!xd || !xd[0] || !yd || !yd[0]) {
            return new Ctor(
              // Return NaN if either NaN, or both Infinity or 0.
              !x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : (
                // Return 0 if x is 0 or y is Infinity, or return Infinity as y is 0.
                xd && xd[0] == 0 || !yd ? sign2 * 0 : sign2 / 0
              )
            );
          }
          if (base) {
            logBase = 1;
            e = x.e - y.e;
          } else {
            base = BASE;
            logBase = LOG_BASE;
            e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);
          }
          yL = yd.length;
          xL = xd.length;
          q = new Ctor(sign2);
          qd = q.d = [];
          for (i = 0; yd[i] == (xd[i] || 0); i++) ;
          if (yd[i] > (xd[i] || 0)) e--;
          if (pr == null) {
            sd = pr = Ctor.precision;
            rm = Ctor.rounding;
          } else if (dp) {
            sd = pr + (x.e - y.e) + 1;
          } else {
            sd = pr;
          }
          if (sd < 0) {
            qd.push(1);
            more = true;
          } else {
            sd = sd / logBase + 2 | 0;
            i = 0;
            if (yL == 1) {
              k = 0;
              yd = yd[0];
              sd++;
              for (; (i < xL || k) && sd--; i++) {
                t = k * base + (xd[i] || 0);
                qd[i] = t / yd | 0;
                k = t % yd | 0;
              }
              more = k || i < xL;
            } else {
              k = base / (yd[0] + 1) | 0;
              if (k > 1) {
                yd = multiplyInteger(yd, k, base);
                xd = multiplyInteger(xd, k, base);
                yL = yd.length;
                xL = xd.length;
              }
              xi = yL;
              rem = xd.slice(0, yL);
              remL = rem.length;
              for (; remL < yL; ) rem[remL++] = 0;
              yz = yd.slice();
              yz.unshift(0);
              yd0 = yd[0];
              if (yd[1] >= base / 2) ++yd0;
              do {
                k = 0;
                cmp = compare(yd, rem, yL, remL);
                if (cmp < 0) {
                  rem0 = rem[0];
                  if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);
                  k = rem0 / yd0 | 0;
                  if (k > 1) {
                    if (k >= base) k = base - 1;
                    prod = multiplyInteger(yd, k, base);
                    prodL = prod.length;
                    remL = rem.length;
                    cmp = compare(prod, rem, prodL, remL);
                    if (cmp == 1) {
                      k--;
                      subtract(prod, yL < prodL ? yz : yd, prodL, base);
                    }
                  } else {
                    if (k == 0) cmp = k = 1;
                    prod = yd.slice();
                  }
                  prodL = prod.length;
                  if (prodL < remL) prod.unshift(0);
                  subtract(rem, prod, remL, base);
                  if (cmp == -1) {
                    remL = rem.length;
                    cmp = compare(yd, rem, yL, remL);
                    if (cmp < 1) {
                      k++;
                      subtract(rem, yL < remL ? yz : yd, remL, base);
                    }
                  }
                  remL = rem.length;
                } else if (cmp === 0) {
                  k++;
                  rem = [0];
                }
                qd[i++] = k;
                if (cmp && rem[0]) {
                  rem[remL++] = xd[xi] || 0;
                } else {
                  rem = [xd[xi]];
                  remL = 1;
                }
              } while ((xi++ < xL || rem[0] !== void 0) && sd--);
              more = rem[0] !== void 0;
            }
            if (!qd[0]) qd.shift();
          }
          if (logBase == 1) {
            q.e = e;
            inexact = more;
          } else {
            for (i = 1, k = qd[0]; k >= 10; k /= 10) i++;
            q.e = i + e * logBase - 1;
            finalise(q, dp ? pr + q.e + 1 : pr, rm, more);
          }
          return q;
        };
      }();
      function finalise(x, sd, rm, isTruncated) {
        var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;
        out: if (sd != null) {
          xd = x.d;
          if (!xd) return x;
          for (digits = 1, k = xd[0]; k >= 10; k /= 10) digits++;
          i = sd - digits;
          if (i < 0) {
            i += LOG_BASE;
            j = sd;
            w = xd[xdi = 0];
            rd = w / mathpow(10, digits - j - 1) % 10 | 0;
          } else {
            xdi = Math.ceil((i + 1) / LOG_BASE);
            k = xd.length;
            if (xdi >= k) {
              if (isTruncated) {
                for (; k++ <= xdi; ) xd.push(0);
                w = rd = 0;
                digits = 1;
                i %= LOG_BASE;
                j = i - LOG_BASE + 1;
              } else {
                break out;
              }
            } else {
              w = k = xd[xdi];
              for (digits = 1; k >= 10; k /= 10) digits++;
              i %= LOG_BASE;
              j = i - LOG_BASE + digits;
              rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;
            }
          }
          isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));
          roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && // Check whether the digit to the left of the rounding digit is odd.
          (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
          if (sd < 1 || !xd[0]) {
            xd.length = 0;
            if (roundUp) {
              sd -= x.e + 1;
              xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);
              x.e = -sd || 0;
            } else {
              xd[0] = x.e = 0;
            }
            return x;
          }
          if (i == 0) {
            xd.length = xdi;
            k = 1;
            xdi--;
          } else {
            xd.length = xdi + 1;
            k = mathpow(10, LOG_BASE - i);
            xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;
          }
          if (roundUp) {
            for (; ; ) {
              if (xdi == 0) {
                for (i = 1, j = xd[0]; j >= 10; j /= 10) i++;
                j = xd[0] += k;
                for (k = 1; j >= 10; j /= 10) k++;
                if (i != k) {
                  x.e++;
                  if (xd[0] == BASE) xd[0] = 1;
                }
                break;
              } else {
                xd[xdi] += k;
                if (xd[xdi] != BASE) break;
                xd[xdi--] = 0;
                k = 1;
              }
            }
          }
          for (i = xd.length; xd[--i] === 0; ) xd.pop();
        }
        if (external) {
          if (x.e > Ctor.maxE) {
            x.d = null;
            x.e = NaN;
          } else if (x.e < Ctor.minE) {
            x.e = 0;
            x.d = [0];
          }
        }
        return x;
      }
      function finiteToString(x, isExp, sd) {
        if (!x.isFinite()) return nonFiniteToString(x);
        var k, e = x.e, str = digitsToString(x.d), len = str.length;
        if (isExp) {
          if (sd && (k = sd - len) > 0) {
            str = str.charAt(0) + "." + str.slice(1) + getZeroString(k);
          } else if (len > 1) {
            str = str.charAt(0) + "." + str.slice(1);
          }
          str = str + (x.e < 0 ? "e" : "e+") + x.e;
        } else if (e < 0) {
          str = "0." + getZeroString(-e - 1) + str;
          if (sd && (k = sd - len) > 0) str += getZeroString(k);
        } else if (e >= len) {
          str += getZeroString(e + 1 - len);
          if (sd && (k = sd - e - 1) > 0) str = str + "." + getZeroString(k);
        } else {
          if ((k = e + 1) < len) str = str.slice(0, k) + "." + str.slice(k);
          if (sd && (k = sd - len) > 0) {
            if (e + 1 === len) str += ".";
            str += getZeroString(k);
          }
        }
        return str;
      }
      function getBase10Exponent(digits, e) {
        var w = digits[0];
        for (e *= LOG_BASE; w >= 10; w /= 10) e++;
        return e;
      }
      function getLn10(Ctor, sd, pr) {
        if (sd > LN10_PRECISION) {
          external = true;
          if (pr) Ctor.precision = pr;
          throw Error(precisionLimitExceeded);
        }
        return finalise(new Ctor(LN10), sd, 1, true);
      }
      function getPi(Ctor, sd, rm) {
        if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);
        return finalise(new Ctor(PI), sd, rm, true);
      }
      function getPrecision(digits) {
        var w = digits.length - 1, len = w * LOG_BASE + 1;
        w = digits[w];
        if (w) {
          for (; w % 10 == 0; w /= 10) len--;
          for (w = digits[0]; w >= 10; w /= 10) len++;
        }
        return len;
      }
      function getZeroString(k) {
        var zs = "";
        for (; k--; ) zs += "0";
        return zs;
      }
      function intPow(Ctor, x, n, pr) {
        var isTruncated, r = new Ctor(1), k = Math.ceil(pr / LOG_BASE + 4);
        external = false;
        for (; ; ) {
          if (n % 2) {
            r = r.times(x);
            if (truncate(r.d, k)) isTruncated = true;
          }
          n = mathfloor(n / 2);
          if (n === 0) {
            n = r.d.length - 1;
            if (isTruncated && r.d[n] === 0) ++r.d[n];
            break;
          }
          x = x.times(x);
          truncate(x.d, k);
        }
        external = true;
        return r;
      }
      function isOdd(n) {
        return n.d[n.d.length - 1] & 1;
      }
      function maxOrMin(Ctor, args, ltgt) {
        var y, x = new Ctor(args[0]), i = 0;
        for (; ++i < args.length; ) {
          y = new Ctor(args[i]);
          if (!y.s) {
            x = y;
            break;
          } else if (x[ltgt](y)) {
            x = y;
          }
        }
        return x;
      }
      function naturalExponential(x, sd) {
        var denominator, guard, j, pow2, sum2, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (!x.d || !x.d[0] || x.e > 17) {
          return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        t = new Ctor(0.03125);
        while (x.e > -2) {
          x = x.times(t);
          k += 5;
        }
        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;
        wpr += guard;
        denominator = pow2 = sum2 = new Ctor(1);
        Ctor.precision = wpr;
        for (; ; ) {
          pow2 = finalise(pow2.times(x), wpr, 1);
          denominator = denominator.times(++i);
          t = sum2.plus(divide(pow2, denominator, wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
            j = k;
            while (j--) sum2 = finalise(sum2.times(sum2), wpr, 1);
            if (sd == null) {
              if (rep < 3 && checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += 10;
                denominator = pow2 = t = new Ctor(1);
                i = 0;
                rep++;
              } else {
                return finalise(sum2, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum2;
            }
          }
          sum2 = t;
        }
      }
      function naturalLogarithm(y, sd) {
        var c, c0, denominator, e, numerator, rep, sum2, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;
        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {
          return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);
        }
        if (sd == null) {
          external = false;
          wpr = pr;
        } else {
          wpr = sd;
        }
        Ctor.precision = wpr += guard;
        c = digitsToString(xd);
        c0 = c.charAt(0);
        if (Math.abs(e = x.e) < 15e14) {
          while (c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3) {
            x = x.times(y);
            c = digitsToString(x.d);
            c0 = c.charAt(0);
            n++;
          }
          e = x.e;
          if (c0 > 1) {
            x = new Ctor("0." + c);
            e++;
          } else {
            x = new Ctor(c0 + "." + c.slice(1));
          }
        } else {
          t = getLn10(Ctor, wpr + 2, pr).times(e + "");
          x = naturalLogarithm(new Ctor(c0 + "." + c.slice(1)), wpr - guard).plus(t);
          Ctor.precision = pr;
          return sd == null ? finalise(x, pr, rm, external = true) : x;
        }
        x1 = x;
        sum2 = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);
        x2 = finalise(x.times(x), wpr, 1);
        denominator = 3;
        for (; ; ) {
          numerator = finalise(numerator.times(x2), wpr, 1);
          t = sum2.plus(divide(numerator, new Ctor(denominator), wpr, 1));
          if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum2.d).slice(0, wpr)) {
            sum2 = sum2.times(2);
            if (e !== 0) sum2 = sum2.plus(getLn10(Ctor, wpr + 2, pr).times(e + ""));
            sum2 = divide(sum2, new Ctor(n), wpr, 1);
            if (sd == null) {
              if (checkRoundingDigits(sum2.d, wpr - guard, rm, rep)) {
                Ctor.precision = wpr += guard;
                t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);
                x2 = finalise(x.times(x), wpr, 1);
                denominator = rep = 1;
              } else {
                return finalise(sum2, Ctor.precision = pr, rm, external = true);
              }
            } else {
              Ctor.precision = pr;
              return sum2;
            }
          }
          sum2 = t;
          denominator += 2;
        }
      }
      function nonFiniteToString(x) {
        return String(x.s * x.s / 0);
      }
      function parseDecimal(x, str) {
        var e, i, len;
        if ((e = str.indexOf(".")) > -1) str = str.replace(".", "");
        if ((i = str.search(/e/i)) > 0) {
          if (e < 0) e = i;
          e += +str.slice(i + 1);
          str = str.substring(0, i);
        } else if (e < 0) {
          e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++) ;
        for (len = str.length; str.charCodeAt(len - 1) === 48; --len) ;
        str = str.slice(i, len);
        if (str) {
          len -= i;
          x.e = e = e - i - 1;
          x.d = [];
          i = (e + 1) % LOG_BASE;
          if (e < 0) i += LOG_BASE;
          if (i < len) {
            if (i) x.d.push(+str.slice(0, i));
            for (len -= LOG_BASE; i < len; ) x.d.push(+str.slice(i, i += LOG_BASE));
            str = str.slice(i);
            i = LOG_BASE - str.length;
          } else {
            i -= len;
          }
          for (; i--; ) str += "0";
          x.d.push(+str);
          if (external) {
            if (x.e > x.constructor.maxE) {
              x.d = null;
              x.e = NaN;
            } else if (x.e < x.constructor.minE) {
              x.e = 0;
              x.d = [0];
            }
          }
        } else {
          x.e = 0;
          x.d = [0];
        }
        return x;
      }
      function parseOther(x, str) {
        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;
        if (str.indexOf("_") > -1) {
          str = str.replace(/(\d)_(?=\d)/g, "$1");
          if (isDecimal.test(str)) return parseDecimal(x, str);
        } else if (str === "Infinity" || str === "NaN") {
          if (!+str) x.s = NaN;
          x.e = NaN;
          x.d = null;
          return x;
        }
        if (isHex.test(str)) {
          base = 16;
          str = str.toLowerCase();
        } else if (isBinary.test(str)) {
          base = 2;
        } else if (isOctal.test(str)) {
          base = 8;
        } else {
          throw Error(invalidArgument + str);
        }
        i = str.search(/p/i);
        if (i > 0) {
          p = +str.slice(i + 1);
          str = str.substring(2, i);
        } else {
          str = str.slice(2);
        }
        i = str.indexOf(".");
        isFloat = i >= 0;
        Ctor = x.constructor;
        if (isFloat) {
          str = str.replace(".", "");
          len = str.length;
          i = len - i;
          divisor = intPow(Ctor, new Ctor(base), i, i * 2);
        }
        xd = convertBase(str, base, BASE);
        xe = xd.length - 1;
        for (i = xe; xd[i] === 0; --i) xd.pop();
        if (i < 0) return new Ctor(x.s * 0);
        x.e = getBase10Exponent(xd, xe);
        x.d = xd;
        external = false;
        if (isFloat) x = divide(x, divisor, len * 4);
        if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));
        external = true;
        return x;
      }
      function sine(Ctor, x) {
        var k, len = x.d.length;
        if (len < 3) {
          return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);
        }
        k = 1.4 * Math.sqrt(len);
        k = k > 16 ? 16 : k | 0;
        x = x.times(1 / tinyPow(5, k));
        x = taylorSeries(Ctor, 2, x, x);
        var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);
        for (; k--; ) {
          sin2_x = x.times(x);
          x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));
        }
        return x;
      }
      function taylorSeries(Ctor, n, x, y, isHyperbolic) {
        var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);
        external = false;
        x2 = x.times(x);
        u = new Ctor(y);
        for (; ; ) {
          t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);
          u = isHyperbolic ? y.plus(t) : y.minus(t);
          y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);
          t = u.plus(y);
          if (t.d[k] !== void 0) {
            for (j = k; t.d[j] === u.d[j] && j--; ) ;
            if (j == -1) break;
          }
          j = u;
          u = y;
          y = t;
          t = j;
          i++;
        }
        external = true;
        t.d.length = k + 1;
        return t;
      }
      function tinyPow(b, e) {
        var n = b;
        while (--e) n *= b;
        return n;
      }
      function toLessThanHalfPi(Ctor, x) {
        var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);
        x = x.abs();
        if (x.lte(halfPi)) {
          quadrant = isNeg ? 4 : 1;
          return x;
        }
        t = x.divToInt(pi);
        if (t.isZero()) {
          quadrant = isNeg ? 3 : 2;
        } else {
          x = x.minus(t.times(pi));
          if (x.lte(halfPi)) {
            quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;
            return x;
          }
          quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;
        }
        return x.minus(pi).abs();
      }
      function toStringBinary(x, baseOut, sd, rm) {
        var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;
        if (isExp) {
          checkInt32(sd, 1, MAX_DIGITS);
          if (rm === void 0) rm = Ctor.rounding;
          else checkInt32(rm, 0, 8);
        } else {
          sd = Ctor.precision;
          rm = Ctor.rounding;
        }
        if (!x.isFinite()) {
          str = nonFiniteToString(x);
        } else {
          str = finiteToString(x);
          i = str.indexOf(".");
          if (isExp) {
            base = 2;
            if (baseOut == 16) {
              sd = sd * 4 - 3;
            } else if (baseOut == 8) {
              sd = sd * 3 - 2;
            }
          } else {
            base = baseOut;
          }
          if (i >= 0) {
            str = str.replace(".", "");
            y = new Ctor(1);
            y.e = str.length - i;
            y.d = convertBase(finiteToString(y), 10, base);
            y.e = y.d.length;
          }
          xd = convertBase(str, 10, base);
          e = len = xd.length;
          for (; xd[--len] == 0; ) xd.pop();
          if (!xd[0]) {
            str = isExp ? "0p+0" : "0";
          } else {
            if (i < 0) {
              e--;
            } else {
              x = new Ctor(x);
              x.d = xd;
              x.e = e;
              x = divide(x, y, sd, rm, 0, base);
              xd = x.d;
              e = x.e;
              roundUp = inexact;
            }
            i = xd[sd];
            k = base / 2;
            roundUp = roundUp || xd[sd + 1] !== void 0;
            roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));
            xd.length = sd;
            if (roundUp) {
              for (; ++xd[--sd] > base - 1; ) {
                xd[sd] = 0;
                if (!sd) {
                  ++e;
                  xd.unshift(1);
                }
              }
            }
            for (len = xd.length; !xd[len - 1]; --len) ;
            for (i = 0, str = ""; i < len; i++) str += NUMERALS.charAt(xd[i]);
            if (isExp) {
              if (len > 1) {
                if (baseOut == 16 || baseOut == 8) {
                  i = baseOut == 16 ? 4 : 3;
                  for (--len; len % i; len++) str += "0";
                  xd = convertBase(str, base, baseOut);
                  for (len = xd.length; !xd[len - 1]; --len) ;
                  for (i = 1, str = "1."; i < len; i++) str += NUMERALS.charAt(xd[i]);
                } else {
                  str = str.charAt(0) + "." + str.slice(1);
                }
              }
              str = str + (e < 0 ? "p" : "p+") + e;
            } else if (e < 0) {
              for (; ++e; ) str = "0" + str;
              str = "0." + str;
            } else {
              if (++e > len) for (e -= len; e--; ) str += "0";
              else if (e < len) str = str.slice(0, e) + "." + str.slice(e);
            }
          }
          str = (baseOut == 16 ? "0x" : baseOut == 2 ? "0b" : baseOut == 8 ? "0o" : "") + str;
        }
        return x.s < 0 ? "-" + str : str;
      }
      function truncate(arr, len) {
        if (arr.length > len) {
          arr.length = len;
          return true;
        }
      }
      function abs(x) {
        return new this(x).abs();
      }
      function acos(x) {
        return new this(x).acos();
      }
      function acosh(x) {
        return new this(x).acosh();
      }
      function add(x, y) {
        return new this(x).plus(y);
      }
      function asin(x) {
        return new this(x).asin();
      }
      function asinh(x) {
        return new this(x).asinh();
      }
      function atan(x) {
        return new this(x).atan();
      }
      function atanh(x) {
        return new this(x).atanh();
      }
      function atan2(y, x) {
        y = new this(y);
        x = new this(x);
        var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;
        if (!y.s || !x.s) {
          r = new this(NaN);
        } else if (!y.d && !x.d) {
          r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);
          r.s = y.s;
        } else if (!x.d || y.isZero()) {
          r = x.s < 0 ? getPi(this, pr, rm) : new this(0);
          r.s = y.s;
        } else if (!y.d || x.isZero()) {
          r = getPi(this, wpr, 1).times(0.5);
          r.s = y.s;
        } else if (x.s < 0) {
          this.precision = wpr;
          this.rounding = 1;
          r = this.atan(divide(y, x, wpr, 1));
          x = getPi(this, wpr, 1);
          this.precision = pr;
          this.rounding = rm;
          r = y.s < 0 ? r.minus(x) : r.plus(x);
        } else {
          r = this.atan(divide(y, x, wpr, 1));
        }
        return r;
      }
      function cbrt(x) {
        return new this(x).cbrt();
      }
      function ceil(x) {
        return finalise(x = new this(x), x.e + 1, 2);
      }
      function clamp(x, min2, max2) {
        return new this(x).clamp(min2, max2);
      }
      function config(obj) {
        if (!obj || typeof obj !== "object") throw Error(decimalError + "Object expected");
        var i, p, v, useDefaults = obj.defaults === true, ps = [
          "precision",
          1,
          MAX_DIGITS,
          "rounding",
          0,
          8,
          "toExpNeg",
          -EXP_LIMIT,
          0,
          "toExpPos",
          0,
          EXP_LIMIT,
          "maxE",
          0,
          EXP_LIMIT,
          "minE",
          -EXP_LIMIT,
          0,
          "modulo",
          0,
          9
        ];
        for (i = 0; i < ps.length; i += 3) {
          if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];
          if ((v = obj[p]) !== void 0) {
            if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;
            else throw Error(invalidArgument + p + ": " + v);
          }
        }
        if (p = "crypto", useDefaults) this[p] = DEFAULTS[p];
        if ((v = obj[p]) !== void 0) {
          if (v === true || v === false || v === 0 || v === 1) {
            if (v) {
              if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                this[p] = true;
              } else {
                throw Error(cryptoUnavailable);
              }
            } else {
              this[p] = false;
            }
          } else {
            throw Error(invalidArgument + p + ": " + v);
          }
        }
        return this;
      }
      function cos(x) {
        return new this(x).cos();
      }
      function cosh(x) {
        return new this(x).cosh();
      }
      function clone(obj) {
        var i, p, ps;
        function Decimal2(v) {
          var e, i2, t, x = this;
          if (!(x instanceof Decimal2)) return new Decimal2(v);
          x.constructor = Decimal2;
          if (isDecimalInstance(v)) {
            x.s = v.s;
            if (external) {
              if (!v.d || v.e > Decimal2.maxE) {
                x.e = NaN;
                x.d = null;
              } else if (v.e < Decimal2.minE) {
                x.e = 0;
                x.d = [0];
              } else {
                x.e = v.e;
                x.d = v.d.slice();
              }
            } else {
              x.e = v.e;
              x.d = v.d ? v.d.slice() : v.d;
            }
            return;
          }
          t = typeof v;
          if (t === "number") {
            if (v === 0) {
              x.s = 1 / v < 0 ? -1 : 1;
              x.e = 0;
              x.d = [0];
              return;
            }
            if (v < 0) {
              v = -v;
              x.s = -1;
            } else {
              x.s = 1;
            }
            if (v === ~~v && v < 1e7) {
              for (e = 0, i2 = v; i2 >= 10; i2 /= 10) e++;
              if (external) {
                if (e > Decimal2.maxE) {
                  x.e = NaN;
                  x.d = null;
                } else if (e < Decimal2.minE) {
                  x.e = 0;
                  x.d = [0];
                } else {
                  x.e = e;
                  x.d = [v];
                }
              } else {
                x.e = e;
                x.d = [v];
              }
              return;
            } else if (v * 0 !== 0) {
              if (!v) x.s = NaN;
              x.e = NaN;
              x.d = null;
              return;
            }
            return parseDecimal(x, v.toString());
          } else if (t !== "string") {
            throw Error(invalidArgument + v);
          }
          if ((i2 = v.charCodeAt(0)) === 45) {
            v = v.slice(1);
            x.s = -1;
          } else {
            if (i2 === 43) v = v.slice(1);
            x.s = 1;
          }
          return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);
        }
        Decimal2.prototype = P;
        Decimal2.ROUND_UP = 0;
        Decimal2.ROUND_DOWN = 1;
        Decimal2.ROUND_CEIL = 2;
        Decimal2.ROUND_FLOOR = 3;
        Decimal2.ROUND_HALF_UP = 4;
        Decimal2.ROUND_HALF_DOWN = 5;
        Decimal2.ROUND_HALF_EVEN = 6;
        Decimal2.ROUND_HALF_CEIL = 7;
        Decimal2.ROUND_HALF_FLOOR = 8;
        Decimal2.EUCLID = 9;
        Decimal2.config = Decimal2.set = config;
        Decimal2.clone = clone;
        Decimal2.isDecimal = isDecimalInstance;
        Decimal2.abs = abs;
        Decimal2.acos = acos;
        Decimal2.acosh = acosh;
        Decimal2.add = add;
        Decimal2.asin = asin;
        Decimal2.asinh = asinh;
        Decimal2.atan = atan;
        Decimal2.atanh = atanh;
        Decimal2.atan2 = atan2;
        Decimal2.cbrt = cbrt;
        Decimal2.ceil = ceil;
        Decimal2.clamp = clamp;
        Decimal2.cos = cos;
        Decimal2.cosh = cosh;
        Decimal2.div = div;
        Decimal2.exp = exp;
        Decimal2.floor = floor;
        Decimal2.hypot = hypot;
        Decimal2.ln = ln;
        Decimal2.log = log;
        Decimal2.log10 = log10;
        Decimal2.log2 = log2;
        Decimal2.max = max;
        Decimal2.min = min;
        Decimal2.mod = mod;
        Decimal2.mul = mul;
        Decimal2.pow = pow;
        Decimal2.random = random;
        Decimal2.round = round;
        Decimal2.sign = sign;
        Decimal2.sin = sin;
        Decimal2.sinh = sinh;
        Decimal2.sqrt = sqrt;
        Decimal2.sub = sub;
        Decimal2.sum = sum;
        Decimal2.tan = tan;
        Decimal2.tanh = tanh;
        Decimal2.trunc = trunc;
        if (obj === void 0) obj = {};
        if (obj) {
          if (obj.defaults !== true) {
            ps = ["precision", "rounding", "toExpNeg", "toExpPos", "maxE", "minE", "modulo", "crypto"];
            for (i = 0; i < ps.length; ) if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];
          }
        }
        Decimal2.config(obj);
        return Decimal2;
      }
      function div(x, y) {
        return new this(x).div(y);
      }
      function exp(x) {
        return new this(x).exp();
      }
      function floor(x) {
        return finalise(x = new this(x), x.e + 1, 3);
      }
      function hypot() {
        var i, n, t = new this(0);
        external = false;
        for (i = 0; i < arguments.length; ) {
          n = new this(arguments[i++]);
          if (!n.d) {
            if (n.s) {
              external = true;
              return new this(1 / 0);
            }
            t = n;
          } else if (t.d) {
            t = t.plus(n.times(n));
          }
        }
        external = true;
        return t.sqrt();
      }
      function isDecimalInstance(obj) {
        return obj instanceof Decimal || obj && obj.toStringTag === tag || false;
      }
      function ln(x) {
        return new this(x).ln();
      }
      function log(x, y) {
        return new this(x).log(y);
      }
      function log2(x) {
        return new this(x).log(2);
      }
      function log10(x) {
        return new this(x).log(10);
      }
      function max() {
        return maxOrMin(this, arguments, "lt");
      }
      function min() {
        return maxOrMin(this, arguments, "gt");
      }
      function mod(x, y) {
        return new this(x).mod(y);
      }
      function mul(x, y) {
        return new this(x).mul(y);
      }
      function pow(x, y) {
        return new this(x).pow(y);
      }
      function random(sd) {
        var d, e, k, n, i = 0, r = new this(1), rd = [];
        if (sd === void 0) sd = this.precision;
        else checkInt32(sd, 1, MAX_DIGITS);
        k = Math.ceil(sd / LOG_BASE);
        if (!this.crypto) {
          for (; i < k; ) rd[i++] = Math.random() * 1e7 | 0;
        } else if (crypto.getRandomValues) {
          d = crypto.getRandomValues(new Uint32Array(k));
          for (; i < k; ) {
            n = d[i];
            if (n >= 429e7) {
              d[i] = crypto.getRandomValues(new Uint32Array(1))[0];
            } else {
              rd[i++] = n % 1e7;
            }
          }
        } else if (crypto.randomBytes) {
          d = crypto.randomBytes(k *= 4);
          for (; i < k; ) {
            n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 127) << 24);
            if (n >= 214e7) {
              crypto.randomBytes(4).copy(d, i);
            } else {
              rd.push(n % 1e7);
              i += 4;
            }
          }
          i = k / 4;
        } else {
          throw Error(cryptoUnavailable);
        }
        k = rd[--i];
        sd %= LOG_BASE;
        if (k && sd) {
          n = mathpow(10, LOG_BASE - sd);
          rd[i] = (k / n | 0) * n;
        }
        for (; rd[i] === 0; i--) rd.pop();
        if (i < 0) {
          e = 0;
          rd = [0];
        } else {
          e = -1;
          for (; rd[0] === 0; e -= LOG_BASE) rd.shift();
          for (k = 1, n = rd[0]; n >= 10; n /= 10) k++;
          if (k < LOG_BASE) e -= LOG_BASE - k;
        }
        r.e = e;
        r.d = rd;
        return r;
      }
      function round(x) {
        return finalise(x = new this(x), x.e + 1, this.rounding);
      }
      function sign(x) {
        x = new this(x);
        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;
      }
      function sin(x) {
        return new this(x).sin();
      }
      function sinh(x) {
        return new this(x).sinh();
      }
      function sqrt(x) {
        return new this(x).sqrt();
      }
      function sub(x, y) {
        return new this(x).sub(y);
      }
      function sum() {
        var i = 0, args = arguments, x = new this(args[i]);
        external = false;
        for (; x.s && ++i < args.length; ) x = x.plus(args[i]);
        external = true;
        return finalise(x, this.precision, this.rounding);
      }
      function tan(x) {
        return new this(x).tan();
      }
      function tanh(x) {
        return new this(x).tanh();
      }
      function trunc(x) {
        return finalise(x = new this(x), x.e + 1, 1);
      }
      Decimal = clone(DEFAULTS);
      Decimal.prototype.constructor = Decimal;
      Decimal["default"] = Decimal.Decimal = Decimal;
      LN10 = new Decimal(LN10);
      PI = new Decimal(PI);
      if (typeof define == "function" && define.amd) {
        define(function() {
          return Decimal;
        });
      } else if (typeof module != "undefined" && module.exports) {
        if (typeof Symbol == "function" && typeof Symbol.iterator == "symbol") {
          P[Symbol["for"]("nodejs.util.inspect.custom")] = P.toString;
          P[Symbol.toStringTag] = "Decimal";
        }
        module.exports = Decimal;
      } else {
        if (!globalScope) {
          globalScope = typeof self != "undefined" && self && self.self == self ? self : window;
        }
        noConflict = globalScope.Decimal;
        Decimal.noConflict = function() {
          globalScope.Decimal = noConflict;
          return Decimal;
        };
        globalScope.Decimal = Decimal;
      }
    })(exports);
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/constants/index.js
var require_constants = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TOKENS_MAPPING = exports.NETWORKS_MODULES = exports.VERSION_0_5 = exports.VERSION_0 = exports.SCRIPTS_V2 = exports.SCRIPTS_V1 = exports.COIN_STORE = exports.COIN_INFO = exports.RESOURCES_V05_ACCOUNT = exports.MODULES_V05_ACCOUNT = exports.COINS_ACCOUNT = exports.RESOURCES_ACCOUNT = exports.MODULES_ACCOUNT = void 0;
    exports.MODULES_ACCOUNT = "0x190d44266241744264b964a37b8f09863167a12d3e70cda39376cfb4e3561e12";
    exports.RESOURCES_ACCOUNT = "0x05a97986a9d031c4567e15b797be516910cfcb4156312482efc6a19c0a30c948";
    exports.COINS_ACCOUNT = "0x43417434fd869edee76cca2a4d2301e528a1551b1d719b75c350c3c97d15b8b9";
    exports.MODULES_V05_ACCOUNT = "0x163df34fccbf003ce219d3f1d9e70d140b60622cb9dd47599c25fb2f797ba6e";
    exports.RESOURCES_V05_ACCOUNT = "0x61d2c22a6cb7831bee0f48363b0eec92369357aece0d1142062f7d5d85c7bef8";
    exports.COIN_INFO = "0x1::coin::CoinInfo";
    exports.COIN_STORE = "0x1::coin::CoinStore";
    exports.SCRIPTS_V1 = "scripts";
    exports.SCRIPTS_V2 = "scripts_v2";
    exports.VERSION_0 = 0;
    exports.VERSION_0_5 = 0.5;
    exports.NETWORKS_MODULES = {
      Scripts: `${exports.MODULES_ACCOUNT}::scripts_v2`,
      Faucet: `${exports.COINS_ACCOUNT}::faucet`,
      CoinInfo: `${exports.COIN_INFO}`,
      CoinStore: `${exports.COIN_STORE}`
    };
    exports.TOKENS_MAPPING = {
      APTOS: "0x1::aptos_coin::AptosCoin",
      USDT: "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDT",
      BTC: "0xae478ff7d83ed072dbc5e264250e67ef58f57c99d89b447efd8a0a2e8b2be76e::coin::T",
      WETH: "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::WETH",
      USDC: "0xf22bede237a07e121b56d91a491eb7bcdfd1f5907926a9e58338f964a01b17fa::asset::USDC",
      amAPT: "0x111ae3e5bc816a5e63c2da97d0aa3886519e0cd5e4b046659fa35796bd11542a::amapt_token::AmnisApt"
      // Amnis APT
    };
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/hex.js
var require_hex = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/hex.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkAptosType = exports.toBuffer = exports.checkAddress = exports.shortAddress = exports.shortString = exports.addHexPrefix = void 0;
    var HEX_REGEXP = /^[-+]?[0-9A-Fa-f]+\.?[0-9A-Fa-f]*?$/;
    function addHexPrefix(hex) {
      return !hex.startsWith("0x") ? "0x" + hex : hex;
    }
    exports.addHexPrefix = addHexPrefix;
    function shortString(str, start = 4, end = 4) {
      const slen = Math.max(start, 1);
      const elen = Math.max(end, 1);
      return str.slice(0, slen + 2) + " ... " + str.slice(-elen);
    }
    exports.shortString = shortString;
    function shortAddress(address, start = 4, end = 4) {
      return shortString(addHexPrefix(address), start, end);
    }
    exports.shortAddress = shortAddress;
    function checkAddress(address, options = { leadingZero: true }) {
      if (typeof address !== "string") {
        return false;
      }
      let str = address;
      if (options.leadingZero) {
        if (!address.startsWith("0x")) {
          return false;
        } else {
          str = str.substring(2);
        }
      }
      return HEX_REGEXP.test(str);
    }
    exports.checkAddress = checkAddress;
    function toBuffer(v) {
      if (!Buffer.isBuffer(v)) {
        if (Array.isArray(v)) {
          v = Buffer.from(v);
        } else if (typeof v === "string") {
          if (exports.isHexString(v)) {
            v = Buffer.from(exports.padToEven(exports.stripHexPrefix(v)), "hex");
          } else {
            v = Buffer.from(v);
          }
        } else if (typeof v === "number") {
          v = exports.intToBuffer(v);
        } else if (v === null || v === void 0) {
          v = Buffer.allocUnsafe(0);
        } else if (v.toArray) {
          v = Buffer.from(v.toArray());
        } else {
          throw new Error("invalid type");
        }
      }
      return v;
    }
    exports.toBuffer = toBuffer;
    function checkAptosType(type, options = { leadingZero: true }) {
      var _a, _b, _c, _d, _e;
      if (typeof type !== "string") {
        return false;
      }
      let _type = type.replace(/\s/g, "");
      const openBracketsCount = (_b = (_a = _type.match(/</g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      const closeBracketsCount = (_d = (_c = _type.match(/>/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
      if (openBracketsCount !== closeBracketsCount) {
        return false;
      }
      const genericsString = _type.match(/(<.+>)$/);
      const generics = (_e = genericsString === null || genericsString === void 0 ? void 0 : genericsString[1]) === null || _e === void 0 ? void 0 : _e.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
      if (generics) {
        _type = _type.slice(0, _type.indexOf("<"));
        const validGenerics = generics.every((g) => {
          var _a2, _b2, _c2, _d2;
          const gOpenCount = (_b2 = (_a2 = g.match(/</g)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0;
          const gCloseCount = (_d2 = (_c2 = g.match(/>/g)) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
          let t = g;
          if (gOpenCount !== gCloseCount) {
            t = t.slice(0, -(gCloseCount - gOpenCount));
          }
          return checkAptosType(t, options);
        });
        if (!validGenerics) {
          return false;
        }
      }
      const parts = _type.split("::");
      if (parts.length !== 3) {
        return false;
      }
      return checkAddress(parts[0], options) && parts[1].length >= 1 && parts[2].length >= 1;
    }
    exports.checkAptosType = checkAptosType;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/contracts.js
var require_contracts = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/contracts.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCurve = exports.getScriptsFor = exports.checkAptosType = exports.extractAddressFromType = exports.withSlippage = exports.composeType = exports.is_sorted = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var buffer_1 = require_buffer();
    var decimal_js_1 = tslib_1.__importDefault(require_decimal());
    var constants_1 = require_constants();
    var hex_1 = require_hex();
    var EQUAL = 0;
    var LESS_THAN = 1;
    var GREATER_THAN = 2;
    function cmp(a, b) {
      if (a === b) {
        return EQUAL;
      } else if (a < b) {
        return LESS_THAN;
      } else {
        return GREATER_THAN;
      }
    }
    function compare(symbolX, symbolY) {
      const lenCmp = cmp(symbolX.length, symbolY.length);
      if (lenCmp != EQUAL) {
        return lenCmp;
      }
      let i = 0;
      while (i < symbolX.length && i < symbolY.length) {
        const elem_cmp = cmp(symbolX.charCodeAt(i), symbolY.charCodeAt(i));
        if (elem_cmp != EQUAL)
          return elem_cmp;
        i++;
      }
      return EQUAL;
    }
    function cmp_addresses(a, b) {
      if (a.startsWith("0x")) {
        a = a.substring(2);
      }
      if (a.length != 64) {
        while (a.length < 64) {
          a = "0" + a;
        }
      }
      if (b.startsWith("0x")) {
        b = b.substring(2);
      }
      if (b.length != 64) {
        while (b.length < 64) {
          b = "0" + b;
        }
      }
      const a_buf = buffer_1.Buffer.from(a, "hex");
      const b_buf = buffer_1.Buffer.from(b, "hex");
      for (let i = 0; i < 32; i++) {
        if (a_buf[i] < b_buf[i]) {
          return LESS_THAN;
        } else if (a_buf[i] > b_buf[i]) {
          return GREATER_THAN;
        }
      }
      return EQUAL;
    }
    function compare_types(coin_x, coin_y) {
      const coin_x_parts = coin_x.split("::").reverse();
      const coin_y_parts = coin_y.split("::").reverse();
      const coin_x_address = coin_x_parts.pop();
      const coin_y_address = coin_y_parts.pop();
      for (let i = 0; i < 2; i++) {
        const c = compare(coin_x_parts[i], coin_y_parts[i]);
        if (c != EQUAL) {
          return c;
        }
      }
      return cmp_addresses(coin_x_address, coin_y_address);
    }
    function is_sorted(coin_x, coin_y) {
      return compare_types(coin_x, coin_y) == LESS_THAN;
    }
    exports.is_sorted = is_sorted;
    function composeType(address, ...args) {
      const generics = Array.isArray(args[args.length - 1]) ? args.pop() : [];
      const chains = [address, ...args].filter(Boolean);
      let result = chains.join("::");
      if (generics && generics.length) {
        result += `<${generics.join(",")}>`;
      }
      return result;
    }
    exports.composeType = composeType;
    function withSlippage(slippage, value, isPlussed) {
      const multiply = new decimal_js_1.default(1e4);
      const slippagePercent = slippage.mul(multiply);
      return isPlussed ? value.plus(value.mul(slippagePercent).div(multiply)).toNumber() : value.minus(value.mul(slippagePercent).div(multiply)).toNumber();
    }
    exports.withSlippage = withSlippage;
    function extractAddressFromType(type) {
      return type.split("::")[0];
    }
    exports.extractAddressFromType = extractAddressFromType;
    function checkAptosType(type, options = { leadingZero: true }) {
      var _a, _b, _c, _d, _e;
      if (typeof type !== "string") {
        return false;
      }
      let _type = type.replace(/\s/g, "");
      const openBracketsCount = (_b = (_a = _type.match(/</g)) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
      const closeBracketsCount = (_d = (_c = _type.match(/>/g)) === null || _c === void 0 ? void 0 : _c.length) !== null && _d !== void 0 ? _d : 0;
      if (openBracketsCount !== closeBracketsCount) {
        return false;
      }
      const genericsString = _type.match(/(<.+>)$/);
      const generics = (_e = genericsString === null || genericsString === void 0 ? void 0 : genericsString[1]) === null || _e === void 0 ? void 0 : _e.match(/(\w+::\w+::\w+)(?:<.*?>(?!>))?/g);
      if (generics) {
        _type = _type.slice(0, _type.indexOf("<"));
        const validGenerics = generics.every((g) => {
          var _a2, _b2, _c2, _d2;
          const gOpenCount = (_b2 = (_a2 = g.match(/</g)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0;
          const gCloseCount = (_d2 = (_c2 = g.match(/>/g)) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d2 !== void 0 ? _d2 : 0;
          let t = g;
          if (gOpenCount !== gCloseCount) {
            t = t.slice(0, -(gCloseCount - gOpenCount));
          }
          return checkAptosType(t, options);
        });
        if (!validGenerics) {
          return false;
        }
      }
      const parts = _type.split("::");
      if (parts.length !== 3) {
        return false;
      }
      return (0, hex_1.checkAddress)(parts[0], options) && parts[1].length >= 1 && parts[2].length >= 1;
    }
    exports.checkAptosType = checkAptosType;
    function getScriptsFor(version) {
      if (version === constants_1.VERSION_0_5)
        return constants_1.SCRIPTS_V1;
      switch (version) {
        case constants_1.VERSION_0:
          return constants_1.SCRIPTS_V2;
        case constants_1.VERSION_0_5:
          return constants_1.SCRIPTS_V1;
      }
      throw new Error("Unknown contract version requested");
    }
    exports.getScriptsFor = getScriptsFor;
    function getCurve(type, curves, contract) {
      if (contract === constants_1.VERSION_0_5) {
        if (type === "stable") {
          return curves.stableV05;
        }
        return curves.uncorrelatedV05;
      }
      if (type === "stable") {
        return curves.stable;
      }
      return curves.uncorrelated;
    }
    exports.getCurve = getCurve;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/numbers.js
var require_numbers = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/numbers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertDecimalToFixedString = exports.convertValueToDecimal = exports.decimalsMultiplier = exports.d = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var decimal_js_1 = tslib_1.__importDefault(require_decimal());
    function d(value) {
      if (decimal_js_1.default.isDecimal(value)) {
        return value;
      }
      return new decimal_js_1.default(value === void 0 ? 0 : value);
    }
    exports.d = d;
    function decimalsMultiplier(decimals) {
      return d(10).pow(d(decimals).abs());
    }
    exports.decimalsMultiplier = decimalsMultiplier;
    function convertValueToDecimal(value, decimals = 0) {
      const mul = decimalsMultiplier(decimals);
      return d(value).mul(mul);
    }
    exports.convertValueToDecimal = convertValueToDecimal;
    function convertDecimalToFixedString(value, decimals) {
      const mul = decimalsMultiplier(decimals);
      return value.div(mul).toFixed(decimals);
    }
    exports.convertDecimalToFixedString = convertDecimalToFixedString;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/liquidity.js
var require_liquidity = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/liquidity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getPoolStr = exports.getOptimalLiquidityAmount = exports.calcOutputBurnLiquidity = exports.calcReceivedLP = void 0;
    var decimal_js_1 = require_decimal();
    var numbers_1 = require_numbers();
    var contracts_1 = require_contracts();
    var MINIMAL_LIQUIDITY = 1e4;
    function calcReceivedLP({ x, y, xReserve, yReserve, lpSupply }) {
      const dxReserve = (0, numbers_1.d)(xReserve);
      const dyReserve = (0, numbers_1.d)(yReserve);
      const dx = (0, numbers_1.d)(x);
      const dy = (0, numbers_1.d)(y);
      const dSupply = (0, numbers_1.d)(lpSupply);
      if (dxReserve.eq(0) || dyReserve.eq(0)) {
        return decimal_js_1.Decimal.sqrt(dx.mul(dy)).minus(MINIMAL_LIQUIDITY).toFixed(0);
      }
      const xLp = dx.mul(dSupply).div(dxReserve);
      const yLp = dy.mul(dSupply).div(dyReserve);
      return decimal_js_1.Decimal.min(xLp, yLp).toFixed(0);
    }
    exports.calcReceivedLP = calcReceivedLP;
    function calcOutputBurnLiquidity({ xReserve, yReserve, lpSupply, toBurn }) {
      const xReturn = toBurn.mul(xReserve).div(lpSupply);
      const yReturn = toBurn.mul(yReserve).div(lpSupply);
      if (xReturn.eq(0) || yReturn.eq(0)) {
        return void 0;
      }
      return {
        x: xReturn,
        y: yReturn
      };
    }
    exports.calcOutputBurnLiquidity = calcOutputBurnLiquidity;
    function getOptimalLiquidityAmount(xDesired, xReserve, yReserve) {
      return xDesired.mul(yReserve).div(xReserve);
    }
    exports.getOptimalLiquidityAmount = getOptimalLiquidityAmount;
    function getPoolStr(coinX, coinY, curve, modulesLiquidityPool) {
      const [sortedX, sortedY] = (0, contracts_1.is_sorted)(coinX, coinY) ? [coinX, coinY] : [coinY, coinX];
      return (0, contracts_1.composeType)(modulesLiquidityPool, [sortedX, sortedY, curve]);
    }
    exports.getPoolStr = getPoolStr;
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/index.js
var require_utils = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.convertDecimalToFixedString = exports.convertValueToDecimal = exports.decimalsMultiplier = exports.d = exports.getPoolStr = exports.getOptimalLiquidityAmount = exports.calcOutputBurnLiquidity = exports.calcReceivedLP = exports.extractAddressFromType = exports.composeType = exports.withSlippage = exports.is_sorted = exports.getCoinsInWithFeesStable = exports.getCoinsOutWithFeesStable = exports.getCoinOutWithFees = exports.getCoinInWithFees = void 0;
    var swap_math_1 = require_swap_math();
    Object.defineProperty(exports, "getCoinInWithFees", { enumerable: true, get: function() {
      return swap_math_1.getCoinInWithFees;
    } });
    Object.defineProperty(exports, "getCoinOutWithFees", { enumerable: true, get: function() {
      return swap_math_1.getCoinOutWithFees;
    } });
    Object.defineProperty(exports, "getCoinsOutWithFeesStable", { enumerable: true, get: function() {
      return swap_math_1.getCoinsOutWithFeesStable;
    } });
    Object.defineProperty(exports, "getCoinsInWithFeesStable", { enumerable: true, get: function() {
      return swap_math_1.getCoinsInWithFeesStable;
    } });
    var contracts_1 = require_contracts();
    Object.defineProperty(exports, "is_sorted", { enumerable: true, get: function() {
      return contracts_1.is_sorted;
    } });
    Object.defineProperty(exports, "withSlippage", { enumerable: true, get: function() {
      return contracts_1.withSlippage;
    } });
    Object.defineProperty(exports, "composeType", { enumerable: true, get: function() {
      return contracts_1.composeType;
    } });
    Object.defineProperty(exports, "extractAddressFromType", { enumerable: true, get: function() {
      return contracts_1.extractAddressFromType;
    } });
    var liquidity_1 = require_liquidity();
    Object.defineProperty(exports, "calcReceivedLP", { enumerable: true, get: function() {
      return liquidity_1.calcReceivedLP;
    } });
    Object.defineProperty(exports, "calcOutputBurnLiquidity", { enumerable: true, get: function() {
      return liquidity_1.calcOutputBurnLiquidity;
    } });
    Object.defineProperty(exports, "getOptimalLiquidityAmount", { enumerable: true, get: function() {
      return liquidity_1.getOptimalLiquidityAmount;
    } });
    Object.defineProperty(exports, "getPoolStr", { enumerable: true, get: function() {
      return liquidity_1.getPoolStr;
    } });
    var numbers_1 = require_numbers();
    Object.defineProperty(exports, "d", { enumerable: true, get: function() {
      return numbers_1.d;
    } });
    Object.defineProperty(exports, "decimalsMultiplier", { enumerable: true, get: function() {
      return numbers_1.decimalsMultiplier;
    } });
    Object.defineProperty(exports, "convertValueToDecimal", { enumerable: true, get: function() {
      return numbers_1.convertValueToDecimal;
    } });
    Object.defineProperty(exports, "convertDecimalToFixedString", { enumerable: true, get: function() {
      return numbers_1.convertDecimalToFixedString;
    } });
  }
});

// node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/swap-math.js
var require_swap_math = __commonJS({
  "node_modules/@pontem/liquidswap-sdk/dist/tsc/utils/swap-math.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dStable = exports.lp_value = exports.f = exports.get_y = exports.coin_out = exports.getCoinsOutWithFeesStable = exports.coin_in = exports.getCoinsInWithFeesStable = exports.getCoinInWithFees = exports.getCoinOutWithFees = void 0;
    var tslib_1 = (init_tslib_es6(), __toCommonJS(tslib_es6_exports));
    var decimal_js_1 = tslib_1.__importDefault(require_decimal());
    var utils_1 = require_utils();
    var e8 = new decimal_js_1.default("100000000");
    var DENOMINATOR = new decimal_js_1.default(1e4);
    function getCoinOutWithFees(coinInVal, reserveInSize, reserveOutSize, fee) {
      const { feePct, feeScale } = { feePct: fee, feeScale: (0, utils_1.d)(DENOMINATOR) };
      const feeMultiplier = feeScale.minus(feePct);
      const coinInAfterFees = coinInVal.mul(feeMultiplier);
      const newReservesInSize = reserveInSize.mul(feeScale).plus(coinInAfterFees);
      return coinInAfterFees.mul(reserveOutSize).div(newReservesInSize);
    }
    exports.getCoinOutWithFees = getCoinOutWithFees;
    function getCoinInWithFees(coinOutVal, reserveOutSize, reserveInSize, fee) {
      const feeMultiplier = DENOMINATOR.minus(fee);
      const newReservesOutSize = reserveOutSize.minus(coinOutVal).mul(feeMultiplier);
      return coinOutVal.mul(DENOMINATOR).mul(reserveInSize).div(newReservesOutSize).plus(1);
    }
    exports.getCoinInWithFees = getCoinInWithFees;
    function getCoinsInWithFeesStable(coinOut, reserveOut, reserveIn, scaleOut, scaleIn, fee) {
      const r = coin_in(coinOut, scaleOut, scaleIn, reserveOut, reserveIn);
      return r.plus(1).mul(DENOMINATOR).div(DENOMINATOR.minus(fee)).plus(1);
    }
    exports.getCoinsInWithFeesStable = getCoinsInWithFeesStable;
    function coin_in(coinOut, scaleOut, scaleIn, reserveOut, reserveIn) {
      const xy = lp_value(reserveIn, scaleIn, reserveOut, scaleOut);
      const reserve_in = reserveIn.mul(e8).div(scaleIn);
      const reserve_out = reserveOut.mul(e8).div(scaleOut);
      const amount_out = coinOut.mul(e8).div(scaleOut);
      const total_reserve = reserve_out.minus(amount_out);
      const x = get_y(total_reserve, xy, reserve_in).minus(reserve_in);
      return x.mul(scaleIn).div(e8);
    }
    exports.coin_in = coin_in;
    function getCoinsOutWithFeesStable(coinIn, reserveIn, reserveOut, scaleIn, scaleOut, fee) {
      let coin_in_val_after_fees = new decimal_js_1.default(0);
      const coin_in_val_scaled = coinIn.mul(DENOMINATOR.minus(fee));
      if (!coin_in_val_scaled.mod(DENOMINATOR).eq(0)) {
        coin_in_val_after_fees = coin_in_val_scaled.div(DENOMINATOR).plus(1);
      } else {
        coin_in_val_after_fees = coin_in_val_scaled.div(DENOMINATOR);
      }
      return coin_out(coin_in_val_after_fees, scaleIn, scaleOut, reserveIn, reserveOut);
    }
    exports.getCoinsOutWithFeesStable = getCoinsOutWithFeesStable;
    function coin_out(coinIn, scaleIn, scaleOut, reserveIn, reserveOut) {
      const xy = lp_value(reserveIn, scaleIn, reserveOut, scaleOut);
      const reserve_in = reserveIn.mul(e8).div(scaleIn);
      const reserve_out = reserveOut.mul(e8).dividedBy(scaleOut);
      const amount_in = coinIn.mul(e8).div(scaleIn);
      const total_reserve = amount_in.plus(reserve_in);
      const y = reserve_out.minus(get_y(total_reserve, xy, reserve_out));
      return y.mul(scaleOut).div(e8);
    }
    exports.coin_out = coin_out;
    function get_y(x0, xy, y) {
      let i = 0;
      while (i < 255) {
        const k = f(x0, y);
        let dy = new decimal_js_1.default(0);
        if (k.lt(xy)) {
          dy = xy.minus(k).div(dStable(x0, y)).plus(1);
          y = y.plus(dy);
        } else {
          dy = k.minus(xy).dividedBy(dStable(x0, y));
          y = y.minus(dy);
        }
        if (dy.lte(1)) {
          return y;
        }
        i++;
      }
      return y;
    }
    exports.get_y = get_y;
    function f(x0, y) {
      const yyy = y.mul(y).mul(y);
      const a = x0.mul(yyy);
      const xxx = x0.mul(x0).mul(x0);
      const b = xxx.mul(y);
      return a.plus(b);
    }
    exports.f = f;
    function lp_value(x_coin, x_scale, y_coin, y_scale) {
      const x = x_coin.mul(e8).div(x_scale);
      const y = y_coin.mul(e8).div(y_scale);
      const a = x.mul(y);
      const b = x.mul(x).plus(y.mul(y));
      return a.mul(b);
    }
    exports.lp_value = lp_value;
    function dStable(x0, y) {
      const x3 = x0.mul(3);
      const yy = y.mul(y);
      const xyy3 = x3.mul(yy);
      const xxx = x0.mul(x0).mul(x0);
      return xyy3.plus(xxx);
    }
    exports.dStable = dStable;
  }
});

export {
  require_swap_math,
  require_utils
};
/*! Bundled license information:

decimal.js/decimal.js:
  (*!
   *  decimal.js v10.4.3
   *  An arbitrary-precision Decimal type for JavaScript.
   *  https://github.com/MikeMcl/decimal.js
   *  Copyright (c) 2022 Michael Mclaughlin <M8ch88l@gmail.com>
   *  MIT Licence
   *)
*/
//# sourceMappingURL=chunk-Q6EMES3S.js.map
