import {
  require_poseidon_lite
} from "./chunk-HLYV2BFP.js";
import {
  require_eventemitter3
} from "./chunk-KEMPSE3P.js";
import {
  __export,
  __toESM
} from "./chunk-OL46QLBJ.js";

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6EMN3BOV.mjs
function o(a24, i47, e5) {
  let r26 = e5.value;
  return e5.value = async function(...t30) {
    let [n18] = t30;
    if (n18.transaction.feePayerAddress && !n18.feePayerAuthenticator) throw new Error("You are submitting a Fee Payer transaction but missing the feePayerAuthenticator");
    return r26.apply(this, t30);
  }, e5;
}
function u(a24, i47, e5) {
  let r26 = e5.value;
  return e5.value = async function(...t30) {
    let [n18] = t30;
    if (n18.transaction.feePayerAddress && !n18.feePayerPublicKey) throw new Error("You are simulating a Fee Payer transaction but missing the feePayerPublicKey");
    return r26.apply(this, t30);
  }, e5;
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LG7RJQ57.mjs
var s = class extends Error {
  constructor(e5, i47) {
    super(e5), this.invalidReason = i47;
  }
};

// node_modules/@noble/hashes/esm/crypto.js
var crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@noble/hashes/esm/_assert.js
function number(n18) {
  if (!Number.isSafeInteger(n18) || n18 < 0)
    throw new Error(`positive integer expected, not ${n18}`);
}
function isBytes(a24) {
  return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
}
function bytes(b11, ...lengths) {
  if (!isBytes(b11))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b11.length))
    throw new Error(`Uint8Array expected of length ${lengths}, not of length=${b11.length}`);
}
function hash(h17) {
  if (typeof h17 !== "function" || typeof h17.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(h17.outputLen);
  number(h17.blockLen);
}
function exists(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}

// node_modules/@noble/hashes/esm/utils.js
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var rotl = (word, shift) => word << shift | word >>> 32 - shift >>> 0;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
var byteSwap = (word) => word << 24 & 4278190080 | word << 8 & 16711680 | word >>> 8 & 65280 | word >>> 24 & 255;
function byteSwap32(arr) {
  for (let i47 = 0; i47 < arr.length; i47++) {
    arr[i47] = byteSwap(arr[i47]);
  }
}
var hexes = Array.from({ length: 256 }, (_8, i47) => i47.toString(16).padStart(2, "0"));
function bytesToHex(bytes2) {
  bytes(bytes2);
  let hex2 = "";
  for (let i47 = 0; i47 < bytes2.length; i47++) {
    hex2 += hexes[bytes2[i47]];
  }
  return hex2;
}
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase16(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
}
function hexToBytes(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex2.charCodeAt(hi));
    const n22 = asciiToBase16(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n22;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  bytes(data);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i47 = 0; i47 < arrays.length; i47++) {
    const a24 = arrays[i47];
    bytes(a24);
    sum += a24.length;
  }
  const res = new Uint8Array(sum);
  for (let i47 = 0, pad = 0; i47 < arrays.length; i47++) {
    const a24 = arrays[i47];
    res.set(a24, pad);
    pad += a24.length;
  }
  return res;
}
var Hash = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
var toStr = {}.toString;
function checkOpts(defaults2, opts) {
  if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults2, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-BCUSI3N6.mjs
var l = ((e5) => (e5.TOO_SHORT = "too_short", e5.INVALID_LENGTH = "invalid_length", e5.INVALID_HEX_CHARS = "invalid_hex_chars", e5))(l || {});
var i = class n {
  constructor(t30) {
    this.data = t30;
  }
  toUint8Array() {
    return this.data;
  }
  toStringWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  static fromHexString(t30) {
    let r26 = t30;
    if (r26.startsWith("0x") && (r26 = r26.slice(2)), r26.length === 0) throw new s("Hex string is too short, must be at least 1 char long, excluding the optional leading 0x.", "too_short");
    if (r26.length % 2 !== 0) throw new s("Hex string must be an even number of hex characters.", "invalid_length");
    try {
      return new n(hexToBytes(r26));
    } catch (e5) {
      throw new s(`Hex string contains invalid hex characters: ${e5 == null ? void 0 : e5.message}`, "invalid_hex_chars");
    }
  }
  static fromHexInput(t30) {
    return t30 instanceof Uint8Array ? new n(t30) : n.fromHexString(t30);
  }
  static isValid(t30) {
    try {
      return n.fromHexString(t30), { valid: true };
    } catch (r26) {
      return { valid: false, invalidReason: r26 == null ? void 0 : r26.invalidReason, invalidReasonMessage: r26 == null ? void 0 : r26.message };
    }
  }
  equals(t30) {
    return this.data.length !== t30.data.length ? false : this.data.every((r26, e5) => r26 === t30.data[e5]);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-56CNRT2K.mjs
var t = 255;
var n2 = 65535;
var U = 4294967295;
var _ = 18446744073709551615n;
var o2 = 340282366920938463463374607431768211455n;
var i2 = 115792089237316195423570985008687907853269984665640564039457584007913129639935n;

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FVA2OPG4.mjs
var h = Object.defineProperty;
var i3 = Object.getOwnPropertyDescriptor;
var j = (g10, b11, d20, c14) => {
  for (var a24 = c14 > 1 ? void 0 : c14 ? i3(b11, d20) : b11, e5 = g10.length - 1, f16; e5 >= 0; e5--) (f16 = g10[e5]) && (a24 = (c14 ? f16(b11, d20, a24) : f16(a24)) || a24);
  return c14 && a24 && h(b11, d20, a24), a24;
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-A63SMUOU.mjs
var B = class {
  bcsToBytes() {
    let e5 = new n3();
    return this.serialize(e5), e5.toUint8Array();
  }
  bcsToHex() {
    let e5 = this.bcsToBytes();
    return i.fromHexInput(e5);
  }
};
var n3 = class {
  constructor(e5 = 64) {
    if (e5 <= 0) throw new Error("Length needs to be greater than 0");
    this.buffer = new ArrayBuffer(e5), this.offset = 0;
  }
  ensureBufferWillHandleSize(e5) {
    for (; this.buffer.byteLength < this.offset + e5; ) {
      let t30 = new ArrayBuffer(this.buffer.byteLength * 2);
      new Uint8Array(t30).set(new Uint8Array(this.buffer)), this.buffer = t30;
    }
  }
  appendToBuffer(e5) {
    this.ensureBufferWillHandleSize(e5.length), new Uint8Array(this.buffer, this.offset).set(e5), this.offset += e5.length;
  }
  serializeWithFunction(e5, t30, i47) {
    this.ensureBufferWillHandleSize(t30);
    let a24 = new DataView(this.buffer, this.offset);
    e5.apply(a24, [0, i47, true]), this.offset += t30;
  }
  serializeStr(e5) {
    let t30 = new TextEncoder();
    this.serializeBytes(t30.encode(e5));
  }
  serializeBytes(e5) {
    this.serializeU32AsUleb128(e5.length), this.appendToBuffer(e5);
  }
  serializeFixedBytes(e5) {
    this.appendToBuffer(e5);
  }
  serializeBool(e5) {
    A(e5);
    let t30 = e5 ? 1 : 0;
    this.appendToBuffer(new Uint8Array([t30]));
  }
  serializeU8(e5) {
    this.appendToBuffer(new Uint8Array([e5]));
  }
  serializeU16(e5) {
    this.serializeWithFunction(DataView.prototype.setUint16, 2, e5);
  }
  serializeU32(e5) {
    this.serializeWithFunction(DataView.prototype.setUint32, 4, e5);
  }
  serializeU64(e5) {
    let t30 = BigInt(e5) & BigInt(U), i47 = BigInt(e5) >> BigInt(32);
    this.serializeU32(Number(t30)), this.serializeU32(Number(i47));
  }
  serializeU128(e5) {
    let t30 = BigInt(e5) & _, i47 = BigInt(e5) >> BigInt(64);
    this.serializeU64(t30), this.serializeU64(i47);
  }
  serializeU256(e5) {
    let t30 = BigInt(e5) & o2, i47 = BigInt(e5) >> BigInt(128);
    this.serializeU128(t30), this.serializeU128(i47);
  }
  serializeU32AsUleb128(e5) {
    let t30 = e5, i47 = [];
    for (; t30 >>> 7; ) i47.push(t30 & 127 | 128), t30 >>>= 7;
    i47.push(t30), this.appendToBuffer(new Uint8Array(i47));
  }
  toUint8Array() {
    return new Uint8Array(this.buffer).slice(0, this.offset);
  }
  serialize(e5) {
    e5.serialize(this);
  }
  serializeVector(e5) {
    this.serializeU32AsUleb128(e5.length), e5.forEach((t30) => {
      t30.serialize(this);
    });
  }
  serializeOption(e5) {
    let t30 = e5 !== void 0;
    this.serializeBool(t30), t30 && e5.serialize(this);
  }
  serializeOptionStr(e5) {
    e5 === void 0 ? this.serializeU32AsUleb128(0) : (this.serializeU32AsUleb128(1), this.serializeStr(e5));
  }
};
j([o3(0, t)], n3.prototype, "serializeU8", 1), j([o3(0, n2)], n3.prototype, "serializeU16", 1), j([o3(0, U)], n3.prototype, "serializeU32", 1), j([o3(BigInt(0), _)], n3.prototype, "serializeU64", 1), j([o3(BigInt(0), o2)], n3.prototype, "serializeU128", 1), j([o3(BigInt(0), i2)], n3.prototype, "serializeU256", 1), j([o3(0, U)], n3.prototype, "serializeU32AsUleb128", 1);
function A(r26) {
  if (typeof r26 != "boolean") throw new Error(`${r26} is not a boolean value`);
}
var z = (r26, e5, t30) => `${r26} is out of range: [${e5}, ${t30}]`;
function g(r26, e5, t30) {
  let i47 = BigInt(r26);
  if (i47 > BigInt(t30) || i47 < BigInt(e5)) throw new Error(z(r26, e5, t30));
}
function o3(r26, e5) {
  return (t30, i47, a24) => {
    let p13 = a24.value;
    return a24.value = function(u15) {
      return g(u15, r26, e5), p13.apply(this, [u15]);
    }, a24;
  };
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-OHRL766V.mjs
var g2 = ((s12) => (s12.INCORRECT_NUMBER_OF_BYTES = "incorrect_number_of_bytes", s12.INVALID_HEX_CHARS = "invalid_hex_chars", s12.TOO_SHORT = "too_short", s12.TOO_LONG = "too_long", s12.LEADING_ZERO_X_REQUIRED = "leading_zero_x_required", s12.LONG_FORM_REQUIRED_UNLESS_SPECIAL = "long_form_required_unless_special", s12.INVALID_PADDING_ZEROES = "INVALID_PADDING_ZEROES", s12))(g2 || {});
var r = class r2 extends B {
  constructor(t30) {
    if (super(), t30.length !== r2.LENGTH) throw new s("AccountAddress data should be exactly 32 bytes long", "incorrect_number_of_bytes");
    this.data = t30;
  }
  isSpecial() {
    return this.data.slice(0, this.data.length - 1).every((t30) => t30 === 0) && this.data[this.data.length - 1] < 16;
  }
  toString() {
    return `0x${this.toStringWithoutPrefix()}`;
  }
  toStringWithoutPrefix() {
    let t30 = bytesToHex(this.data);
    return this.isSpecial() && (t30 = t30[t30.length - 1]), t30;
  }
  toStringLong() {
    return `0x${this.toStringLongWithoutPrefix()}`;
  }
  toStringLongWithoutPrefix() {
    return bytesToHex(this.data);
  }
  toUint8Array() {
    return this.data;
  }
  serialize(t30) {
    t30.serializeFixedBytes(this.data);
  }
  serializeForEntryFunction(t30) {
    let e5 = this.bcsToBytes();
    t30.serializeBytes(e5);
  }
  serializeForScriptFunction(t30) {
    t30.serializeU32AsUleb128(3), t30.serialize(this);
  }
  static deserialize(t30) {
    let e5 = t30.deserializeFixedBytes(r2.LENGTH);
    return new r2(e5);
  }
  static fromStringStrict(t30) {
    if (!t30.startsWith("0x")) throw new s("Hex string must start with a leading 0x.", "leading_zero_x_required");
    let e5 = r2.fromString(t30);
    if (t30.length !== r2.LONG_STRING_LENGTH + 2) if (e5.isSpecial()) {
      if (t30.length !== 3) throw new s(`The given hex string ${t30} is a special address not in LONG form, it must be 0x0 to 0xf without padding zeroes.`, "INVALID_PADDING_ZEROES");
    } else throw new s(`The given hex string ${t30} is not a special address, it must be represented as 0x + 64 chars.`, "long_form_required_unless_special");
    return e5;
  }
  static fromString(t30) {
    let e5 = t30;
    if (t30.startsWith("0x") && (e5 = t30.slice(2)), e5.length === 0) throw new s("Hex string is too short, must be 1 to 64 chars long, excluding the leading 0x.", "too_short");
    if (e5.length > 64) throw new s("Hex string is too long, must be 1 to 64 chars long, excluding the leading 0x.", "too_long");
    let n18;
    try {
      n18 = hexToBytes(e5.padStart(64, "0"));
    } catch (c14) {
      throw new s(`Hex characters are invalid: ${c14 == null ? void 0 : c14.message}`, "invalid_hex_chars");
    }
    return new r2(n18);
  }
  static from(t30) {
    return typeof t30 == "string" ? r2.fromString(t30) : t30 instanceof Uint8Array ? new r2(t30) : t30;
  }
  static fromStrict(t30) {
    return typeof t30 == "string" ? r2.fromStringStrict(t30) : t30 instanceof Uint8Array ? new r2(t30) : t30;
  }
  static isValid(t30) {
    try {
      return t30.strict ? r2.fromStrict(t30.input) : r2.from(t30.input), { valid: true };
    } catch (e5) {
      return { valid: false, invalidReason: e5 == null ? void 0 : e5.invalidReason, invalidReasonMessage: e5 == null ? void 0 : e5.message };
    }
  }
  equals(t30) {
    return this.data.length !== t30.data.length ? false : this.data.every((e5, n18) => e5 === t30.data[n18]);
  }
};
r.LENGTH = 32, r.LONG_STRING_LENGTH = 64, r.ZERO = r.from("0x0"), r.ONE = r.from("0x1"), r.TWO = r.from("0x2"), r.THREE = r.from("0x3"), r.FOUR = r.from("0x4"), r.A = r.from("0xA");
var d = r;

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-H6YNXJNF.mjs
var t2 = class a extends B {
  constructor(e5) {
    super(), this.value = i.fromHexInput(e5).toUint8Array();
  }
  serialize(e5) {
    e5.serializeFixedBytes(this.value);
  }
  serializeForEntryFunction(e5) {
    e5.serialize(this);
  }
  serializeForScriptFunction(e5) {
    e5.serialize(this);
  }
  static deserialize(e5, s12) {
    let o26 = e5.deserializeFixedBytes(s12);
    return new a(o26);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YPHH6CAO.mjs
var d2 = class i4 extends B {
  constructor(e5) {
    super(), A(e5), this.value = e5;
  }
  serialize(e5) {
    e5.serializeBool(this.value);
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  serializeForScriptFunction(e5) {
    e5.serializeU32AsUleb128(5), e5.serialize(this);
  }
  static deserialize(e5) {
    return new i4(e5.deserializeBool());
  }
};
var U2 = class i5 extends B {
  constructor(e5) {
    super(), g(e5, 0, t), this.value = e5;
  }
  serialize(e5) {
    e5.serializeU8(this.value);
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  serializeForScriptFunction(e5) {
    e5.serializeU32AsUleb128(0), e5.serialize(this);
  }
  static deserialize(e5) {
    return new i5(e5.deserializeU8());
  }
};
var p = class i6 extends B {
  constructor(e5) {
    super(), g(e5, 0, n2), this.value = e5;
  }
  serialize(e5) {
    e5.serializeU16(this.value);
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  serializeForScriptFunction(e5) {
    e5.serializeU32AsUleb128(6), e5.serialize(this);
  }
  static deserialize(e5) {
    return new i6(e5.deserializeU16());
  }
};
var b = class i7 extends B {
  constructor(e5) {
    super(), g(e5, 0, U), this.value = e5;
  }
  serialize(e5) {
    e5.serializeU32(this.value);
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  serializeForScriptFunction(e5) {
    e5.serializeU32AsUleb128(7), e5.serialize(this);
  }
  static deserialize(e5) {
    return new i7(e5.deserializeU32());
  }
};
var y = class i8 extends B {
  constructor(e5) {
    super(), g(e5, BigInt(0), _), this.value = BigInt(e5);
  }
  serialize(e5) {
    e5.serializeU64(this.value);
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  serializeForScriptFunction(e5) {
    e5.serializeU32AsUleb128(1), e5.serialize(this);
  }
  static deserialize(e5) {
    return new i8(e5.deserializeU64());
  }
};
var m = class i9 extends B {
  constructor(e5) {
    super(), g(e5, BigInt(0), o2), this.value = BigInt(e5);
  }
  serialize(e5) {
    e5.serializeU128(this.value);
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  serializeForScriptFunction(e5) {
    e5.serializeU32AsUleb128(2), e5.serialize(this);
  }
  static deserialize(e5) {
    return new i9(e5.deserializeU128());
  }
};
var B2 = class i10 extends B {
  constructor(e5) {
    super(), g(e5, BigInt(0), i2), this.value = BigInt(e5);
  }
  serialize(e5) {
    e5.serializeU256(this.value);
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  serializeForScriptFunction(e5) {
    e5.serializeU32AsUleb128(8), e5.serialize(this);
  }
  static deserialize(e5) {
    return new i10(e5.deserializeU256());
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-KMJ6TF6Y.mjs
var t3 = class n4 extends B {
  constructor(e5) {
    super(), this.values = e5;
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  serializeForScriptFunction(e5) {
    if (!(this.values[0] instanceof U2) && this.values[0] !== void 0) throw new Error("Script function arguments only accept u8 vectors");
    e5.serializeU32AsUleb128(4), e5.serialize(this);
  }
  static U8(e5) {
    let r26;
    if (Array.isArray(e5) && e5.length === 0) r26 = [];
    else if (Array.isArray(e5) && typeof e5[0] == "number") r26 = e5;
    else if (typeof e5 == "string") {
      let i47 = i.fromHexInput(e5);
      r26 = Array.from(i47.toUint8Array());
    } else if (e5 instanceof Uint8Array) r26 = Array.from(e5);
    else throw new Error("Invalid input type, must be an number[], Uint8Array, or hex string");
    return new n4(r26.map((i47) => new U2(i47)));
  }
  static U16(e5) {
    return new n4(e5.map((r26) => new p(r26)));
  }
  static U32(e5) {
    return new n4(e5.map((r26) => new b(r26)));
  }
  static U64(e5) {
    return new n4(e5.map((r26) => new y(r26)));
  }
  static U128(e5) {
    return new n4(e5.map((r26) => new m(r26)));
  }
  static U256(e5) {
    return new n4(e5.map((r26) => new B2(r26)));
  }
  static Bool(e5) {
    return new n4(e5.map((r26) => new d2(r26)));
  }
  static MoveString(e5) {
    return new n4(e5.map((r26) => new a2(r26)));
  }
  serialize(e5) {
    e5.serializeVector(this.values);
  }
  static deserialize(e5, r26) {
    let i47 = e5.deserializeUleb128AsU32(), y12 = new Array();
    for (let p13 = 0; p13 < i47; p13 += 1) y12.push(r26.deserialize(e5));
    return new n4(y12);
  }
};
var a2 = class n5 extends B {
  constructor(e5) {
    super(), this.value = e5;
  }
  serialize(e5) {
    e5.serializeStr(this.value);
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  serializeForScriptFunction(e5) {
    let r26 = this.bcsToBytes().slice(1);
    t3.U8(r26).serializeForScriptFunction(e5);
  }
  static deserialize(e5) {
    return new n5(e5.deserializeStr());
  }
};
var z2 = class n6 extends B {
  constructor(e5) {
    super(), typeof e5 < "u" && e5 !== null ? this.vec = new t3([e5]) : this.vec = new t3([]), [this.value] = this.vec.values;
  }
  serializeForEntryFunction(e5) {
    let r26 = this.bcsToBytes();
    e5.serializeBytes(r26);
  }
  unwrap() {
    if (this.isSome()) return this.vec.values[0];
    throw new Error("Called unwrap on a MoveOption with no value");
  }
  isSome() {
    return this.vec.values.length === 1;
  }
  serialize(e5) {
    this.vec.serialize(e5);
  }
  static U8(e5) {
    return new n6(e5 != null ? new U2(e5) : void 0);
  }
  static U16(e5) {
    return new n6(e5 != null ? new p(e5) : void 0);
  }
  static U32(e5) {
    return new n6(e5 != null ? new b(e5) : void 0);
  }
  static U64(e5) {
    return new n6(e5 != null ? new y(e5) : void 0);
  }
  static U128(e5) {
    return new n6(e5 != null ? new m(e5) : void 0);
  }
  static U256(e5) {
    return new n6(e5 != null ? new B2(e5) : void 0);
  }
  static Bool(e5) {
    return new n6(e5 != null ? new d2(e5) : void 0);
  }
  static MoveString(e5) {
    return new n6(e5 != null ? new a2(e5) : void 0);
  }
  static deserialize(e5, r26) {
    let i47 = t3.deserialize(e5, r26);
    return new n6(i47.values[0]);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-G7UNU5GI.mjs
function D(n18) {
  return typeof n18 == "boolean";
}
function l2(n18) {
  return typeof n18 == "string";
}
function d3(n18) {
  return typeof n18 == "number";
}
function P(n18) {
  if (d3(n18)) return n18;
  if (l2(n18) && n18 !== "") return Number.parseInt(n18, 10);
}
function w(n18) {
  return typeof n18 == "number" || typeof n18 == "bigint" || typeof n18 == "string";
}
function G(n18) {
  return n18 == null;
}
function $(n18) {
  return T(n18) || B3(n18) || U3(n18) || b2(n18) || I(n18) || v(n18) || h2(n18) || E(n18) || x(n18) || S(n18) || n18 instanceof t3 || n18 instanceof z2;
}
function T(n18) {
  return n18 instanceof d2;
}
function E(n18) {
  return n18 instanceof d;
}
function x(n18) {
  return n18 instanceof a2;
}
function S(n18) {
  return n18 instanceof t2;
}
function B3(n18) {
  return n18 instanceof U2;
}
function U3(n18) {
  return n18 instanceof p;
}
function b2(n18) {
  return n18 instanceof b;
}
function I(n18) {
  return n18 instanceof y;
}
function v(n18) {
  return n18 instanceof m;
}
function h2(n18) {
  return n18 instanceof B2;
}
function O(n18) {
  return "bytecode" in n18;
}
function R(n18, t30) {
  throw new Error(`Type mismatch for argument ${t30}, expected '${n18}'`);
}
function W(n18) {
  let t30 = n18.params.findIndex((e5) => e5 !== "signer" && e5 !== "&signer");
  return t30 < 0 ? n18.params.length : t30;
}
function L(n18) {
  let t30 = n18.split("::");
  if (t30.length !== 3) throw new Error(`Invalid function ${n18}`);
  let e5 = t30[0], F8 = t30[1], A15 = t30[2];
  return { moduleAddress: e5, moduleName: F8, functionName: A15 };
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YUNDX5I7.mjs
var r3 = class t4 extends B {
  constructor(i47) {
    super(), this.identifier = i47;
  }
  serialize(i47) {
    i47.serializeStr(this.identifier);
  }
  static deserialize(i47) {
    let s12 = i47.deserializeStr();
    return new t4(s12);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-SUJLWCRN.mjs
var t5 = class extends B {
  static deserialize(e5) {
    let r26 = e5.deserializeUleb128AsU32();
    switch (r26) {
      case 0:
        return c.load(e5);
      case 1:
        return u2.load(e5);
      case 2:
        return p2.load(e5);
      case 3:
        return z3.load(e5);
      case 4:
        return S2.load(e5);
      case 5:
        return U4.load(e5);
      case 6:
        return y2.load(e5);
      case 7:
        return b3.load(e5);
      case 8:
        return d4.load(e5);
      case 9:
        return g3.load(e5);
      case 10:
        return T2.load(e5);
      case 255:
        return h3.load(e5);
      default:
        throw new Error(`Unknown variant index for TypeTag: ${r26}`);
    }
  }
  isBool() {
    return this instanceof c;
  }
  isAddress() {
    return this instanceof S2;
  }
  isGeneric() {
    return this instanceof h3;
  }
  isSigner() {
    return this instanceof U4;
  }
  isVector() {
    return this instanceof y2;
  }
  isStruct() {
    return this instanceof b3;
  }
  isU8() {
    return this instanceof u2;
  }
  isU16() {
    return this instanceof d4;
  }
  isU32() {
    return this instanceof g3;
  }
  isU64() {
    return this instanceof p2;
  }
  isU128() {
    return this instanceof z3;
  }
  isU256() {
    return this instanceof T2;
  }
};
var c = class i11 extends t5 {
  toString() {
    return "bool";
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(0);
  }
  static load(e5) {
    return new i11();
  }
};
var u2 = class i12 extends t5 {
  toString() {
    return "u8";
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(1);
  }
  static load(e5) {
    return new i12();
  }
};
var d4 = class i13 extends t5 {
  toString() {
    return "u16";
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(8);
  }
  static load(e5) {
    return new i13();
  }
};
var g3 = class i14 extends t5 {
  toString() {
    return "u32";
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(9);
  }
  static load(e5) {
    return new i14();
  }
};
var p2 = class i15 extends t5 {
  toString() {
    return "u64";
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(2);
  }
  static load(e5) {
    return new i15();
  }
};
var z3 = class i16 extends t5 {
  toString() {
    return "u128";
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(3);
  }
  static load(e5) {
    return new i16();
  }
};
var T2 = class i17 extends t5 {
  toString() {
    return "u256";
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(10);
  }
  static load(e5) {
    return new i17();
  }
};
var S2 = class i18 extends t5 {
  toString() {
    return "address";
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(4);
  }
  static load(e5) {
    return new i18();
  }
};
var U4 = class i19 extends t5 {
  toString() {
    return "signer";
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(5);
  }
  static load(e5) {
    return new i19();
  }
};
var x2 = class i20 extends t5 {
  constructor(r26) {
    super();
    this.value = r26;
  }
  toString() {
    return `&${this.value.toString()}`;
  }
  serialize(r26) {
    r26.serializeU32AsUleb128(254);
  }
  static load(r26) {
    let s12 = t5.deserialize(r26);
    return new i20(s12);
  }
};
var h3 = class i21 extends t5 {
  constructor(r26) {
    super();
    this.value = r26;
    if (r26 < 0) throw new Error("Generic type parameter index cannot be negative");
  }
  toString() {
    return `T${this.value}`;
  }
  serialize(r26) {
    r26.serializeU32AsUleb128(255), r26.serializeU32(this.value);
  }
  static load(r26) {
    let s12 = r26.deserializeU32();
    return new i21(s12);
  }
};
var y2 = class i22 extends t5 {
  constructor(r26) {
    super();
    this.value = r26;
  }
  toString() {
    return `vector<${this.value.toString()}>`;
  }
  static u8() {
    return new i22(new u2());
  }
  serialize(r26) {
    r26.serializeU32AsUleb128(6), this.value.serialize(r26);
  }
  static load(r26) {
    let s12 = t5.deserialize(r26);
    return new i22(s12);
  }
};
var b3 = class i23 extends t5 {
  constructor(r26) {
    super();
    this.value = r26;
  }
  toString() {
    let r26 = "";
    return this.value.typeArgs.length > 0 && (r26 = `<${this.value.typeArgs.map((s12) => s12.toString()).join(", ")}>`), `${this.value.address.toString()}::${this.value.moduleName.identifier}::${this.value.name.identifier}${r26}`;
  }
  serialize(r26) {
    r26.serializeU32AsUleb128(7), this.value.serialize(r26);
  }
  static load(r26) {
    let s12 = o4.deserialize(r26);
    return new i23(s12);
  }
  isTypeTag(r26, s12, l19) {
    return this.value.moduleName.identifier === s12 && this.value.name.identifier === l19 && this.value.address.equals(r26);
  }
  isString() {
    return this.isTypeTag(d.ONE, "string", "String");
  }
  isOption() {
    return this.isTypeTag(d.ONE, "option", "Option");
  }
  isObject() {
    return this.isTypeTag(d.ONE, "object", "Object");
  }
};
var o4 = class i24 extends B {
  constructor(e5, r26, s12, l19) {
    super(), this.address = e5, this.moduleName = r26, this.name = s12, this.typeArgs = l19;
  }
  serialize(e5) {
    e5.serialize(this.address), e5.serialize(this.moduleName), e5.serialize(this.name), e5.serializeVector(this.typeArgs);
  }
  static deserialize(e5) {
    let r26 = d.deserialize(e5), s12 = r3.deserialize(e5), l19 = r3.deserialize(e5), f16 = e5.deserializeVector(t5);
    return new i24(r26, s12, l19, f16);
  }
};
function O2() {
  return new o4(d.ONE, new r3("aptos_coin"), new r3("AptosCoin"), []);
}
function E2() {
  return new o4(d.ONE, new r3("string"), new r3("String"), []);
}
function V(i47) {
  return new o4(d.ONE, new r3("option"), new r3("Option"), [i47]);
}
function j2(i47) {
  return new o4(d.ONE, new r3("object"), new r3("Object"), [i47]);
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NWOMSL6K.mjs
function V2(e5) {
  return !!e5.match(/^[_a-zA-Z0-9]+$/);
}
function W2(e5) {
  return !!e5.match(/\s/);
}
function $2(e5) {
  return !!e5.match(/^T[0-9]+$/);
}
function F(e5) {
  return !!e5.match(/^&.+$/);
}
function k(e5) {
  switch (e5) {
    case "signer":
    case "address":
    case "bool":
    case "u8":
    case "u16":
    case "u32":
    case "u64":
    case "u128":
    case "u256":
      return true;
    default:
      return false;
  }
}
function L2(e5, i47) {
  let c14 = i47;
  for (; c14 < e5.length; c14 += 1) {
    let s12 = e5[c14];
    if (!W2(s12)) break;
  }
  return c14;
}
var R2 = ((a24) => (a24.InvalidTypeTag = "unknown type", a24.UnexpectedGenericType = "unexpected generic type", a24.UnexpectedTypeArgumentClose = "unexpected '>'", a24.UnexpectedWhitespaceCharacter = "unexpected whitespace character", a24.UnexpectedComma = "unexpected ','", a24.TypeArgumentCountMismatch = "type argument count doesn't match expected amount", a24.MissingTypeArgumentClose = "no matching '>' for '<'", a24.MissingTypeArgument = "no type argument before ','", a24.UnexpectedPrimitiveTypeArguments = "primitive types not expected to have type arguments", a24.UnexpectedVectorTypeArgumentCount = "vector type expected to have exactly one type argument", a24.UnexpectedStructFormat = "unexpected struct format, must be of the form 0xaddress::module_name::struct_name", a24.InvalidModuleNameCharacter = "module name must only contain alphanumeric or '_' characters", a24.InvalidStructNameCharacter = "struct name must only contain alphanumeric or '_' characters", a24.InvalidAddress = "struct address must be valid", a24))(R2 || {});
var t6 = class extends Error {
  constructor(i47, c14) {
    super(`Failed to parse typeTag '${i47}', ${c14}`);
  }
};
function j3(e5, i47) {
  let c14 = (i47 == null ? void 0 : i47.allowGenerics) ?? false, s12 = [], u15 = [], n18 = [], o26 = 0, r26 = "", T11 = 1;
  for (; o26 < e5.length; ) {
    let d20 = e5[o26];
    if (d20 === "<") s12.push({ savedExpectedTypes: T11, savedStr: r26, savedTypes: n18 }), r26 = "", n18 = [], T11 = 1;
    else if (d20 === ">") {
      if (r26 !== "") {
        let a24 = g4(r26, u15, c14);
        n18.push(a24);
      }
      let p13 = s12.pop();
      if (p13 === void 0) throw new t6(e5, "unexpected '>'");
      if (T11 !== n18.length) throw new t6(e5, "type argument count doesn't match expected amount");
      let { savedStr: m15, savedTypes: h17, savedExpectedTypes: _8 } = p13;
      u15 = n18, n18 = h17, r26 = m15, T11 = _8;
    } else if (d20 === ",") {
      if (s12.length === 0) throw new t6(e5, "unexpected ','");
      if (r26.length === 0) throw new t6(e5, "no type argument before ','");
      let p13 = g4(r26, u15, c14);
      u15 = [], n18.push(p13), r26 = "", T11 += 1;
    } else if (W2(d20)) {
      let p13 = false;
      if (r26.length !== 0) {
        let h17 = g4(r26, u15, c14);
        u15 = [], n18.push(h17), r26 = "", p13 = true;
      }
      o26 = L2(e5, o26);
      let m15 = e5[o26];
      if (o26 < e5.length && p13 && m15 !== "," && m15 !== ">") throw new t6(e5, "unexpected whitespace character");
      continue;
    } else r26 += d20;
    o26 += 1;
  }
  if (s12.length > 0) throw new t6(e5, "no matching '>' for '<'");
  switch (n18.length) {
    case 0:
      return g4(r26, u15, c14);
    case 1:
      if (r26 === "") return n18[0];
      throw new t6(e5, "unexpected ','");
    default:
      throw new t6(e5, "unexpected whitespace character");
  }
}
function g4(e5, i47, c14) {
  let s12 = e5.trim(), u15 = s12.toLowerCase();
  if (k(u15) && i47.length > 0) throw new t6(e5, "primitive types not expected to have type arguments");
  switch (s12.toLowerCase()) {
    case "signer":
      return new U4();
    case "bool":
      return new c();
    case "address":
      return new S2();
    case "u8":
      return new u2();
    case "u16":
      return new d4();
    case "u32":
      return new g3();
    case "u64":
      return new p2();
    case "u128":
      return new z3();
    case "u256":
      return new T2();
    case "vector":
      if (i47.length !== 1) throw new t6(e5, "vector type expected to have exactly one type argument");
      return new y2(i47[0]);
    default:
      if (F(s12)) {
        let r26 = s12.substring(1);
        return new x2(g4(r26, i47, c14));
      }
      if ($2(s12)) {
        if (c14) return new h3(Number(s12.split("T")[1]));
        throw new t6(e5, "unexpected generic type");
      }
      if (!s12.match(/:/)) throw new t6(e5, "unknown type");
      let n18 = s12.split("::");
      if (n18.length !== 3) throw new t6(e5, "unexpected struct format, must be of the form 0xaddress::module_name::struct_name");
      let o26;
      try {
        o26 = d.fromString(n18[0]);
      } catch {
        throw new t6(e5, "struct address must be valid");
      }
      if (!V2(n18[1])) throw new t6(e5, "module name must only contain alphanumeric or '_' characters");
      if (!V2(n18[2])) throw new t6(e5, "struct name must only contain alphanumeric or '_' characters");
      return new b3(new o4(o26, new r3(n18[1]), new r3(n18[2]), i47));
  }
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-VHNX2NUR.mjs
var a3 = `
    fragment TokenActivitiesFields on token_activities_v2 {
  after_value
  before_value
  entry_function_id_str
  event_account_address
  event_index
  from_address
  is_fungible_v2
  property_version_v1
  to_address
  token_amount
  token_data_id
  token_standard
  transaction_timestamp
  transaction_version
  type
}
    `;
var i25 = `
    fragment AnsTokenFragment on current_aptos_names {
  domain
  expiration_timestamp
  registered_address
  subdomain
  token_standard
  is_primary
  owner_address
  subdomain_expiration_policy
  domain_expiration_timestamp
}
    `;
var s2 = `
    fragment CurrentTokenOwnershipFields on current_token_ownerships_v2 {
  token_standard
  token_properties_mutated_v1
  token_data_id
  table_type_v1
  storage_id
  property_version_v1
  owner_address
  last_transaction_version
  last_transaction_timestamp
  is_soulbound_v2
  is_fungible_v2
  amount
  current_token_data {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;
var _2 = `
    query getAccountCoinsCount($address: String) {
  current_fungible_asset_balances_aggregate(
    where: {owner_address: {_eq: $address}}
  ) {
    aggregate {
      count
    }
  }
}
    `;
var u3 = `
    query getAccountCoinsData($where_condition: current_fungible_asset_balances_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_fungible_asset_balances_order_by!]) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
    metadata {
      token_standard
      symbol
      supply_aggregator_table_key_v1
      supply_aggregator_table_handle_v1
      project_uri
      name
      last_transaction_version
      last_transaction_timestamp
      icon_uri
      decimals
      creator_address
      asset_type
    }
  }
}
    `;
var c2 = `
    query getAccountCollectionsWithOwnedTokens($where_condition: current_collection_ownership_v2_view_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_collection_ownership_v2_view_order_by!]) {
  current_collection_ownership_v2_view(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      mutable_description
      max_supply
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
    collection_id
    collection_name
    collection_uri
    creator_address
    distinct_tokens
    last_transaction_version
    owner_address
    single_token_uri
  }
}
    `;
var d5 = `
    query getAccountOwnedTokens($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var l3 = `
    query getAccountOwnedTokensByTokenData($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var y3 = `
    query getAccountOwnedTokensFromCollection($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var p3 = `
    query getAccountTokensCount($where_condition: current_token_ownerships_v2_bool_exp, $offset: Int, $limit: Int) {
  current_token_ownerships_v2_aggregate(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    aggregate {
      count
    }
  }
}
    `;
var m2 = `
    query getAccountTransactionsCount($address: String) {
  account_transactions_aggregate(where: {account_address: {_eq: $address}}) {
    aggregate {
      count
    }
  }
}
    `;
var g5 = `
    query getChainTopUserTransactions($limit: Int) {
  user_transactions(limit: $limit, order_by: {version: desc}) {
    version
  }
}
    `;
var T3 = `
    query getCollectionData($where_condition: current_collections_v2_bool_exp!) {
  current_collections_v2(where: $where_condition) {
    uri
    total_minted_v2
    token_standard
    table_handle_v1
    mutable_uri
    mutable_description
    max_supply
    collection_id
    collection_name
    creator_address
    current_supply
    description
    last_transaction_timestamp
    last_transaction_version
    cdn_asset_uris {
      cdn_image_uri
      asset_uri
      animation_optimizer_retry_count
      cdn_animation_uri
      cdn_json_uri
      image_optimizer_retry_count
      json_parser_retry_count
      raw_animation_uri
      raw_image_uri
    }
  }
}
    `;
var b4 = `
    query getCurrentFungibleAssetBalances($where_condition: current_fungible_asset_balances_bool_exp, $offset: Int, $limit: Int) {
  current_fungible_asset_balances(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    is_frozen
    is_primary
    last_transaction_timestamp
    last_transaction_version
    owner_address
    storage_id
    token_standard
  }
}
    `;
var $3 = `
    query getDelegatedStakingActivities($delegatorAddress: String, $poolAddress: String) {
  delegated_staking_activities(
    where: {delegator_address: {_eq: $delegatorAddress}, pool_address: {_eq: $poolAddress}}
  ) {
    amount
    delegator_address
    event_index
    event_type
    pool_address
    transaction_version
  }
}
    `;
var k2 = `
    query getEvents($where_condition: events_bool_exp, $offset: Int, $limit: Int, $order_by: [events_order_by!]) {
  events(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    account_address
    creation_number
    data
    event_index
    sequence_number
    transaction_block_height
    transaction_version
    type
    indexed_type
  }
}
    `;
var f = `
    query getFungibleAssetActivities($where_condition: fungible_asset_activities_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_activities(
    where: $where_condition
    offset: $offset
    limit: $limit
  ) {
    amount
    asset_type
    block_height
    entry_function_id_str
    event_index
    gas_fee_payer_address
    is_frozen
    is_gas_fee
    is_transaction_success
    owner_address
    storage_id
    storage_refund_amount
    token_standard
    transaction_timestamp
    transaction_version
    type
  }
}
    `;
var h4 = `
    query getFungibleAssetMetadata($where_condition: fungible_asset_metadata_bool_exp, $offset: Int, $limit: Int) {
  fungible_asset_metadata(where: $where_condition, offset: $offset, limit: $limit) {
    icon_uri
    project_uri
    supply_aggregator_table_handle_v1
    supply_aggregator_table_key_v1
    creator_address
    asset_type
    decimals
    last_transaction_timestamp
    last_transaction_version
    name
    symbol
    token_standard
    supply_v2
    maximum_v2
  }
}
    `;
var G2 = `
    query getNames($offset: Int, $limit: Int, $where_condition: current_aptos_names_bool_exp, $order_by: [current_aptos_names_order_by!]) {
  current_aptos_names(
    limit: $limit
    where: $where_condition
    order_by: $order_by
    offset: $offset
  ) {
    ...AnsTokenFragment
  }
}
    ${i25}`;
var w2 = `
    query getNumberOfDelegators($where_condition: num_active_delegator_per_pool_bool_exp, $order_by: [num_active_delegator_per_pool_order_by!]) {
  num_active_delegator_per_pool(where: $where_condition, order_by: $order_by) {
    num_active_delegator
    pool_address
  }
}
    `;
var v2 = `
    query getObjectData($where_condition: current_objects_bool_exp, $offset: Int, $limit: Int, $order_by: [current_objects_order_by!]) {
  current_objects(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    allow_ungated_transfer
    state_key_hash
    owner_address
    object_address
    last_transaction_version
    last_guid_creation_num
    is_deleted
  }
}
    `;
var C = `
    query getProcessorStatus($where_condition: processor_status_bool_exp) {
  processor_status(where: $where_condition) {
    last_success_version
    processor
    last_updated
  }
}
    `;
var A2 = `
    query getTableItemsData($where_condition: table_items_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_items_order_by!]) {
  table_items(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    decoded_key
    decoded_value
    key
    table_handle
    transaction_version
    write_set_change_index
  }
}
    `;
var q = `
    query getTableItemsMetadata($where_condition: table_metadatas_bool_exp!, $offset: Int, $limit: Int, $order_by: [table_metadatas_order_by!]) {
  table_metadatas(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    handle
    key_type
    value_type
  }
}
    `;
var Q = `
    query getTokenActivity($where_condition: token_activities_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [token_activities_v2_order_by!]) {
  token_activities_v2(
    where: $where_condition
    order_by: $order_by
    offset: $offset
    limit: $limit
  ) {
    ...TokenActivitiesFields
  }
}
    ${a3}`;
var x3 = `
    query getCurrentTokenOwnership($where_condition: current_token_ownerships_v2_bool_exp!, $offset: Int, $limit: Int, $order_by: [current_token_ownerships_v2_order_by!]) {
  current_token_ownerships_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    ...CurrentTokenOwnershipFields
  }
}
    ${s2}`;
var D2 = `
    query getTokenData($where_condition: current_token_datas_v2_bool_exp, $offset: Int, $limit: Int, $order_by: [current_token_datas_v2_order_by!]) {
  current_token_datas_v2(
    where: $where_condition
    offset: $offset
    limit: $limit
    order_by: $order_by
  ) {
    collection_id
    description
    is_fungible_v2
    largest_property_version_v1
    last_transaction_timestamp
    last_transaction_version
    maximum
    supply
    token_data_id
    token_name
    token_properties
    token_standard
    token_uri
    decimals
    current_collection {
      collection_id
      collection_name
      creator_address
      current_supply
      description
      last_transaction_timestamp
      last_transaction_version
      max_supply
      mutable_description
      mutable_uri
      table_handle_v1
      token_standard
      total_minted_v2
      uri
    }
  }
}
    `;

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-TDGQGILY.mjs
var n7 = class extends Error {
  constructor({ apiType: r26, aptosRequest: t30, aptosResponse: e5 }) {
    super(d6({ apiType: r26, aptosRequest: t30, aptosResponse: e5 })), this.name = "AptosApiError", this.url = e5.url, this.status = e5.status, this.statusText = e5.statusText, this.data = e5.data, this.request = t30;
  }
};
function d6({ apiType: s12, aptosRequest: r26, aptosResponse: t30 }) {
  var _a, _b, _c, _d, _e, _f, _g;
  let e5 = (_b = (_a = t30.headers) == null ? void 0 : _a.traceparent) == null ? void 0 : _b.split("-")[1], u15 = e5 ? `(trace_id:${e5}) ` : "", a24 = `Request to [${s12}]: ${r26.method} ${t30.url ?? r26.url} ${u15}failed with`;
  return s12 === "Indexer" && ((_e = (_d = (_c = t30.data) == null ? void 0 : _c.errors) == null ? void 0 : _d[0]) == null ? void 0 : _e.message) != null ? `${a24}: ${t30.data.errors[0].message}` : ((_f = t30.data) == null ? void 0 : _f.message) != null && ((_g = t30.data) == null ? void 0 : _g.error_code) != null ? `${a24}: ${JSON.stringify(t30.data)}` : `${a24} status: ${t30.statusText}(code:${t30.status}) and response body: ${l4(t30.data)}`;
}
var i26 = 400;
function l4(s12) {
  let r26 = JSON.stringify(s12);
  return r26.length <= i26 ? r26 : `truncated(original_size:${r26.length}): ${r26.slice(0, i26 / 2)}...${r26.slice(-i26 / 2)}`;
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-DDKAXJOY.mjs
var o5 = "1.26.0";

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-5BSAUHMZ.mjs
async function A3(s12, u15) {
  let { url: t30, method: n18, body: i47, contentType: a24, params: o26, overrides: e5, originMethod: R7 } = s12, p13 = { ...e5 == null ? void 0 : e5.HEADERS, "x-aptos-client": `aptos-typescript-sdk/${o5}`, "content-type": a24 ?? "application/json", "x-aptos-typescript-sdk-origin-method": R7 };
  return (e5 == null ? void 0 : e5.AUTH_TOKEN) && (p13.Authorization = `Bearer ${e5 == null ? void 0 : e5.AUTH_TOKEN}`), (e5 == null ? void 0 : e5.API_KEY) && (p13.Authorization = `Bearer ${e5 == null ? void 0 : e5.API_KEY}`), u15.provider({ url: t30, method: n18, body: i47, params: o26, headers: p13, overrides: e5 });
}
async function y4(s12, u15, t30) {
  let { url: n18, path: i47 } = s12, a24 = i47 ? `${n18}/${i47}` : n18, o26 = await A3({ ...s12, url: a24 }, u15.client), e5 = { status: o26.status, statusText: o26.statusText, data: o26.data, headers: o26.headers, config: o26.config, request: o26.request, url: a24 };
  if (e5.status === 401) throw new n7({ apiType: t30, aptosRequest: s12, aptosResponse: e5 });
  if (t30 === "Indexer") {
    let R7 = e5.data;
    if (R7.errors) throw new n7({ apiType: t30, aptosRequest: s12, aptosResponse: e5 });
    e5.data = R7.data;
  } else if ((t30 === "Pepper" || t30 === "Prover") && e5.status >= 400) throw new n7({ apiType: t30, aptosRequest: s12, aptosResponse: e5 });
  if (e5.status >= 200 && e5.status < 300) return e5;
  throw new n7({ apiType: t30, aptosRequest: s12, aptosResponse: e5 });
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-A2SMIFMN.mjs
async function r4(e5) {
  let { aptosConfig: t30, overrides: s12, params: n18, contentType: o26, acceptType: i47, path: a24, originMethod: R7, type: d20 } = e5, u15 = t30.getRequestUrl(d20);
  return y4({ url: u15, method: "GET", originMethod: R7, path: a24, contentType: o26, acceptType: i47, params: n18, overrides: { ...t30.clientConfig, ...s12 } }, t30, e5.type);
}
async function m3(e5) {
  var _a, _b;
  let { aptosConfig: t30 } = e5;
  return r4({ ...e5, type: "Fullnode", overrides: { ...t30.clientConfig, ...t30.fullnodeConfig, ...e5.overrides, HEADERS: { ...(_a = t30.clientConfig) == null ? void 0 : _a.HEADERS, ...(_b = t30.fullnodeConfig) == null ? void 0 : _b.HEADERS } } });
}
async function y5(e5) {
  return r4({ ...e5, type: "Pepper" });
}
async function A4(e5) {
  let t30 = [], s12, n18 = e5.params;
  do {
    let o26 = await r4({ type: "Fullnode", aptosConfig: e5.aptosConfig, originMethod: e5.originMethod, path: e5.path, params: n18, overrides: e5.overrides });
    s12 = o26.headers["x-aptos-cursor"], delete o26.headers, t30.push(...o26.data), n18.start = s12;
  } while (s12 != null);
  return t30;
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-4MDBWSPX.mjs
async function o6(e5) {
  let { type: t30, originMethod: s12, path: i47, body: r26, acceptType: R7, contentType: f16, params: c14, aptosConfig: n18, overrides: A15 } = e5, d20 = n18.getRequestUrl(t30);
  return y4({ url: d20, method: "POST", originMethod: s12, path: i47, body: r26, contentType: f16, acceptType: R7, params: c14, overrides: A15 }, n18, e5.type);
}
async function q2(e5) {
  var _a, _b;
  let { aptosConfig: t30 } = e5;
  return o6({ ...e5, type: "Fullnode", overrides: { ...t30.clientConfig, ...t30.fullnodeConfig, ...e5.overrides, HEADERS: { ...(_a = t30.clientConfig) == null ? void 0 : _a.HEADERS, ...(_b = t30.fullnodeConfig) == null ? void 0 : _b.HEADERS } } });
}
async function C2(e5) {
  var _a, _b;
  let { aptosConfig: t30 } = e5;
  return o6({ ...e5, type: "Indexer", overrides: { ...t30.clientConfig, ...t30.indexerConfig, ...e5.overrides, HEADERS: { ...(_a = t30.clientConfig) == null ? void 0 : _a.HEADERS, ...(_b = t30.indexerConfig) == null ? void 0 : _b.HEADERS } } });
}
async function m4(e5) {
  var _a, _b, _c;
  let { aptosConfig: t30 } = e5, s12 = { ...t30, clientConfig: { ...t30.clientConfig } };
  return (_a = s12 == null ? void 0 : s12.clientConfig) == null ? true : delete _a.API_KEY, o6({ ...e5, type: "Faucet", overrides: { ...s12.clientConfig, ...s12.faucetConfig, ...e5.overrides, HEADERS: { ...(_b = s12.clientConfig) == null ? void 0 : _b.HEADERS, ...(_c = s12.faucetConfig) == null ? void 0 : _c.HEADERS } } });
}
async function E3(e5) {
  return o6({ ...e5, type: "Pepper" });
}
async function a4(e5) {
  return o6({ ...e5, type: "Prover" });
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-T6VJAACM.mjs
async function d7(o26) {
  let { aptosConfig: s12 } = o26, { data: e5 } = await m3({ aptosConfig: s12, originMethod: "getLedgerInfo", path: "" });
  return e5;
}
async function C3(o26) {
  let { aptosConfig: s12, limit: e5 } = o26;
  return (await a5({ aptosConfig: s12, query: { query: g5, variables: { limit: e5 } }, originMethod: "getChainTopUserTransactions" })).user_transactions;
}
async function a5(o26) {
  let { aptosConfig: s12, query: e5, originMethod: t30 } = o26, { data: r26 } = await C2({ aptosConfig: s12, originMethod: t30 ?? "queryIndexer", path: "", body: e5, overrides: { WITH_CREDENTIALS: false } });
  return r26;
}
async function u4(o26) {
  let { aptosConfig: s12 } = o26;
  return (await a5({ aptosConfig: s12, query: { query: C }, originMethod: "getProcessorStatuses" })).processor_status;
}
async function h5(o26) {
  let s12 = await u4({ aptosConfig: o26.aptosConfig });
  return BigInt(s12[0].last_success_version);
}
async function T4(o26) {
  let { aptosConfig: s12, processorType: e5 } = o26;
  return (await a5({ aptosConfig: s12, query: { query: C, variables: { where_condition: { processor: { _eq: e5 } } } }, originMethod: "getProcessorStatus" })).processor_status[0];
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-BTUJC43M.mjs
async function b5(t30) {
  let { aptosConfig: a24, handle: e5, data: o26, options: r26 } = t30;
  return (await q2({ aptosConfig: a24, originMethod: "getTableItem", path: `tables/${e5}/item`, params: { ledger_version: r26 == null ? void 0 : r26.ledgerVersion }, body: o26 })).data;
}
async function f2(t30) {
  let { aptosConfig: a24, options: e5 } = t30, o26 = { query: A2, variables: { where_condition: e5 == null ? void 0 : e5.where, offset: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit, order_by: e5 == null ? void 0 : e5.orderBy } };
  return (await a5({ aptosConfig: a24, query: o26, originMethod: "getTableItemsData" })).table_items;
}
async function T5(t30) {
  let { aptosConfig: a24, options: e5 } = t30, o26 = { query: q, variables: { where_condition: e5 == null ? void 0 : e5.where, offset: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit, order_by: e5 == null ? void 0 : e5.orderBy } };
  return (await a5({ aptosConfig: a24, query: o26, originMethod: "getTableItemsMetadata" })).table_metadatas;
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YDZBU2DJ.mjs
var o7 = class t7 extends B {
  constructor(e5, r26) {
    super(), this.address = e5, this.name = r26;
  }
  static fromStr(e5) {
    let r26 = e5.split("::");
    if (r26.length !== 2) throw new Error("Invalid module id.");
    return new t7(d.fromString(r26[0]), new r3(r26[1]));
  }
  serialize(e5) {
    this.address.serialize(e5), this.name.serialize(e5);
  }
  static deserialize(e5) {
    let r26 = d.deserialize(e5), n18 = r3.deserialize(e5);
    return new t7(r26, n18);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-P5V7OZNN.mjs
var t8 = class l5 extends B {
  constructor(e5) {
    super(), this.value = new t2(e5);
  }
  serialize(e5) {
    e5.serialize(this.value);
  }
  serializeForEntryFunction(e5) {
    e5.serializeU32AsUleb128(this.value.value.length), e5.serialize(this);
  }
  static deserialize(e5, s12) {
    let a24 = t2.deserialize(e5, s12);
    return new l5(a24.value);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LDTF3ABK.mjs
function D3(t30) {
  let e5 = t30.deserializeUleb128AsU32();
  switch (e5) {
    case 0:
      return U2.deserialize(t30);
    case 1:
      return y.deserialize(t30);
    case 2:
      return m.deserialize(t30);
    case 3:
      return d.deserialize(t30);
    case 4:
      return t3.deserialize(t30, U2);
    case 5:
      return d2.deserialize(t30);
    case 6:
      return p.deserialize(t30);
    case 7:
      return b.deserialize(t30);
    case 8:
      return B2.deserialize(t30);
    default:
      throw new Error(`Unknown variant index for ScriptTransactionArgument: ${e5}`);
  }
}
var a6 = class extends B {
  static deserialize(e5) {
    let r26 = e5.deserializeUleb128AsU32();
    switch (r26) {
      case 0:
        return A5.load(e5);
      case 2:
        return z4.load(e5);
      case 3:
        return h6.load(e5);
      default:
        throw new Error(`Unknown variant index for TransactionPayload: ${r26}`);
    }
  }
};
var A5 = class t9 extends a6 {
  constructor(e5) {
    super(), this.script = e5;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(0), this.script.serialize(e5);
  }
  static load(e5) {
    let r26 = U5.deserialize(e5);
    return new t9(r26);
  }
};
var z4 = class t10 extends a6 {
  constructor(e5) {
    super(), this.entryFunction = e5;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(2), this.entryFunction.serialize(e5);
  }
  static load(e5) {
    let r26 = l6.deserialize(e5);
    return new t10(r26);
  }
};
var h6 = class t11 extends a6 {
  constructor(e5) {
    super(), this.multiSig = e5;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(3), this.multiSig.serialize(e5);
  }
  static load(e5) {
    let r26 = f3.deserialize(e5);
    return new t11(r26);
  }
};
var l6 = class t12 {
  constructor(e5, r26, i47, n18) {
    this.module_name = e5, this.function_name = r26, this.type_args = i47, this.args = n18;
  }
  static build(e5, r26, i47, n18) {
    return new t12(o7.fromStr(e5), new r3(r26), i47, n18);
  }
  serialize(e5) {
    this.module_name.serialize(e5), this.function_name.serialize(e5), e5.serializeVector(this.type_args), e5.serializeU32AsUleb128(this.args.length), this.args.forEach((r26) => {
      r26.serializeForEntryFunction(e5);
    });
  }
  static deserialize(e5) {
    let r26 = o7.deserialize(e5), i47 = r3.deserialize(e5), n18 = e5.deserializeVector(t5), o26 = e5.deserializeUleb128AsU32(), s12 = new Array();
    for (let c14 = 0; c14 < o26; c14 += 1) {
      let M5 = e5.deserializeUleb128AsU32(), B9 = t8.deserialize(e5, M5);
      s12.push(B9);
    }
    return new t12(r26, i47, n18, s12);
  }
};
var U5 = class t13 {
  constructor(e5, r26, i47) {
    this.bytecode = e5, this.type_args = r26, this.args = i47;
  }
  serialize(e5) {
    e5.serializeBytes(this.bytecode), e5.serializeVector(this.type_args), e5.serializeU32AsUleb128(this.args.length), this.args.forEach((r26) => {
      r26.serializeForScriptFunction(e5);
    });
  }
  static deserialize(e5) {
    let r26 = e5.deserializeBytes(), i47 = e5.deserializeVector(t5), n18 = e5.deserializeUleb128AsU32(), o26 = new Array();
    for (let s12 = 0; s12 < n18; s12 += 1) {
      let c14 = D3(e5);
      o26.push(c14);
    }
    return new t13(r26, i47, o26);
  }
};
var f3 = class t14 {
  constructor(e5, r26) {
    this.multisig_address = e5, this.transaction_payload = r26;
  }
  serialize(e5) {
    this.multisig_address.serialize(e5), this.transaction_payload === void 0 ? e5.serializeBool(false) : (e5.serializeBool(true), this.transaction_payload.serialize(e5));
  }
  static deserialize(e5) {
    let r26 = d.deserialize(e5), i47 = e5.deserializeBool(), n18;
    return i47 && (n18 = b6.deserialize(e5)), new t14(r26, n18);
  }
};
var b6 = class t15 extends B {
  constructor(e5) {
    super(), this.transaction_payload = e5;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(0), this.transaction_payload.serialize(e5);
  }
  static deserialize(e5) {
    return e5.deserializeUleb128AsU32(), new t15(l6.deserialize(e5));
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-BOYYQAB4.mjs
var r5 = class a7 extends B {
  constructor(e5) {
    super(), this.chainId = e5;
  }
  serialize(e5) {
    e5.serializeU8(this.chainId);
  }
  static deserialize(e5) {
    let s12 = e5.deserializeU8();
    return new a7(s12);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GXTEJ7NO.mjs
var t16 = class i27 extends B {
  constructor(e5, s12, a24, r26, c14, d20, l19) {
    super(), this.sender = e5, this.sequence_number = s12, this.payload = a24, this.max_gas_amount = r26, this.gas_unit_price = c14, this.expiration_timestamp_secs = d20, this.chain_id = l19;
  }
  serialize(e5) {
    this.sender.serialize(e5), e5.serializeU64(this.sequence_number), this.payload.serialize(e5), e5.serializeU64(this.max_gas_amount), e5.serializeU64(this.gas_unit_price), e5.serializeU64(this.expiration_timestamp_secs), this.chain_id.serialize(e5);
  }
  static deserialize(e5) {
    let s12 = d.deserialize(e5), a24 = e5.deserializeU64(), r26 = a6.deserialize(e5), c14 = e5.deserializeU64(), d20 = e5.deserializeU64(), l19 = e5.deserializeU64(), m15 = r5.deserialize(e5);
    return new i27(s12, a24, r26, c14, d20, l19, m15);
  }
};
var o8 = class extends B {
  static deserialize(e5) {
    let s12 = e5.deserializeUleb128AsU32();
    switch (s12) {
      case 0:
        return u5.load(e5);
      case 1:
        return p4.load(e5);
      default:
        throw new Error(`Unknown variant index for RawTransactionWithData: ${s12}`);
    }
  }
};
var u5 = class i28 extends o8 {
  constructor(e5, s12) {
    super(), this.raw_txn = e5, this.secondary_signer_addresses = s12;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(0), this.raw_txn.serialize(e5), e5.serializeVector(this.secondary_signer_addresses);
  }
  static load(e5) {
    let s12 = t16.deserialize(e5), a24 = e5.deserializeVector(d);
    return new i28(s12, a24);
  }
};
var p4 = class i29 extends o8 {
  constructor(e5, s12, a24) {
    super(), this.raw_txn = e5, this.secondary_signer_addresses = s12, this.fee_payer_address = a24;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(1), this.raw_txn.serialize(e5), e5.serializeVector(this.secondary_signer_addresses), this.fee_payer_address.serialize(e5);
  }
  static load(e5) {
    let s12 = t16.deserialize(e5), a24 = e5.deserializeVector(d), r26 = d.deserialize(e5);
    return new i29(s12, a24, r26);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-L36ZHC7J.mjs
var S3 = ((O7) => (O7.FULLNODE = "Fullnode", O7.INDEXER = "Indexer", O7.FAUCET = "Faucet", O7.PEPPER = "Pepper", O7.PROVER = "Prover", O7))(S3 || {});
var R3 = 2e5;
var t17 = 20;
var n8 = 20;
var o9 = "0x1::aptos_coin::AptosCoin";
var T6 = "APTOS::RawTransaction";
var A6 = "APTOS::RawTransactionWithData";
var E4 = ((_8) => (_8.ACCOUNT_TRANSACTION_PROCESSOR = "account_transactions_processor", _8.DEFAULT = "default_processor", _8.EVENTS_PROCESSOR = "events_processor", _8.FUNGIBLE_ASSET_PROCESSOR = "fungible_asset_processor", _8.STAKE_PROCESSOR = "stake_processor", _8.TOKEN_V2_PROCESSOR = "token_v2_processor", _8.USER_TRANSACTION_PROCESSOR = "user_transaction_processor", _8.OBJECT_PROCESSOR = "objects_processor", _8))(E4 || {});

// node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig(n18, le = false) {
  if (le)
    return { h: Number(n18 & U32_MASK64), l: Number(n18 >> _32n & U32_MASK64) };
  return { h: Number(n18 >> _32n & U32_MASK64) | 0, l: Number(n18 & U32_MASK64) | 0 };
}
function split(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i47 = 0; i47 < lst.length; i47++) {
    const { h: h17, l: l19 } = fromBig(lst[i47], le);
    [Ah[i47], Al[i47]] = [h17, l19];
  }
  return [Ah, Al];
}
var toBig = (h17, l19) => BigInt(h17 >>> 0) << _32n | BigInt(l19 >>> 0);
var shrSH = (h17, _l, s12) => h17 >>> s12;
var shrSL = (h17, l19, s12) => h17 << 32 - s12 | l19 >>> s12;
var rotrSH = (h17, l19, s12) => h17 >>> s12 | l19 << 32 - s12;
var rotrSL = (h17, l19, s12) => h17 << 32 - s12 | l19 >>> s12;
var rotrBH = (h17, l19, s12) => h17 << 64 - s12 | l19 >>> s12 - 32;
var rotrBL = (h17, l19, s12) => h17 >>> s12 - 32 | l19 << 64 - s12;
var rotr32H = (_h, l19) => l19;
var rotr32L = (h17, _l) => h17;
var rotlSH = (h17, l19, s12) => h17 << s12 | l19 >>> 32 - s12;
var rotlSL = (h17, l19, s12) => l19 << s12 | h17 >>> 32 - s12;
var rotlBH = (h17, l19, s12) => l19 << s12 - 32 | h17 >>> 64 - s12;
var rotlBL = (h17, l19, s12) => h17 << s12 - 32 | l19 >>> 64 - s12;
function add(Ah, Al, Bh, Bl) {
  const l19 = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l19 / 2 ** 32 | 0) | 0, l: l19 | 0 };
}
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@noble/hashes/esm/sha3.js
var SHA3_PI = [];
var SHA3_ROTL = [];
var _SHA3_IOTA = [];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R7 = _1n, x10 = 1, y12 = 0; round < 24; round++) {
  [x10, y12] = [y12, (2 * x10 + 3 * y12) % 5];
  SHA3_PI.push(2 * (5 * y12 + x10));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t30 = _0n;
  for (let j6 = 0; j6 < 7; j6++) {
    R7 = (R7 << _1n ^ (R7 >> _7n) * _0x71n) % _256n;
    if (R7 & _2n)
      t30 ^= _1n << (_1n << BigInt(j6)) - _1n;
  }
  _SHA3_IOTA.push(t30);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h17, l19, s12) => s12 > 32 ? rotlBH(h17, l19, s12) : rotlSH(h17, l19, s12);
var rotlL = (h17, l19, s12) => s12 > 32 ? rotlBL(h17, l19, s12) : rotlSL(h17, l19, s12);
function keccakP(s12, rounds = 24) {
  const B9 = new Uint32Array(5 * 2);
  for (let round = 24 - rounds; round < 24; round++) {
    for (let x10 = 0; x10 < 10; x10++)
      B9[x10] = s12[x10] ^ s12[x10 + 10] ^ s12[x10 + 20] ^ s12[x10 + 30] ^ s12[x10 + 40];
    for (let x10 = 0; x10 < 10; x10 += 2) {
      const idx1 = (x10 + 8) % 10;
      const idx0 = (x10 + 2) % 10;
      const B0 = B9[idx0];
      const B1 = B9[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B9[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B9[idx1 + 1];
      for (let y12 = 0; y12 < 50; y12 += 10) {
        s12[x10 + y12] ^= Th;
        s12[x10 + y12 + 1] ^= Tl;
      }
    }
    let curH = s12[2];
    let curL = s12[3];
    for (let t30 = 0; t30 < 24; t30++) {
      const shift = SHA3_ROTL[t30];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t30];
      curH = s12[PI];
      curL = s12[PI + 1];
      s12[PI] = Th;
      s12[PI + 1] = Tl;
    }
    for (let y12 = 0; y12 < 50; y12 += 10) {
      for (let x10 = 0; x10 < 10; x10++)
        B9[x10] = s12[y12 + x10];
      for (let x10 = 0; x10 < 10; x10++)
        s12[y12 + x10] ^= ~B9[(x10 + 2) % 10] & B9[(x10 + 4) % 10];
    }
    s12[0] ^= SHA3_IOTA_H[round];
    s12[1] ^= SHA3_IOTA_L[round];
  }
  B9.fill(0);
}
var Keccak = class _Keccak extends Hash {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    if (!isLE)
      byteSwap32(this.state32);
    keccakP(this.state32, this.rounds);
    if (!isLE)
      byteSwap32(this.state32);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i47 = 0; i47 < take; i47++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
};
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-3NRBTP3S.mjs
function d8(e5) {
  return e5.feePayerAddress ? new p4(e5.rawTransaction, e5.secondarySignerAddresses ?? [], e5.feePayerAddress) : e5.secondarySignerAddresses ? new u5(e5.rawTransaction, e5.secondarySignerAddresses) : e5.rawTransaction;
}
function n9(e5, r26) {
  let i47 = sha3_256.create();
  if (!r26.startsWith("APTOS::")) throw new Error(`Domain separator needs to start with 'APTOS::'.  Provided - ${r26}`);
  i47.update(r26);
  let s12 = i47.digest(), o26 = e5, t30 = new Uint8Array(s12.length + o26.length);
  return t30.set(s12), t30.set(o26, s12.length), t30;
}
function u6(e5) {
  return n9(e5.bcsToBytes(), `APTOS::${e5.constructor.name}`);
}
function S4(e5) {
  let r26 = d8(e5);
  return e5.feePayerAddress ? n9(r26.bcsToBytes(), A6) : e5.secondarySignerAddresses ? n9(r26.bcsToBytes(), A6) : n9(r26.bcsToBytes(), T6);
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-76OH2Z4Q.mjs
var t18 = class extends B {
  toString() {
    let n18 = this.toUint8Array();
    return i.fromHexInput(n18).toString();
  }
};
var a8 = class extends t18 {
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MLDQ2TY2.mjs
var o10 = class extends B {
  toString() {
    let i47 = this.toUint8Array();
    return i.fromHexInput(i47).toString();
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-F7EMGK4M.mjs
var o11 = (r26) => typeof r26 == "string" ? i.isValid(r26).valid ? r26 : Buffer.from(r26, "utf8") : r26;

// node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash {
  constructor(hash2, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash2);
    const key = toBytes(_key);
    this.iHash = hash2.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash2.create().update(key).digest() : key);
    for (let i47 = 0; i47 < pad.length; i47++)
      pad[i47] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash2.create();
    for (let i47 = 0; i47 < pad.length; i47++)
      pad[i47] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash2, key, message) => new HMAC(hash2, key).update(message).digest();
hmac.create = (hash2, key) => new HMAC(hash2, key);

// node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h17 = isLE2 ? 4 : 0;
  const l19 = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h17, wh, isLE2);
  view.setUint32(byteOffset + l19, wl, isLE2);
}
var Chi = (a24, b11, c14) => a24 & b11 ^ ~a24 & c14;
var Maj = (a24, b11, c14) => a24 & b11 ^ a24 & c14 ^ b11 & c14;
var HashMD = class extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i47 = pos; i47 < blockLen; i47++)
      buffer[i47] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i47 = 0; i47 < outLen; i47++)
      oview.setUint32(4 * i47, state[i47], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor());
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
};

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n18) => BigInt(n18))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  // prettier-ignore
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i47 = 0; i47 < 16; i47++, offset += 4) {
      SHA512_W_H[i47] = view.getUint32(offset);
      SHA512_W_L[i47] = view.getUint32(offset += 4);
    }
    for (let i47 = 16; i47 < 80; i47++) {
      const W15h = SHA512_W_H[i47 - 15] | 0;
      const W15l = SHA512_W_L[i47 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i47 - 2] | 0;
      const W2l = SHA512_W_L[i47 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i47 - 7], SHA512_W_L[i47 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i47 - 7], SHA512_W_H[i47 - 16]);
      SHA512_W_H[i47] = SUMh | 0;
      SHA512_W_L[i47] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i47 = 0; i47 < 80; i47++) {
      const sigma1h = u64_default.rotrSH(Eh, El, 14) ^ u64_default.rotrSH(Eh, El, 18) ^ u64_default.rotrBH(Eh, El, 41);
      const sigma1l = u64_default.rotrSL(Eh, El, 14) ^ u64_default.rotrSL(Eh, El, 18) ^ u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i47], SHA512_W_L[i47]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i47], SHA512_W_H[i47]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al, 28) ^ u64_default.rotrBH(Ah, Al, 34) ^ u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al, 28) ^ u64_default.rotrBL(Ah, Al, 34) ^ u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
    this.outputLen = 28;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
    this.outputLen = 32;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super();
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
    this.outputLen = 48;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash2, _password, _salt, _opts) {
  hash(hash2);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c14, dkLen, asyncTick } = opts;
  number(c14);
  number(dkLen);
  number(asyncTick);
  if (c14 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt2 = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash2, password);
  const PRFSalt = PRF._cloneInto().update(salt2);
  return { c: c14, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u15) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u15.fill(0);
  return DK;
}
function pbkdf2(hash2, password, salt2, opts) {
  const { c: c14, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash2, password, salt2, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u15 = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0; pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u15);
    Ti.set(u15.subarray(0, Ti.length));
    for (let ui = 1; ui < c14; ui++) {
      PRF._cloneInto(prfW).update(u15).digestInto(u15);
      for (let i47 = 0; i47 < Ti.length; i47++)
        Ti[i47] ^= u15[i47];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u15);
}

// node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor() {
    super(64, 32, 8, false);
    this.A = SHA256_IV[0] | 0;
    this.B = SHA256_IV[1] | 0;
    this.C = SHA256_IV[2] | 0;
    this.D = SHA256_IV[3] | 0;
    this.E = SHA256_IV[4] | 0;
    this.F = SHA256_IV[5] | 0;
    this.G = SHA256_IV[6] | 0;
    this.H = SHA256_IV[7] | 0;
  }
  get() {
    const { A: A15, B: B9, C: C8, D: D9, E: E10, F: F8, G: G7, H: H4 } = this;
    return [A15, B9, C8, D9, E10, F8, G7, H4];
  }
  // prettier-ignore
  set(A15, B9, C8, D9, E10, F8, G7, H4) {
    this.A = A15 | 0;
    this.B = B9 | 0;
    this.C = C8 | 0;
    this.D = D9 | 0;
    this.E = E10 | 0;
    this.F = F8 | 0;
    this.G = G7 | 0;
    this.H = H4 | 0;
  }
  process(view, offset) {
    for (let i47 = 0; i47 < 16; i47++, offset += 4)
      SHA256_W[i47] = view.getUint32(offset, false);
    for (let i47 = 16; i47 < 64; i47++) {
      const W15 = SHA256_W[i47 - 15];
      const W22 = SHA256_W[i47 - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W22, 17) ^ rotr(W22, 19) ^ W22 >>> 10;
      SHA256_W[i47] = s1 + SHA256_W[i47 - 7] + s0 + SHA256_W[i47 - 16] | 0;
    }
    let { A: A15, B: B9, C: C8, D: D9, E: E10, F: F8, G: G7, H: H4 } = this;
    for (let i47 = 0; i47 < 64; i47++) {
      const sigma1 = rotr(E10, 6) ^ rotr(E10, 11) ^ rotr(E10, 25);
      const T1 = H4 + sigma1 + Chi(E10, F8, G7) + SHA256_K[i47] + SHA256_W[i47] | 0;
      const sigma0 = rotr(A15, 2) ^ rotr(A15, 13) ^ rotr(A15, 22);
      const T22 = sigma0 + Maj(A15, B9, C8) | 0;
      H4 = G7;
      G7 = F8;
      F8 = E10;
      E10 = D9 + T1 | 0;
      D9 = C8;
      C8 = B9;
      B9 = A15;
      A15 = T1 + T22 | 0;
    }
    A15 = A15 + this.A | 0;
    B9 = B9 + this.B | 0;
    C8 = C8 + this.C | 0;
    D9 = D9 + this.D | 0;
    E10 = E10 + this.E | 0;
    F8 = F8 + this.F | 0;
    G7 = G7 + this.G | 0;
    H4 = H4 + this.H | 0;
    this.set(A15, B9, C8, D9, E10, F8, G7, H4);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super();
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
    this.outputLen = 28;
  }
};
var sha256 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@scure/base/lib/esm/index.js
function assertNumber(n18) {
  if (!Number.isSafeInteger(n18))
    throw new Error(`Wrong integer: ${n18}`);
}
function isBytes2(a24) {
  return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
}
function chain(...args) {
  const id = (a24) => a24;
  const wrap = (a24, b11) => (c14) => a24(b11(c14));
  const encode3 = args.map((x10) => x10.encode).reduceRight(wrap, id);
  const decode2 = args.map((x10) => x10.decode).reduce(wrap, id);
  return { encode: encode3, decode: decode2 };
}
function alphabet(alphabet2) {
  return {
    encode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("alphabet.encode input should be an array of numbers");
      return digits.map((i47) => {
        assertNumber(i47);
        if (i47 < 0 || i47 >= alphabet2.length)
          throw new Error(`Digit index outside alphabet: ${i47} (alphabet: ${alphabet2.length})`);
        return alphabet2[i47];
      });
    },
    decode: (input) => {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("alphabet.decode input should be array of strings");
      return input.map((letter) => {
        if (typeof letter !== "string")
          throw new Error(`alphabet.decode: not string element=${letter}`);
        const index = alphabet2.indexOf(letter);
        if (index === -1)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${alphabet2}`);
        return index;
      });
    }
  };
}
function join(separator = "") {
  if (typeof separator !== "string")
    throw new Error("join separator should be string");
  return {
    encode: (from) => {
      if (!Array.isArray(from) || from.length && typeof from[0] !== "string")
        throw new Error("join.encode input should be array of strings");
      for (let i47 of from)
        if (typeof i47 !== "string")
          throw new Error(`join.encode: non-string input=${i47}`);
      return from.join(separator);
    },
    decode: (to) => {
      if (typeof to !== "string")
        throw new Error("join.decode input should be string");
      return to.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  assertNumber(bits);
  if (typeof chr !== "string")
    throw new Error("padding chr should be string");
  return {
    encode(data) {
      if (!Array.isArray(data) || data.length && typeof data[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i47 of data)
        if (typeof i47 !== "string")
          throw new Error(`padding.encode: non-string input=${i47}`);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      if (!Array.isArray(input) || input.length && typeof input[0] !== "string")
        throw new Error("padding.encode input should be array of strings");
      for (let i47 of input)
        if (typeof i47 !== "string")
          throw new Error(`padding.decode: non-string input=${i47}`);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("Invalid padding: string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        if (!((end - 1) * bits % 8))
          throw new Error("Invalid padding: string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn3) {
  if (typeof fn3 !== "function")
    throw new Error("normalize fn should be function");
  return { encode: (from) => from, decode: (to) => fn3(to) };
}
function convertRadix(data, from, to) {
  if (from < 2)
    throw new Error(`convertRadix: wrong from=${from}, base cannot be less than 2`);
  if (to < 2)
    throw new Error(`convertRadix: wrong to=${to}, base cannot be less than 2`);
  if (!Array.isArray(data))
    throw new Error("convertRadix: data should be array");
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data);
  digits.forEach((d20) => {
    assertNumber(d20);
    if (d20 < 0 || d20 >= from)
      throw new Error(`Wrong integer: ${d20}`);
  });
  while (true) {
    let carry = 0;
    let done = true;
    for (let i47 = pos; i47 < digits.length; i47++) {
      const digit = digits[i47];
      const digitBase = from * carry + digit;
      if (!Number.isSafeInteger(digitBase) || from * carry / from !== carry || digitBase - digit !== from * carry) {
        throw new Error("convertRadix: carry overflow");
      }
      carry = digitBase % to;
      const rounded = Math.floor(digitBase / to);
      digits[i47] = rounded;
      if (!Number.isSafeInteger(rounded) || rounded * to + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded)
        pos = i47;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i47 = 0; i47 < data.length - 1 && data[i47] === 0; i47++)
    res.push(0);
  return res.reverse();
}
var gcd = (a24, b11) => !b11 ? a24 : gcd(b11, a24 % b11);
var radix2carry = (from, to) => from + (to - gcd(from, to));
function convertRadix2(data, from, to, padding2) {
  if (!Array.isArray(data))
    throw new Error("convertRadix2: data should be array");
  if (from <= 0 || from > 32)
    throw new Error(`convertRadix2: wrong from=${from}`);
  if (to <= 0 || to > 32)
    throw new Error(`convertRadix2: wrong to=${to}`);
  if (radix2carry(from, to) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from} to=${to} carryBits=${radix2carry(from, to)}`);
  }
  let carry = 0;
  let pos = 0;
  const mask = 2 ** to - 1;
  const res = [];
  for (const n18 of data) {
    assertNumber(n18);
    if (n18 >= 2 ** from)
      throw new Error(`convertRadix2: invalid data word=${n18} from=${from}`);
    carry = carry << from | n18;
    if (pos + from > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from}`);
    pos += from;
    for (; pos >= to; pos -= to)
      res.push((carry >> pos - to & mask) >>> 0);
    carry &= 2 ** pos - 1;
  }
  carry = carry << to - pos & mask;
  if (!padding2 && pos >= from)
    throw new Error("Excess padding");
  if (!padding2 && carry)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num2) {
  assertNumber(num2);
  return {
    encode: (bytes2) => {
      if (!isBytes2(bytes2))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes2), 2 ** 8, num2);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix.decode input should be array of numbers");
      return Uint8Array.from(convertRadix(digits, num2, 2 ** 8));
    }
  };
}
function radix2(bits, revPadding = false) {
  assertNumber(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes2) => {
      if (!isBytes2(bytes2))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes2), 8, bits, !revPadding);
    },
    decode: (digits) => {
      if (!Array.isArray(digits) || digits.length && typeof digits[0] !== "number")
        throw new Error("radix2.decode input should be array of numbers");
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn3) {
  if (typeof fn3 !== "function")
    throw new Error("unsafeWrapper fn should be function");
  return function(...args) {
    try {
      return fn3.apply(null, args);
    } catch (e5) {
    }
  };
}
function checksum(len, fn3) {
  assertNumber(len);
  if (typeof fn3 !== "function")
    throw new Error("checksum fn should be function");
  return {
    encode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const checksum2 = fn3(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(checksum2, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const newChecksum = fn3(payload).slice(0, len);
      const oldChecksum = data.slice(-len);
      for (let i47 = 0; i47 < len; i47++)
        if (newChecksum[i47] !== oldChecksum[i47])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s12) => s12.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var base64 = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var createBase58check = (sha2562) => chain(checksum(4, (data) => sha2562(sha2562(data))), base58);
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b11 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i47 = 0; i47 < POLYMOD_GENERATORS.length; i47++) {
    if ((b11 >> i47 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i47];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i47 = 0; i47 < len; i47++) {
    const c14 = prefix.charCodeAt(i47);
    if (c14 < 33 || c14 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c14 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i47 = 0; i47 < len; i47++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i47) & 31;
  for (let v8 of words)
    chk = bech32Polymod(chk) ^ v8;
  for (let i47 = 0; i47 < 6; i47++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % 2 ** 30], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode3(prefix, words, limit = 90) {
    if (typeof prefix !== "string")
      throw new Error(`bech32.encode prefix should be string, not ${typeof prefix}`);
    if (!Array.isArray(words) || words.length && typeof words[0] !== "number")
      throw new Error(`bech32.encode words should be array of numbers, not ${typeof words}`);
    if (prefix.length === 0)
      throw new TypeError(`Invalid prefix length ${prefix.length}`);
    const actualLength = prefix.length + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode2(str, limit = 90) {
    if (typeof str !== "string")
      throw new Error(`bech32.decode input should be string, not ${typeof str}`);
    if (str.length < 8 || limit !== false && str.length > limit)
      throw new TypeError(`Wrong string length: ${str.length} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode2);
  function decodeToBytes(str) {
    const { prefix, words } = decode2(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  return { encode: encode3, decode: decode2, decodeToBytes, decodeUnsafe, fromWords, fromWordsUnsafe, toWords };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hex = chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s12) => {
  if (typeof s12 !== "string" || s12.length % 2)
    throw new TypeError(`hex.decode: expected string, got ${typeof s12} with length ${s12.length}`);
  return s12.toLowerCase();
}));

// node_modules/@scure/bip39/esm/index.js
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError(`Invalid mnemonic type: ${typeof str}`);
  return str.normalize("NFKD");
}
function normalize2(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
var salt = (passphrase) => nfkd(`mnemonic${passphrase}`);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha512, normalize2(mnemonic).nfkd, salt(passphrase), { c: 2048, dkLen: 64 });
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LR65XHSF.mjs
var d9 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+'\/[0-9]+'?$/;
var m5 = /^m\/44'\/637'\/[0-9]+'\/[0-9]+\/[0-9]+$/;
var y6 = ((t30) => (t30.ED25519 = "ed25519 seed", t30))(y6 || {});
var g6 = 2147483648;
function D4(e5) {
  return m5.test(e5);
}
function E5(e5) {
  return d9.test(e5);
}
var A7 = (e5, t30) => {
  let r26 = hmac.create(sha512, e5).update(t30).digest();
  return { key: r26.slice(0, 32), chainCode: r26.slice(32) };
};
var f4 = ({ key: e5, chainCode: t30 }, r26) => {
  let n18 = new ArrayBuffer(4);
  new DataView(n18).setUint32(0, r26);
  let o26 = new Uint8Array(n18), s12 = new Uint8Array([0]), a24 = new Uint8Array([...s12, ...e5, ...o26]);
  return A7(t30, a24);
};
var x4 = (e5) => e5.replace("'", "");
var U6 = (e5) => e5.split("/").slice(1).map(x4);
var h7 = (e5) => {
  let t30 = e5.trim().split(/\s+/).map((r26) => r26.toLowerCase()).join(" ");
  return mnemonicToSeedSync(t30);
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-G5MGSV7Y.mjs
var r6 = class r7 extends B {
  constructor(t30) {
    super();
    let { data: e5 } = t30, i47 = i.fromHexInput(e5);
    if (i47.toUint8Array().length !== r7.LENGTH) throw new Error(`Authentication Key length should be ${r7.LENGTH}`);
    this.data = i47;
  }
  serialize(t30) {
    t30.serializeFixedBytes(this.data.toUint8Array());
  }
  static deserialize(t30) {
    let e5 = t30.deserializeFixedBytes(r7.LENGTH);
    return new r7({ data: e5 });
  }
  toString() {
    return this.data.toString();
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  static fromSchemeAndBytes(t30) {
    let { scheme: e5, input: i47 } = t30, u15 = i.fromHexInput(i47).toUint8Array(), h17 = new Uint8Array([...u15, e5]), a24 = sha3_256.create();
    a24.update(h17);
    let y12 = a24.digest();
    return new r7({ data: y12 });
  }
  static fromPublicKeyAndScheme(t30) {
    let { publicKey: e5 } = t30;
    return e5.authKey();
  }
  static fromPublicKey(t30) {
    let { publicKey: e5 } = t30;
    return e5.authKey();
  }
  derivedAddress() {
    return new d(this.data.toUint8Array());
  }
};
r6.LENGTH = 32;
var c3 = r6;

// node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports = {};
__export(utils_exports, {
  aInRange: () => aInRange,
  abool: () => abool,
  abytes: () => abytes,
  bitGet: () => bitGet,
  bitLen: () => bitLen,
  bitMask: () => bitMask,
  bitSet: () => bitSet,
  bytesToHex: () => bytesToHex2,
  bytesToNumberBE: () => bytesToNumberBE,
  bytesToNumberLE: () => bytesToNumberLE,
  concatBytes: () => concatBytes2,
  createHmacDrbg: () => createHmacDrbg,
  ensureBytes: () => ensureBytes,
  equalBytes: () => equalBytes,
  hexToBytes: () => hexToBytes2,
  hexToNumber: () => hexToNumber,
  inRange: () => inRange,
  isBytes: () => isBytes3,
  memoized: () => memoized,
  notImplemented: () => notImplemented,
  numberToBytesBE: () => numberToBytesBE,
  numberToBytesLE: () => numberToBytesLE,
  numberToHexUnpadded: () => numberToHexUnpadded,
  numberToVarBytesBE: () => numberToVarBytesBE,
  utf8ToBytes: () => utf8ToBytes2,
  validateObject: () => validateObject
});
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
function isBytes3(a24) {
  return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
}
function abytes(item) {
  if (!isBytes3(item))
    throw new Error("Uint8Array expected");
}
function abool(title, value) {
  if (typeof value !== "boolean")
    throw new Error(`${title} must be valid boolean, got "${value}".`);
}
var hexes2 = Array.from({ length: 256 }, (_8, i47) => i47.toString(16).padStart(2, "0"));
function bytesToHex2(bytes2) {
  abytes(bytes2);
  let hex2 = "";
  for (let i47 = 0; i47 < bytes2.length; i47++) {
    hex2 += hexes2[bytes2[i47]];
  }
  return hex2;
}
function numberToHexUnpadded(num2) {
  const hex2 = num2.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
var asciis2 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase162(char) {
  if (char >= asciis2._0 && char <= asciis2._9)
    return char - asciis2._0;
  if (char >= asciis2._A && char <= asciis2._F)
    return char - (asciis2._A - 10);
  if (char >= asciis2._a && char <= asciis2._f)
    return char - (asciis2._a - 10);
  return;
}
function hexToBytes2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase162(hex2.charCodeAt(hi));
    const n22 = asciiToBase162(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n22;
  }
  return array;
}
function bytesToNumberBE(bytes2) {
  return hexToNumber(bytesToHex2(bytes2));
}
function bytesToNumberLE(bytes2) {
  abytes(bytes2);
  return hexToNumber(bytesToHex2(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE(n18, len) {
  return hexToBytes2(n18.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n18, len) {
  return numberToBytesBE(n18, len).reverse();
}
function numberToVarBytesBE(n18) {
  return hexToBytes2(numberToHexUnpadded(n18));
}
function ensureBytes(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes2(hex2);
    } catch (e5) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e5}`);
    }
  } else if (isBytes3(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i47 = 0; i47 < arrays.length; i47++) {
    const a24 = arrays[i47];
    abytes(a24);
    sum += a24.length;
  }
  const res = new Uint8Array(sum);
  for (let i47 = 0, pad = 0; i47 < arrays.length; i47++) {
    const a24 = arrays[i47];
    res.set(a24, pad);
    pad += a24.length;
  }
  return res;
}
function equalBytes(a24, b11) {
  if (a24.length !== b11.length)
    return false;
  let diff = 0;
  for (let i47 = 0; i47 < a24.length; i47++)
    diff |= a24[i47] ^ b11[i47];
  return diff === 0;
}
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
var isPosBig = (n18) => typeof n18 === "bigint" && _0n2 <= n18;
function inRange(n18, min, max) {
  return isPosBig(n18) && isPosBig(min) && isPosBig(max) && min <= n18 && n18 < max;
}
function aInRange(title, n18, min, max) {
  if (!inRange(n18, min, max))
    throw new Error(`expected valid ${title}: ${min} <= n < ${max}, got ${typeof n18} ${n18}`);
}
function bitLen(n18) {
  let len;
  for (len = 0; n18 > _0n2; n18 >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n18, pos) {
  return n18 >> BigInt(pos) & _1n2;
}
function bitSet(n18, pos, value) {
  return n18 | (value ? _1n2 : _0n2) << BigInt(pos);
}
var bitMask = (n18) => (_2n2 << BigInt(n18 - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v8 = u8n(hashLen);
  let k6 = u8n(hashLen);
  let i47 = 0;
  const reset = () => {
    v8.fill(1);
    k6.fill(0);
    i47 = 0;
  };
  const h17 = (...b11) => hmacFn(k6, v8, ...b11);
  const reseed = (seed = u8n()) => {
    k6 = h17(u8fr([0]), seed);
    v8 = h17();
    if (seed.length === 0)
      return;
    k6 = h17(u8fr([1]), seed);
    v8 = h17();
  };
  const gen2 = () => {
    if (i47++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v8 = h17();
      const sl = v8.slice();
      out.push(sl);
      len += v8.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes3(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject(object, validators3, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators3))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}
var notImplemented = () => {
  throw new Error("not implemented");
};
function memoized(fn3) {
  const map = /* @__PURE__ */ new WeakMap();
  return (arg, ...args) => {
    const val = map.get(arg);
    if (val !== void 0)
      return val;
    const computed = fn3(arg, ...args);
    map.set(arg, computed);
    return computed;
  };
}

// node_modules/@noble/curves/esm/abstract/modular.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
function mod(a24, b11) {
  const result = a24 % b11;
  return result >= _0n3 ? result : b11 + result;
}
function pow(num2, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num2 % modulo;
    num2 = num2 * num2 % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x10, power, modulo) {
  let res = x10;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a24 = mod(number2, modulo);
  let b11 = modulo;
  let x10 = _0n3, y12 = _1n3, u15 = _1n3, v8 = _0n3;
  while (a24 !== _0n3) {
    const q5 = b11 / a24;
    const r26 = b11 % a24;
    const m15 = x10 - u15 * q5;
    const n18 = y12 - v8 * q5;
    b11 = a24, a24 = r26, x10 = u15, y12 = v8, u15 = m15, v8 = n18;
  }
  const gcd2 = b11;
  if (gcd2 !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x10, modulo);
}
function tonelliShanks(P7) {
  const legendreC = (P7 - _1n3) / _2n3;
  let Q4, S8, Z5;
  for (Q4 = P7 - _1n3, S8 = 0; Q4 % _2n3 === _0n3; Q4 /= _2n3, S8++)
    ;
  for (Z5 = _2n3; Z5 < P7 && pow(Z5, legendreC, P7) !== P7 - _1n3; Z5++)
    ;
  if (S8 === 1) {
    const p1div4 = (P7 + _1n3) / _4n;
    return function tonelliFast(Fp4, n18) {
      const root = Fp4.pow(n18, p1div4);
      if (!Fp4.eql(Fp4.sqr(root), n18))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q4 + _1n3) / _2n3;
  return function tonelliSlow(Fp4, n18) {
    if (Fp4.pow(n18, legendreC) === Fp4.neg(Fp4.ONE))
      throw new Error("Cannot find square root");
    let r26 = S8;
    let g10 = Fp4.pow(Fp4.mul(Fp4.ONE, Z5), Q4);
    let x10 = Fp4.pow(n18, Q1div2);
    let b11 = Fp4.pow(n18, Q4);
    while (!Fp4.eql(b11, Fp4.ONE)) {
      if (Fp4.eql(b11, Fp4.ZERO))
        return Fp4.ZERO;
      let m15 = 1;
      for (let t210 = Fp4.sqr(b11); m15 < r26; m15++) {
        if (Fp4.eql(t210, Fp4.ONE))
          break;
        t210 = Fp4.sqr(t210);
      }
      const ge3 = Fp4.pow(g10, _1n3 << BigInt(r26 - m15 - 1));
      g10 = Fp4.sqr(ge3);
      x10 = Fp4.mul(x10, ge3);
      b11 = Fp4.mul(b11, g10);
      r26 = m15;
    }
    return x10;
  };
}
function FpSqrt(P7) {
  if (P7 % _4n === _3n) {
    const p1div4 = (P7 + _1n3) / _4n;
    return function sqrt3mod4(Fp4, n18) {
      const root = Fp4.pow(n18, p1div4);
      if (!Fp4.eql(Fp4.sqr(root), n18))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P7 % _8n === _5n) {
    const c1 = (P7 - _5n) / _8n;
    return function sqrt5mod8(Fp4, n18) {
      const n22 = Fp4.mul(n18, _2n3);
      const v8 = Fp4.pow(n22, c1);
      const nv = Fp4.mul(n18, v8);
      const i47 = Fp4.mul(Fp4.mul(nv, _2n3), v8);
      const root = Fp4.mul(nv, Fp4.sub(i47, Fp4.ONE));
      if (!Fp4.eql(Fp4.sqr(root), n18))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P7 % _16n === _9n) {
  }
  return tonelliShanks(P7);
}
var isNegativeLE = (num2, modulo) => (mod(num2, modulo) & _1n3) === _1n3;
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f16, num2, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f16.ONE;
  if (power === _1n3)
    return num2;
  let p13 = f16.ONE;
  let d20 = num2;
  while (power > _0n3) {
    if (power & _1n3)
      p13 = f16.mul(p13, d20);
    d20 = f16.sqr(d20);
    power >>= _1n3;
  }
  return p13;
}
function FpInvertBatch(f16, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num2, i47) => {
    if (f16.is0(num2))
      return acc;
    tmp[i47] = acc;
    return f16.mul(acc, num2);
  }, f16.ONE);
  const inverted = f16.inv(lastMultiplied);
  nums.reduceRight((acc, num2, i47) => {
    if (f16.is0(num2))
      return acc;
    tmp[i47] = f16.mul(acc, tmp[i47]);
    return f16.mul(acc, num2);
  }, inverted);
  return tmp;
}
function nLength(n18, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n18.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen3, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f16 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num2) => mod(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num2}`);
      return _0n3 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n3,
    isOdd: (num2) => (num2 & _1n3) === _1n3,
    neg: (num2) => mod(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod(num2 * num2, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow(f16, num2, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert(num2, ORDER),
    sqrt: redef.sqrt || ((n18) => sqrtP(f16, n18)),
    invertBatch: (lst) => FpInvertBatch(f16, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a24, b11, c14) => c14 ? b11 : a24,
    toBytes: (num2) => isLE2 ? numberToBytesLE(num2, BYTES) : numberToBytesBE(num2, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE(bytes2) : bytesToNumberBE(bytes2);
    }
  });
  return Object.freeze(f16);
}
function FpSqrtEven(Fp4, elm) {
  if (!Fp4.isOdd)
    throw new Error(`Field doesn't have isOdd`);
  const root = Fp4.sqrt(elm);
  return Fp4.isOdd(root) ? Fp4.neg(root) : root;
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num2 = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num2, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}

// node_modules/@noble/curves/esm/abstract/curve.js
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);
var pointPrecomputes = /* @__PURE__ */ new WeakMap();
var pointWindowSizes = /* @__PURE__ */ new WeakMap();
function wNAF(c14, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const validateW = (W9) => {
    if (!Number.isSafeInteger(W9) || W9 <= 0 || W9 > bits)
      throw new Error(`Wrong window size=${W9}, should be [1..${bits}]`);
  };
  const opts = (W9) => {
    validateW(W9);
    const windows = Math.ceil(bits / W9) + 1;
    const windowSize = 2 ** (W9 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n18) {
      let p13 = c14.ZERO;
      let d20 = elm;
      while (n18 > _0n4) {
        if (n18 & _1n4)
          p13 = p13.add(d20);
        d20 = d20.double();
        n18 >>= _1n4;
      }
      return p13;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W9) {
      const { windows, windowSize } = opts(W9);
      const points = [];
      let p13 = elm;
      let base = p13;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p13;
        points.push(base);
        for (let i47 = 1; i47 < windowSize; i47++) {
          base = base.add(p13);
          points.push(base);
        }
        p13 = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W9, precomputes, n18) {
      const { windows, windowSize } = opts(W9);
      let p13 = c14.ZERO;
      let f16 = c14.BASE;
      const mask = BigInt(2 ** W9 - 1);
      const maxNumber = 2 ** W9;
      const shiftBy = BigInt(W9);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n18 & mask);
        n18 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n18 += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f16 = f16.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p13 = p13.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p13, f: f16 };
    },
    wNAFCached(P7, n18, transform) {
      const W9 = pointWindowSizes.get(P7) || 1;
      let comp = pointPrecomputes.get(P7);
      if (!comp) {
        comp = this.precomputeWindow(P7, W9);
        if (W9 !== 1)
          pointPrecomputes.set(P7, transform(comp));
      }
      return this.wNAF(W9, comp, n18);
    },
    // We calculate precomputes for elliptic curve point multiplication
    // using windowed method. This specifies window size and
    // stores precomputed values. Usually only base point would be precomputed.
    setWindowSize(P7, W9) {
      validateW(W9);
      pointWindowSizes.set(P7, W9);
      pointPrecomputes.delete(P7);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@noble/curves/esm/abstract/edwards.js
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _8n2 = BigInt(8);
var VERIFY_DEFAULT = { zip215: true };
function validateOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(curve, {
    hash: "function",
    a: "bigint",
    d: "bigint",
    randomBytes: "function"
  }, {
    adjustScalarBytes: "function",
    domain: "function",
    uvRatio: "function",
    mapToCurve: "function"
  });
  return Object.freeze({ ...opts });
}
function twistedEdwards(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp: Fp4, n: CURVE_ORDER, prehash, hash: cHash, randomBytes: randomBytes2, nByteLength, h: cofactor } = CURVE;
  const MASK = _2n4 << BigInt(nByteLength * 8) - _1n5;
  const modP3 = Fp4.create;
  const uvRatio2 = CURVE.uvRatio || ((u15, v8) => {
    try {
      return { isValid: true, value: Fp4.sqrt(u15 * Fp4.inv(v8)) };
    } catch (e5) {
      return { isValid: false, value: _0n5 };
    }
  });
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const domain = CURVE.domain || ((data, ctx, phflag) => {
    abool("phflag", phflag);
    if (ctx.length || phflag)
      throw new Error("Contexts/pre-hash are not supported");
    return data;
  });
  function aCoordinate(title, n18) {
    aInRange("coordinate " + title, n18, _0n5, MASK);
  }
  function assertPoint(other) {
    if (!(other instanceof Point4))
      throw new Error("ExtendedPoint expected");
  }
  const toAffineMemo = memoized((p13, iz) => {
    const { ex: x10, ey: y12, ez: z8 } = p13;
    const is0 = p13.is0();
    if (iz == null)
      iz = is0 ? _8n2 : Fp4.inv(z8);
    const ax = modP3(x10 * iz);
    const ay = modP3(y12 * iz);
    const zz = modP3(z8 * iz);
    if (is0)
      return { x: _0n5, y: _1n5 };
    if (zz !== _1n5)
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p13) => {
    const { a: a24, d: d20 } = CURVE;
    if (p13.is0())
      throw new Error("bad point: ZERO");
    const { ex: X4, ey: Y6, ez: Z5, et: T11 } = p13;
    const X22 = modP3(X4 * X4);
    const Y22 = modP3(Y6 * Y6);
    const Z22 = modP3(Z5 * Z5);
    const Z42 = modP3(Z22 * Z22);
    const aX2 = modP3(X22 * a24);
    const left = modP3(Z22 * modP3(aX2 + Y22));
    const right = modP3(Z42 + modP3(d20 * modP3(X22 * Y22)));
    if (left !== right)
      throw new Error("bad point: equation left != right (1)");
    const XY = modP3(X4 * Y6);
    const ZT = modP3(Z5 * T11);
    if (XY !== ZT)
      throw new Error("bad point: equation left != right (2)");
    return true;
  });
  class Point4 {
    constructor(ex, ey, ez, et2) {
      this.ex = ex;
      this.ey = ey;
      this.ez = ez;
      this.et = et2;
      aCoordinate("x", ex);
      aCoordinate("y", ey);
      aCoordinate("z", ez);
      aCoordinate("t", et2);
      Object.freeze(this);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static fromAffine(p13) {
      if (p13 instanceof Point4)
        throw new Error("extended point not allowed");
      const { x: x10, y: y12 } = p13 || {};
      aCoordinate("x", x10);
      aCoordinate("y", y12);
      return new Point4(x10, y12, _1n5, modP3(x10 * y12));
    }
    static normalizeZ(points) {
      const toInv = Fp4.invertBatch(points.map((p13) => p13.ez));
      return points.map((p13, i47) => p13.toAffine(toInv[i47])).map(Point4.fromAffine);
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // Not required for fromHex(), which always creates valid points.
    // Could be useful for fromAffine().
    assertValidity() {
      assertValidMemo(this);
    }
    // Compare one point to another.
    equals(other) {
      assertPoint(other);
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const { ex: X22, ey: Y22, ez: Z22 } = other;
      const X1Z2 = modP3(X1 * Z22);
      const X2Z1 = modP3(X22 * Z1);
      const Y1Z2 = modP3(Y1 * Z22);
      const Y2Z1 = modP3(Y22 * Z1);
      return X1Z2 === X2Z1 && Y1Z2 === Y2Z1;
    }
    is0() {
      return this.equals(Point4.ZERO);
    }
    negate() {
      return new Point4(modP3(-this.ex), this.ey, this.ez, modP3(-this.et));
    }
    // Fast algo for doubling Extended Point.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#doubling-dbl-2008-hwcd
    // Cost: 4M + 4S + 1*a + 6add + 1*2.
    double() {
      const { a: a24 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1 } = this;
      const A15 = modP3(X1 * X1);
      const B9 = modP3(Y1 * Y1);
      const C8 = modP3(_2n4 * modP3(Z1 * Z1));
      const D9 = modP3(a24 * A15);
      const x1y1 = X1 + Y1;
      const E10 = modP3(modP3(x1y1 * x1y1) - A15 - B9);
      const G8 = D9 + B9;
      const F8 = G8 - C8;
      const H4 = D9 - B9;
      const X32 = modP3(E10 * F8);
      const Y32 = modP3(G8 * H4);
      const T32 = modP3(E10 * H4);
      const Z32 = modP3(F8 * G8);
      return new Point4(X32, Y32, Z32, T32);
    }
    // Fast algo for adding 2 Extended Points.
    // https://hyperelliptic.org/EFD/g1p/auto-twisted-extended.html#addition-add-2008-hwcd
    // Cost: 9M + 1*a + 1*d + 7add.
    add(other) {
      assertPoint(other);
      const { a: a24, d: d20 } = CURVE;
      const { ex: X1, ey: Y1, ez: Z1, et: T1 } = this;
      const { ex: X22, ey: Y22, ez: Z22, et: T22 } = other;
      if (a24 === BigInt(-1)) {
        const A16 = modP3((Y1 - X1) * (Y22 + X22));
        const B10 = modP3((Y1 + X1) * (Y22 - X22));
        const F9 = modP3(B10 - A16);
        if (F9 === _0n5)
          return this.double();
        const C9 = modP3(Z1 * _2n4 * T22);
        const D10 = modP3(T1 * _2n4 * Z22);
        const E11 = D10 + C9;
        const G9 = B10 + A16;
        const H5 = D10 - C9;
        const X33 = modP3(E11 * F9);
        const Y33 = modP3(G9 * H5);
        const T33 = modP3(E11 * H5);
        const Z33 = modP3(F9 * G9);
        return new Point4(X33, Y33, Z33, T33);
      }
      const A15 = modP3(X1 * X22);
      const B9 = modP3(Y1 * Y22);
      const C8 = modP3(T1 * d20 * T22);
      const D9 = modP3(Z1 * Z22);
      const E10 = modP3((X1 + Y1) * (X22 + Y22) - A15 - B9);
      const F8 = D9 - C8;
      const G8 = D9 + C8;
      const H4 = modP3(B9 - a24 * A15);
      const X32 = modP3(E10 * F8);
      const Y32 = modP3(G8 * H4);
      const T32 = modP3(E10 * H4);
      const Z32 = modP3(F8 * G8);
      return new Point4(X32, Y32, Z32, T32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    wNAF(n18) {
      return wnaf.wNAFCached(this, n18, Point4.normalizeZ);
    }
    // Constant-time multiplication.
    multiply(scalar) {
      const n18 = scalar;
      aInRange("scalar", n18, _1n5, CURVE_ORDER);
      const { p: p13, f: f16 } = this.wNAF(n18);
      return Point4.normalizeZ([p13, f16])[0];
    }
    // Non-constant-time multiplication. Uses double-and-add algorithm.
    // It's faster, but should only be used when you don't care about
    // an exposed private key e.g. sig verification.
    // Does NOT allow scalars higher than CURVE.n.
    multiplyUnsafe(scalar) {
      const n18 = scalar;
      aInRange("scalar", n18, _0n5, CURVE_ORDER);
      if (n18 === _0n5)
        return I6;
      if (this.equals(I6) || n18 === _1n5)
        return this;
      if (this.equals(G7))
        return this.wNAF(n18).p;
      return wnaf.unsafeLadder(this, n18);
    }
    // Checks if point is of small order.
    // If you add something to small order point, you will have "dirty"
    // point with torsion component.
    // Multiplies point by cofactor and checks if the result is 0.
    isSmallOrder() {
      return this.multiplyUnsafe(cofactor).is0();
    }
    // Multiplies point by curve order and checks if the result is 0.
    // Returns `false` is the point is dirty.
    isTorsionFree() {
      return wnaf.unsafeLadder(this, CURVE_ORDER).is0();
    }
    // Converts Extended point to default (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    clearCofactor() {
      const { h: cofactor2 } = CURVE;
      if (cofactor2 === _1n5)
        return this;
      return this.multiplyUnsafe(cofactor2);
    }
    // Converts hash string or Uint8Array to Point.
    // Uses algo from RFC8032 5.1.3.
    static fromHex(hex2, zip215 = false) {
      const { d: d20, a: a24 } = CURVE;
      const len = Fp4.BYTES;
      hex2 = ensureBytes("pointHex", hex2, len);
      abool("zip215", zip215);
      const normed = hex2.slice();
      const lastByte = hex2[len - 1];
      normed[len - 1] = lastByte & ~128;
      const y12 = bytesToNumberLE(normed);
      const max = zip215 ? MASK : Fp4.ORDER;
      aInRange("pointHex.y", y12, _0n5, max);
      const y22 = modP3(y12 * y12);
      const u15 = modP3(y22 - _1n5);
      const v8 = modP3(d20 * y22 - a24);
      let { isValid, value: x10 } = uvRatio2(u15, v8);
      if (!isValid)
        throw new Error("Point.fromHex: invalid y coordinate");
      const isXOdd = (x10 & _1n5) === _1n5;
      const isLastByteOdd = (lastByte & 128) !== 0;
      if (!zip215 && x10 === _0n5 && isLastByteOdd)
        throw new Error("Point.fromHex: x=0 and x_0=1");
      if (isLastByteOdd !== isXOdd)
        x10 = modP3(-x10);
      return Point4.fromAffine({ x: x10, y: y12 });
    }
    static fromPrivateKey(privKey) {
      return getExtendedPublicKey(privKey).point;
    }
    toRawBytes() {
      const { x: x10, y: y12 } = this.toAffine();
      const bytes2 = numberToBytesLE(y12, Fp4.BYTES);
      bytes2[bytes2.length - 1] |= x10 & _1n5 ? 128 : 0;
      return bytes2;
    }
    toHex() {
      return bytesToHex2(this.toRawBytes());
    }
  }
  Point4.BASE = new Point4(CURVE.Gx, CURVE.Gy, _1n5, modP3(CURVE.Gx * CURVE.Gy));
  Point4.ZERO = new Point4(_0n5, _1n5, _1n5, _0n5);
  const { BASE: G7, ZERO: I6 } = Point4;
  const wnaf = wNAF(Point4, nByteLength * 8);
  function modN3(a24) {
    return mod(a24, CURVE_ORDER);
  }
  function modN_LE(hash2) {
    return modN3(bytesToNumberLE(hash2));
  }
  function getExtendedPublicKey(key) {
    const len = nByteLength;
    key = ensureBytes("private key", key, len);
    const hashed = ensureBytes("hashed private key", cHash(key), 2 * len);
    const head = adjustScalarBytes2(hashed.slice(0, len));
    const prefix = hashed.slice(len, 2 * len);
    const scalar = modN_LE(head);
    const point = G7.multiply(scalar);
    const pointBytes = point.toRawBytes();
    return { head, prefix, scalar, point, pointBytes };
  }
  function getPublicKey(privKey) {
    return getExtendedPublicKey(privKey).pointBytes;
  }
  function hashDomainToScalar(context = new Uint8Array(), ...msgs) {
    const msg = concatBytes2(...msgs);
    return modN_LE(cHash(domain(msg, ensureBytes("context", context), !!prehash)));
  }
  function sign(msg, privKey, options = {}) {
    msg = ensureBytes("message", msg);
    if (prehash)
      msg = prehash(msg);
    const { prefix, scalar, pointBytes } = getExtendedPublicKey(privKey);
    const r26 = hashDomainToScalar(options.context, prefix, msg);
    const R7 = G7.multiply(r26).toRawBytes();
    const k6 = hashDomainToScalar(options.context, R7, pointBytes, msg);
    const s12 = modN3(r26 + k6 * scalar);
    aInRange("signature.s", s12, _0n5, CURVE_ORDER);
    const res = concatBytes2(R7, numberToBytesLE(s12, Fp4.BYTES));
    return ensureBytes("result", res, nByteLength * 2);
  }
  const verifyOpts = VERIFY_DEFAULT;
  function verify(sig, msg, publicKey, options = verifyOpts) {
    const { context, zip215 } = options;
    const len = Fp4.BYTES;
    sig = ensureBytes("signature", sig, 2 * len);
    msg = ensureBytes("message", msg);
    if (zip215 !== void 0)
      abool("zip215", zip215);
    if (prehash)
      msg = prehash(msg);
    const s12 = bytesToNumberLE(sig.slice(len, 2 * len));
    let A15, R7, SB;
    try {
      A15 = Point4.fromHex(publicKey, zip215);
      R7 = Point4.fromHex(sig.slice(0, len), zip215);
      SB = G7.multiplyUnsafe(s12);
    } catch (error) {
      return false;
    }
    if (!zip215 && A15.isSmallOrder())
      return false;
    const k6 = hashDomainToScalar(context, R7.toRawBytes(), A15.toRawBytes(), msg);
    const RkA = R7.add(A15.multiplyUnsafe(k6));
    return RkA.subtract(SB).clearCofactor().equals(Point4.ZERO);
  }
  G7._setWindowSize(8);
  const utils2 = {
    getExtendedPublicKey,
    // ed25519 private keys are uniform 32b. No need to check for modulo bias, like in secp256k1.
    randomPrivateKey: () => randomBytes2(Fp4.BYTES),
    /**
     * We're doing scalar multiplication (used in getPublicKey etc) with precomputed BASE_POINT
     * values. This slows down first getPublicKey() by milliseconds (see Speed section),
     * but allows to speed-up subsequent getPublicKey() calls up to 20x.
     * @param windowSize 2, 4, 8, 16
     */
    precompute(windowSize = 8, point = Point4.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  return {
    CURVE,
    getPublicKey,
    sign,
    verify,
    ExtendedPoint: Point4,
    utils: utils2
  };
}

// node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip = bytesToNumberBE;
function i2osp(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i47 = length - 1; i47 >= 0; i47--) {
    res[i47] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor(a24, b11) {
  const arr = new Uint8Array(a24.length);
  for (let i47 = 0; i47 < a24.length; i47++) {
    arr[i47] = a24[i47] ^ b11[i47];
  }
  return arr;
}
function anum(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd(msg, DST, lenInBytes, H4) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255)
    DST = H4(concatBytes2(utf8ToBytes2("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H4;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes2(DST, i2osp(DST.length, 1));
  const Z_pad = i2osp(0, r_in_bytes);
  const l_i_b_str = i2osp(lenInBytes, 2);
  const b11 = new Array(ell);
  const b_0 = H4(concatBytes2(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
  b11[0] = H4(concatBytes2(b_0, i2osp(1, 1), DST_prime));
  for (let i47 = 1; i47 <= ell; i47++) {
    const args = [strxor(b_0, b11[i47 - 1]), i2osp(i47 + 1, 1), DST_prime];
    b11[i47] = H4(concatBytes2(...args));
  }
  const pseudo_random_bytes = concatBytes2(...b11);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof(msg, DST, lenInBytes, k6, H4) {
  abytes(msg);
  abytes(DST);
  anum(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k6 / 8);
    DST = H4.create({ dkLen }).update(utf8ToBytes2("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H4.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
}
function hash_to_field(msg, count, options) {
  validateObject(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p13, k: k6, m: m15, hash: hash2, expand, DST: _DST } = options;
  abytes(msg);
  anum(count);
  const DST = typeof _DST === "string" ? utf8ToBytes2(_DST) : _DST;
  const log2p = p13.toString(2).length;
  const L8 = Math.ceil((log2p + k6) / 8);
  const len_in_bytes = count * m15 * L8;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof(msg, DST, len_in_bytes, k6, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u15 = new Array(count);
  for (let i47 = 0; i47 < count; i47++) {
    const e5 = new Array(m15);
    for (let j6 = 0; j6 < m15; j6++) {
      const elm_offset = L8 * (j6 + i47 * m15);
      const tv = prb.subarray(elm_offset, elm_offset + L8);
      e5[j6] = mod(os2ip(tv), p13);
    }
    u15[i47] = e5;
  }
  return u15;
}
function isogenyMap(field, map) {
  const COEFF = map.map((i47) => Array.from(i47).reverse());
  return (x10, y12) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i47) => field.add(field.mul(acc, x10), i47)));
    x10 = field.div(xNum, xDen);
    y12 = field.mul(y12, field.div(yNum, yDen));
    return { x: x10, y: y12 };
  };
}
function createHasher(Point4, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u15 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point4.fromAffine(mapToCurve(u15[0]));
      const u1 = Point4.fromAffine(mapToCurve(u15[1]));
      const P7 = u0.add(u1).clearCofactor();
      P7.assertValidity();
      return P7;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u15 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P7 = Point4.fromAffine(mapToCurve(u15[0])).clearCofactor();
      P7.assertValidity();
      return P7;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i47 of scalars)
        if (typeof i47 !== "bigint")
          throw new Error(`mapToCurve: expected array of bigints, got ${i47} in array`);
      const P7 = Point4.fromAffine(mapToCurve(scalars)).clearCofactor();
      P7.assertValidity();
      return P7;
    }
  };
}

// node_modules/@noble/curves/esm/abstract/montgomery.js
var _0n6 = BigInt(0);
var _1n6 = BigInt(1);
function validateOpts2(curve) {
  validateObject(curve, {
    a: "bigint"
  }, {
    montgomeryBits: "isSafeInteger",
    nByteLength: "isSafeInteger",
    adjustScalarBytes: "function",
    domain: "function",
    powPminus2: "function",
    Gu: "bigint"
  });
  return Object.freeze({ ...curve });
}
function montgomery(curveDef) {
  const CURVE = validateOpts2(curveDef);
  const { P: P7 } = CURVE;
  const modP3 = (n18) => mod(n18, P7);
  const montgomeryBits = CURVE.montgomeryBits;
  const montgomeryBytes = Math.ceil(montgomeryBits / 8);
  const fieldLen = CURVE.nByteLength;
  const adjustScalarBytes2 = CURVE.adjustScalarBytes || ((bytes2) => bytes2);
  const powPminus2 = CURVE.powPminus2 || ((x10) => pow(x10, P7 - BigInt(2), P7));
  function cswap(swap, x_2, x_3) {
    const dummy = modP3(swap * (x_2 - x_3));
    x_2 = modP3(x_2 - dummy);
    x_3 = modP3(x_3 + dummy);
    return [x_2, x_3];
  }
  const a24 = (CURVE.a - BigInt(2)) / BigInt(4);
  function montgomeryLadder(u15, scalar) {
    aInRange("u", u15, _0n6, P7);
    aInRange("scalar", scalar, _0n6, P7);
    const k6 = scalar;
    const x_1 = u15;
    let x_2 = _1n6;
    let z_2 = _0n6;
    let x_3 = u15;
    let z_3 = _1n6;
    let swap = _0n6;
    let sw;
    for (let t30 = BigInt(montgomeryBits - 1); t30 >= _0n6; t30--) {
      const k_t = k6 >> t30 & _1n6;
      swap ^= k_t;
      sw = cswap(swap, x_2, x_3);
      x_2 = sw[0];
      x_3 = sw[1];
      sw = cswap(swap, z_2, z_3);
      z_2 = sw[0];
      z_3 = sw[1];
      swap = k_t;
      const A15 = x_2 + z_2;
      const AA = modP3(A15 * A15);
      const B9 = x_2 - z_2;
      const BB = modP3(B9 * B9);
      const E10 = AA - BB;
      const C8 = x_3 + z_3;
      const D9 = x_3 - z_3;
      const DA = modP3(D9 * A15);
      const CB = modP3(C8 * B9);
      const dacb = DA + CB;
      const da_cb = DA - CB;
      x_3 = modP3(dacb * dacb);
      z_3 = modP3(x_1 * modP3(da_cb * da_cb));
      x_2 = modP3(AA * BB);
      z_2 = modP3(E10 * (AA + modP3(a24 * E10)));
    }
    sw = cswap(swap, x_2, x_3);
    x_2 = sw[0];
    x_3 = sw[1];
    sw = cswap(swap, z_2, z_3);
    z_2 = sw[0];
    z_3 = sw[1];
    const z22 = powPminus2(z_2);
    return modP3(x_2 * z22);
  }
  function encodeUCoordinate(u15) {
    return numberToBytesLE(modP3(u15), montgomeryBytes);
  }
  function decodeUCoordinate(uEnc) {
    const u15 = ensureBytes("u coordinate", uEnc, montgomeryBytes);
    if (fieldLen === 32)
      u15[31] &= 127;
    return bytesToNumberLE(u15);
  }
  function decodeScalar(n18) {
    const bytes2 = ensureBytes("scalar", n18);
    const len = bytes2.length;
    if (len !== montgomeryBytes && len !== fieldLen)
      throw new Error(`Expected ${montgomeryBytes} or ${fieldLen} bytes, got ${len}`);
    return bytesToNumberLE(adjustScalarBytes2(bytes2));
  }
  function scalarMult(scalar, u15) {
    const pointU = decodeUCoordinate(u15);
    const _scalar = decodeScalar(scalar);
    const pu = montgomeryLadder(pointU, _scalar);
    if (pu === _0n6)
      throw new Error("Invalid private or public key received");
    return encodeUCoordinate(pu);
  }
  const GuBytes = encodeUCoordinate(CURVE.Gu);
  function scalarMultBase(scalar) {
    return scalarMult(scalar, GuBytes);
  }
  return {
    scalarMult,
    scalarMultBase,
    getSharedSecret: (privateKey, publicKey) => scalarMult(privateKey, publicKey),
    getPublicKey: (privateKey) => scalarMultBase(privateKey),
    utils: { randomPrivateKey: () => CURVE.randomBytes(CURVE.nByteLength) },
    GuBytes
  };
}

// node_modules/@noble/curves/esm/ed25519.js
var ED25519_P = BigInt("57896044618658097711785492504343953926634992332820282019728792003956564819949");
var ED25519_SQRT_M1 = BigInt("19681161376707505956807079304988542015446066515923890162744021073123829784752");
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n5 = BigInt(2);
var _3n2 = BigInt(3);
var _5n2 = BigInt(5);
var _8n3 = BigInt(8);
function ed25519_pow_2_252_3(x10) {
  const _10n = BigInt(10), _20n = BigInt(20), _40n = BigInt(40), _80n = BigInt(80);
  const P7 = ED25519_P;
  const x22 = x10 * x10 % P7;
  const b22 = x22 * x10 % P7;
  const b42 = pow2(b22, _2n5, P7) * b22 % P7;
  const b52 = pow2(b42, _1n7, P7) * x10 % P7;
  const b102 = pow2(b52, _5n2, P7) * b52 % P7;
  const b20 = pow2(b102, _10n, P7) * b102 % P7;
  const b40 = pow2(b20, _20n, P7) * b20 % P7;
  const b80 = pow2(b40, _40n, P7) * b40 % P7;
  const b160 = pow2(b80, _80n, P7) * b80 % P7;
  const b240 = pow2(b160, _80n, P7) * b80 % P7;
  const b250 = pow2(b240, _10n, P7) * b102 % P7;
  const pow_p_5_8 = pow2(b250, _2n5, P7) * x10 % P7;
  return { pow_p_5_8, b2: b22 };
}
function adjustScalarBytes(bytes2) {
  bytes2[0] &= 248;
  bytes2[31] &= 127;
  bytes2[31] |= 64;
  return bytes2;
}
function uvRatio(u15, v8) {
  const P7 = ED25519_P;
  const v32 = mod(v8 * v8 * v8, P7);
  const v72 = mod(v32 * v32 * v8, P7);
  const pow4 = ed25519_pow_2_252_3(u15 * v72).pow_p_5_8;
  let x10 = mod(u15 * v32 * pow4, P7);
  const vx2 = mod(v8 * x10 * x10, P7);
  const root1 = x10;
  const root2 = mod(x10 * ED25519_SQRT_M1, P7);
  const useRoot1 = vx2 === u15;
  const useRoot2 = vx2 === mod(-u15, P7);
  const noRoot = vx2 === mod(-u15 * ED25519_SQRT_M1, P7);
  if (useRoot1)
    x10 = root1;
  if (useRoot2 || noRoot)
    x10 = root2;
  if (isNegativeLE(x10, P7))
    x10 = mod(-x10, P7);
  return { isValid: useRoot1 || useRoot2, value: x10 };
}
var Fp = (() => Field(ED25519_P, void 0, true))();
var ed25519Defaults = (() => ({
  // Param: a
  a: BigInt(-1),
  // Fp.create(-1) is proper; our way still works and is faster
  // d is equal to -121665/121666 over finite field.
  // Negative number is P - number, and division is invert(number, P)
  d: BigInt("37095705934669439343138083508754565189542113879843219016388785533085940283555"),
  // Finite field 𝔽p over which we'll do calculations; 2n**255n - 19n
  Fp,
  // Subgroup order: how many points curve has
  // 2n**252n + 27742317777372353535851937790883648493n;
  n: BigInt("7237005577332262213973186563042994240857116359379907606001950938285454250989"),
  // Cofactor
  h: _8n3,
  // Base point (x, y) aka generator point
  Gx: BigInt("15112221349535400772501151409588531511454012693041857206046113283949847762202"),
  Gy: BigInt("46316835694926478169428394003475163141307993866256225615783033603165251855960"),
  hash: sha512,
  randomBytes,
  adjustScalarBytes,
  // dom2
  // Ratio of u to v. Allows us to combine inversion and square root. Uses algo from RFC8032 5.1.3.
  // Constant-time, u/√v
  uvRatio
}))();
var ed25519 = (() => twistedEdwards(ed25519Defaults))();
function ed25519_domain(data, ctx, phflag) {
  if (ctx.length > 255)
    throw new Error("Context is too big");
  return concatBytes(utf8ToBytes("SigEd25519 no Ed25519 collisions"), new Uint8Array([phflag ? 1 : 0, ctx.length]), ctx, data);
}
var ed25519ctx = (() => twistedEdwards({
  ...ed25519Defaults,
  domain: ed25519_domain
}))();
var ed25519ph = (() => twistedEdwards(Object.assign({}, ed25519Defaults, {
  domain: ed25519_domain,
  prehash: sha512
})))();
var x25519 = (() => montgomery({
  P: ED25519_P,
  a: BigInt(486662),
  montgomeryBits: 255,
  // n is 253 bits
  nByteLength: 32,
  Gu: BigInt(9),
  powPminus2: (x10) => {
    const P7 = ED25519_P;
    const { pow_p_5_8, b2: b22 } = ed25519_pow_2_252_3(x10);
    return mod(pow2(pow_p_5_8, _3n2, P7) * b22, P7);
  },
  adjustScalarBytes,
  randomBytes
}))();
var ELL2_C1 = (() => (Fp.ORDER + _3n2) / _8n3)();
var ELL2_C2 = (() => Fp.pow(_2n5, ELL2_C1))();
var ELL2_C3 = (() => Fp.sqrt(Fp.neg(Fp.ONE)))();
function map_to_curve_elligator2_curve25519(u15) {
  const ELL2_C4 = (Fp.ORDER - _5n2) / _8n3;
  const ELL2_J = BigInt(486662);
  let tv1 = Fp.sqr(u15);
  tv1 = Fp.mul(tv1, _2n5);
  let xd = Fp.add(tv1, Fp.ONE);
  let x1n = Fp.neg(ELL2_J);
  let tv2 = Fp.sqr(xd);
  let gxd = Fp.mul(tv2, xd);
  let gx1 = Fp.mul(tv1, ELL2_J);
  gx1 = Fp.mul(gx1, x1n);
  gx1 = Fp.add(gx1, tv2);
  gx1 = Fp.mul(gx1, x1n);
  let tv3 = Fp.sqr(gxd);
  tv2 = Fp.sqr(tv3);
  tv3 = Fp.mul(tv3, gxd);
  tv3 = Fp.mul(tv3, gx1);
  tv2 = Fp.mul(tv2, tv3);
  let y112 = Fp.pow(tv2, ELL2_C4);
  y112 = Fp.mul(y112, tv3);
  let y12 = Fp.mul(y112, ELL2_C3);
  tv2 = Fp.sqr(y112);
  tv2 = Fp.mul(tv2, gxd);
  let e1 = Fp.eql(tv2, gx1);
  let y1 = Fp.cmov(y12, y112, e1);
  let x2n = Fp.mul(x1n, tv1);
  let y21 = Fp.mul(y112, u15);
  y21 = Fp.mul(y21, ELL2_C2);
  let y22 = Fp.mul(y21, ELL2_C3);
  let gx2 = Fp.mul(gx1, tv1);
  tv2 = Fp.sqr(y21);
  tv2 = Fp.mul(tv2, gxd);
  let e22 = Fp.eql(tv2, gx2);
  let y23 = Fp.cmov(y22, y21, e22);
  tv2 = Fp.sqr(y1);
  tv2 = Fp.mul(tv2, gxd);
  let e32 = Fp.eql(tv2, gx1);
  let xn = Fp.cmov(x2n, x1n, e32);
  let y13 = Fp.cmov(y23, y1, e32);
  let e42 = Fp.isOdd(y13);
  y13 = Fp.cmov(y13, Fp.neg(y13), e32 !== e42);
  return { xMn: xn, xMd: xd, yMn: y13, yMd: _1n7 };
}
var ELL2_C1_EDWARDS = (() => FpSqrtEven(Fp, Fp.neg(BigInt(486664))))();
function map_to_curve_elligator2_edwards25519(u15) {
  const { xMn, xMd, yMn, yMd } = map_to_curve_elligator2_curve25519(u15);
  let xn = Fp.mul(xMn, yMd);
  xn = Fp.mul(xn, ELL2_C1_EDWARDS);
  let xd = Fp.mul(xMd, yMn);
  let yn2 = Fp.sub(xMn, xMd);
  let yd = Fp.add(xMn, xMd);
  let tv1 = Fp.mul(xd, yd);
  let e5 = Fp.eql(tv1, Fp.ZERO);
  xn = Fp.cmov(xn, Fp.ZERO, e5);
  xd = Fp.cmov(xd, Fp.ONE, e5);
  yn2 = Fp.cmov(yn2, Fp.ONE, e5);
  yd = Fp.cmov(yd, Fp.ONE, e5);
  const inv = Fp.invertBatch([xd, yd]);
  return { x: Fp.mul(xn, inv[0]), y: Fp.mul(yn2, inv[1]) };
}
var htf = (() => createHasher(ed25519.ExtendedPoint, (scalars) => map_to_curve_elligator2_edwards25519(scalars[0]), {
  DST: "edwards25519_XMD:SHA-512_ELL2_RO_",
  encodeDST: "edwards25519_XMD:SHA-512_ELL2_NU_",
  p: Fp.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha512
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();
function assertRstPoint(other) {
  if (!(other instanceof RistPoint))
    throw new Error("RistrettoPoint expected");
}
var SQRT_M1 = ED25519_SQRT_M1;
var SQRT_AD_MINUS_ONE = BigInt("25063068953384623474111414158702152701244531502492656460079210482610430750235");
var INVSQRT_A_MINUS_D = BigInt("54469307008909316920995813868745141605393597292927456921205312896311721017578");
var ONE_MINUS_D_SQ = BigInt("1159843021668779879193775521855586647937357759715417654439879720876111806838");
var D_MINUS_ONE_SQ = BigInt("40440834346308536858101042469323190826248399146238708352240133220865137265952");
var invertSqrt = (number2) => uvRatio(_1n7, number2);
var MAX_255B = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var bytes255ToNumberLE = (bytes2) => ed25519.CURVE.Fp.create(bytesToNumberLE(bytes2) & MAX_255B);
function calcElligatorRistrettoMap(r0) {
  const { d: d20 } = ed25519.CURVE;
  const P7 = ed25519.CURVE.Fp.ORDER;
  const mod3 = ed25519.CURVE.Fp.create;
  const r26 = mod3(SQRT_M1 * r0 * r0);
  const Ns = mod3((r26 + _1n7) * ONE_MINUS_D_SQ);
  let c14 = BigInt(-1);
  const D9 = mod3((c14 - d20 * r26) * mod3(r26 + d20));
  let { isValid: Ns_D_is_sq, value: s12 } = uvRatio(Ns, D9);
  let s_ = mod3(s12 * r0);
  if (!isNegativeLE(s_, P7))
    s_ = mod3(-s_);
  if (!Ns_D_is_sq)
    s12 = s_;
  if (!Ns_D_is_sq)
    c14 = r26;
  const Nt2 = mod3(c14 * (r26 - _1n7) * D_MINUS_ONE_SQ - D9);
  const s22 = s12 * s12;
  const W0 = mod3((s12 + s12) * D9);
  const W1 = mod3(Nt2 * SQRT_AD_MINUS_ONE);
  const W22 = mod3(_1n7 - s22);
  const W32 = mod3(_1n7 + s22);
  return new ed25519.ExtendedPoint(mod3(W0 * W32), mod3(W22 * W1), mod3(W1 * W32), mod3(W0 * W22));
}
var RistPoint = class _RistPoint {
  // Private property to discourage combining ExtendedPoint + RistrettoPoint
  // Always use Ristretto encoding/decoding instead.
  constructor(ep) {
    this.ep = ep;
  }
  static fromAffine(ap) {
    return new _RistPoint(ed25519.ExtendedPoint.fromAffine(ap));
  }
  /**
   * Takes uniform output of 64-byte hash function like sha512 and converts it to `RistrettoPoint`.
   * The hash-to-group operation applies Elligator twice and adds the results.
   * **Note:** this is one-way map, there is no conversion from point to hash.
   * https://ristretto.group/formulas/elligator.html
   * @param hex 64-byte output of a hash function
   */
  static hashToCurve(hex2) {
    hex2 = ensureBytes("ristrettoHash", hex2, 64);
    const r1 = bytes255ToNumberLE(hex2.slice(0, 32));
    const R1 = calcElligatorRistrettoMap(r1);
    const r26 = bytes255ToNumberLE(hex2.slice(32, 64));
    const R22 = calcElligatorRistrettoMap(r26);
    return new _RistPoint(R1.add(R22));
  }
  /**
   * Converts ristretto-encoded string to ristretto point.
   * https://ristretto.group/formulas/decoding.html
   * @param hex Ristretto-encoded 32 bytes. Not every 32-byte string is valid ristretto encoding
   */
  static fromHex(hex2) {
    hex2 = ensureBytes("ristrettoHex", hex2, 32);
    const { a: a24, d: d20 } = ed25519.CURVE;
    const P7 = ed25519.CURVE.Fp.ORDER;
    const mod3 = ed25519.CURVE.Fp.create;
    const emsg = "RistrettoPoint.fromHex: the hex is not valid encoding of RistrettoPoint";
    const s12 = bytes255ToNumberLE(hex2);
    if (!equalBytes(numberToBytesLE(s12, 32), hex2) || isNegativeLE(s12, P7))
      throw new Error(emsg);
    const s22 = mod3(s12 * s12);
    const u1 = mod3(_1n7 + a24 * s22);
    const u22 = mod3(_1n7 - a24 * s22);
    const u1_2 = mod3(u1 * u1);
    const u2_2 = mod3(u22 * u22);
    const v8 = mod3(a24 * d20 * u1_2 - u2_2);
    const { isValid, value: I6 } = invertSqrt(mod3(v8 * u2_2));
    const Dx = mod3(I6 * u22);
    const Dy = mod3(I6 * Dx * v8);
    let x10 = mod3((s12 + s12) * Dx);
    if (isNegativeLE(x10, P7))
      x10 = mod3(-x10);
    const y12 = mod3(u1 * Dy);
    const t30 = mod3(x10 * y12);
    if (!isValid || isNegativeLE(t30, P7) || y12 === _0n7)
      throw new Error(emsg);
    return new _RistPoint(new ed25519.ExtendedPoint(x10, y12, _1n7, t30));
  }
  /**
   * Encodes ristretto point to Uint8Array.
   * https://ristretto.group/formulas/encoding.html
   */
  toRawBytes() {
    let { ex: x10, ey: y12, ez: z8, et: t30 } = this.ep;
    const P7 = ed25519.CURVE.Fp.ORDER;
    const mod3 = ed25519.CURVE.Fp.create;
    const u1 = mod3(mod3(z8 + y12) * mod3(z8 - y12));
    const u22 = mod3(x10 * y12);
    const u2sq = mod3(u22 * u22);
    const { value: invsqrt } = invertSqrt(mod3(u1 * u2sq));
    const D1 = mod3(invsqrt * u1);
    const D22 = mod3(invsqrt * u22);
    const zInv = mod3(D1 * D22 * t30);
    let D9;
    if (isNegativeLE(t30 * zInv, P7)) {
      let _x = mod3(y12 * SQRT_M1);
      let _y = mod3(x10 * SQRT_M1);
      x10 = _x;
      y12 = _y;
      D9 = mod3(D1 * INVSQRT_A_MINUS_D);
    } else {
      D9 = D22;
    }
    if (isNegativeLE(x10 * zInv, P7))
      y12 = mod3(-y12);
    let s12 = mod3((z8 - y12) * D9);
    if (isNegativeLE(s12, P7))
      s12 = mod3(-s12);
    return numberToBytesLE(s12, 32);
  }
  toHex() {
    return bytesToHex2(this.toRawBytes());
  }
  toString() {
    return this.toHex();
  }
  // Compare one point to another.
  equals(other) {
    assertRstPoint(other);
    const { ex: X1, ey: Y1 } = this.ep;
    const { ex: X22, ey: Y22 } = other.ep;
    const mod3 = ed25519.CURVE.Fp.create;
    const one = mod3(X1 * Y22) === mod3(Y1 * X22);
    const two = mod3(Y1 * Y22) === mod3(X1 * X22);
    return one || two;
  }
  add(other) {
    assertRstPoint(other);
    return new _RistPoint(this.ep.add(other.ep));
  }
  subtract(other) {
    assertRstPoint(other);
    return new _RistPoint(this.ep.subtract(other.ep));
  }
  multiply(scalar) {
    return new _RistPoint(this.ep.multiply(scalar));
  }
  multiplyUnsafe(scalar) {
    return new _RistPoint(this.ep.multiplyUnsafe(scalar));
  }
  double() {
    return new _RistPoint(this.ep.double());
  }
  negate() {
    return new _RistPoint(this.ep.negate());
  }
};
var RistrettoPoint = (() => {
  if (!RistPoint.BASE)
    RistPoint.BASE = new RistPoint(ed25519.ExtendedPoint.BASE);
  if (!RistPoint.ZERO)
    RistPoint.ZERO = new RistPoint(ed25519.ExtendedPoint.ZERO);
  return RistPoint;
})();

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-Q7MD4V7H.mjs
var d10 = [237, 211, 245, 92, 26, 99, 18, 88, 214, 156, 247, 162, 222, 249, 222, 20, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 16];
function w3(z8) {
  let e5 = z8.toUint8Array().slice(32);
  for (let t30 = d10.length - 1; t30 >= 0; t30 -= 1) {
    if (e5[t30] < d10[t30]) return true;
    if (e5[t30] > d10[t30]) return false;
  }
  return false;
}
var i30 = class i31 extends a8 {
  constructor(e5) {
    super();
    let t30 = i.fromHexInput(e5);
    if (t30.toUint8Array().length !== i31.LENGTH) throw new Error(`PublicKey length should be ${i31.LENGTH}`);
    this.key = t30;
  }
  verifySignature(e5) {
    let { message: t30, signature: n18 } = e5;
    if (!w3(n18)) return false;
    let o26 = o11(t30), c14 = i.fromHexInput(o26).toUint8Array(), u15 = n18.toUint8Array(), l19 = this.key.toUint8Array();
    return ed25519.verify(u15, c14, l19);
  }
  authKey() {
    return c3.fromSchemeAndBytes({ scheme: 0, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(e5) {
    e5.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(e5) {
    let t30 = e5.deserializeBytes();
    return new i31(t30);
  }
  static isPublicKey(e5) {
    return e5 instanceof i31;
  }
  static isInstance(e5) {
    var _a, _b;
    return "key" in e5 && ((_b = (_a = e5.key) == null ? void 0 : _a.data) == null ? void 0 : _b.length) === i31.LENGTH;
  }
};
i30.LENGTH = 32;
var m6 = i30;
var r8 = class r9 extends B {
  constructor(e5) {
    super();
    let t30 = i.fromHexInput(e5);
    if (t30.toUint8Array().length !== r9.LENGTH) throw new Error(`PrivateKey length should be ${r9.LENGTH}`);
    this.signingKey = t30;
  }
  static generate() {
    let e5 = ed25519.utils.randomPrivateKey();
    return new r9(e5);
  }
  static fromDerivationPath(e5, t30) {
    if (!E5(e5)) throw new Error(`Invalid derivation path ${e5}`);
    return r9.fromDerivationPathInner(e5, h7(t30));
  }
  static fromDerivationPathInner(e5, t30, n18 = g6) {
    let { key: o26, chainCode: c14 } = A7(r9.SLIP_0010_SEED, t30), u15 = U6(e5).map((x10) => parseInt(x10, 10)), { key: l19 } = u15.reduce((x10, I6) => f4(x10, I6 + n18), { key: o26, chainCode: c14 });
    return new r9(l19);
  }
  publicKey() {
    let e5 = ed25519.getPublicKey(this.signingKey.toUint8Array());
    return new m6(e5);
  }
  sign(e5) {
    let t30 = o11(e5), n18 = i.fromHexInput(t30).toUint8Array(), o26 = ed25519.sign(n18, this.signingKey.toUint8Array());
    return new h8(o26);
  }
  toUint8Array() {
    return this.signingKey.toUint8Array();
  }
  toString() {
    return this.signingKey.toString();
  }
  serialize(e5) {
    e5.serializeBytes(this.toUint8Array());
  }
  static deserialize(e5) {
    let t30 = e5.deserializeBytes();
    return new r9(t30);
  }
  static isPrivateKey(e5) {
    return e5 instanceof r9;
  }
};
r8.LENGTH = 32, r8.SLIP_0010_SEED = "ed25519 seed";
var U7 = r8;
var a9 = class a10 extends o10 {
  constructor(e5) {
    super();
    let t30 = i.fromHexInput(e5);
    if (t30.toUint8Array().length !== a10.LENGTH) throw new Error(`Signature length should be ${a10.LENGTH}`);
    this.data = t30;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(e5) {
    e5.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e5) {
    let t30 = e5.deserializeBytes();
    return new a10(t30);
  }
};
a9.LENGTH = 64;
var h8 = a9;

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-UWPO7WWS.mjs
var o12 = class o13 extends a8 {
  constructor(r26) {
    super();
    let { publicKeys: e5, threshold: t30 } = r26;
    if (e5.length > o13.MAX_KEYS || e5.length < o13.MIN_KEYS) throw new Error(`Must have between ${o13.MIN_KEYS} and ${o13.MAX_KEYS} public keys, inclusive`);
    if (t30 < o13.MIN_THRESHOLD || t30 > e5.length) throw new Error(`Threshold must be between ${o13.MIN_THRESHOLD} and ${e5.length}, inclusive`);
    this.publicKeys = e5, this.threshold = t30;
  }
  verifySignature(r26) {
    let { message: e5, signature: t30 } = r26;
    if (!(t30 instanceof y7)) return false;
    let s12 = [];
    for (let i47 = 0; i47 < 4; i47 += 1) for (let n18 = 0; n18 < 8; n18 += 1) if ((t30.bitmap[i47] & 1 << 7 - n18) !== 0) {
      let u15 = i47 * 8 + n18;
      s12.push(u15);
    }
    if (s12.length !== t30.signatures.length) throw new Error("Bitmap and signatures length mismatch");
    if (s12.length < this.threshold) throw new Error("Not enough signatures");
    for (let i47 = 0; i47 < s12.length; i47 += 1) if (!this.publicKeys[s12[i47]].verifySignature({ message: e5, signature: t30.signatures[i47] })) return false;
    return true;
  }
  authKey() {
    return c3.fromSchemeAndBytes({ scheme: 1, input: this.toUint8Array() });
  }
  toUint8Array() {
    let r26 = new Uint8Array(this.publicKeys.length * m6.LENGTH + 1);
    return this.publicKeys.forEach((e5, t30) => {
      r26.set(e5.toUint8Array(), t30 * m6.LENGTH);
    }), r26[this.publicKeys.length * m6.LENGTH] = this.threshold, r26;
  }
  serialize(r26) {
    r26.serializeBytes(this.toUint8Array());
  }
  static deserialize(r26) {
    let e5 = r26.deserializeBytes(), t30 = e5[e5.length - 1], s12 = [];
    for (let i47 = 0; i47 < e5.length - 1; i47 += m6.LENGTH) {
      let n18 = i47;
      s12.push(new m6(e5.subarray(n18, n18 + m6.LENGTH)));
    }
    return new o13({ publicKeys: s12, threshold: t30 });
  }
};
o12.MAX_KEYS = 32, o12.MIN_KEYS = 2, o12.MIN_THRESHOLD = 1;
var d11 = o12;
var a11 = class a12 extends o10 {
  constructor(r26) {
    super();
    let { signatures: e5, bitmap: t30 } = r26;
    if (e5.length > a12.MAX_SIGNATURES_SUPPORTED) throw new Error(`The number of signatures cannot be greater than ${a12.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = e5, !(t30 instanceof Uint8Array)) this.bitmap = a12.createBitmap({ bits: t30 });
    else {
      if (t30.length !== a12.BITMAP_LEN) throw new Error(`"bitmap" length should be ${a12.BITMAP_LEN}`);
      this.bitmap = t30;
    }
  }
  toUint8Array() {
    let r26 = new Uint8Array(this.signatures.length * h8.LENGTH + a12.BITMAP_LEN);
    return this.signatures.forEach((e5, t30) => {
      r26.set(e5.toUint8Array(), t30 * h8.LENGTH);
    }), r26.set(this.bitmap, this.signatures.length * h8.LENGTH), r26;
  }
  serialize(r26) {
    r26.serializeBytes(this.toUint8Array());
  }
  static deserialize(r26) {
    let e5 = r26.deserializeBytes(), t30 = e5.subarray(e5.length - 4), s12 = [];
    for (let i47 = 0; i47 < e5.length - t30.length; i47 += h8.LENGTH) {
      let n18 = i47;
      s12.push(new h8(e5.subarray(n18, n18 + h8.LENGTH)));
    }
    return new a12({ signatures: s12, bitmap: t30 });
  }
  static createBitmap(r26) {
    let { bits: e5 } = r26, t30 = 128, s12 = new Uint8Array([0, 0, 0, 0]), i47 = /* @__PURE__ */ new Set();
    return e5.forEach((n18, c14) => {
      if (n18 >= a12.MAX_SIGNATURES_SUPPORTED) throw new Error(`Cannot have a signature larger than ${a12.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (i47.has(n18)) throw new Error("Duplicate bits detected.");
      if (c14 > 0 && n18 <= e5[c14 - 1]) throw new Error("The bits need to be sorted in ascending order.");
      i47.add(n18);
      let u15 = Math.floor(n18 / 8), b11 = s12[u15];
      b11 |= t30 >> n18 % 8, s12[u15] = b11;
    }), s12;
  }
};
a11.MAX_SIGNATURES_SUPPORTED = 32, a11.BITMAP_LEN = 4;
var y7 = a11;

// node_modules/@noble/curves/esm/abstract/weierstrass.js
function validateSigVerOpts(opts) {
  if (opts.lowS !== void 0)
    abool("lowS", opts.lowS);
  if (opts.prehash !== void 0)
    abool("prehash", opts.prehash);
}
function validatePointOpts(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp4, a: a24 } = opts;
  if (endo) {
    if (!Fp4.eql(a24, Fp4.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n, hexToBytes: h2b } = utils_exports;
var DER = {
  // asn.1 DER encoding utils
  Err: class DERErr extends Error {
    constructor(m15 = "") {
      super(m15);
    }
  },
  _parseInt(data) {
    const { Err: E10 } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E10("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E10("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E10("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E10("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E10 } = DER;
    const data = typeof hex2 === "string" ? h2b(hex2) : hex2;
    abytes(data);
    let l19 = data.length;
    if (l19 < 2 || data[0] != 48)
      throw new E10("Invalid signature tag");
    if (data[1] !== l19 - 2)
      throw new E10("Invalid signature: incorrect length");
    const { d: r26, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s12, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E10("Invalid signature: left bytes after parsing");
    return { r: r26, s: s12 };
  },
  hexFromSig(sig) {
    const slice = (s13) => Number.parseInt(s13[0], 16) & 8 ? "00" + s13 : s13;
    const h17 = (num2) => {
      const hex2 = num2.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s12 = slice(h17(sig.s));
    const r26 = slice(h17(sig.r));
    const shl = s12.length / 2;
    const rhl = r26.length / 2;
    const sl = h17(shl);
    const rl = h17(rhl);
    return `30${h17(rhl + shl + 4)}02${rl}${r26}02${sl}${s12}`;
  }
};
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n6 = BigInt(2);
var _3n3 = BigInt(3);
var _4n2 = BigInt(4);
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp: Fp4 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a24 = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp4.toBytes(a24.x), Fp4.toBytes(a24.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x10 = Fp4.fromBytes(tail.subarray(0, Fp4.BYTES));
    const y12 = Fp4.fromBytes(tail.subarray(Fp4.BYTES, 2 * Fp4.BYTES));
    return { x: x10, y: y12 };
  });
  function weierstrassEquation(x10) {
    const { a: a24, b: b11 } = CURVE;
    const x22 = Fp4.sqr(x10);
    const x32 = Fp4.mul(x22, x10);
    return Fp4.add(Fp4.add(x32, Fp4.mul(x10, a24)), b11);
  }
  if (!Fp4.eql(Fp4.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num2) {
    return inRange(num2, _1n8, CURVE.n);
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: N6 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes3(key))
        key = bytesToHex2(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num2;
    try {
      num2 = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num2 = mod(num2, N6);
    aInRange("private key", num2, _1n8, N6);
    return num2;
  }
  function assertPrjPoint(other) {
    if (!(other instanceof Point4))
      throw new Error("ProjectivePoint expected");
  }
  const toAffineMemo = memoized((p13, iz) => {
    const { px: x10, py: y12, pz: z8 } = p13;
    if (Fp4.eql(z8, Fp4.ONE))
      return { x: x10, y: y12 };
    const is0 = p13.is0();
    if (iz == null)
      iz = is0 ? Fp4.ONE : Fp4.inv(z8);
    const ax = Fp4.mul(x10, iz);
    const ay = Fp4.mul(y12, iz);
    const zz = Fp4.mul(z8, iz);
    if (is0)
      return { x: Fp4.ZERO, y: Fp4.ZERO };
    if (!Fp4.eql(zz, Fp4.ONE))
      throw new Error("invZ was invalid");
    return { x: ax, y: ay };
  });
  const assertValidMemo = memoized((p13) => {
    if (p13.is0()) {
      if (CURVE.allowInfinityPoint && !Fp4.is0(p13.py))
        return;
      throw new Error("bad point: ZERO");
    }
    const { x: x10, y: y12 } = p13.toAffine();
    if (!Fp4.isValid(x10) || !Fp4.isValid(y12))
      throw new Error("bad point: x or y not FE");
    const left = Fp4.sqr(y12);
    const right = weierstrassEquation(x10);
    if (!Fp4.eql(left, right))
      throw new Error("bad point: equation left != right");
    if (!p13.isTorsionFree())
      throw new Error("bad point: not in prime-order subgroup");
    return true;
  });
  class Point4 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp4.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp4.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp4.isValid(pz))
        throw new Error("z required");
      Object.freeze(this);
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p13) {
      const { x: x10, y: y12 } = p13 || {};
      if (!p13 || !Fp4.isValid(x10) || !Fp4.isValid(y12))
        throw new Error("invalid affine point");
      if (p13 instanceof Point4)
        throw new Error("projective point not allowed");
      const is0 = (i47) => Fp4.eql(i47, Fp4.ZERO);
      if (is0(x10) && is0(y12))
        return Point4.ZERO;
      return new Point4(x10, y12, Fp4.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp4.invertBatch(points.map((p13) => p13.pz));
      return points.map((p13, i47) => p13.toAffine(toInv[i47])).map(Point4.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P7 = Point4.fromAffine(fromBytes(ensureBytes("pointHex", hex2)));
      P7.assertValidity();
      return P7;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point4.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      wnaf.setWindowSize(this, windowSize);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      assertValidMemo(this);
    }
    hasEvenY() {
      const { y: y12 } = this.toAffine();
      if (Fp4.isOdd)
        return !Fp4.isOdd(y12);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      const U1 = Fp4.eql(Fp4.mul(X1, Z22), Fp4.mul(X22, Z1));
      const U22 = Fp4.eql(Fp4.mul(Y1, Z22), Fp4.mul(Y22, Z1));
      return U1 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point4(this.px, Fp4.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a24, b: b11 } = CURVE;
      const b32 = Fp4.mul(b11, _3n3);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X32 = Fp4.ZERO, Y32 = Fp4.ZERO, Z32 = Fp4.ZERO;
      let t0 = Fp4.mul(X1, X1);
      let t1 = Fp4.mul(Y1, Y1);
      let t210 = Fp4.mul(Z1, Z1);
      let t32 = Fp4.mul(X1, Y1);
      t32 = Fp4.add(t32, t32);
      Z32 = Fp4.mul(X1, Z1);
      Z32 = Fp4.add(Z32, Z32);
      X32 = Fp4.mul(a24, Z32);
      Y32 = Fp4.mul(b32, t210);
      Y32 = Fp4.add(X32, Y32);
      X32 = Fp4.sub(t1, Y32);
      Y32 = Fp4.add(t1, Y32);
      Y32 = Fp4.mul(X32, Y32);
      X32 = Fp4.mul(t32, X32);
      Z32 = Fp4.mul(b32, Z32);
      t210 = Fp4.mul(a24, t210);
      t32 = Fp4.sub(t0, t210);
      t32 = Fp4.mul(a24, t32);
      t32 = Fp4.add(t32, Z32);
      Z32 = Fp4.add(t0, t0);
      t0 = Fp4.add(Z32, t0);
      t0 = Fp4.add(t0, t210);
      t0 = Fp4.mul(t0, t32);
      Y32 = Fp4.add(Y32, t0);
      t210 = Fp4.mul(Y1, Z1);
      t210 = Fp4.add(t210, t210);
      t0 = Fp4.mul(t210, t32);
      X32 = Fp4.sub(X32, t0);
      Z32 = Fp4.mul(t210, t1);
      Z32 = Fp4.add(Z32, Z32);
      Z32 = Fp4.add(Z32, Z32);
      return new Point4(X32, Y32, Z32);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      let X32 = Fp4.ZERO, Y32 = Fp4.ZERO, Z32 = Fp4.ZERO;
      const a24 = CURVE.a;
      const b32 = Fp4.mul(CURVE.b, _3n3);
      let t0 = Fp4.mul(X1, X22);
      let t1 = Fp4.mul(Y1, Y22);
      let t210 = Fp4.mul(Z1, Z22);
      let t32 = Fp4.add(X1, Y1);
      let t42 = Fp4.add(X22, Y22);
      t32 = Fp4.mul(t32, t42);
      t42 = Fp4.add(t0, t1);
      t32 = Fp4.sub(t32, t42);
      t42 = Fp4.add(X1, Z1);
      let t52 = Fp4.add(X22, Z22);
      t42 = Fp4.mul(t42, t52);
      t52 = Fp4.add(t0, t210);
      t42 = Fp4.sub(t42, t52);
      t52 = Fp4.add(Y1, Z1);
      X32 = Fp4.add(Y22, Z22);
      t52 = Fp4.mul(t52, X32);
      X32 = Fp4.add(t1, t210);
      t52 = Fp4.sub(t52, X32);
      Z32 = Fp4.mul(a24, t42);
      X32 = Fp4.mul(b32, t210);
      Z32 = Fp4.add(X32, Z32);
      X32 = Fp4.sub(t1, Z32);
      Z32 = Fp4.add(t1, Z32);
      Y32 = Fp4.mul(X32, Z32);
      t1 = Fp4.add(t0, t0);
      t1 = Fp4.add(t1, t0);
      t210 = Fp4.mul(a24, t210);
      t42 = Fp4.mul(b32, t42);
      t1 = Fp4.add(t1, t210);
      t210 = Fp4.sub(t0, t210);
      t210 = Fp4.mul(a24, t210);
      t42 = Fp4.add(t42, t210);
      t0 = Fp4.mul(t1, t42);
      Y32 = Fp4.add(Y32, t0);
      t0 = Fp4.mul(t52, t42);
      X32 = Fp4.mul(t32, X32);
      X32 = Fp4.sub(X32, t0);
      t0 = Fp4.mul(t32, t1);
      Z32 = Fp4.mul(t52, Z32);
      Z32 = Fp4.add(Z32, t0);
      return new Point4(X32, Y32, Z32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point4.ZERO);
    }
    wNAF(n18) {
      return wnaf.wNAFCached(this, n18, Point4.normalizeZ);
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(sc) {
      aInRange("scalar", sc, _0n8, CURVE.n);
      const I6 = Point4.ZERO;
      if (sc === _0n8)
        return I6;
      if (sc === _1n8)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, sc);
      let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(sc);
      let k1p = I6;
      let k2p = I6;
      let d20 = this;
      while (k1 > _0n8 || k22 > _0n8) {
        if (k1 & _1n8)
          k1p = k1p.add(d20);
        if (k22 & _1n8)
          k2p = k2p.add(d20);
        d20 = d20.double();
        k1 >>= _1n8;
        k22 >>= _1n8;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point4(Fp4.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      const { endo, n: N6 } = CURVE;
      aInRange("scalar", scalar, _1n8, N6);
      let point, fake;
      if (endo) {
        const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(scalar);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point4(Fp4.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p13, f: f16 } = this.wNAF(scalar);
        point = p13;
        fake = f16;
      }
      return Point4.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q4, a24, b11) {
      const G7 = Point4.BASE;
      const mul = (P7, a25) => a25 === _0n8 || a25 === _1n8 || !P7.equals(G7) ? P7.multiplyUnsafe(a25) : P7.multiply(a25);
      const sum = mul(this, a24).add(mul(Q4, b11));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      return toAffineMemo(this, iz);
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n8)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point4, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n8)
        return this;
      if (clearCofactor)
        return clearCofactor(Point4, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      abool("isCompressed", isCompressed);
      this.assertValidity();
      return toBytes2(Point4, this, isCompressed);
    }
    toHex(isCompressed = true) {
      abool("isCompressed", isCompressed);
      return bytesToHex2(this.toRawBytes(isCompressed));
    }
  }
  Point4.BASE = new Point4(CURVE.Gx, CURVE.Gy, Fp4.ONE);
  Point4.ZERO = new Point4(Fp4.ZERO, Fp4.ONE, Fp4.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point4, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point4,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts3(curve) {
  const opts = validateBasic(curve);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass(curveDef) {
  const CURVE = validateOpts3(curveDef);
  const { Fp: Fp4, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp4.BYTES + 1;
  const uncompressedLen = 2 * Fp4.BYTES + 1;
  function modN3(a24) {
    return mod(a24, CURVE_ORDER);
  }
  function invN(a24) {
    return invert(a24, CURVE_ORDER);
  }
  const { ProjectivePoint: Point4, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a24 = point.toAffine();
      const x10 = Fp4.toBytes(a24.x);
      const cat = concatBytes2;
      abool("isCompressed", isCompressed);
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x10);
      } else {
        return cat(Uint8Array.from([4]), x10, Fp4.toBytes(a24.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x10 = bytesToNumberBE(tail);
        if (!inRange(x10, _1n8, Fp4.ORDER))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x10);
        let y12;
        try {
          y12 = Fp4.sqrt(y22);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y12 & _1n8) === _1n8;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y12 = Fp4.neg(y12);
        return { x: x10, y: y12 };
      } else if (len === uncompressedLen && head === 4) {
        const x10 = Fp4.fromBytes(tail.subarray(0, Fp4.BYTES));
        const y12 = Fp4.fromBytes(tail.subarray(Fp4.BYTES, 2 * Fp4.BYTES));
        return { x: x10, y: y12 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num2) => bytesToHex2(numberToBytesBE(num2, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n8;
    return number2 > HALF;
  }
  function normalizeS(s12) {
    return isBiggerThanHalfOrder(s12) ? modN3(-s12) : s12;
  }
  const slcNum = (b11, from, to) => bytesToNumberBE(b11.slice(from, to));
  class Signature {
    constructor(r26, s12, recovery) {
      this.r = r26;
      this.s = s12;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l19 = CURVE.nByteLength;
      hex2 = ensureBytes("compactSignature", hex2, l19 * 2);
      return new Signature(slcNum(hex2, 0, l19), slcNum(hex2, l19, 2 * l19));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r26, s: s12 } = DER.toSig(ensureBytes("DER", hex2));
      return new Signature(r26, s12);
    }
    assertValidity() {
      aInRange("r", this.r, _1n8, CURVE_ORDER);
      aInRange("s", this.s, _1n8, CURVE_ORDER);
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r26, s: s12, recovery: rec } = this;
      const h17 = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r26 + CURVE.n : r26;
      if (radj >= Fp4.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R7 = Point4.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN3(-h17 * ir);
      const u22 = modN3(s12 * ir);
      const Q4 = Point4.BASE.multiplyAndAddUnsafe(R7, u1, u22);
      if (!Q4)
        throw new Error("point at infinify");
      Q4.assertValidity();
      return Q4;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN3(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point4.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point4.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes3(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point4)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b11 = Point4.fromHex(publicB);
    return b11.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num2 = bytesToNumberBE(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN3(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num2) {
    aInRange(`num < 2^${CURVE.nBitLength}`, num2, _0n8, ORDER_MASK);
    return numberToBytesBE(num2, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k6) => k6 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    validateSigVerOpts(opts);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d20 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d20), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e5 = ent === true ? randomBytes2(Fp4.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e5));
    }
    const seed = concatBytes2(...seedArgs);
    const m15 = h1int;
    function k2sig(kBytes) {
      const k6 = bits2int(kBytes);
      if (!isWithinCurveOrder(k6))
        return;
      const ik = invN(k6);
      const q5 = Point4.BASE.multiply(k6).toAffine();
      const r26 = modN3(q5.x);
      if (r26 === _0n8)
        return;
      const s12 = modN3(ik * modN3(m15 + r26 * d20));
      if (s12 === _0n8)
        return;
      let recovery = (q5.x === r26 ? 0 : 2) | Number(q5.y & _1n8);
      let normS = s12;
      if (lowS && isBiggerThanHalfOrder(s12)) {
        normS = normalizeS(s12);
        recovery ^= 1;
      }
      return new Signature(r26, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C8 = CURVE;
    const drbg = createHmacDrbg(C8.hash.outputLen, C8.nByteLength, C8.hmac);
    return drbg(seed, k2sig);
  }
  Point4.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    validateSigVerOpts(opts);
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P7;
    try {
      if (typeof sg === "string" || isBytes3(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r27, s: s13 } = sg;
        _sig = new Signature(r27, s13);
      } else {
        throw new Error("PARSE");
      }
      P7 = Point4.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r26, s: s12 } = _sig;
    const h17 = bits2int_modN(msgHash);
    const is = invN(s12);
    const u1 = modN3(h17 * is);
    const u22 = modN3(r26 * is);
    const R7 = (_a = Point4.BASE.multiplyAndAddUnsafe(P7, u1, u22)) == null ? void 0 : _a.toAffine();
    if (!R7)
      return false;
    const v8 = modN3(R7.x);
    return v8 === r26;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point4,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio(Fp4, Z5) {
  const q5 = Fp4.ORDER;
  let l19 = _0n8;
  for (let o26 = q5 - _1n8; o26 % _2n6 === _0n8; o26 /= _2n6)
    l19 += _1n8;
  const c1 = l19;
  const _2n_pow_c1_1 = _2n6 << c1 - _1n8 - _1n8;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n6;
  const c22 = (q5 - _1n8) / _2n_pow_c1;
  const c32 = (c22 - _1n8) / _2n6;
  const c42 = _2n_pow_c1 - _1n8;
  const c52 = _2n_pow_c1_1;
  const c62 = Fp4.pow(Z5, c22);
  const c72 = Fp4.pow(Z5, (c22 + _1n8) / _2n6);
  let sqrtRatio = (u15, v8) => {
    let tv1 = c62;
    let tv2 = Fp4.pow(v8, c42);
    let tv3 = Fp4.sqr(tv2);
    tv3 = Fp4.mul(tv3, v8);
    let tv5 = Fp4.mul(u15, tv3);
    tv5 = Fp4.pow(tv5, c32);
    tv5 = Fp4.mul(tv5, tv2);
    tv2 = Fp4.mul(tv5, v8);
    tv3 = Fp4.mul(tv5, u15);
    let tv4 = Fp4.mul(tv3, tv2);
    tv5 = Fp4.pow(tv4, c52);
    let isQR = Fp4.eql(tv5, Fp4.ONE);
    tv2 = Fp4.mul(tv3, c72);
    tv5 = Fp4.mul(tv4, tv1);
    tv3 = Fp4.cmov(tv2, tv3, isQR);
    tv4 = Fp4.cmov(tv5, tv4, isQR);
    for (let i47 = c1; i47 > _1n8; i47--) {
      let tv52 = i47 - _2n6;
      tv52 = _2n6 << tv52 - _1n8;
      let tvv5 = Fp4.pow(tv4, tv52);
      const e1 = Fp4.eql(tvv5, Fp4.ONE);
      tv2 = Fp4.mul(tv3, tv1);
      tv1 = Fp4.mul(tv1, tv1);
      tvv5 = Fp4.mul(tv4, tv1);
      tv3 = Fp4.cmov(tv2, tv3, e1);
      tv4 = Fp4.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp4.ORDER % _4n2 === _3n3) {
    const c14 = (Fp4.ORDER - _3n3) / _4n2;
    const c23 = Fp4.sqrt(Fp4.neg(Z5));
    sqrtRatio = (u15, v8) => {
      let tv1 = Fp4.sqr(v8);
      const tv2 = Fp4.mul(u15, v8);
      tv1 = Fp4.mul(tv1, tv2);
      let y1 = Fp4.pow(tv1, c14);
      y1 = Fp4.mul(y1, tv2);
      const y22 = Fp4.mul(y1, c23);
      const tv3 = Fp4.mul(Fp4.sqr(y1), v8);
      const isQR = Fp4.eql(tv3, u15);
      let y12 = Fp4.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y12 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU(Fp4, opts) {
  validateField(Fp4);
  if (!Fp4.isValid(opts.A) || !Fp4.isValid(opts.B) || !Fp4.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio(Fp4, opts.Z);
  if (!Fp4.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u15) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x10, y12;
    tv1 = Fp4.sqr(u15);
    tv1 = Fp4.mul(tv1, opts.Z);
    tv2 = Fp4.sqr(tv1);
    tv2 = Fp4.add(tv2, tv1);
    tv3 = Fp4.add(tv2, Fp4.ONE);
    tv3 = Fp4.mul(tv3, opts.B);
    tv4 = Fp4.cmov(opts.Z, Fp4.neg(tv2), !Fp4.eql(tv2, Fp4.ZERO));
    tv4 = Fp4.mul(tv4, opts.A);
    tv2 = Fp4.sqr(tv3);
    tv6 = Fp4.sqr(tv4);
    tv5 = Fp4.mul(tv6, opts.A);
    tv2 = Fp4.add(tv2, tv5);
    tv2 = Fp4.mul(tv2, tv3);
    tv6 = Fp4.mul(tv6, tv4);
    tv5 = Fp4.mul(tv6, opts.B);
    tv2 = Fp4.add(tv2, tv5);
    x10 = Fp4.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y12 = Fp4.mul(tv1, u15);
    y12 = Fp4.mul(y12, value);
    x10 = Fp4.cmov(x10, tv3, isValid);
    y12 = Fp4.cmov(y12, value, isValid);
    const e1 = Fp4.isOdd(u15) === Fp4.isOdd(y12);
    y12 = Fp4.cmov(Fp4.neg(y12), y12, e1);
    x10 = Fp4.div(x10, tv4);
    return { x: x10, y: y12 };
  };
}

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash2) => weierstrass({ ...curveDef, ...getHash(hash2) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n9 = BigInt(1);
var _2n7 = BigInt(2);
var divNearest = (a24, b11) => (a24 + b11 / _2n7) / b11;
function sqrtMod(y12) {
  const P7 = secp256k1P;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y12 * y12 * y12 % P7;
  const b32 = b22 * b22 * y12 % P7;
  const b62 = pow2(b32, _3n6, P7) * b32 % P7;
  const b92 = pow2(b62, _3n6, P7) * b32 % P7;
  const b11 = pow2(b92, _2n7, P7) * b22 % P7;
  const b222 = pow2(b11, _11n, P7) * b11 % P7;
  const b44 = pow2(b222, _22n, P7) * b222 % P7;
  const b88 = pow2(b44, _44n, P7) * b44 % P7;
  const b176 = pow2(b88, _88n, P7) * b88 % P7;
  const b220 = pow2(b176, _44n, P7) * b44 % P7;
  const b223 = pow2(b220, _3n6, P7) * b32 % P7;
  const t1 = pow2(b223, _23n, P7) * b222 % P7;
  const t210 = pow2(t1, _6n, P7) * b22 % P7;
  const root = pow2(t210, _2n7, P7);
  if (!Fp2.eql(Fp2.sqr(root), y12))
    throw new Error("Cannot find square root");
  return root;
}
var Fp2 = Field(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp2,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k6) => {
      const n18 = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n9 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a24 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b22 * k6, n18);
      const c22 = divNearest(-b1 * k6, n18);
      let k1 = mod(k6 - c1 * a1 - c22 * a24, n18);
      let k22 = mod(-c1 * b1 - c22 * b22, n18);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n18 - k1;
      if (k2neg)
        k22 = n18 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k6);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256);
var _0n9 = BigInt(0);
var TAGGED_HASH_PREFIXES = {};
function taggedHash(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c14) => c14.charCodeAt(0)));
    tagP = concatBytes2(tagH, tagH);
    TAGGED_HASH_PREFIXES[tag] = tagP;
  }
  return sha256(concatBytes2(tagP, ...messages));
}
var pointToBytes = (point) => point.toRawBytes(true).slice(1);
var numTo32b = (n18) => numberToBytesBE(n18, 32);
var modP = (x10) => mod(x10, secp256k1P);
var modN = (x10) => mod(x10, secp256k1N);
var Point = secp256k1.ProjectivePoint;
var GmulAdd = (Q4, a24, b11) => Point.BASE.multiplyAndAddUnsafe(Q4, a24, b11);
function schnorrGetExtPubKey(priv) {
  let d_ = secp256k1.utils.normPrivateKeyToScalar(priv);
  let p13 = Point.fromPrivateKey(d_);
  const scalar = p13.hasEvenY() ? d_ : modN(-d_);
  return { scalar, bytes: pointToBytes(p13) };
}
function lift_x(x10) {
  aInRange("x", x10, _1n9, secp256k1P);
  const xx = modP(x10 * x10);
  const c14 = modP(xx * x10 + BigInt(7));
  let y12 = sqrtMod(c14);
  if (y12 % _2n7 !== _0n9)
    y12 = modP(-y12);
  const p13 = new Point(x10, y12, _1n9);
  p13.assertValidity();
  return p13;
}
var num = bytesToNumberBE;
function challenge(...args) {
  return modN(num(taggedHash("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey(privateKey) {
  return schnorrGetExtPubKey(privateKey).bytes;
}
function schnorrSign(message, privateKey, auxRand = randomBytes(32)) {
  const m15 = ensureBytes("message", message);
  const { bytes: px, scalar: d20 } = schnorrGetExtPubKey(privateKey);
  const a24 = ensureBytes("auxRand", auxRand, 32);
  const t30 = numTo32b(d20 ^ num(taggedHash("BIP0340/aux", a24)));
  const rand = taggedHash("BIP0340/nonce", t30, px, m15);
  const k_ = modN(num(rand));
  if (k_ === _0n9)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k6 } = schnorrGetExtPubKey(k_);
  const e5 = challenge(rx, px, m15);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b(modN(k6 + e5 * d20)), 32);
  if (!schnorrVerify(sig, m15, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify(signature, message, publicKey) {
  const sig = ensureBytes("signature", signature, 64);
  const m15 = ensureBytes("message", message);
  const pub = ensureBytes("publicKey", publicKey, 32);
  try {
    const P7 = lift_x(num(pub));
    const r26 = num(sig.subarray(0, 32));
    if (!inRange(r26, _1n9, secp256k1P))
      return false;
    const s12 = num(sig.subarray(32, 64));
    if (!inRange(s12, _1n9, secp256k1N))
      return false;
    const e5 = challenge(numTo32b(r26), pointToBytes(P7), m15);
    const R7 = GmulAdd(P7, s12, modN(-e5));
    if (!R7 || !R7.hasEvenY() || R7.toAffine().x !== r26)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr = (() => ({
  getPublicKey: schnorrGetPublicKey,
  sign: schnorrSign,
  verify: schnorrVerify,
  utils: {
    randomPrivateKey: secp256k1.utils.randomPrivateKey,
    lift_x,
    pointToBytes,
    numberToBytesBE,
    bytesToNumberBE,
    taggedHash,
    mod
  }
}))();
var isoMap = (() => isogenyMap(Fp2, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i47) => i47.map((j6) => BigInt(j6)))))();
var mapSWU = (() => mapToCurveSimpleSWU(Fp2, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp2.create(BigInt("-11"))
}))();
var htf2 = (() => createHasher(secp256k1.ProjectivePoint, (scalars) => {
  const { x: x10, y: y12 } = mapSWU(Fp2.create(scalars[0]));
  return isoMap(x10, y12);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp2.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve2 = (() => htf2.hashToCurve)();
var encodeToCurve2 = (() => htf2.encodeToCurve)();

// node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map((_8, i47) => i47));
var Pi = Id.map((i47) => (9 * i47 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i47 = 0; i47 < 4; i47++)
  for (let j6 of [idxL, idxR])
    j6.push(j6[i47].map((k6) => Rho[k6]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i47) => new Uint8Array(i47));
var shiftsL = idxL.map((idx, i47) => idx.map((j6) => shifts[i47][j6]));
var shiftsR = idxR.map((idx, i47) => idx.map((j6) => shifts[i47][j6]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f5(group, x10, y12, z8) {
  if (group === 0)
    return x10 ^ y12 ^ z8;
  else if (group === 1)
    return x10 & y12 | ~x10 & z8;
  else if (group === 2)
    return (x10 | ~y12) ^ z8;
  else if (group === 3)
    return x10 & z8 | y12 & ~z8;
  else
    return x10 ^ (y12 | ~z8);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2: h22, h3: h32, h4: h42 } = this;
    return [h0, h1, h22, h32, h42];
  }
  set(h0, h1, h22, h32, h42) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h22 | 0;
    this.h3 = h32 | 0;
    this.h4 = h42 | 0;
  }
  process(view, offset) {
    for (let i47 = 0; i47 < 16; i47++, offset += 4)
      R_BUF[i47] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i47 = 0; i47 < 16; i47++) {
        const tl = rotl(al + f5(group, bl, cl, dl) + R_BUF[rl[i47]] + hbl, sl[i47]) + el | 0;
        al = el, el = dl, dl = rotl(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i47 = 0; i47 < 16; i47++) {
        const tr = rotl(ar + f5(rGroup, br, cr, dr) + R_BUF[rr[i47]] + hbr, sr[i47]) + er | 0;
        ar = er, er = dr, dr = rotl(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/@scure/bip32/node_modules/@noble/curves/esm/abstract/utils.js
var utils_exports2 = {};
__export(utils_exports2, {
  abytes: () => abytes2,
  bitGet: () => bitGet2,
  bitLen: () => bitLen2,
  bitMask: () => bitMask2,
  bitSet: () => bitSet2,
  bytesToHex: () => bytesToHex3,
  bytesToNumberBE: () => bytesToNumberBE2,
  bytesToNumberLE: () => bytesToNumberLE2,
  concatBytes: () => concatBytes3,
  createHmacDrbg: () => createHmacDrbg2,
  ensureBytes: () => ensureBytes2,
  equalBytes: () => equalBytes2,
  hexToBytes: () => hexToBytes3,
  hexToNumber: () => hexToNumber2,
  isBytes: () => isBytes4,
  numberToBytesBE: () => numberToBytesBE2,
  numberToBytesLE: () => numberToBytesLE2,
  numberToHexUnpadded: () => numberToHexUnpadded2,
  numberToVarBytesBE: () => numberToVarBytesBE2,
  utf8ToBytes: () => utf8ToBytes3,
  validateObject: () => validateObject2
});
var _0n10 = BigInt(0);
var _1n10 = BigInt(1);
var _2n8 = BigInt(2);
function isBytes4(a24) {
  return a24 instanceof Uint8Array || a24 != null && typeof a24 === "object" && a24.constructor.name === "Uint8Array";
}
function abytes2(item) {
  if (!isBytes4(item))
    throw new Error("Uint8Array expected");
}
var hexes3 = Array.from({ length: 256 }, (_8, i47) => i47.toString(16).padStart(2, "0"));
function bytesToHex3(bytes2) {
  abytes2(bytes2);
  let hex2 = "";
  for (let i47 = 0; i47 < bytes2.length; i47++) {
    hex2 += hexes3[bytes2[i47]];
  }
  return hex2;
}
function numberToHexUnpadded2(num2) {
  const hex2 = num2.toString(16);
  return hex2.length & 1 ? `0${hex2}` : hex2;
}
function hexToNumber2(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  return BigInt(hex2 === "" ? "0" : `0x${hex2}`);
}
var asciis3 = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
function asciiToBase163(char) {
  if (char >= asciis3._0 && char <= asciis3._9)
    return char - asciis3._0;
  if (char >= asciis3._A && char <= asciis3._F)
    return char - (asciis3._A - 10);
  if (char >= asciis3._a && char <= asciis3._f)
    return char - (asciis3._a - 10);
  return;
}
function hexToBytes3(hex2) {
  if (typeof hex2 !== "string")
    throw new Error("hex string expected, got " + typeof hex2);
  const hl = hex2.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0; ai < al; ai++, hi += 2) {
    const n1 = asciiToBase163(hex2.charCodeAt(hi));
    const n22 = asciiToBase163(hex2.charCodeAt(hi + 1));
    if (n1 === void 0 || n22 === void 0) {
      const char = hex2[hi] + hex2[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n22;
  }
  return array;
}
function bytesToNumberBE2(bytes2) {
  return hexToNumber2(bytesToHex3(bytes2));
}
function bytesToNumberLE2(bytes2) {
  abytes2(bytes2);
  return hexToNumber2(bytesToHex3(Uint8Array.from(bytes2).reverse()));
}
function numberToBytesBE2(n18, len) {
  return hexToBytes3(n18.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE2(n18, len) {
  return numberToBytesBE2(n18, len).reverse();
}
function numberToVarBytesBE2(n18) {
  return hexToBytes3(numberToHexUnpadded2(n18));
}
function ensureBytes2(title, hex2, expectedLength) {
  let res;
  if (typeof hex2 === "string") {
    try {
      res = hexToBytes3(hex2);
    } catch (e5) {
      throw new Error(`${title} must be valid hex string, got "${hex2}". Cause: ${e5}`);
    }
  } else if (isBytes4(hex2)) {
    res = Uint8Array.from(hex2);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes3(...arrays) {
  let sum = 0;
  for (let i47 = 0; i47 < arrays.length; i47++) {
    const a24 = arrays[i47];
    abytes2(a24);
    sum += a24.length;
  }
  const res = new Uint8Array(sum);
  for (let i47 = 0, pad = 0; i47 < arrays.length; i47++) {
    const a24 = arrays[i47];
    res.set(a24, pad);
    pad += a24.length;
  }
  return res;
}
function equalBytes2(a24, b11) {
  if (a24.length !== b11.length)
    return false;
  let diff = 0;
  for (let i47 = 0; i47 < a24.length; i47++)
    diff |= a24[i47] ^ b11[i47];
  return diff === 0;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen2(n18) {
  let len;
  for (len = 0; n18 > _0n10; n18 >>= _1n10, len += 1)
    ;
  return len;
}
function bitGet2(n18, pos) {
  return n18 >> BigInt(pos) & _1n10;
}
function bitSet2(n18, pos, value) {
  return n18 | (value ? _1n10 : _0n10) << BigInt(pos);
}
var bitMask2 = (n18) => (_2n8 << BigInt(n18 - 1)) - _1n10;
var u8n2 = (data) => new Uint8Array(data);
var u8fr2 = (arr) => Uint8Array.from(arr);
function createHmacDrbg2(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v8 = u8n2(hashLen);
  let k6 = u8n2(hashLen);
  let i47 = 0;
  const reset = () => {
    v8.fill(1);
    k6.fill(0);
    i47 = 0;
  };
  const h17 = (...b11) => hmacFn(k6, v8, ...b11);
  const reseed = (seed = u8n2()) => {
    k6 = h17(u8fr2([0]), seed);
    v8 = h17();
    if (seed.length === 0)
      return;
    k6 = h17(u8fr2([1]), seed);
    v8 = h17();
  };
  const gen2 = () => {
    if (i47++ >= 1e3)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v8 = h17();
      const sl = v8.slice();
      out.push(sl);
      len += v8.length;
    }
    return concatBytes3(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = void 0;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
var validatorFns2 = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes4(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object) => object.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};
function validateObject2(object, validators3, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns2[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object[fieldName];
    if (isOptional && val === void 0)
      return;
    if (!checkVal(val, object)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators3))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object;
}

// node_modules/@scure/bip32/node_modules/@noble/curves/esm/abstract/modular.js
var _0n11 = BigInt(0);
var _1n11 = BigInt(1);
var _2n9 = BigInt(2);
var _3n4 = BigInt(3);
var _4n3 = BigInt(4);
var _5n3 = BigInt(5);
var _8n4 = BigInt(8);
var _9n2 = BigInt(9);
var _16n2 = BigInt(16);
function mod2(a24, b11) {
  const result = a24 % b11;
  return result >= _0n11 ? result : b11 + result;
}
function pow3(num2, power, modulo) {
  if (modulo <= _0n11 || power < _0n11)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n11)
    return _0n11;
  let res = _1n11;
  while (power > _0n11) {
    if (power & _1n11)
      res = res * num2 % modulo;
    num2 = num2 * num2 % modulo;
    power >>= _1n11;
  }
  return res;
}
function pow22(x10, power, modulo) {
  let res = x10;
  while (power-- > _0n11) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert2(number2, modulo) {
  if (number2 === _0n11 || modulo <= _0n11) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a24 = mod2(number2, modulo);
  let b11 = modulo;
  let x10 = _0n11, y12 = _1n11, u15 = _1n11, v8 = _0n11;
  while (a24 !== _0n11) {
    const q5 = b11 / a24;
    const r26 = b11 % a24;
    const m15 = x10 - u15 * q5;
    const n18 = y12 - v8 * q5;
    b11 = a24, a24 = r26, x10 = u15, y12 = v8, u15 = m15, v8 = n18;
  }
  const gcd2 = b11;
  if (gcd2 !== _1n11)
    throw new Error("invert: does not exist");
  return mod2(x10, modulo);
}
function tonelliShanks2(P7) {
  const legendreC = (P7 - _1n11) / _2n9;
  let Q4, S8, Z5;
  for (Q4 = P7 - _1n11, S8 = 0; Q4 % _2n9 === _0n11; Q4 /= _2n9, S8++)
    ;
  for (Z5 = _2n9; Z5 < P7 && pow3(Z5, legendreC, P7) !== P7 - _1n11; Z5++)
    ;
  if (S8 === 1) {
    const p1div4 = (P7 + _1n11) / _4n3;
    return function tonelliFast(Fp4, n18) {
      const root = Fp4.pow(n18, p1div4);
      if (!Fp4.eql(Fp4.sqr(root), n18))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q4 + _1n11) / _2n9;
  return function tonelliSlow(Fp4, n18) {
    if (Fp4.pow(n18, legendreC) === Fp4.neg(Fp4.ONE))
      throw new Error("Cannot find square root");
    let r26 = S8;
    let g10 = Fp4.pow(Fp4.mul(Fp4.ONE, Z5), Q4);
    let x10 = Fp4.pow(n18, Q1div2);
    let b11 = Fp4.pow(n18, Q4);
    while (!Fp4.eql(b11, Fp4.ONE)) {
      if (Fp4.eql(b11, Fp4.ZERO))
        return Fp4.ZERO;
      let m15 = 1;
      for (let t210 = Fp4.sqr(b11); m15 < r26; m15++) {
        if (Fp4.eql(t210, Fp4.ONE))
          break;
        t210 = Fp4.sqr(t210);
      }
      const ge3 = Fp4.pow(g10, _1n11 << BigInt(r26 - m15 - 1));
      g10 = Fp4.sqr(ge3);
      x10 = Fp4.mul(x10, ge3);
      b11 = Fp4.mul(b11, g10);
      r26 = m15;
    }
    return x10;
  };
}
function FpSqrt2(P7) {
  if (P7 % _4n3 === _3n4) {
    const p1div4 = (P7 + _1n11) / _4n3;
    return function sqrt3mod4(Fp4, n18) {
      const root = Fp4.pow(n18, p1div4);
      if (!Fp4.eql(Fp4.sqr(root), n18))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P7 % _8n4 === _5n3) {
    const c1 = (P7 - _5n3) / _8n4;
    return function sqrt5mod8(Fp4, n18) {
      const n22 = Fp4.mul(n18, _2n9);
      const v8 = Fp4.pow(n22, c1);
      const nv = Fp4.mul(n18, v8);
      const i47 = Fp4.mul(Fp4.mul(nv, _2n9), v8);
      const root = Fp4.mul(nv, Fp4.sub(i47, Fp4.ONE));
      if (!Fp4.eql(Fp4.sqr(root), n18))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P7 % _16n2 === _9n2) {
  }
  return tonelliShanks2(P7);
}
var FIELD_FIELDS2 = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];
function validateField2(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS2.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject2(field, opts);
}
function FpPow2(f16, num2, power) {
  if (power < _0n11)
    throw new Error("Expected power > 0");
  if (power === _0n11)
    return f16.ONE;
  if (power === _1n11)
    return num2;
  let p13 = f16.ONE;
  let d20 = num2;
  while (power > _0n11) {
    if (power & _1n11)
      p13 = f16.mul(p13, d20);
    d20 = f16.sqr(d20);
    power >>= _1n11;
  }
  return p13;
}
function FpInvertBatch2(f16, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num2, i47) => {
    if (f16.is0(num2))
      return acc;
    tmp[i47] = acc;
    return f16.mul(acc, num2);
  }, f16.ONE);
  const inverted = f16.inv(lastMultiplied);
  nums.reduceRight((acc, num2, i47) => {
    if (f16.is0(num2))
      return acc;
    tmp[i47] = f16.mul(acc, tmp[i47]);
    return f16.mul(acc, num2);
  }, inverted);
  return tmp;
}
function nLength2(n18, nBitLength) {
  const _nBitLength = nBitLength !== void 0 ? nBitLength : n18.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field2(ORDER, bitLen3, isLE2 = false, redef = {}) {
  if (ORDER <= _0n11)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength2(ORDER, bitLen3);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt2(ORDER);
  const f16 = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask2(BITS),
    ZERO: _0n11,
    ONE: _1n11,
    create: (num2) => mod2(num2, ORDER),
    isValid: (num2) => {
      if (typeof num2 !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num2}`);
      return _0n11 <= num2 && num2 < ORDER;
    },
    is0: (num2) => num2 === _0n11,
    isOdd: (num2) => (num2 & _1n11) === _1n11,
    neg: (num2) => mod2(-num2, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num2) => mod2(num2 * num2, ORDER),
    add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
    pow: (num2, power) => FpPow2(f16, num2, power),
    div: (lhs, rhs) => mod2(lhs * invert2(rhs, ORDER), ORDER),
    // Same as above, but doesn't normalize
    sqrN: (num2) => num2 * num2,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num2) => invert2(num2, ORDER),
    sqrt: redef.sqrt || ((n18) => sqrtP(f16, n18)),
    invertBatch: (lst) => FpInvertBatch2(f16, lst),
    // TODO: do we really need constant cmov?
    // We don't have const-time bigints anyway, so probably will be not very useful
    cmov: (a24, b11, c14) => c14 ? b11 : a24,
    toBytes: (num2) => isLE2 ? numberToBytesLE2(num2, BYTES) : numberToBytesBE2(num2, BYTES),
    fromBytes: (bytes2) => {
      if (bytes2.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes2.length}`);
      return isLE2 ? bytesToNumberLE2(bytes2) : bytesToNumberBE2(bytes2);
    }
  });
  return Object.freeze(f16);
}
function getFieldBytesLength2(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength = fieldOrder.toString(2).length;
  return Math.ceil(bitLength / 8);
}
function getMinHashLength2(fieldOrder) {
  const length = getFieldBytesLength2(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField2(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength2(fieldOrder);
  const minLen = getMinHashLength2(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num2 = isLE2 ? bytesToNumberBE2(key) : bytesToNumberLE2(key);
  const reduced = mod2(num2, fieldOrder - _1n11) + _1n11;
  return isLE2 ? numberToBytesLE2(reduced, fieldLen) : numberToBytesBE2(reduced, fieldLen);
}

// node_modules/@scure/bip32/node_modules/@noble/curves/esm/abstract/curve.js
var _0n12 = BigInt(0);
var _1n12 = BigInt(1);
function wNAF2(c14, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W9) => {
    const windows = Math.ceil(bits / W9) + 1;
    const windowSize = 2 ** (W9 - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    // non-const time multiplication ladder
    unsafeLadder(elm, n18) {
      let p13 = c14.ZERO;
      let d20 = elm;
      while (n18 > _0n12) {
        if (n18 & _1n12)
          p13 = p13.add(d20);
        d20 = d20.double();
        n18 >>= _1n12;
      }
      return p13;
    },
    /**
     * Creates a wNAF precomputation window. Used for caching.
     * Default window size is set by `utils.precompute()` and is equal to 8.
     * Number of precomputed points depends on the curve size:
     * 2^(𝑊−1) * (Math.ceil(𝑛 / 𝑊) + 1), where:
     * - 𝑊 is the window size
     * - 𝑛 is the bitlength of the curve order.
     * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
     * @returns precomputed point tables flattened to a single array
     */
    precomputeWindow(elm, W9) {
      const { windows, windowSize } = opts(W9);
      const points = [];
      let p13 = elm;
      let base = p13;
      for (let window2 = 0; window2 < windows; window2++) {
        base = p13;
        points.push(base);
        for (let i47 = 1; i47 < windowSize; i47++) {
          base = base.add(p13);
          points.push(base);
        }
        p13 = base.double();
      }
      return points;
    },
    /**
     * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
     * @param W window size
     * @param precomputes precomputed tables
     * @param n scalar (we don't check here, but should be less than curve order)
     * @returns real and fake (for const-time) points
     */
    wNAF(W9, precomputes, n18) {
      const { windows, windowSize } = opts(W9);
      let p13 = c14.ZERO;
      let f16 = c14.BASE;
      const mask = BigInt(2 ** W9 - 1);
      const maxNumber = 2 ** W9;
      const shiftBy = BigInt(W9);
      for (let window2 = 0; window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n18 & mask);
        n18 >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n18 += _1n12;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f16 = f16.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p13 = p13.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p: p13, f: f16 };
    },
    wNAFCached(P7, precomputesMap, n18, transform) {
      const W9 = P7._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P7);
      if (!comp) {
        comp = this.precomputeWindow(P7, W9);
        if (W9 !== 1) {
          precomputesMap.set(P7, transform(comp));
        }
      }
      return this.wNAF(W9, comp, n18);
    }
  };
}
function validateBasic2(curve) {
  validateField2(curve.Fp);
  validateObject2(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength2(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}

// node_modules/@scure/bip32/node_modules/@noble/curves/esm/abstract/weierstrass.js
function validatePointOpts2(curve) {
  const opts = validateBasic2(curve);
  validateObject2(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp: Fp4, a: a24 } = opts;
  if (endo) {
    if (!Fp4.eql(a24, Fp4.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
}
var { bytesToNumberBE: b2n2, hexToBytes: h2b2 } = utils_exports2;
var DER2 = {
  // asn.1 DER encoding utils
  Err: class DERErr2 extends Error {
    constructor(m15 = "") {
      super(m15);
    }
  },
  _parseInt(data) {
    const { Err: E10 } = DER2;
    if (data.length < 2 || data[0] !== 2)
      throw new E10("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E10("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E10("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E10("Invalid signature integer: unnecessary leading zero");
    return { d: b2n2(res), l: data.subarray(len + 2) };
  },
  toSig(hex2) {
    const { Err: E10 } = DER2;
    const data = typeof hex2 === "string" ? h2b2(hex2) : hex2;
    abytes2(data);
    let l19 = data.length;
    if (l19 < 2 || data[0] != 48)
      throw new E10("Invalid signature tag");
    if (data[1] !== l19 - 2)
      throw new E10("Invalid signature: incorrect length");
    const { d: r26, l: sBytes } = DER2._parseInt(data.subarray(2));
    const { d: s12, l: rBytesLeft } = DER2._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E10("Invalid signature: left bytes after parsing");
    return { r: r26, s: s12 };
  },
  hexFromSig(sig) {
    const slice = (s13) => Number.parseInt(s13[0], 16) & 8 ? "00" + s13 : s13;
    const h17 = (num2) => {
      const hex2 = num2.toString(16);
      return hex2.length & 1 ? `0${hex2}` : hex2;
    };
    const s12 = slice(h17(sig.s));
    const r26 = slice(h17(sig.r));
    const shl = s12.length / 2;
    const rhl = r26.length / 2;
    const sl = h17(shl);
    const rl = h17(rhl);
    return `30${h17(rhl + shl + 4)}02${rl}${r26}02${sl}${s12}`;
  }
};
var _0n13 = BigInt(0);
var _1n13 = BigInt(1);
var _2n10 = BigInt(2);
var _3n5 = BigInt(3);
var _4n4 = BigInt(4);
function weierstrassPoints2(opts) {
  const CURVE = validatePointOpts2(opts);
  const { Fp: Fp4 } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a24 = point.toAffine();
    return concatBytes3(Uint8Array.from([4]), Fp4.toBytes(a24.x), Fp4.toBytes(a24.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes2) => {
    const tail = bytes2.subarray(1);
    const x10 = Fp4.fromBytes(tail.subarray(0, Fp4.BYTES));
    const y12 = Fp4.fromBytes(tail.subarray(Fp4.BYTES, 2 * Fp4.BYTES));
    return { x: x10, y: y12 };
  });
  function weierstrassEquation(x10) {
    const { a: a24, b: b11 } = CURVE;
    const x22 = Fp4.sqr(x10);
    const x32 = Fp4.mul(x22, x10);
    return Fp4.add(Fp4.add(x32, Fp4.mul(x10, a24)), b11);
  }
  if (!Fp4.eql(Fp4.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num2) {
    return typeof num2 === "bigint" && _0n13 < num2 && num2 < CURVE.n;
  }
  function assertGE(num2) {
    if (!isWithinCurveOrder(num2))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n18 } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes4(key))
        key = bytesToHex3(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num2;
    try {
      num2 = typeof key === "bigint" ? key : bytesToNumberBE2(ensureBytes2("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num2 = mod2(num2, n18);
    assertGE(num2);
    return num2;
  }
  const pointPrecomputes2 = /* @__PURE__ */ new Map();
  function assertPrjPoint(other) {
    if (!(other instanceof Point4))
      throw new Error("ProjectivePoint expected");
  }
  class Point4 {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp4.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp4.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp4.isValid(pz))
        throw new Error("z required");
    }
    // Does not validate if the point is on-curve.
    // Use fromHex instead, or call assertValidity() later.
    static fromAffine(p13) {
      const { x: x10, y: y12 } = p13 || {};
      if (!p13 || !Fp4.isValid(x10) || !Fp4.isValid(y12))
        throw new Error("invalid affine point");
      if (p13 instanceof Point4)
        throw new Error("projective point not allowed");
      const is0 = (i47) => Fp4.eql(i47, Fp4.ZERO);
      if (is0(x10) && is0(y12))
        return Point4.ZERO;
      return new Point4(x10, y12, Fp4.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    /**
     * Takes a bunch of Projective Points but executes only one
     * inversion on all of them. Inversion is very slow operation,
     * so this improves performance massively.
     * Optimization: converts a list of projective points to a list of identical points with Z=1.
     */
    static normalizeZ(points) {
      const toInv = Fp4.invertBatch(points.map((p13) => p13.pz));
      return points.map((p13, i47) => p13.toAffine(toInv[i47])).map(Point4.fromAffine);
    }
    /**
     * Converts hash string or Uint8Array to Point.
     * @param hex short/long ECDSA hex
     */
    static fromHex(hex2) {
      const P7 = Point4.fromAffine(fromBytes(ensureBytes2("pointHex", hex2)));
      P7.assertValidity();
      return P7;
    }
    // Multiplies generator point by privateKey.
    static fromPrivateKey(privateKey) {
      return Point4.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    // "Private method", don't use it directly
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes2.delete(this);
    }
    // A point on curve is valid if it conforms to equation.
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp4.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x: x10, y: y12 } = this.toAffine();
      if (!Fp4.isValid(x10) || !Fp4.isValid(y12))
        throw new Error("bad point: x or y not FE");
      const left = Fp4.sqr(y12);
      const right = weierstrassEquation(x10);
      if (!Fp4.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y: y12 } = this.toAffine();
      if (Fp4.isOdd)
        return !Fp4.isOdd(y12);
      throw new Error("Field doesn't support isOdd");
    }
    /**
     * Compare one point to another.
     */
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      const U1 = Fp4.eql(Fp4.mul(X1, Z22), Fp4.mul(X22, Z1));
      const U22 = Fp4.eql(Fp4.mul(Y1, Z22), Fp4.mul(Y22, Z1));
      return U1 && U22;
    }
    /**
     * Flips point to one corresponding to (x, -y) in Affine coordinates.
     */
    negate() {
      return new Point4(this.px, Fp4.neg(this.py), this.pz);
    }
    // Renes-Costello-Batina exception-free doubling formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 3
    // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
    double() {
      const { a: a24, b: b11 } = CURVE;
      const b32 = Fp4.mul(b11, _3n5);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let X32 = Fp4.ZERO, Y32 = Fp4.ZERO, Z32 = Fp4.ZERO;
      let t0 = Fp4.mul(X1, X1);
      let t1 = Fp4.mul(Y1, Y1);
      let t210 = Fp4.mul(Z1, Z1);
      let t32 = Fp4.mul(X1, Y1);
      t32 = Fp4.add(t32, t32);
      Z32 = Fp4.mul(X1, Z1);
      Z32 = Fp4.add(Z32, Z32);
      X32 = Fp4.mul(a24, Z32);
      Y32 = Fp4.mul(b32, t210);
      Y32 = Fp4.add(X32, Y32);
      X32 = Fp4.sub(t1, Y32);
      Y32 = Fp4.add(t1, Y32);
      Y32 = Fp4.mul(X32, Y32);
      X32 = Fp4.mul(t32, X32);
      Z32 = Fp4.mul(b32, Z32);
      t210 = Fp4.mul(a24, t210);
      t32 = Fp4.sub(t0, t210);
      t32 = Fp4.mul(a24, t32);
      t32 = Fp4.add(t32, Z32);
      Z32 = Fp4.add(t0, t0);
      t0 = Fp4.add(Z32, t0);
      t0 = Fp4.add(t0, t210);
      t0 = Fp4.mul(t0, t32);
      Y32 = Fp4.add(Y32, t0);
      t210 = Fp4.mul(Y1, Z1);
      t210 = Fp4.add(t210, t210);
      t0 = Fp4.mul(t210, t32);
      X32 = Fp4.sub(X32, t0);
      Z32 = Fp4.mul(t210, t1);
      Z32 = Fp4.add(Z32, Z32);
      Z32 = Fp4.add(Z32, Z32);
      return new Point4(X32, Y32, Z32);
    }
    // Renes-Costello-Batina exception-free addition formula.
    // There is 30% faster Jacobian formula, but it is not complete.
    // https://eprint.iacr.org/2015/1060, algorithm 1
    // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X22, py: Y22, pz: Z22 } = other;
      let X32 = Fp4.ZERO, Y32 = Fp4.ZERO, Z32 = Fp4.ZERO;
      const a24 = CURVE.a;
      const b32 = Fp4.mul(CURVE.b, _3n5);
      let t0 = Fp4.mul(X1, X22);
      let t1 = Fp4.mul(Y1, Y22);
      let t210 = Fp4.mul(Z1, Z22);
      let t32 = Fp4.add(X1, Y1);
      let t42 = Fp4.add(X22, Y22);
      t32 = Fp4.mul(t32, t42);
      t42 = Fp4.add(t0, t1);
      t32 = Fp4.sub(t32, t42);
      t42 = Fp4.add(X1, Z1);
      let t52 = Fp4.add(X22, Z22);
      t42 = Fp4.mul(t42, t52);
      t52 = Fp4.add(t0, t210);
      t42 = Fp4.sub(t42, t52);
      t52 = Fp4.add(Y1, Z1);
      X32 = Fp4.add(Y22, Z22);
      t52 = Fp4.mul(t52, X32);
      X32 = Fp4.add(t1, t210);
      t52 = Fp4.sub(t52, X32);
      Z32 = Fp4.mul(a24, t42);
      X32 = Fp4.mul(b32, t210);
      Z32 = Fp4.add(X32, Z32);
      X32 = Fp4.sub(t1, Z32);
      Z32 = Fp4.add(t1, Z32);
      Y32 = Fp4.mul(X32, Z32);
      t1 = Fp4.add(t0, t0);
      t1 = Fp4.add(t1, t0);
      t210 = Fp4.mul(a24, t210);
      t42 = Fp4.mul(b32, t42);
      t1 = Fp4.add(t1, t210);
      t210 = Fp4.sub(t0, t210);
      t210 = Fp4.mul(a24, t210);
      t42 = Fp4.add(t42, t210);
      t0 = Fp4.mul(t1, t42);
      Y32 = Fp4.add(Y32, t0);
      t0 = Fp4.mul(t52, t42);
      X32 = Fp4.mul(t32, X32);
      X32 = Fp4.sub(X32, t0);
      t0 = Fp4.mul(t32, t1);
      Z32 = Fp4.mul(t52, Z32);
      Z32 = Fp4.add(Z32, t0);
      return new Point4(X32, Y32, Z32);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point4.ZERO);
    }
    wNAF(n18) {
      return wnaf.wNAFCached(this, pointPrecomputes2, n18, (comp) => {
        const toInv = Fp4.invertBatch(comp.map((p13) => p13.pz));
        return comp.map((p13, i47) => p13.toAffine(toInv[i47])).map(Point4.fromAffine);
      });
    }
    /**
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about
     * an exposed private key e.g. sig verification, which works over *public* keys.
     */
    multiplyUnsafe(n18) {
      const I6 = Point4.ZERO;
      if (n18 === _0n13)
        return I6;
      assertGE(n18);
      if (n18 === _1n13)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n18);
      let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n18);
      let k1p = I6;
      let k2p = I6;
      let d20 = this;
      while (k1 > _0n13 || k22 > _0n13) {
        if (k1 & _1n13)
          k1p = k1p.add(d20);
        if (k22 & _1n13)
          k2p = k2p.add(d20);
        d20 = d20.double();
        k1 >>= _1n13;
        k22 >>= _1n13;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point4(Fp4.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    /**
     * Constant time multiplication.
     * Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available.
     * Uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    multiply(scalar) {
      assertGE(scalar);
      let n18 = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n18);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k22);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point4(Fp4.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p: p13, f: f16 } = this.wNAF(n18);
        point = p13;
        fake = f16;
      }
      return Point4.normalizeZ([point, fake])[0];
    }
    /**
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster.
     * The trick could be useful if both P and Q are not G (not in our case).
     * @returns non-zero affine point
     */
    multiplyAndAddUnsafe(Q4, a24, b11) {
      const G7 = Point4.BASE;
      const mul = (P7, a25) => a25 === _0n13 || a25 === _1n13 || !P7.equals(G7) ? P7.multiplyUnsafe(a25) : P7.multiply(a25);
      const sum = mul(this, a24).add(mul(Q4, b11));
      return sum.is0() ? void 0 : sum;
    }
    // Converts Projective point to affine (x, y) coordinates.
    // Can accept precomputed Z^-1 - for example, from invertBatch.
    // (x, y, z) ∋ (x=x/z, y=y/z)
    toAffine(iz) {
      const { px: x10, py: y12, pz: z8 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp4.ONE : Fp4.inv(z8);
      const ax = Fp4.mul(x10, iz);
      const ay = Fp4.mul(y12, iz);
      const zz = Fp4.mul(z8, iz);
      if (is0)
        return { x: Fp4.ZERO, y: Fp4.ZERO };
      if (!Fp4.eql(zz, Fp4.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n13)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point4, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n13)
        return this;
      if (clearCofactor)
        return clearCofactor(Point4, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point4, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex3(this.toRawBytes(isCompressed));
    }
  }
  Point4.BASE = new Point4(CURVE.Gx, CURVE.Gy, Fp4.ONE);
  Point4.ZERO = new Point4(Fp4.ZERO, Fp4.ONE, Fp4.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF2(Point4, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point4,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
function validateOpts4(curve) {
  const opts = validateBasic2(curve);
  validateObject2(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
}
function weierstrass2(curveDef) {
  const CURVE = validateOpts4(curveDef);
  const { Fp: Fp4, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp4.BYTES + 1;
  const uncompressedLen = 2 * Fp4.BYTES + 1;
  function isValidFieldElement(num2) {
    return _0n13 < num2 && num2 < Fp4.ORDER;
  }
  function modN3(a24) {
    return mod2(a24, CURVE_ORDER);
  }
  function invN(a24) {
    return invert2(a24, CURVE_ORDER);
  }
  const { ProjectivePoint: Point4, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints2({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a24 = point.toAffine();
      const x10 = Fp4.toBytes(a24.x);
      const cat = concatBytes3;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x10);
      } else {
        return cat(Uint8Array.from([4]), x10, Fp4.toBytes(a24.y));
      }
    },
    fromBytes(bytes2) {
      const len = bytes2.length;
      const head = bytes2[0];
      const tail = bytes2.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x10 = bytesToNumberBE2(tail);
        if (!isValidFieldElement(x10))
          throw new Error("Point is not on curve");
        const y22 = weierstrassEquation(x10);
        let y12;
        try {
          y12 = Fp4.sqrt(y22);
        } catch (sqrtError) {
          const suffix = sqrtError instanceof Error ? ": " + sqrtError.message : "";
          throw new Error("Point is not on curve" + suffix);
        }
        const isYOdd = (y12 & _1n13) === _1n13;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y12 = Fp4.neg(y12);
        return { x: x10, y: y12 };
      } else if (len === uncompressedLen && head === 4) {
        const x10 = Fp4.fromBytes(tail.subarray(0, Fp4.BYTES));
        const y12 = Fp4.fromBytes(tail.subarray(Fp4.BYTES, 2 * Fp4.BYTES));
        return { x: x10, y: y12 };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num2) => bytesToHex3(numberToBytesBE2(num2, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n13;
    return number2 > HALF;
  }
  function normalizeS(s12) {
    return isBiggerThanHalfOrder(s12) ? modN3(-s12) : s12;
  }
  const slcNum = (b11, from, to) => bytesToNumberBE2(b11.slice(from, to));
  class Signature {
    constructor(r26, s12, recovery) {
      this.r = r26;
      this.s = s12;
      this.recovery = recovery;
      this.assertValidity();
    }
    // pair (bytes of r, bytes of s)
    static fromCompact(hex2) {
      const l19 = CURVE.nByteLength;
      hex2 = ensureBytes2("compactSignature", hex2, l19 * 2);
      return new Signature(slcNum(hex2, 0, l19), slcNum(hex2, l19, 2 * l19));
    }
    // DER encoded ECDSA signature
    // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
    static fromDER(hex2) {
      const { r: r26, s: s12 } = DER2.toSig(ensureBytes2("DER", hex2));
      return new Signature(r26, s12);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r: r26, s: s12, recovery: rec } = this;
      const h17 = bits2int_modN(ensureBytes2("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r26 + CURVE.n : r26;
      if (radj >= Fp4.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R7 = Point4.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN3(-h17 * ir);
      const u22 = modN3(s12 * ir);
      const Q4 = Point4.BASE.multiplyAndAddUnsafe(R7, u1, u22);
      if (!Q4)
        throw new Error("point at infinify");
      Q4.assertValidity();
      return Q4;
    }
    // Signatures should be low-s, to prevent malleability.
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN3(-this.s), this.recovery) : this;
    }
    // DER-encoded
    toDERRawBytes() {
      return hexToBytes3(this.toDERHex());
    }
    toDERHex() {
      return DER2.hexFromSig({ r: this.r, s: this.s });
    }
    // padded bytes of r, then padded bytes of s
    toCompactRawBytes() {
      return hexToBytes3(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils2 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    /**
     * Produces cryptographically secure private key from random of size
     * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
     */
    randomPrivateKey: () => {
      const length = getMinHashLength2(CURVE.n);
      return mapHashToField2(CURVE.randomBytes(length), CURVE.n);
    },
    /**
     * Creates precompute table for an arbitrary EC point. Makes point "cached".
     * Allows to massively speed-up `point.multiply(scalar)`.
     * @returns cached point
     * @example
     * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
     * fast.multiply(privKey); // much faster ECDH now
     */
    precompute(windowSize = 8, point = Point4.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point4.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes4(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point4)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b11 = Point4.fromHex(publicB);
    return b11.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes2) {
    const num2 = bytesToNumberBE2(bytes2);
    const delta = bytes2.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num2 >> BigInt(delta) : num2;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes2) {
    return modN3(bits2int(bytes2));
  };
  const ORDER_MASK = bitMask2(CURVE.nBitLength);
  function int2octets(num2) {
    if (typeof num2 !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n13 <= num2 && num2 < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE2(num2, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k6) => k6 in opts))
      throw new Error("sign() legacy options not supported");
    const { hash: hash2, randomBytes: randomBytes2 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes2("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes2("prehashed msgHash", hash2(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d20 = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d20), int2octets(h1int)];
    if (ent != null && ent !== false) {
      const e5 = ent === true ? randomBytes2(Fp4.BYTES) : ent;
      seedArgs.push(ensureBytes2("extraEntropy", e5));
    }
    const seed = concatBytes3(...seedArgs);
    const m15 = h1int;
    function k2sig(kBytes) {
      const k6 = bits2int(kBytes);
      if (!isWithinCurveOrder(k6))
        return;
      const ik = invN(k6);
      const q5 = Point4.BASE.multiply(k6).toAffine();
      const r26 = modN3(q5.x);
      if (r26 === _0n13)
        return;
      const s12 = modN3(ik * modN3(m15 + r26 * d20));
      if (s12 === _0n13)
        return;
      let recovery = (q5.x === r26 ? 0 : 2) | Number(q5.y & _1n13);
      let normS = s12;
      if (lowS && isBiggerThanHalfOrder(s12)) {
        normS = normalizeS(s12);
        recovery ^= 1;
      }
      return new Signature(r26, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C8 = CURVE;
    const drbg = createHmacDrbg2(C8.hash.outputLen, C8.nByteLength, C8.hmac);
    return drbg(seed, k2sig);
  }
  Point4.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    var _a;
    const sg = signature;
    msgHash = ensureBytes2("msgHash", msgHash);
    publicKey = ensureBytes2("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = void 0;
    let P7;
    try {
      if (typeof sg === "string" || isBytes4(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER2.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r27, s: s13 } = sg;
        _sig = new Signature(r27, s13);
      } else {
        throw new Error("PARSE");
      }
      P7 = Point4.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r: r26, s: s12 } = _sig;
    const h17 = bits2int_modN(msgHash);
    const is = invN(s12);
    const u1 = modN3(h17 * is);
    const u22 = modN3(r26 * is);
    const R7 = (_a = Point4.BASE.multiplyAndAddUnsafe(P7, u1, u22)) == null ? void 0 : _a.toAffine();
    if (!R7)
      return false;
    const v8 = modN3(R7.x);
    return v8 === r26;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point4,
    Signature,
    utils: utils2
  };
}
function SWUFpSqrtRatio2(Fp4, Z5) {
  const q5 = Fp4.ORDER;
  let l19 = _0n13;
  for (let o26 = q5 - _1n13; o26 % _2n10 === _0n13; o26 /= _2n10)
    l19 += _1n13;
  const c1 = l19;
  const _2n_pow_c1_1 = _2n10 << c1 - _1n13 - _1n13;
  const _2n_pow_c1 = _2n_pow_c1_1 * _2n10;
  const c22 = (q5 - _1n13) / _2n_pow_c1;
  const c32 = (c22 - _1n13) / _2n10;
  const c42 = _2n_pow_c1 - _1n13;
  const c52 = _2n_pow_c1_1;
  const c62 = Fp4.pow(Z5, c22);
  const c72 = Fp4.pow(Z5, (c22 + _1n13) / _2n10);
  let sqrtRatio = (u15, v8) => {
    let tv1 = c62;
    let tv2 = Fp4.pow(v8, c42);
    let tv3 = Fp4.sqr(tv2);
    tv3 = Fp4.mul(tv3, v8);
    let tv5 = Fp4.mul(u15, tv3);
    tv5 = Fp4.pow(tv5, c32);
    tv5 = Fp4.mul(tv5, tv2);
    tv2 = Fp4.mul(tv5, v8);
    tv3 = Fp4.mul(tv5, u15);
    let tv4 = Fp4.mul(tv3, tv2);
    tv5 = Fp4.pow(tv4, c52);
    let isQR = Fp4.eql(tv5, Fp4.ONE);
    tv2 = Fp4.mul(tv3, c72);
    tv5 = Fp4.mul(tv4, tv1);
    tv3 = Fp4.cmov(tv2, tv3, isQR);
    tv4 = Fp4.cmov(tv5, tv4, isQR);
    for (let i47 = c1; i47 > _1n13; i47--) {
      let tv52 = i47 - _2n10;
      tv52 = _2n10 << tv52 - _1n13;
      let tvv5 = Fp4.pow(tv4, tv52);
      const e1 = Fp4.eql(tvv5, Fp4.ONE);
      tv2 = Fp4.mul(tv3, tv1);
      tv1 = Fp4.mul(tv1, tv1);
      tvv5 = Fp4.mul(tv4, tv1);
      tv3 = Fp4.cmov(tv2, tv3, e1);
      tv4 = Fp4.cmov(tvv5, tv4, e1);
    }
    return { isValid: isQR, value: tv3 };
  };
  if (Fp4.ORDER % _4n4 === _3n5) {
    const c14 = (Fp4.ORDER - _3n5) / _4n4;
    const c23 = Fp4.sqrt(Fp4.neg(Z5));
    sqrtRatio = (u15, v8) => {
      let tv1 = Fp4.sqr(v8);
      const tv2 = Fp4.mul(u15, v8);
      tv1 = Fp4.mul(tv1, tv2);
      let y1 = Fp4.pow(tv1, c14);
      y1 = Fp4.mul(y1, tv2);
      const y22 = Fp4.mul(y1, c23);
      const tv3 = Fp4.mul(Fp4.sqr(y1), v8);
      const isQR = Fp4.eql(tv3, u15);
      let y12 = Fp4.cmov(y22, y1, isQR);
      return { isValid: isQR, value: y12 };
    };
  }
  return sqrtRatio;
}
function mapToCurveSimpleSWU2(Fp4, opts) {
  validateField2(Fp4);
  if (!Fp4.isValid(opts.A) || !Fp4.isValid(opts.B) || !Fp4.isValid(opts.Z))
    throw new Error("mapToCurveSimpleSWU: invalid opts");
  const sqrtRatio = SWUFpSqrtRatio2(Fp4, opts.Z);
  if (!Fp4.isOdd)
    throw new Error("Fp.isOdd is not implemented!");
  return (u15) => {
    let tv1, tv2, tv3, tv4, tv5, tv6, x10, y12;
    tv1 = Fp4.sqr(u15);
    tv1 = Fp4.mul(tv1, opts.Z);
    tv2 = Fp4.sqr(tv1);
    tv2 = Fp4.add(tv2, tv1);
    tv3 = Fp4.add(tv2, Fp4.ONE);
    tv3 = Fp4.mul(tv3, opts.B);
    tv4 = Fp4.cmov(opts.Z, Fp4.neg(tv2), !Fp4.eql(tv2, Fp4.ZERO));
    tv4 = Fp4.mul(tv4, opts.A);
    tv2 = Fp4.sqr(tv3);
    tv6 = Fp4.sqr(tv4);
    tv5 = Fp4.mul(tv6, opts.A);
    tv2 = Fp4.add(tv2, tv5);
    tv2 = Fp4.mul(tv2, tv3);
    tv6 = Fp4.mul(tv6, tv4);
    tv5 = Fp4.mul(tv6, opts.B);
    tv2 = Fp4.add(tv2, tv5);
    x10 = Fp4.mul(tv1, tv3);
    const { isValid, value } = sqrtRatio(tv2, tv6);
    y12 = Fp4.mul(tv1, u15);
    y12 = Fp4.mul(y12, value);
    x10 = Fp4.cmov(x10, tv3, isValid);
    y12 = Fp4.cmov(y12, value, isValid);
    const e1 = Fp4.isOdd(u15) === Fp4.isOdd(y12);
    y12 = Fp4.cmov(Fp4.neg(y12), y12, e1);
    x10 = Fp4.div(x10, tv4);
    return { x: x10, y: y12 };
  };
}

// node_modules/@scure/bip32/node_modules/@noble/curves/esm/_shortw_utils.js
function getHash2(hash2) {
  return {
    hash: hash2,
    hmac: (key, ...msgs) => hmac(hash2, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve2(curveDef, defHash) {
  const create = (hash2) => weierstrass2({ ...curveDef, ...getHash2(hash2) });
  return Object.freeze({ ...create(defHash), create });
}

// node_modules/@scure/bip32/node_modules/@noble/curves/esm/abstract/hash-to-curve.js
var os2ip2 = bytesToNumberBE2;
function i2osp2(value, length) {
  if (value < 0 || value >= 1 << 8 * length) {
    throw new Error(`bad I2OSP call: value=${value} length=${length}`);
  }
  const res = Array.from({ length }).fill(0);
  for (let i47 = length - 1; i47 >= 0; i47--) {
    res[i47] = value & 255;
    value >>>= 8;
  }
  return new Uint8Array(res);
}
function strxor2(a24, b11) {
  const arr = new Uint8Array(a24.length);
  for (let i47 = 0; i47 < a24.length; i47++) {
    arr[i47] = a24[i47] ^ b11[i47];
  }
  return arr;
}
function anum2(item) {
  if (!Number.isSafeInteger(item))
    throw new Error("number expected");
}
function expand_message_xmd2(msg, DST, lenInBytes, H4) {
  abytes2(msg);
  abytes2(DST);
  anum2(lenInBytes);
  if (DST.length > 255)
    DST = H4(concatBytes3(utf8ToBytes3("H2C-OVERSIZE-DST-"), DST));
  const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H4;
  const ell = Math.ceil(lenInBytes / b_in_bytes);
  if (ell > 255)
    throw new Error("Invalid xmd length");
  const DST_prime = concatBytes3(DST, i2osp2(DST.length, 1));
  const Z_pad = i2osp2(0, r_in_bytes);
  const l_i_b_str = i2osp2(lenInBytes, 2);
  const b11 = new Array(ell);
  const b_0 = H4(concatBytes3(Z_pad, msg, l_i_b_str, i2osp2(0, 1), DST_prime));
  b11[0] = H4(concatBytes3(b_0, i2osp2(1, 1), DST_prime));
  for (let i47 = 1; i47 <= ell; i47++) {
    const args = [strxor2(b_0, b11[i47 - 1]), i2osp2(i47 + 1, 1), DST_prime];
    b11[i47] = H4(concatBytes3(...args));
  }
  const pseudo_random_bytes = concatBytes3(...b11);
  return pseudo_random_bytes.slice(0, lenInBytes);
}
function expand_message_xof2(msg, DST, lenInBytes, k6, H4) {
  abytes2(msg);
  abytes2(DST);
  anum2(lenInBytes);
  if (DST.length > 255) {
    const dkLen = Math.ceil(2 * k6 / 8);
    DST = H4.create({ dkLen }).update(utf8ToBytes3("H2C-OVERSIZE-DST-")).update(DST).digest();
  }
  if (lenInBytes > 65535 || DST.length > 255)
    throw new Error("expand_message_xof: invalid lenInBytes");
  return H4.create({ dkLen: lenInBytes }).update(msg).update(i2osp2(lenInBytes, 2)).update(DST).update(i2osp2(DST.length, 1)).digest();
}
function hash_to_field2(msg, count, options) {
  validateObject2(options, {
    DST: "stringOrUint8Array",
    p: "bigint",
    m: "isSafeInteger",
    k: "isSafeInteger",
    hash: "hash"
  });
  const { p: p13, k: k6, m: m15, hash: hash2, expand, DST: _DST } = options;
  abytes2(msg);
  anum2(count);
  const DST = typeof _DST === "string" ? utf8ToBytes3(_DST) : _DST;
  const log2p = p13.toString(2).length;
  const L8 = Math.ceil((log2p + k6) / 8);
  const len_in_bytes = count * m15 * L8;
  let prb;
  if (expand === "xmd") {
    prb = expand_message_xmd2(msg, DST, len_in_bytes, hash2);
  } else if (expand === "xof") {
    prb = expand_message_xof2(msg, DST, len_in_bytes, k6, hash2);
  } else if (expand === "_internal_pass") {
    prb = msg;
  } else {
    throw new Error('expand must be "xmd" or "xof"');
  }
  const u15 = new Array(count);
  for (let i47 = 0; i47 < count; i47++) {
    const e5 = new Array(m15);
    for (let j6 = 0; j6 < m15; j6++) {
      const elm_offset = L8 * (j6 + i47 * m15);
      const tv = prb.subarray(elm_offset, elm_offset + L8);
      e5[j6] = mod2(os2ip2(tv), p13);
    }
    u15[i47] = e5;
  }
  return u15;
}
function isogenyMap2(field, map) {
  const COEFF = map.map((i47) => Array.from(i47).reverse());
  return (x10, y12) => {
    const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i47) => field.add(field.mul(acc, x10), i47)));
    x10 = field.div(xNum, xDen);
    y12 = field.mul(y12, field.div(yNum, yDen));
    return { x: x10, y: y12 };
  };
}
function createHasher2(Point4, mapToCurve, def) {
  if (typeof mapToCurve !== "function")
    throw new Error("mapToCurve() must be defined");
  return {
    // Encodes byte string to elliptic curve.
    // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    hashToCurve(msg, options) {
      const u15 = hash_to_field2(msg, 2, { ...def, DST: def.DST, ...options });
      const u0 = Point4.fromAffine(mapToCurve(u15[0]));
      const u1 = Point4.fromAffine(mapToCurve(u15[1]));
      const P7 = u0.add(u1).clearCofactor();
      P7.assertValidity();
      return P7;
    },
    // Encodes byte string to elliptic curve.
    // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
    encodeToCurve(msg, options) {
      const u15 = hash_to_field2(msg, 1, { ...def, DST: def.encodeDST, ...options });
      const P7 = Point4.fromAffine(mapToCurve(u15[0])).clearCofactor();
      P7.assertValidity();
      return P7;
    },
    // Same as encodeToCurve, but without hash
    mapToCurve(scalars) {
      if (!Array.isArray(scalars))
        throw new Error("mapToCurve: expected array of bigints");
      for (const i47 of scalars)
        if (typeof i47 !== "bigint")
          throw new Error(`mapToCurve: expected array of bigints, got ${i47} in array`);
      const P7 = Point4.fromAffine(mapToCurve(scalars)).clearCofactor();
      P7.assertValidity();
      return P7;
    }
  };
}

// node_modules/@scure/bip32/node_modules/@noble/curves/esm/secp256k1.js
var secp256k1P2 = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n14 = BigInt(1);
var _2n11 = BigInt(2);
var divNearest2 = (a24, b11) => (a24 + b11 / _2n11) / b11;
function sqrtMod2(y12) {
  const P7 = secp256k1P2;
  const _3n6 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b22 = y12 * y12 * y12 % P7;
  const b32 = b22 * b22 * y12 % P7;
  const b62 = pow22(b32, _3n6, P7) * b32 % P7;
  const b92 = pow22(b62, _3n6, P7) * b32 % P7;
  const b11 = pow22(b92, _2n11, P7) * b22 % P7;
  const b222 = pow22(b11, _11n, P7) * b11 % P7;
  const b44 = pow22(b222, _22n, P7) * b222 % P7;
  const b88 = pow22(b44, _44n, P7) * b44 % P7;
  const b176 = pow22(b88, _88n, P7) * b88 % P7;
  const b220 = pow22(b176, _44n, P7) * b44 % P7;
  const b223 = pow22(b220, _3n6, P7) * b32 % P7;
  const t1 = pow22(b223, _23n, P7) * b222 % P7;
  const t210 = pow22(t1, _6n, P7) * b22 % P7;
  const root = pow22(t210, _2n11, P7);
  if (!Fp3.eql(Fp3.sqr(root), y12))
    throw new Error("Cannot find square root");
  return root;
}
var Fp3 = Field2(secp256k1P2, void 0, void 0, { sqrt: sqrtMod2 });
var secp256k12 = createCurve2({
  a: BigInt(0),
  // equation params: a, b
  b: BigInt(7),
  // Seem to be rigid: bitcointalk.org/index.php?topic=289795.msg3183975#msg3183975
  Fp: Fp3,
  // Field's prime: 2n**256n - 2n**32n - 2n**9n - 2n**8n - 2n**7n - 2n**6n - 2n**4n - 1n
  n: secp256k1N2,
  // Curve order, total count of valid points in the field
  // Base point (x, y) aka generator point
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  // Cofactor
  lowS: true,
  // Allow only low-S signatures by default in sign() and verify()
  /**
   * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
   * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
   * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
   * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
   */
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k6) => {
      const n18 = secp256k1N2;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n14 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a24 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b22 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest2(b22 * k6, n18);
      const c22 = divNearest2(-b1 * k6, n18);
      let k1 = mod2(k6 - c1 * a1 - c22 * a24, n18);
      let k22 = mod2(-c1 * b1 - c22 * b22, n18);
      const k1neg = k1 > POW_2_128;
      const k2neg = k22 > POW_2_128;
      if (k1neg)
        k1 = n18 - k1;
      if (k2neg)
        k22 = n18 - k22;
      if (k1 > POW_2_128 || k22 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k6);
      }
      return { k1neg, k1, k2neg, k2: k22 };
    }
  }
}, sha256);
var _0n14 = BigInt(0);
var fe = (x10) => typeof x10 === "bigint" && _0n14 < x10 && x10 < secp256k1P2;
var ge = (x10) => typeof x10 === "bigint" && _0n14 < x10 && x10 < secp256k1N2;
var TAGGED_HASH_PREFIXES2 = {};
function taggedHash2(tag, ...messages) {
  let tagP = TAGGED_HASH_PREFIXES2[tag];
  if (tagP === void 0) {
    const tagH = sha256(Uint8Array.from(tag, (c14) => c14.charCodeAt(0)));
    tagP = concatBytes3(tagH, tagH);
    TAGGED_HASH_PREFIXES2[tag] = tagP;
  }
  return sha256(concatBytes3(tagP, ...messages));
}
var pointToBytes2 = (point) => point.toRawBytes(true).slice(1);
var numTo32b2 = (n18) => numberToBytesBE2(n18, 32);
var modP2 = (x10) => mod2(x10, secp256k1P2);
var modN2 = (x10) => mod2(x10, secp256k1N2);
var Point2 = secp256k12.ProjectivePoint;
var GmulAdd2 = (Q4, a24, b11) => Point2.BASE.multiplyAndAddUnsafe(Q4, a24, b11);
function schnorrGetExtPubKey2(priv) {
  let d_ = secp256k12.utils.normPrivateKeyToScalar(priv);
  let p13 = Point2.fromPrivateKey(d_);
  const scalar = p13.hasEvenY() ? d_ : modN2(-d_);
  return { scalar, bytes: pointToBytes2(p13) };
}
function lift_x2(x10) {
  if (!fe(x10))
    throw new Error("bad x: need 0 < x < p");
  const xx = modP2(x10 * x10);
  const c14 = modP2(xx * x10 + BigInt(7));
  let y12 = sqrtMod2(c14);
  if (y12 % _2n11 !== _0n14)
    y12 = modP2(-y12);
  const p13 = new Point2(x10, y12, _1n14);
  p13.assertValidity();
  return p13;
}
function challenge2(...args) {
  return modN2(bytesToNumberBE2(taggedHash2("BIP0340/challenge", ...args)));
}
function schnorrGetPublicKey2(privateKey) {
  return schnorrGetExtPubKey2(privateKey).bytes;
}
function schnorrSign2(message, privateKey, auxRand = randomBytes(32)) {
  const m15 = ensureBytes2("message", message);
  const { bytes: px, scalar: d20 } = schnorrGetExtPubKey2(privateKey);
  const a24 = ensureBytes2("auxRand", auxRand, 32);
  const t30 = numTo32b2(d20 ^ bytesToNumberBE2(taggedHash2("BIP0340/aux", a24)));
  const rand = taggedHash2("BIP0340/nonce", t30, px, m15);
  const k_ = modN2(bytesToNumberBE2(rand));
  if (k_ === _0n14)
    throw new Error("sign failed: k is zero");
  const { bytes: rx, scalar: k6 } = schnorrGetExtPubKey2(k_);
  const e5 = challenge2(rx, px, m15);
  const sig = new Uint8Array(64);
  sig.set(rx, 0);
  sig.set(numTo32b2(modN2(k6 + e5 * d20)), 32);
  if (!schnorrVerify2(sig, m15, px))
    throw new Error("sign: Invalid signature produced");
  return sig;
}
function schnorrVerify2(signature, message, publicKey) {
  const sig = ensureBytes2("signature", signature, 64);
  const m15 = ensureBytes2("message", message);
  const pub = ensureBytes2("publicKey", publicKey, 32);
  try {
    const P7 = lift_x2(bytesToNumberBE2(pub));
    const r26 = bytesToNumberBE2(sig.subarray(0, 32));
    if (!fe(r26))
      return false;
    const s12 = bytesToNumberBE2(sig.subarray(32, 64));
    if (!ge(s12))
      return false;
    const e5 = challenge2(numTo32b2(r26), pointToBytes2(P7), m15);
    const R7 = GmulAdd2(P7, s12, modN2(-e5));
    if (!R7 || !R7.hasEvenY() || R7.toAffine().x !== r26)
      return false;
    return true;
  } catch (error) {
    return false;
  }
}
var schnorr2 = (() => ({
  getPublicKey: schnorrGetPublicKey2,
  sign: schnorrSign2,
  verify: schnorrVerify2,
  utils: {
    randomPrivateKey: secp256k12.utils.randomPrivateKey,
    lift_x: lift_x2,
    pointToBytes: pointToBytes2,
    numberToBytesBE: numberToBytesBE2,
    bytesToNumberBE: bytesToNumberBE2,
    taggedHash: taggedHash2,
    mod: mod2
  }
}))();
var isoMap2 = (() => isogenyMap2(Fp3, [
  // xNum
  [
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
    "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
    "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
    "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
  ],
  // xDen
  [
    "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
    "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
    "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
    "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
    "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
  ],
  // yDen
  [
    "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
    "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
    "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
    "0x0000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i47) => i47.map((j6) => BigInt(j6)))))();
var mapSWU2 = (() => mapToCurveSimpleSWU2(Fp3, {
  A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
  B: BigInt("1771"),
  Z: Fp3.create(BigInt("-11"))
}))();
var htf3 = (() => createHasher2(secp256k12.ProjectivePoint, (scalars) => {
  const { x: x10, y: y12 } = mapSWU2(Fp3.create(scalars[0]));
  return isoMap2(x10, y12);
}, {
  DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
  encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
  p: Fp3.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve3 = (() => htf3.hashToCurve)();
var encodeToCurve3 = (() => htf3.encodeToCurve)();

// node_modules/@scure/bip32/lib/esm/index.js
var Point3 = secp256k12.ProjectivePoint;
var base58check = createBase58check(sha256);
function bytesToNumber(bytes2) {
  return BigInt(`0x${bytesToHex(bytes2)}`);
}
function numberToBytes(num2) {
  return hexToBytes(num2.toString(16).padStart(64, "0"));
}
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
var HARDENED_OFFSET = 2147483648;
var hash160 = (data) => ripemd160(sha256(data));
var fromU32 = (data) => createView(data).getUint32(0, false);
var toU32 = (n18) => {
  if (!Number.isSafeInteger(n18) || n18 < 0 || n18 > 2 ** 32 - 1) {
    throw new Error(`Invalid number=${n18}. Should be from 0 to 2 ** 32 - 1`);
  }
  const buf = new Uint8Array(4);
  createView(buf).setUint32(0, n18, false);
  return buf;
};
var HDKey = class _HDKey {
  get fingerprint() {
    if (!this.pubHash) {
      throw new Error("No publicKey set!");
    }
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const priv = this.privateKey;
    if (!priv) {
      throw new Error("No private key");
    }
    return base58check.encode(this.serialize(this.versions.private, concatBytes(new Uint8Array([0]), priv)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) {
      throw new Error("No public key");
    }
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
    bytes(seed);
    if (8 * seed.length < 128 || 8 * seed.length > 512) {
      throw new Error(`HDKey: wrong seed length=${seed.length}. Should be between 128 and 512 bits; 256 bits is advised)`);
    }
    const I6 = hmac(sha512, MASTER_SECRET, seed);
    return new _HDKey({
      versions,
      chainCode: I6.slice(32),
      privateKey: I6.slice(0, 32)
    });
  }
  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
    const keyBuffer = base58check.decode(base58key);
    const keyView = createView(keyBuffer);
    const version = keyView.getUint32(0, false);
    const opt = {
      versions,
      depth: keyBuffer[4],
      parentFingerprint: keyView.getUint32(5, false),
      index: keyView.getUint32(9, false),
      chainCode: keyBuffer.slice(13, 45)
    };
    const key = keyBuffer.slice(45);
    const isPriv = key[0] === 0;
    if (version !== versions[isPriv ? "private" : "public"]) {
      throw new Error("Version mismatch");
    }
    if (isPriv) {
      return new _HDKey({ ...opt, privateKey: key.slice(1) });
    } else {
      return new _HDKey({ ...opt, publicKey: key });
    }
  }
  static fromJSON(json) {
    return _HDKey.fromExtendedKey(json.xpriv);
  }
  constructor(opt) {
    this.depth = 0;
    this.index = 0;
    this.chainCode = null;
    this.parentFingerprint = 0;
    if (!opt || typeof opt !== "object") {
      throw new Error("HDKey.constructor must not be called directly");
    }
    this.versions = opt.versions || BITCOIN_VERSIONS;
    this.depth = opt.depth || 0;
    this.chainCode = opt.chainCode || null;
    this.index = opt.index || 0;
    this.parentFingerprint = opt.parentFingerprint || 0;
    if (!this.depth) {
      if (this.parentFingerprint || this.index) {
        throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
    }
    if (opt.publicKey && opt.privateKey) {
      throw new Error("HDKey: publicKey and privateKey at same time.");
    }
    if (opt.privateKey) {
      if (!secp256k12.utils.isValidPrivateKey(opt.privateKey)) {
        throw new Error("Invalid private key");
      }
      this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
      this.privKeyBytes = numberToBytes(this.privKey);
      this.pubKey = secp256k12.getPublicKey(opt.privateKey, true);
    } else if (opt.publicKey) {
      this.pubKey = Point3.fromHex(opt.publicKey).toRawBytes(true);
    } else {
      throw new Error("HDKey: no public or private key provided");
    }
    this.pubHash = hash160(this.pubKey);
  }
  derive(path) {
    if (!/^[mM]'?/.test(path)) {
      throw new Error('Path must start with "m" or "M"');
    }
    if (/^[mM]'?$/.test(path)) {
      return this;
    }
    const parts = path.replace(/^[mM]'?\//, "").split("/");
    let child = this;
    for (const c14 of parts) {
      const m15 = /^(\d+)('?)$/.exec(c14);
      const m1 = m15 && m15[1];
      if (!m15 || m15.length !== 3 || typeof m1 !== "string") {
        throw new Error(`Invalid child index: ${c14}`);
      }
      let idx = +m1;
      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
        throw new Error("Invalid index");
      }
      if (m15[2] === "'") {
        idx += HARDENED_OFFSET;
      }
      child = child.deriveChild(idx);
    }
    return child;
  }
  deriveChild(index) {
    if (!this.pubKey || !this.chainCode) {
      throw new Error("No publicKey or chainCode set");
    }
    let data = toU32(index);
    if (index >= HARDENED_OFFSET) {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("Could not derive hardened child key");
      }
      data = concatBytes(new Uint8Array([0]), priv, data);
    } else {
      data = concatBytes(this.pubKey, data);
    }
    const I6 = hmac(sha512, this.chainCode, data);
    const childTweak = bytesToNumber(I6.slice(0, 32));
    const chainCode = I6.slice(32);
    if (!secp256k12.utils.isValidPrivateKey(childTweak)) {
      throw new Error("Tweak bigger than curve order");
    }
    const opt = {
      versions: this.versions,
      chainCode,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index
    };
    try {
      if (this.privateKey) {
        const added = mod2(this.privKey + childTweak, secp256k12.CURVE.n);
        if (!secp256k12.utils.isValidPrivateKey(added)) {
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        }
        opt.privateKey = added;
      } else {
        const added = Point3.fromHex(this.pubKey).add(Point3.fromPrivateKey(childTweak));
        if (added.equals(Point3.ZERO)) {
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        }
        opt.publicKey = added.toRawBytes(true);
      }
      return new _HDKey(opt);
    } catch (err) {
      return this.deriveChild(index + 1);
    }
  }
  sign(hash2) {
    if (!this.privateKey) {
      throw new Error("No privateKey set!");
    }
    bytes(hash2, 32);
    return secp256k12.sign(hash2, this.privKey).toCompactRawBytes();
  }
  verify(hash2, signature) {
    bytes(hash2, 32);
    bytes(signature, 64);
    if (!this.publicKey) {
      throw new Error("No publicKey set!");
    }
    let sig;
    try {
      sig = secp256k12.Signature.fromCompact(signature);
    } catch (error) {
      return false;
    }
    return secp256k12.verify(sig, hash2, this.publicKey);
  }
  wipePrivateData() {
    this.privKey = void 0;
    if (this.privKeyBytes) {
      this.privKeyBytes.fill(0);
      this.privKeyBytes = void 0;
    }
    return this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(version, key) {
    if (!this.chainCode) {
      throw new Error("No chainCode set");
    }
    bytes(key, 33);
    return concatBytes(toU32(version), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-O4BBULNE.mjs
var i32 = class i33 extends t18 {
  constructor(e5) {
    super();
    let t30 = i.fromHexInput(e5);
    if (t30.toUint8Array().length !== i33.LENGTH) throw new Error(`PublicKey length should be ${i33.LENGTH}`);
    this.key = t30;
  }
  verifySignature(e5) {
    let { message: t30, signature: n18 } = e5, y12 = o11(t30), l19 = i.fromHexInput(y12).toUint8Array(), A15 = sha3_256(l19), x10 = n18.toUint8Array();
    return secp256k1.verify(x10, A15, this.key.toUint8Array(), { lowS: true });
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  serialize(e5) {
    e5.serializeBytes(this.key.toUint8Array());
  }
  static deserialize(e5) {
    let t30 = e5.deserializeBytes();
    return new i33(t30);
  }
  static isPublicKey(e5) {
    return e5 instanceof i33;
  }
  static isInstance(e5) {
    var _a, _b;
    return "key" in e5 && ((_b = (_a = e5.key) == null ? void 0 : _a.data) == null ? void 0 : _b.length) === i33.LENGTH;
  }
};
i32.LENGTH = 65;
var u7 = i32;
var r10 = class r11 extends B {
  constructor(e5) {
    super();
    let t30 = i.fromHexInput(e5);
    if (t30.toUint8Array().length !== r11.LENGTH) throw new Error(`PrivateKey length should be ${r11.LENGTH}`);
    this.key = t30;
  }
  static generate() {
    let e5 = secp256k1.utils.randomPrivateKey();
    return new r11(e5);
  }
  static fromDerivationPath(e5, t30) {
    if (!D4(e5)) throw new Error(`Invalid derivation path ${e5}`);
    return r11.fromDerivationPathInner(e5, h7(t30));
  }
  static fromDerivationPathInner(e5, t30) {
    let { privateKey: n18 } = HDKey.fromMasterSeed(t30).derive(e5);
    if (n18 === null) throw new Error("Invalid key");
    return new r11(n18);
  }
  sign(e5) {
    let t30 = o11(e5), n18 = i.fromHexInput(t30), y12 = sha3_256(n18.toUint8Array()), l19 = secp256k1.sign(y12, this.key.toUint8Array(), { lowS: true });
    return new m7(l19.toCompactRawBytes());
  }
  publicKey() {
    let e5 = secp256k1.getPublicKey(this.key.toUint8Array(), false);
    return new u7(e5);
  }
  toUint8Array() {
    return this.key.toUint8Array();
  }
  toString() {
    return this.key.toString();
  }
  serialize(e5) {
    e5.serializeBytes(this.toUint8Array());
  }
  static deserialize(e5) {
    let t30 = e5.deserializeBytes();
    return new r11(t30);
  }
  static isPrivateKey(e5) {
    return e5 instanceof r11;
  }
};
r10.LENGTH = 32;
var v3 = r10;
var a13 = class a14 extends o10 {
  constructor(e5) {
    super();
    let t30 = i.fromHexInput(e5);
    if (t30.toUint8Array().length !== a14.LENGTH) throw new Error(`Signature length should be ${a14.LENGTH}, received ${t30.toUint8Array().length}`);
    this.data = t30;
  }
  toUint8Array() {
    return this.data.toUint8Array();
  }
  serialize(e5) {
    e5.serializeBytes(this.data.toUint8Array());
  }
  static deserialize(e5) {
    let t30 = e5.deserializeBytes();
    return new a14(t30);
  }
};
a13.LENGTH = 64;
var m7 = a13;

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MQGW234H.mjs
var e = class extends B {
  toString() {
    let s12 = this.bcsToBytes();
    return i.fromHexInput(s12).toString();
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-DZXM2MQY.mjs
var n10 = class {
  constructor(e5) {
    this.buffer = new ArrayBuffer(e5.length), new Uint8Array(this.buffer).set(e5, 0), this.offset = 0;
  }
  read(e5) {
    if (this.offset + e5 > this.buffer.byteLength) throw new Error("Reached to the end of buffer");
    let i47 = this.buffer.slice(this.offset, this.offset + e5);
    return this.offset += e5, i47;
  }
  deserializeStr() {
    let e5 = this.deserializeBytes();
    return new TextDecoder().decode(e5);
  }
  deserializeOptionStr() {
    return this.deserializeBool() ? this.deserializeStr() : void 0;
  }
  deserializeOption(e5) {
    return this.deserializeBool() ? this.deserialize(e5) : void 0;
  }
  deserializeBytes() {
    let e5 = this.deserializeUleb128AsU32();
    return new Uint8Array(this.read(e5));
  }
  deserializeFixedBytes(e5) {
    return new Uint8Array(this.read(e5));
  }
  deserializeBool() {
    let e5 = new Uint8Array(this.read(1))[0];
    if (e5 !== 1 && e5 !== 0) throw new Error("Invalid boolean value");
    return e5 === 1;
  }
  deserializeU8() {
    return new DataView(this.read(1)).getUint8(0);
  }
  deserializeU16() {
    return new DataView(this.read(2)).getUint16(0, true);
  }
  deserializeU32() {
    return new DataView(this.read(4)).getUint32(0, true);
  }
  deserializeU64() {
    let e5 = this.deserializeU32(), i47 = this.deserializeU32();
    return BigInt(BigInt(i47) << BigInt(32) | BigInt(e5));
  }
  deserializeU128() {
    let e5 = this.deserializeU64(), i47 = this.deserializeU64();
    return BigInt(i47 << BigInt(64) | e5);
  }
  deserializeU256() {
    let e5 = this.deserializeU128(), i47 = this.deserializeU128();
    return BigInt(i47 << BigInt(128) | e5);
  }
  deserializeUleb128AsU32() {
    let e5 = BigInt(0), i47 = 0;
    for (; e5 < U; ) {
      let t30 = this.deserializeU8();
      if (e5 |= BigInt(t30 & 127) << BigInt(i47), !(t30 & 128)) break;
      i47 += 7;
    }
    if (e5 > U) throw new Error("Overflow while parsing uleb128-encoded uint32 value");
    return Number(e5);
  }
  deserialize(e5) {
    return e5.deserialize(this);
  }
  deserializeVector(e5) {
    let i47 = this.deserializeUleb128AsU32(), t30 = new Array();
    for (let s12 = 0; s12 < i47; s12 += 1) t30.push(this.deserialize(e5));
    return t30;
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YZWR7OV5.mjs
var c4 = class i34 extends t18 {
  constructor(e5) {
    super();
    let r26 = e5.constructor.name;
    switch (r26) {
      case m6.name:
        this.publicKey = e5, this.variant = 0;
        break;
      default:
        throw new Error(`Unsupported key for EphemeralPublicKey - ${r26}`);
    }
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  verifySignature(e5) {
    let { message: r26, signature: a24 } = e5;
    return this.publicKey.verifySignature({ message: r26, signature: a24.signature });
  }
  serialize(e5) {
    if (this.publicKey instanceof m6) e5.serializeU32AsUleb128(0), this.publicKey.serialize(e5);
    else throw new Error("Unknown public key type");
  }
  static deserialize(e5) {
    let r26 = e5.deserializeUleb128AsU32();
    switch (r26) {
      case 0:
        return new i34(m6.deserialize(e5));
      default:
        throw new Error(`Unknown variant index for EphemeralPublicKey: ${r26}`);
    }
  }
  static isPublicKey(e5) {
    return e5 instanceof i34;
  }
};
var p5 = class i35 extends o10 {
  constructor(e5) {
    super();
    let r26 = e5.constructor.name;
    switch (r26) {
      case h8.name:
        this.signature = e5;
        break;
      default:
        throw new Error(`Unsupported signature for EphemeralSignature - ${r26}`);
    }
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  static fromHex(e5) {
    let r26 = i.fromHexInput(e5), a24 = new n10(r26.toUint8Array());
    return i35.deserialize(a24);
  }
  serialize(e5) {
    if (this.signature instanceof h8) e5.serializeU32AsUleb128(0), this.signature.serialize(e5);
    else throw new Error("Unknown signature type");
  }
  static deserialize(e5) {
    let r26 = e5.deserializeUleb128AsU32();
    switch (r26) {
      case 0:
        return new i35(h8.deserialize(e5));
      default:
        throw new Error(`Unknown variant index for EphemeralSignature: ${r26}`);
    }
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-IVVWQKCF.mjs
var import_poseidon_lite = __toESM(require_poseidon_lite(), 1);
var e2 = [import_poseidon_lite.poseidon1, import_poseidon_lite.poseidon2, import_poseidon_lite.poseidon3, import_poseidon_lite.poseidon4, import_poseidon_lite.poseidon5, import_poseidon_lite.poseidon6, import_poseidon_lite.poseidon7, import_poseidon_lite.poseidon8, import_poseidon_lite.poseidon9, import_poseidon_lite.poseidon10, import_poseidon_lite.poseidon11, import_poseidon_lite.poseidon12, import_poseidon_lite.poseidon13, import_poseidon_lite.poseidon14, import_poseidon_lite.poseidon15, import_poseidon_lite.poseidon16];
var s3 = 31;
var B4 = 16;
var i36 = (B4 - 1) * s3;
function x5(n18, t30) {
  let o26 = new TextEncoder().encode(n18);
  return $4(o26, t30);
}
function $4(n18, t30) {
  if (n18.length > t30) throw new Error(`Inputted bytes of length ${n18} is longer than ${t30}`);
  let r26 = T7(n18, t30);
  return k3(r26);
}
function m8(n18, t30) {
  if (n18.length > t30) throw new Error(`Input bytes of length ${n18} is longer than ${t30}`);
  let r26 = N(n18, t30);
  return _3(r26);
}
function T7(n18, t30) {
  if (n18.length > t30) throw new Error(`Input bytes of length ${n18} is longer than ${t30}`);
  return m8(n18, t30).concat([BigInt(n18.length)]);
}
function _3(n18) {
  if (n18.length > i36) throw new Error(`Can't pack more than ${i36}.  Was given ${n18.length} bytes`);
  return P2(n18, s3).map((t30) => L3(t30));
}
function P2(n18, t30) {
  let r26 = [];
  for (let o26 = 0; o26 < n18.length; o26 += t30) r26.push(n18.subarray(o26, o26 + t30));
  return r26;
}
function L3(n18) {
  let t30 = BigInt(0);
  for (let r26 = n18.length - 1; r26 >= 0; r26 -= 1) t30 = t30 << BigInt(8) | BigInt(n18[r26]);
  return t30;
}
function C4(n18, t30) {
  let r26 = new Uint8Array(t30);
  for (let o26 = 0; o26 < t30; o26 += 1) r26[o26] = Number(n18 & BigInt(255)), n18 >>= BigInt(8);
  return r26;
}
function N(n18, t30) {
  if (t30 < n18.length) throw new Error("Padded size must be greater than or equal to the input array size.");
  let r26 = new Uint8Array(t30);
  r26.set(n18);
  for (let o26 = n18.length; o26 < t30; o26 += 1) r26[o26] = 0;
  return r26;
}
function k3(n18) {
  if (n18.length > e2.length) throw new Error(`Unable to hash input of length ${n18.length}.  Max input length is ${e2.length}`);
  return e2[n18.length - 1](n18);
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-AH44UPM4.mjs
var n11 = /* @__PURE__ */ new Map();
function m9(r26, e5, t30) {
  return async (...s12) => {
    if (n11.has(e5)) {
      let { value: i47, timestamp: u15 } = n11.get(e5);
      if (t30 === void 0 || Date.now() - u15 <= t30) return i47;
    }
    let a24 = await r26(...s12);
    return n11.set(e5, { value: a24, timestamp: Date.now() }), a24;
  };
}

// node_modules/jwt-decode/build/esm/index.js
var InvalidTokenError = class extends Error {
};
InvalidTokenError.prototype.name = "InvalidTokenError";
function b64DecodeUnicode(str) {
  return decodeURIComponent(atob(str).replace(/(.)/g, (m15, p13) => {
    let code = p13.charCodeAt(0).toString(16).toUpperCase();
    if (code.length < 2) {
      code = "0" + code;
    }
    return "%" + code;
  }));
}
function base64UrlDecode(str) {
  let output2 = str.replace(/-/g, "+").replace(/_/g, "/");
  switch (output2.length % 4) {
    case 0:
      break;
    case 2:
      output2 += "==";
      break;
    case 3:
      output2 += "=";
      break;
    default:
      throw new Error("base64 string is not of the correct length");
  }
  try {
    return b64DecodeUnicode(output2);
  } catch (err) {
    return atob(output2);
  }
}
function jwtDecode(token, options) {
  if (typeof token !== "string") {
    throw new InvalidTokenError("Invalid token specified: must be a string");
  }
  options || (options = {});
  const pos = options.header === true ? 0 : 1;
  const part = token.split(".")[pos];
  if (typeof part !== "string") {
    throw new InvalidTokenError(`Invalid token specified: missing part #${pos + 1}`);
  }
  let decoded;
  try {
    decoded = base64UrlDecode(part);
  } catch (e5) {
    throw new InvalidTokenError(`Invalid token specified: invalid base64 for part #${pos + 1} (${e5.message})`);
  }
  try {
    return JSON.parse(decoded);
  } catch (e5) {
    throw new InvalidTokenError(`Invalid token specified: invalid json for part #${pos + 1} (${e5.message})`);
  }
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YY7NLCQK.mjs
var he = 1e7;
var F2 = 120;
var L4 = 30;
var N2 = 330;
var ge2 = 120;
var fe2 = 350;
var Se = 300;
var xe = 93;
var o14 = class o15 extends a8 {
  constructor(e5, t30) {
    super();
    let i47 = i.fromHexInput(t30).toUint8Array();
    if (i47.length !== o15.ID_COMMITMENT_LENGTH) throw new Error(`Id Commitment length in bytes should be ${o15.ID_COMMITMENT_LENGTH}`);
    this.iss = e5, this.idCommitment = i47;
  }
  authKey() {
    let e5 = new n3();
    return e5.serializeU32AsUleb128(3), e5.serializeFixedBytes(this.bcsToBytes()), c3.fromSchemeAndBytes({ scheme: 2, input: e5.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  toString() {
    return i.fromHexInput(this.toUint8Array()).toString();
  }
  verifySignature(e5) {
    throw new Error("Not yet implemented");
  }
  serialize(e5) {
    e5.serializeStr(this.iss), e5.serializeBytes(this.idCommitment);
  }
  static deserialize(e5) {
    let t30 = e5.deserializeStr(), i47 = e5.deserializeBytes();
    return new o15(t30, i47);
  }
  static load(e5) {
    let t30 = e5.deserializeStr(), i47 = e5.deserializeBytes();
    return new o15(t30, i47);
  }
  static isPublicKey(e5) {
    return e5 instanceof o15;
  }
  static create(e5) {
    return _4(e5), new o15(e5.iss, _4(e5));
  }
  static fromJwtAndPepper(e5) {
    let { jwt: t30, pepper: i47, uidKey: a24 = "sub" } = e5, n18 = jwtDecode(t30), s12 = n18.iss;
    if (typeof n18.aud != "string") throw new Error("aud was not found or an array of values");
    let M5 = n18.aud, R7 = n18[a24];
    return o15.create({ iss: s12, uidKey: a24, uidVal: R7, aud: M5, pepper: i47 });
  }
  static isInstance(e5) {
    return "iss" in e5 && typeof e5.iss == "string" && "idCommitment" in e5 && e5.idCommitment instanceof Uint8Array;
  }
};
o14.ID_COMMITMENT_LENGTH = 32;
var A9 = o14;
function _4(r26) {
  let { uidKey: e5, uidVal: t30, aud: i47, pepper: a24 } = r26, n18 = [L3(i.fromHexInput(a24).toUint8Array()), x5(i47, F2), x5(t30, N2), x5(e5, L4)];
  return C4(k3(n18), A9.ID_COMMITMENT_LENGTH);
}
var D5 = class r12 extends o10 {
  constructor(e5) {
    super();
    let { jwtHeader: t30, ephemeralCertificate: i47, expiryDateSecs: a24, ephemeralPublicKey: n18, ephemeralSignature: s12 } = e5;
    this.jwtHeader = t30, this.ephemeralCertificate = i47, this.expiryDateSecs = a24, this.ephemeralPublicKey = n18, this.ephemeralSignature = s12;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e5) {
    this.ephemeralCertificate.serialize(e5), e5.serializeStr(this.jwtHeader), e5.serializeU64(this.expiryDateSecs), this.ephemeralPublicKey.serialize(e5), this.ephemeralSignature.serialize(e5);
  }
  static deserialize(e5) {
    let t30 = h10.deserialize(e5), i47 = e5.deserializeStr(), a24 = e5.deserializeU64(), n18 = c4.deserialize(e5), s12 = p5.deserialize(e5);
    return new r12({ jwtHeader: i47, expiryDateSecs: Number(a24), ephemeralCertificate: t30, ephemeralPublicKey: n18, ephemeralSignature: s12 });
  }
  static getSimulationSignature() {
    return new r12({ jwtHeader: "{}", ephemeralCertificate: new h10(new S5({ proof: new f7(new g8({ a: new Uint8Array(32), b: new Uint8Array(64), c: new Uint8Array(32) }), 0), expHorizonSecs: 0 }), 0), expiryDateSecs: 0, ephemeralPublicKey: new c4(new m6(new Uint8Array(32))), ephemeralSignature: new p5(new h8(new Uint8Array(64))) });
  }
  static isSignature(e5) {
    return e5 instanceof r12;
  }
};
var h10 = class r13 extends o10 {
  constructor(e5, t30) {
    super(), this.signature = e5, this.variant = t30;
  }
  toUint8Array() {
    return this.signature.toUint8Array();
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(this.variant), this.signature.serialize(e5);
  }
  static deserialize(e5) {
    let t30 = e5.deserializeUleb128AsU32();
    switch (t30) {
      case 0:
        return new r13(S5.deserialize(e5), t30);
      default:
        throw new Error(`Unknown variant index for EphemeralCertificate: ${t30}`);
    }
  }
};
var c6 = class r14 extends B {
  constructor(e5) {
    if (super(), this.data = i.fromHexInput(e5).toUint8Array(), this.data.length !== 32) throw new Error("Input needs to be 32 bytes");
  }
  serialize(e5) {
    e5.serializeFixedBytes(this.data);
  }
  static deserialize(e5) {
    let t30 = e5.deserializeFixedBytes(32);
    return new r14(t30);
  }
};
var l8 = class r15 extends B {
  constructor(e5) {
    if (super(), this.data = i.fromHexInput(e5).toUint8Array(), this.data.length !== 64) throw new Error("Input needs to be 64 bytes");
  }
  serialize(e5) {
    e5.serializeFixedBytes(this.data);
  }
  static deserialize(e5) {
    let t30 = e5.deserializeFixedBytes(64);
    return new r15(t30);
  }
};
var g8 = class r16 extends e {
  constructor(e5) {
    super();
    let { a: t30, b: i47, c: a24 } = e5;
    this.a = new c6(t30), this.b = new l8(i47), this.c = new c6(a24);
  }
  serialize(e5) {
    this.a.serialize(e5), this.b.serialize(e5), this.c.serialize(e5);
  }
  static deserialize(e5) {
    let t30 = c6.deserialize(e5).bcsToBytes(), i47 = l8.deserialize(e5).bcsToBytes(), a24 = c6.deserialize(e5).bcsToBytes();
    return new r16({ a: t30, b: i47, c: a24 });
  }
};
var f7 = class r17 extends B {
  constructor(e5, t30) {
    super(), this.proof = e5, this.variant = t30;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(this.variant), this.proof.serialize(e5);
  }
  static deserialize(e5) {
    let t30 = e5.deserializeUleb128AsU32();
    switch (t30) {
      case 0:
        return new r17(g8.deserialize(e5), t30);
      default:
        throw new Error(`Unknown variant index for ZkProof: ${t30}`);
    }
  }
};
var S5 = class r18 extends o10 {
  constructor(e5) {
    super();
    let { proof: t30, expHorizonSecs: i47, trainingWheelsSignature: a24, extraField: n18, overrideAudVal: s12 } = e5;
    this.proof = t30, this.expHorizonSecs = i47, this.trainingWheelsSignature = a24, this.extraField = n18, this.overrideAudVal = s12;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  static fromBytes(e5) {
    return r18.deserialize(new n10(e5));
  }
  serialize(e5) {
    this.proof.serialize(e5), e5.serializeU64(this.expHorizonSecs), e5.serializeOptionStr(this.extraField), e5.serializeOptionStr(this.overrideAudVal), e5.serializeOption(this.trainingWheelsSignature);
  }
  static deserialize(e5) {
    let t30 = f7.deserialize(e5), i47 = Number(e5.deserializeU64()), a24 = e5.deserializeOptionStr(), n18 = e5.deserializeOptionStr(), s12 = e5.deserializeOption(p5);
    return new r18({ proof: t30, expHorizonSecs: i47, trainingWheelsSignature: s12, extraField: a24, overrideAudVal: n18 });
  }
};
var z5 = class r19 {
  constructor(e5, t30) {
    this.verficationKey = e5, this.maxExpHorizonSecs = t30;
  }
  static create(e5, t30) {
    return new r19(new K({ alphaG1: e5.alpha_g1, betaG2: e5.beta_g2, deltaG2: e5.delta_g2, gammaAbcG1: e5.gamma_abc_g1, gammaG2: e5.gamma_g2 }), t30);
  }
};
var K = class r20 {
  constructor(e5) {
    let { alphaG1: t30, betaG2: i47, deltaG2: a24, gammaAbcG1: n18, gammaG2: s12 } = e5;
    this.alphaG1 = new c6(t30), this.betaG2 = new l8(i47), this.deltaG2 = new l8(a24), this.gammaAbcG1 = [new c6(n18[0]), new c6(n18[1])], this.gammaG2 = new l8(s12);
  }
  static fromGroth16VerificationKeyResponse(e5) {
    return new r20({ alphaG1: e5.alpha_g1, betaG2: e5.beta_g2, deltaG2: e5.delta_g2, gammaAbcG1: e5.gamma_abc_g1, gammaG2: e5.gamma_g2 });
  }
};
async function be(r26) {
  let { aptosConfig: e5 } = r26;
  return m9(async () => {
    let t30 = await O3(r26), i47 = await j4(r26);
    return z5.create(i47, Number(t30.max_exp_horizon_secs));
  }, `keyless-configuration-${e5.network}`, 1e3 * 60 * 5)();
}
async function O3(r26) {
  let { aptosConfig: e5, options: t30 } = r26, i47 = "0x1::keyless_account::Configuration", { data: a24 } = await m3({ aptosConfig: e5, originMethod: "getKeylessConfigurationResource", path: `accounts/${d.from("0x1").toString()}/resource/${i47}`, params: { ledger_version: t30 == null ? void 0 : t30.ledgerVersion } });
  return a24.data;
}
async function j4(r26) {
  let { aptosConfig: e5, options: t30 } = r26, i47 = "0x1::keyless_account::Groth16VerificationKey", { data: a24 } = await m3({ aptosConfig: e5, originMethod: "getGroth16VerificationKeyResource", path: `accounts/${d.from("0x1").toString()}/resource/${i47}`, params: { ledger_version: t30 == null ? void 0 : t30.ledgerVersion } });
  return a24.data;
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-C7HIUK23.mjs
var f8 = class r21 extends a8 {
  constructor(e5) {
    if (super(), this.publicKey = e5, e5 instanceof m6) this.variant = 0;
    else if (e5 instanceof u7) this.variant = 1;
    else if (e5 instanceof A9) this.variant = 3;
    else throw new Error("Unsupported public key type");
  }
  verifySignature(e5) {
    let { message: t30, signature: i47 } = e5;
    return l9.isInstance(i47) ? this.publicKey.verifySignature({ message: t30, signature: i47.signature }) : false;
  }
  authKey() {
    return c3.fromSchemeAndBytes({ scheme: 2, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(this.variant), this.publicKey.serialize(e5);
  }
  static deserialize(e5) {
    let t30 = e5.deserializeUleb128AsU32(), i47;
    switch (t30) {
      case 0:
        i47 = m6.deserialize(e5);
        break;
      case 1:
        i47 = u7.deserialize(e5);
        break;
      case 3:
        i47 = A9.deserialize(e5);
        break;
      default:
        throw new Error(`Unknown variant index for AnyPublicKey: ${t30}`);
    }
    return new r21(i47);
  }
  static isPublicKey(e5) {
    return e5 instanceof r21;
  }
  isEd25519() {
    return this.publicKey instanceof m6;
  }
  isSecp256k1PublicKey() {
    return this.publicKey instanceof u7;
  }
  static isInstance(e5) {
    return "publicKey" in e5 && "variant" in e5;
  }
};
var l9 = class r22 extends o10 {
  constructor(e5) {
    if (super(), this.signature = e5, e5 instanceof h8) this.variant = 0;
    else if (e5 instanceof m7) this.variant = 1;
    else if (e5 instanceof D5) this.variant = 3;
    else throw new Error("Unsupported signature type");
  }
  toUint8Array() {
    return console.warn("[Aptos SDK] Calls to AnySignature.toUint8Array() will soon return the underlying signature bytes. Use AnySignature.bcsToBytes() instead."), this.bcsToBytes();
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(this.variant), this.signature.serialize(e5);
  }
  static deserialize(e5) {
    let t30 = e5.deserializeUleb128AsU32(), i47;
    switch (t30) {
      case 0:
        i47 = h8.deserialize(e5);
        break;
      case 1:
        i47 = m7.deserialize(e5);
        break;
      case 3:
        i47 = D5.deserialize(e5);
        break;
      default:
        throw new Error(`Unknown variant index for AnySignature: ${t30}`);
    }
    return new r22(i47);
  }
  static isInstance(e5) {
    return "signature" in e5 && typeof e5.signature == "object" && e5.signature !== null && "toUint8Array" in e5.signature;
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-R3IDASOF.mjs
function d13(l19) {
  let e5 = l19;
  return e5 -= e5 >> 1 & 1431655765, e5 = (e5 & 858993459) + (e5 >> 2 & 858993459), (e5 + (e5 >> 4) & 252645135) * 16843009 >> 24;
}
var f9 = class l10 extends a8 {
  constructor(e5) {
    super();
    let { publicKeys: r26, signaturesRequired: t30 } = e5;
    if (t30 < 1) throw new Error("The number of required signatures needs to be greater than 0");
    if (r26.length < t30) throw new Error(`Provided ${r26.length} public keys is smaller than the ${t30} required signatures`);
    this.publicKeys = r26.map((i47) => i47 instanceof f8 ? i47 : new f8(i47)), this.signaturesRequired = t30;
  }
  verifySignature(e5) {
    throw new Error("not implemented");
  }
  authKey() {
    return c3.fromSchemeAndBytes({ scheme: 3, input: this.toUint8Array() });
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e5) {
    e5.serializeVector(this.publicKeys), e5.serializeU8(this.signaturesRequired);
  }
  static deserialize(e5) {
    let r26 = e5.deserializeVector(f8), t30 = e5.deserializeU8();
    return new l10({ publicKeys: r26, signaturesRequired: t30 });
  }
  createBitmap(e5) {
    let { bits: r26 } = e5, t30 = 128, i47 = new Uint8Array([0, 0, 0, 0]), a24 = /* @__PURE__ */ new Set();
    return r26.forEach((n18, u15) => {
      if (u15 + 1 > this.publicKeys.length) throw new Error(`Signature index ${u15 + 1} is out of public keys range, ${this.publicKeys.length}.`);
      if (a24.has(n18)) throw new Error(`Duplicate bit ${n18} detected.`);
      a24.add(n18);
      let c14 = Math.floor(n18 / 8), y12 = i47[c14];
      y12 |= t30 >> n18 % 8, i47[c14] = y12;
    }), i47;
  }
  getIndex(e5) {
    let r26 = e5 instanceof f8 ? e5 : new f8(e5), t30 = this.publicKeys.findIndex((i47) => i47.toString() === r26.toString());
    if (t30 !== -1) return t30;
    throw new Error("Public key not found in MultiKey");
  }
};
var s4 = class s5 extends o10 {
  constructor(e5) {
    super();
    let { signatures: r26, bitmap: t30 } = e5;
    if (r26.length > s5.MAX_SIGNATURES_SUPPORTED) throw new Error(`The number of signatures cannot be greater than ${s5.MAX_SIGNATURES_SUPPORTED}`);
    if (this.signatures = r26.map((a24) => a24 instanceof l9 ? a24 : new l9(a24)), !(t30 instanceof Uint8Array)) this.bitmap = s5.createBitmap({ bits: t30 });
    else {
      if (t30.length !== s5.BITMAP_LEN) throw new Error(`"bitmap" length should be ${s5.BITMAP_LEN}`);
      this.bitmap = t30;
    }
    let i47 = this.bitmap.reduce((a24, n18) => a24 + d13(n18), 0);
    if (i47 !== this.signatures.length) throw new Error(`Expecting ${i47} signatures from the bitmap, but got ${this.signatures.length}`);
  }
  static createBitmap(e5) {
    let { bits: r26 } = e5, t30 = 128, i47 = new Uint8Array([0, 0, 0, 0]), a24 = /* @__PURE__ */ new Set();
    return r26.forEach((n18) => {
      if (n18 >= s5.MAX_SIGNATURES_SUPPORTED) throw new Error(`Cannot have a signature larger than ${s5.MAX_SIGNATURES_SUPPORTED - 1}.`);
      if (a24.has(n18)) throw new Error("Duplicate bits detected.");
      a24.add(n18);
      let u15 = Math.floor(n18 / 8), c14 = i47[u15];
      c14 |= t30 >> n18 % 8, i47[u15] = c14;
    }), i47;
  }
  toUint8Array() {
    return this.bcsToBytes();
  }
  serialize(e5) {
    e5.serializeVector(this.signatures), e5.serializeBytes(this.bitmap);
  }
  static deserialize(e5) {
    let r26 = e5.deserializeVector(l9), t30 = e5.deserializeBytes();
    return new s5({ signatures: r26, bitmap: t30 });
  }
};
s4.BITMAP_LEN = 4, s4.MAX_SIGNATURES_SUPPORTED = s4.BITMAP_LEN * 8;
var p7 = s4;

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZXSNAEPE.mjs
var r23 = class extends B {
  static deserialize(i47) {
    let e5 = i47.deserializeUleb128AsU32();
    switch (e5) {
      case 0:
        return u9.load(i47);
      case 1:
        return l11.load(i47);
      case 2:
        return n12.load(i47);
      case 3:
        return a16.load(i47);
      default:
        throw new Error(`Unknown variant index for AccountAuthenticator: ${e5}`);
    }
  }
  isEd25519() {
    return this instanceof u9;
  }
  isMultiEd25519() {
    return this instanceof l11;
  }
  isSingleKey() {
    return this instanceof n12;
  }
  isMultiKey() {
    return this instanceof a16;
  }
};
var u9 = class t19 extends r23 {
  constructor(i47, e5) {
    super(), this.public_key = i47, this.signature = e5;
  }
  serialize(i47) {
    i47.serializeU32AsUleb128(0), this.public_key.serialize(i47), this.signature.serialize(i47);
  }
  static load(i47) {
    let e5 = m6.deserialize(i47), s12 = h8.deserialize(i47);
    return new t19(e5, s12);
  }
};
var l11 = class t20 extends r23 {
  constructor(i47, e5) {
    super(), this.public_key = i47, this.signature = e5;
  }
  serialize(i47) {
    i47.serializeU32AsUleb128(1), this.public_key.serialize(i47), this.signature.serialize(i47);
  }
  static load(i47) {
    let e5 = d11.deserialize(i47), s12 = y7.deserialize(i47);
    return new t20(e5, s12);
  }
};
var n12 = class t21 extends r23 {
  constructor(i47, e5) {
    super(), this.public_key = i47, this.signature = e5;
  }
  serialize(i47) {
    i47.serializeU32AsUleb128(2), this.public_key.serialize(i47), this.signature.serialize(i47);
  }
  static load(i47) {
    let e5 = f8.deserialize(i47), s12 = l9.deserialize(i47);
    return new t21(e5, s12);
  }
};
var a16 = class t22 extends r23 {
  constructor(i47, e5) {
    super(), this.public_keys = i47, this.signatures = e5;
  }
  serialize(i47) {
    i47.serializeU32AsUleb128(3), this.public_keys.serialize(i47), this.signatures.serialize(i47);
  }
  static load(i47) {
    let e5 = f9.deserialize(i47), s12 = p7.deserialize(i47);
    return new t22(e5, s12);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ITADRWJI.mjs
var c7 = class a17 {
  constructor(t30) {
    this.signingScheme = 0;
    let { privateKey: e5, address: r26 } = t30;
    this.privateKey = e5, this.publicKey = e5.publicKey(), this.accountAddress = r26 ? d.from(r26) : this.publicKey.authKey().derivedAddress();
  }
  static generate() {
    let t30 = U7.generate();
    return new a17({ privateKey: t30 });
  }
  static fromDerivationPath(t30) {
    let { path: e5, mnemonic: r26 } = t30, u15 = U7.fromDerivationPath(e5, r26);
    return new a17({ privateKey: u15 });
  }
  verifySignature(t30) {
    return this.publicKey.verifySignature(t30);
  }
  signWithAuthenticator(t30) {
    return new u9(this.publicKey, this.privateKey.sign(t30));
  }
  signTransactionWithAuthenticator(t30) {
    return new u9(this.publicKey, this.signTransaction(t30));
  }
  sign(t30) {
    return this.privateKey.sign(t30);
  }
  signTransaction(t30) {
    return this.sign(S4(t30));
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-KZY3TZVR.mjs
var h11 = class c8 {
  constructor(e5) {
    this.signingScheme = 2;
    let { privateKey: r26, address: t30 } = e5;
    this.privateKey = r26, this.publicKey = new f8(r26.publicKey()), this.accountAddress = t30 ? d.from(t30) : this.publicKey.authKey().derivedAddress();
  }
  static generate(e5 = {}) {
    let { scheme: r26 = 0 } = e5, t30;
    switch (r26) {
      case 0:
        t30 = U7.generate();
        break;
      case 2:
        t30 = v3.generate();
        break;
      default:
        throw new Error(`Unsupported signature scheme ${r26}`);
    }
    return new c8({ privateKey: t30 });
  }
  static fromDerivationPath(e5) {
    let { scheme: r26 = 0, path: t30, mnemonic: o26 } = e5, n18;
    switch (r26) {
      case 0:
        n18 = U7.fromDerivationPath(t30, o26);
        break;
      case 2:
        n18 = v3.fromDerivationPath(t30, o26);
        break;
      default:
        throw new Error(`Unsupported signature scheme ${r26}`);
    }
    return new c8({ privateKey: n18 });
  }
  verifySignature(e5) {
    return this.publicKey.verifySignature(e5);
  }
  signWithAuthenticator(e5) {
    return new n12(this.publicKey, this.sign(e5));
  }
  signTransactionWithAuthenticator(e5) {
    return new n12(this.publicKey, this.signTransaction(e5));
  }
  sign(e5) {
    return new l9(this.privateKey.sign(e5));
  }
  signTransaction(e5) {
    return this.sign(S4(e5));
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-QEIKAT6S.mjs
var o16 = class {
  static generate(e5 = {}) {
    let { scheme: t30 = 0, legacy: r26 = true } = e5;
    return t30 === 0 && r26 ? c7.generate() : h11.generate({ scheme: t30 });
  }
  static fromPrivateKey(e5) {
    let { privateKey: t30, address: r26, legacy: a24 = true } = e5;
    return t30 instanceof U7 && a24 ? new c7({ privateKey: t30, address: r26 }) : new h11({ privateKey: t30, address: r26 });
  }
  static fromPrivateKeyAndAddress(e5) {
    return this.fromPrivateKey(e5);
  }
  static fromDerivationPath(e5) {
    let { scheme: t30 = 0, mnemonic: r26, path: a24, legacy: s12 = true } = e5;
    return t30 === 0 && s12 ? c7.fromDerivationPath({ mnemonic: r26, path: a24 }) : h11.fromDerivationPath({ scheme: t30, mnemonic: r26, path: a24 });
  }
  static authKey(e5) {
    let { publicKey: t30 } = e5;
    return t30.authKey();
  }
  verifySignature(e5) {
    return this.publicKey.verifySignature(e5);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WRRQ7L5K.mjs
var d14 = (e5, r26) => {
  let t30 = e5.bcsToBytes(), s12 = typeof r26 == "string" ? Buffer.from(r26, "utf8") : r26, o26 = new Uint8Array([...t30, ...s12, 254]);
  return new d(sha3_256(o26));
};
var f10 = (e5, r26) => {
  let t30 = e5.bcsToBytes(), s12 = typeof r26 == "string" ? Buffer.from(r26, "utf8") : r26, o26 = new Uint8Array([...t30, ...s12, 255]);
  return new d(sha3_256(o26));
};
var a18 = (e5, r26, t30) => {
  let s12 = `${r26}::${t30}`;
  return d14(e5, s12);
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-XDDQWRYI.mjs
async function R4(o26) {
  let { aptosConfig: n18, accountAddress: t30 } = o26, { data: e5 } = await m3({ aptosConfig: n18, originMethod: "getInfo", path: `accounts/${d.from(t30).toString()}` });
  return e5;
}
async function Y(o26) {
  let { aptosConfig: n18, accountAddress: t30, options: e5 } = o26;
  return A4({ aptosConfig: n18, originMethod: "getModules", path: `accounts/${d.from(t30).toString()}/modules`, params: { ledger_version: e5 == null ? void 0 : e5.ledgerVersion, start: e5 == null ? void 0 : e5.offset, limit: (e5 == null ? void 0 : e5.limit) ?? 1e3 } });
}
async function Z(o26) {
  var _a;
  return ((_a = o26.options) == null ? void 0 : _a.ledgerVersion) !== void 0 ? Q2(o26) : m9(async () => Q2(o26), `module-${o26.accountAddress}-${o26.moduleName}`, 1e3 * 60 * 5)();
}
async function Q2(o26) {
  let { aptosConfig: n18, accountAddress: t30, moduleName: e5, options: r26 } = o26, { data: s12 } = await m3({ aptosConfig: n18, originMethod: "getModule", path: `accounts/${d.from(t30).toString()}/module/${e5}`, params: { ledger_version: r26 == null ? void 0 : r26.ledgerVersion } });
  return s12;
}
async function ee(o26) {
  let { aptosConfig: n18, accountAddress: t30, options: e5 } = o26;
  return A4({ aptosConfig: n18, originMethod: "getTransactions", path: `accounts/${d.from(t30).toString()}/transactions`, params: { start: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit } });
}
async function oe(o26) {
  let { aptosConfig: n18, accountAddress: t30, options: e5 } = o26;
  return A4({ aptosConfig: n18, originMethod: "getResources", path: `accounts/${d.from(t30).toString()}/resources`, params: { ledger_version: e5 == null ? void 0 : e5.ledgerVersion, start: e5 == null ? void 0 : e5.offset, limit: (e5 == null ? void 0 : e5.limit) ?? 999 } });
}
async function x6(o26) {
  let { aptosConfig: n18, accountAddress: t30, resourceType: e5, options: r26 } = o26, { data: s12 } = await m3({ aptosConfig: n18, originMethod: "getResource", path: `accounts/${d.from(t30).toString()}/resource/${e5}`, params: { ledger_version: r26 == null ? void 0 : r26.ledgerVersion } });
  return s12.data;
}
async function L5(o26) {
  let { aptosConfig: n18, authenticationKey: t30, options: e5 } = o26, r26 = await x6({ aptosConfig: n18, accountAddress: "0x1", resourceType: "0x1::account::OriginatingAddress", options: e5 }), { address_map: { handle: s12 } } = r26, c14 = d.from(t30);
  try {
    let a24 = await b5({ aptosConfig: n18, handle: s12, data: { key: c14.toString(), key_type: "address", value_type: "address" }, options: e5 });
    return d.from(a24);
  } catch (a24) {
    if (a24 instanceof n7 && a24.data.error_code === "table_item_not_found") return c14;
    throw a24;
  }
}
async function te(o26) {
  let { aptosConfig: n18, accountAddress: t30 } = o26, r26 = { owner_address: { _eq: d.from(t30).toStringLong() }, amount: { _gt: 0 } }, c14 = await a5({ aptosConfig: n18, query: { query: p3, variables: { where_condition: r26 } }, originMethod: "getAccountTokensCount" });
  return c14.current_token_ownerships_v2_aggregate.aggregate ? c14.current_token_ownerships_v2_aggregate.aggregate.count : 0;
}
async function ne(o26) {
  let { aptosConfig: n18, accountAddress: t30, options: e5 } = o26, s12 = { owner_address: { _eq: d.from(t30).toStringLong() }, amount: { _gt: 0 } };
  (e5 == null ? void 0 : e5.tokenStandard) && (s12.token_standard = { _eq: e5 == null ? void 0 : e5.tokenStandard });
  let c14 = { query: d5, variables: { where_condition: s12, offset: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit, order_by: e5 == null ? void 0 : e5.orderBy } };
  return (await a5({ aptosConfig: n18, query: c14, originMethod: "getAccountOwnedTokens" })).current_token_ownerships_v2;
}
async function re(o26) {
  let { aptosConfig: n18, accountAddress: t30, collectionAddress: e5, options: r26 } = o26, s12 = d.from(t30).toStringLong(), c14 = d.from(e5).toStringLong(), a24 = { owner_address: { _eq: s12 }, current_token_data: { collection_id: { _eq: c14 } }, amount: { _gt: 0 } };
  (r26 == null ? void 0 : r26.tokenStandard) && (a24.token_standard = { _eq: r26 == null ? void 0 : r26.tokenStandard });
  let u15 = { query: y3, variables: { where_condition: a24, offset: r26 == null ? void 0 : r26.offset, limit: r26 == null ? void 0 : r26.limit, order_by: r26 == null ? void 0 : r26.orderBy } };
  return (await a5({ aptosConfig: n18, query: u15, originMethod: "getAccountOwnedTokensFromCollectionAddress" })).current_token_ownerships_v2;
}
async function se(o26) {
  let { aptosConfig: n18, accountAddress: t30, options: e5 } = o26, s12 = { owner_address: { _eq: d.from(t30).toStringLong() } };
  (e5 == null ? void 0 : e5.tokenStandard) && (s12.current_collection = { token_standard: { _eq: e5 == null ? void 0 : e5.tokenStandard } });
  let c14 = { query: c2, variables: { where_condition: s12, offset: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit, order_by: e5 == null ? void 0 : e5.orderBy } };
  return (await a5({ aptosConfig: n18, query: c14, originMethod: "getAccountCollectionsWithOwnedTokens" })).current_collection_ownership_v2_view;
}
async function ce(o26) {
  let { aptosConfig: n18, accountAddress: t30 } = o26, e5 = d.from(t30).toStringLong(), s12 = await a5({ aptosConfig: n18, query: { query: m2, variables: { address: e5 } }, originMethod: "getAccountTransactionsCount" });
  return s12.account_transactions_aggregate.aggregate ? s12.account_transactions_aggregate.aggregate.count : 0;
}
async function ie(o26) {
  let { aptosConfig: n18, accountAddress: t30, coinType: e5, faMetadataAddress: r26 } = o26, s12, c14;
  if (e5 !== void 0 && r26 !== void 0) c14 = d.from(r26).toStringLong();
  else if (e5 !== void 0 && r26 === void 0) s12 = e5, o26.coinType === o9 ? c14 = d.A.toStringLong() : c14 = d14(d.A, e5).toStringLong();
  else if (e5 === void 0 && r26 !== void 0) {
    let m15 = d.from(r26);
    c14 = m15.toStringLong(), m15 === d.A && (s12 = o9);
  } else throw new Error("Either coinType, fungibleAssetAddress, or both must be provided");
  let a24 = d.from(t30).toStringLong(), u15 = { asset_type: { _eq: c14 } };
  e5 !== void 0 && (u15 = { asset_type: { _in: [s12, c14] } });
  let l19 = await B5({ aptosConfig: n18, accountAddress: a24, options: { where: u15 } });
  return l19[0] ? l19[0].amount : 0;
}
async function B5(o26) {
  let { aptosConfig: n18, accountAddress: t30, options: e5 } = o26, r26 = d.from(t30).toStringLong(), s12 = { ...e5 == null ? void 0 : e5.where, owner_address: { _eq: r26 } }, c14 = { query: u3, variables: { where_condition: s12, offset: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit, order_by: e5 == null ? void 0 : e5.orderBy } };
  return (await a5({ aptosConfig: n18, query: c14, originMethod: "getAccountCoinsData" })).current_fungible_asset_balances;
}
async function ae(o26) {
  let { aptosConfig: n18, accountAddress: t30 } = o26, e5 = d.from(t30).toStringLong(), s12 = await a5({ aptosConfig: n18, query: { query: _2, variables: { address: e5 } }, originMethod: "getAccountCoinsCount" });
  if (!s12.current_fungible_asset_balances_aggregate.aggregate) throw Error("Failed to get the count of account coins");
  return s12.current_fungible_asset_balances_aggregate.aggregate.count;
}
async function de(o26) {
  let { aptosConfig: n18, accountAddress: t30, options: e5 } = o26, s12 = { owner_address: { _eq: d.from(t30).toStringLong() } }, c14 = { query: v2, variables: { where_condition: s12, offset: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit, order_by: e5 == null ? void 0 : e5.orderBy } };
  return (await a5({ aptosConfig: n18, query: c14, originMethod: "getAccountOwnedObjects" })).current_objects;
}
async function ue(o26) {
  let { aptosConfig: n18, privateKey: t30 } = o26, e5 = new f8(t30.publicKey());
  if (t30 instanceof v3) {
    let s12 = c3.fromPublicKey({ publicKey: e5 }).derivedAddress();
    return o16.fromPrivateKey({ privateKey: t30, address: s12 });
  }
  if (t30 instanceof U7) {
    let r26 = c3.fromPublicKey({ publicKey: e5 });
    if (await I3({ authKey: r26, aptosConfig: n18 })) {
      let u15 = r26.derivedAddress();
      return o16.fromPrivateKey({ privateKey: t30, address: u15, legacy: false });
    }
    let c14 = c3.fromPublicKey({ publicKey: e5.publicKey });
    if (await I3({ authKey: c14, aptosConfig: n18 })) {
      let u15 = c14.derivedAddress();
      return o16.fromPrivateKey({ privateKey: t30, address: u15, legacy: true });
    }
  }
  throw new Error(`Can't derive account from private key ${t30}`);
}
async function I3(o26) {
  let { aptosConfig: n18, authKey: t30 } = o26, e5 = await L5({ aptosConfig: n18, authenticationKey: t30.derivedAddress() });
  try {
    return await R4({ aptosConfig: n18, accountAddress: e5 }), true;
  } catch (r26) {
    if (r26.status === 404) return false;
    throw new Error(`Error while looking for an account info ${e5.toString()}`);
  }
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-2RCCHNYU.mjs
var Y2 = new TextEncoder();
function sn(n18) {
  return (n18 == null ? void 0 : n18.map((e5) => l2(e5) ? j3(e5) : e5)) ?? [];
}
async function W3(n18, e5, t30, u15) {
  let r26 = await Z({ aptosConfig: u15, accountAddress: n18, moduleName: e5 });
  if (r26.abi) return r26.abi.exposed_functions.find((o26) => o26.name === t30);
}
async function fn(n18, e5, t30, u15) {
  let r26 = await W3(n18, e5, t30, u15);
  if (!r26) throw new Error(`Could not find entry function ABI for '${n18}::${e5}::${t30}'`);
  if (!r26.is_entry) throw new Error(`'${n18}::${e5}::${t30}' is not an entry function`);
  let o26 = W(r26), T11 = [];
  for (let f16 = o26; f16 < r26.params.length; f16 += 1) T11.push(j3(r26.params[f16], { allowGenerics: true }));
  return { signers: o26, typeParameters: r26.generic_type_params, parameters: T11 };
}
async function on(n18, e5, t30, u15) {
  let r26 = await W3(n18, e5, t30, u15);
  if (!r26) throw new Error(`Could not find view function ABI for '${n18}::${e5}::${t30}'`);
  if (!r26.is_view) throw new Error(`'${n18}::${e5}::${t30}' is not an view function`);
  let o26 = [];
  for (let f16 = 0; f16 < r26.params.length; f16 += 1) o26.push(j3(r26.params[f16], { allowGenerics: true }));
  let T11 = [];
  for (let f16 = 0; f16 < r26.return.length; f16 += 1) T11.push(j3(r26.return[f16], { allowGenerics: true }));
  return { typeParameters: r26.generic_type_params, parameters: o26, returnTypes: T11 };
}
function cn(n18, e5, t30, u15, r26) {
  if (u15 >= e5.parameters.length) throw new Error(`Too many arguments for '${n18}', expected ${e5.parameters.length}`);
  let o26 = e5.parameters[u15];
  return U9(t30, o26, u15, r26);
}
function U9(n18, e5, t30, u15) {
  return $(n18) ? (p8(e5, n18, t30), n18) : Z2(n18, e5, t30, u15);
}
function Z2(n18, e5, t30, u15) {
  if (e5.isBool()) {
    if (D(n18)) return new d2(n18);
    if (l2(n18)) {
      if (n18 === "true") return new d2(true);
      if (n18 === "false") return new d2(false);
    }
    R("boolean", t30);
  }
  if (e5.isAddress()) {
    if (l2(n18)) return d.fromString(n18);
    R("string | AccountAddress", t30);
  }
  if (e5.isU8()) {
    let r26 = P(n18);
    if (r26 !== void 0) return new U2(r26);
    R("number | string", t30);
  }
  if (e5.isU16()) {
    let r26 = P(n18);
    if (r26 !== void 0) return new p(r26);
    R("number | string", t30);
  }
  if (e5.isU32()) {
    let r26 = P(n18);
    if (r26 !== void 0) return new b(r26);
    R("number | string", t30);
  }
  if (e5.isU64()) {
    if (w(n18)) return new y(BigInt(n18));
    R("bigint | number | string", t30);
  }
  if (e5.isU128()) {
    if (w(n18)) return new m(BigInt(n18));
    R("bigint | number | string", t30);
  }
  if (e5.isU256()) {
    if (w(n18)) return new B2(BigInt(n18));
    R("bigint | number | string", t30);
  }
  if (e5.isGeneric()) {
    let r26 = e5.value;
    if (r26 < 0 || r26 >= u15.length) throw new Error(`Generic argument ${e5.toString()} is invalid for argument ${t30}`);
    return U9(n18, u15[r26], t30, u15);
  }
  if (e5.isVector()) {
    if (e5.value.isU8()) {
      if (l2(n18)) return t3.U8(Y2.encode(n18));
      if (n18 instanceof Uint8Array) return t3.U8(n18);
      if (n18 instanceof ArrayBuffer) return t3.U8(new Uint8Array(n18));
    }
    if (Array.isArray(n18)) return new t3(n18.map((r26) => U9(r26, e5.value, t30, u15)));
    throw new Error(`Type mismatch for argument ${t30}, type '${e5.toString()}'`);
  }
  if (e5.isStruct()) {
    if (e5.isString()) {
      if (l2(n18)) return new a2(n18);
      R("string", t30);
    }
    if (e5.isObject()) {
      if (l2(n18)) return d.fromString(n18);
      R("string | AccountAddress", t30);
    }
    if (e5.isOption()) {
      if (G(n18)) {
        let r26 = e5.value.typeArgs[0];
        return r26 instanceof c ? new z2(null) : r26 instanceof S2 ? new z2(null) : r26 instanceof u2 ? new z2(null) : r26 instanceof d4 ? new z2(null) : r26 instanceof g3 ? new z2(null) : r26 instanceof p2 ? new z2(null) : r26 instanceof z3 ? new z2(null) : r26 instanceof T2 ? new z2(null) : new z2(null);
      }
      return new z2(U9(n18, e5.value.typeArgs[0], t30, u15));
    }
    throw new Error(`Unsupported struct input type for argument ${t30}, type '${e5.toString()}'`);
  }
  throw new Error(`Type mismatch for argument ${t30}, type '${e5.toString()}'`);
}
function p8(n18, e5, t30) {
  if (n18.isBool()) {
    if (T(e5)) return;
    R("Bool", t30);
  }
  if (n18.isAddress()) {
    if (E(e5)) return;
    R("AccountAddress", t30);
  }
  if (n18.isU8()) {
    if (B3(e5)) return;
    R("U8", t30);
  }
  if (n18.isU16()) {
    if (U3(e5)) return;
    R("U16", t30);
  }
  if (n18.isU32()) {
    if (b2(e5)) return;
    R("U32", t30);
  }
  if (n18.isU64()) {
    if (I(e5)) return;
    R("U64", t30);
  }
  if (n18.isU128()) {
    if (v(e5)) return;
    R("U128", t30);
  }
  if (n18.isU256()) {
    if (h2(e5)) return;
    R("U256", t30);
  }
  if (n18.isVector()) {
    if (e5 instanceof t3) {
      e5.values.length > 0 && p8(n18.value, e5.values[0], t30);
      return;
    }
    R("MoveVector", t30);
  }
  if (n18 instanceof b3) {
    if (n18.isString()) {
      if (x(e5)) return;
      R("MoveString", t30);
    }
    if (n18.isObject()) {
      if (E(e5)) return;
      R("AccountAddress", t30);
    }
    if (n18.isOption()) {
      if (e5 instanceof z2) {
        e5.value !== void 0 && p8(n18.value.typeArgs[0], e5.value, t30);
        return;
      }
      R("MoveOption", t30);
    }
  }
  throw new Error(`Type mismatch for argument ${t30}, expected '${n18.toString()}'`);
}

// node_modules/js-base64/base64.mjs
var _hasBuffer = typeof Buffer === "function";
var _TD = typeof TextDecoder === "function" ? new TextDecoder() : void 0;
var _TE = typeof TextEncoder === "function" ? new TextEncoder() : void 0;
var b64ch = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
var b64chs = Array.prototype.slice.call(b64ch);
var b64tab = ((a24) => {
  let tab = {};
  a24.forEach((c14, i47) => tab[c14] = i47);
  return tab;
})(b64chs);
var b64re = /^(?:[A-Za-z\d+\/]{4})*?(?:[A-Za-z\d+\/]{2}(?:==)?|[A-Za-z\d+\/]{3}=?)?$/;
var _fromCC = String.fromCharCode.bind(String);
var _U8Afrom = typeof Uint8Array.from === "function" ? Uint8Array.from.bind(Uint8Array) : (it) => new Uint8Array(Array.prototype.slice.call(it, 0));
var _tidyB64 = (s12) => s12.replace(/[^A-Za-z0-9\+\/]/g, "");
var re_btou = /[\xC0-\xDF][\x80-\xBF]|[\xE0-\xEF][\x80-\xBF]{2}|[\xF0-\xF7][\x80-\xBF]{3}/g;
var cb_btou = (cccc) => {
  switch (cccc.length) {
    case 4:
      var cp = (7 & cccc.charCodeAt(0)) << 18 | (63 & cccc.charCodeAt(1)) << 12 | (63 & cccc.charCodeAt(2)) << 6 | 63 & cccc.charCodeAt(3), offset = cp - 65536;
      return _fromCC((offset >>> 10) + 55296) + _fromCC((offset & 1023) + 56320);
    case 3:
      return _fromCC((15 & cccc.charCodeAt(0)) << 12 | (63 & cccc.charCodeAt(1)) << 6 | 63 & cccc.charCodeAt(2));
    default:
      return _fromCC((31 & cccc.charCodeAt(0)) << 6 | 63 & cccc.charCodeAt(1));
  }
};
var btou = (b11) => b11.replace(re_btou, cb_btou);
var atobPolyfill = (asc) => {
  asc = asc.replace(/\s+/g, "");
  if (!b64re.test(asc))
    throw new TypeError("malformed base64.");
  asc += "==".slice(2 - (asc.length & 3));
  let u24, bin = "", r1, r26;
  for (let i47 = 0; i47 < asc.length; ) {
    u24 = b64tab[asc.charAt(i47++)] << 18 | b64tab[asc.charAt(i47++)] << 12 | (r1 = b64tab[asc.charAt(i47++)]) << 6 | (r26 = b64tab[asc.charAt(i47++)]);
    bin += r1 === 64 ? _fromCC(u24 >> 16 & 255) : r26 === 64 ? _fromCC(u24 >> 16 & 255, u24 >> 8 & 255) : _fromCC(u24 >> 16 & 255, u24 >> 8 & 255, u24 & 255);
  }
  return bin;
};
var _atob = typeof atob === "function" ? (asc) => atob(_tidyB64(asc)) : _hasBuffer ? (asc) => Buffer.from(asc, "base64").toString("binary") : atobPolyfill;
var _toUint8Array = _hasBuffer ? (a24) => _U8Afrom(Buffer.from(a24, "base64")) : (a24) => _U8Afrom(_atob(a24).split("").map((c14) => c14.charCodeAt(0)));
var _decode = _hasBuffer ? (a24) => Buffer.from(a24, "base64").toString("utf8") : _TD ? (a24) => _TD.decode(_toUint8Array(a24)) : (a24) => btou(_atob(a24));
var _unURI = (a24) => _tidyB64(a24.replace(/[-_]/g, (m0) => m0 == "-" ? "+" : "/"));
var decode = (src) => _decode(_unURI(src));

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-YTQVMLFD.mjs
async function c9(o26) {
  return new Promise((e5) => {
    setTimeout(e5, o26);
  });
}
var d15 = () => Math.floor(Date.now() / 1e3);
function i37(o26) {
  let e5 = new Date(o26 * 1e3);
  return e5.setMinutes(0), e5.setSeconds(0), e5.setMilliseconds(0), Math.floor(e5.getTime() / 1e3);
}
function u10(o26) {
  let e5 = o26.replace(/-/g, "+").replace(/_/g, "/"), n18 = e5 + "==".substring(0, (3 - e5.length % 3) % 3);
  return decode(n18);
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-FETZGNB3.mjs
async function H(o26) {
  let { aptosConfig: n18, options: t30 } = o26;
  return A4({ aptosConfig: n18, originMethod: "getTransactions", path: "transactions", params: { start: t30 == null ? void 0 : t30.offset, limit: t30 == null ? void 0 : t30.limit } });
}
async function G3(o26) {
  let { aptosConfig: n18 } = o26;
  return m9(async () => {
    let { data: t30 } = await m3({ aptosConfig: n18, originMethod: "getGasPriceEstimation", path: "estimate_gas_price" });
    return t30;
  }, `gas-price-${n18.network}`, 1e3 * 60 * 5)();
}
async function W4(o26) {
  let { aptosConfig: n18, ledgerVersion: t30 } = o26, { data: s12 } = await m3({ aptosConfig: n18, originMethod: "getTransactionByVersion", path: `transactions/by_version/${t30}` });
  return s12;
}
async function y9(o26) {
  let { aptosConfig: n18, transactionHash: t30 } = o26, { data: s12 } = await m3({ aptosConfig: n18, path: `transactions/by_hash/${t30}`, originMethod: "getTransactionByHash" });
  return s12;
}
async function O4(o26) {
  let { aptosConfig: n18, transactionHash: t30 } = o26;
  try {
    return (await y9({ aptosConfig: n18, transactionHash: t30 })).type === "pending_transaction";
  } catch (s12) {
    if ((s12 == null ? void 0 : s12.status) === 404) return true;
    throw s12;
  }
}
async function R5(o26) {
  let { aptosConfig: n18, transactionHash: t30 } = o26, { data: s12 } = await m3({ aptosConfig: n18, path: `transactions/wait_by_hash/${t30}`, originMethod: "longWaitForTransaction" });
  return s12;
}
async function q3(o26) {
  let { aptosConfig: n18, transactionHash: t30, options: s12 } = o26, r26 = (s12 == null ? void 0 : s12.timeoutSecs) ?? 20, u15 = (s12 == null ? void 0 : s12.checkSuccess) ?? true, e5 = true, p13 = 0, i47, g10, l19 = 200, h17 = 1.5;
  function c14(a24) {
    if (!(a24 instanceof n7) || (g10 = a24, a24.status !== 404 && a24.status >= 400 && a24.status < 500)) throw a24;
  }
  try {
    i47 = await y9({ aptosConfig: n18, transactionHash: t30 }), e5 = i47.type === "pending_transaction";
  } catch (a24) {
    c14(a24);
  }
  if (e5) {
    let a24 = Date.now();
    try {
      i47 = await R5({ aptosConfig: n18, transactionHash: t30 }), e5 = i47.type === "pending_transaction";
    } catch (w5) {
      c14(w5);
    }
    p13 = (Date.now() - a24) / 1e3;
  }
  for (; e5 && !(p13 >= r26); ) {
    try {
      if (i47 = await y9({ aptosConfig: n18, transactionHash: t30 }), e5 = i47.type === "pending_transaction", !e5) break;
    } catch (a24) {
      c14(a24);
    }
    await c9(l19), p13 += l19 / 1e3, l19 *= h17;
  }
  if (i47 === void 0) throw g10 || new m10(`Fetching transaction ${t30} failed and timed out after ${r26} seconds`, i47);
  if (i47.type === "pending_transaction") throw new m10(`Transaction ${t30} timed out in pending state after ${r26} seconds`, i47);
  if (!u15) return i47;
  if (!i47.success) throw new T8(`Transaction ${t30} failed with an error: ${i47.vm_status}`, i47);
  return i47;
}
async function z6(o26) {
  let { aptosConfig: n18, processorType: t30 } = o26, s12 = BigInt(o26.minimumLedgerVersion), r26 = 3e3, u15 = (/* @__PURE__ */ new Date()).getTime(), e5 = BigInt(-1);
  for (; e5 < s12; ) {
    if ((/* @__PURE__ */ new Date()).getTime() - u15 > r26) throw new Error("waitForLastSuccessIndexerVersionSync timeout");
    if (t30 === void 0 ? e5 = await h5({ aptosConfig: n18 }) : e5 = (await T4({ aptosConfig: n18, processorType: t30 })).last_success_version, e5 >= s12) break;
    await c9(200);
  }
}
var m10 = class extends Error {
  constructor(n18, t30) {
    super(n18), this.lastSubmittedTransaction = t30;
  }
};
var T8 = class extends Error {
  constructor(n18, t30) {
    super(n18), this.transaction = t30;
  }
};
async function U10(o26) {
  let { aptosConfig: n18, ledgerVersion: t30, options: s12 } = o26, { data: r26 } = await m3({ aptosConfig: n18, originMethod: "getBlockByVersion", path: `blocks/by_version/${t30}`, params: { with_transactions: s12 == null ? void 0 : s12.withTransactions } });
  return P3({ block: r26, ...o26 });
}
async function X(o26) {
  let { aptosConfig: n18, blockHeight: t30, options: s12 } = o26, { data: r26 } = await m3({ aptosConfig: n18, originMethod: "getBlockByHeight", path: `blocks/by_height/${t30}`, params: { with_transactions: s12 == null ? void 0 : s12.withTransactions } });
  return P3({ block: r26, ...o26 });
}
async function P3(o26) {
  let { aptosConfig: n18, block: t30, options: s12 } = o26;
  if (s12 == null ? void 0 : s12.withTransactions) {
    t30.transactions = t30.transactions ?? [];
    let r26 = t30.transactions[t30.transactions.length - 1], u15 = BigInt(t30.first_version), e5 = BigInt(t30.last_version), p13 = r26 == null ? void 0 : r26.version, i47;
    if (p13 === void 0 ? i47 = u15 - 1n : i47 = BigInt(p13), i47 === e5) return t30;
    let g10 = [], l19 = 100n;
    for (let c14 = i47 + 1n; c14 < e5; c14 += BigInt(100)) g10.push(H({ aptosConfig: n18, options: { offset: c14, limit: Math.min(Number(l19), Number(e5 - c14 + 1n)) } }));
    let h17 = await Promise.all(g10);
    for (let c14 of h17) t30.transactions.push(...c14);
  }
  return t30;
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-76HTG7Z7.mjs
var o17 = class t23 extends B {
  constructor(e5, s12, r26) {
    super(), this.rawTransaction = e5, this.feePayerAddress = r26, this.secondarySignerAddresses = s12;
  }
  serialize(e5) {
    this.rawTransaction.serialize(e5), e5.serializeVector(this.secondarySignerAddresses), this.feePayerAddress === void 0 ? e5.serializeBool(false) : (e5.serializeBool(true), this.feePayerAddress.serialize(e5));
  }
  static deserialize(e5) {
    let s12 = t16.deserialize(e5), r26 = e5.deserializeVector(d), c14 = e5.deserializeBool(), a24;
    return c14 && (a24 = d.deserialize(e5)), new t23(s12, r26, a24);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ITMW7GWH.mjs
var n13 = class extends B {
  static deserialize(e5) {
    let r26 = e5.deserializeUleb128AsU32();
    switch (r26) {
      case 0:
        return o18.load(e5);
      case 1:
        return d16.load(e5);
      case 2:
        return u11.load(e5);
      case 3:
        return l12.load(e5);
      case 4:
        return A10.load(e5);
      default:
        throw new Error(`Unknown variant index for TransactionAuthenticator: ${r26}`);
    }
  }
};
var o18 = class s6 extends n13 {
  constructor(e5, r26) {
    super(), this.public_key = e5, this.signature = r26;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(0), this.public_key.serialize(e5), this.signature.serialize(e5);
  }
  static load(e5) {
    let r26 = m6.deserialize(e5), t30 = h8.deserialize(e5);
    return new s6(r26, t30);
  }
};
var d16 = class s7 extends n13 {
  constructor(e5, r26) {
    super(), this.public_key = e5, this.signature = r26;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(1), this.public_key.serialize(e5), this.signature.serialize(e5);
  }
  static load(e5) {
    let r26 = d11.deserialize(e5), t30 = y7.deserialize(e5);
    return new s7(r26, t30);
  }
};
var u11 = class s8 extends n13 {
  constructor(e5, r26, t30) {
    super(), this.sender = e5, this.secondary_signer_addresses = r26, this.secondary_signers = t30;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(2), this.sender.serialize(e5), e5.serializeVector(this.secondary_signer_addresses), e5.serializeVector(this.secondary_signers);
  }
  static load(e5) {
    let r26 = r23.deserialize(e5), t30 = e5.deserializeVector(d), c14 = e5.deserializeVector(r23);
    return new s8(r26, t30, c14);
  }
};
var l12 = class s9 extends n13 {
  constructor(e5, r26, t30, c14) {
    super(), this.sender = e5, this.secondary_signer_addresses = r26, this.secondary_signers = t30, this.fee_payer = c14;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(3), this.sender.serialize(e5), e5.serializeVector(this.secondary_signer_addresses), e5.serializeVector(this.secondary_signers), this.fee_payer.address.serialize(e5), this.fee_payer.authenticator.serialize(e5);
  }
  static load(e5) {
    let r26 = r23.deserialize(e5), t30 = e5.deserializeVector(d), c14 = e5.deserializeVector(r23), _8 = d.deserialize(e5), z8 = r23.deserialize(e5), S8 = { address: _8, authenticator: z8 };
    return new s9(r26, t30, c14, S8);
  }
};
var A10 = class s10 extends n13 {
  constructor(e5) {
    super(), this.sender = e5;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(4), this.sender.serialize(e5);
  }
  static load(e5) {
    let r26 = r23.deserialize(e5);
    return new s10(r26);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-N3PNKHCQ.mjs
var n14 = class o19 extends B {
  constructor(t30, a24) {
    super(), this.raw_txn = t30, this.authenticator = a24;
  }
  serialize(t30) {
    this.raw_txn.serialize(t30), this.authenticator.serialize(t30);
  }
  static deserialize(t30) {
    let a24 = t16.deserialize(t30), s12 = n13.deserialize(t30);
    return new o19(a24, s12);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZXPBRVOA.mjs
var o20 = class t24 extends B {
  constructor(e5, r26) {
    super(), this.rawTransaction = e5, this.feePayerAddress = r26;
  }
  serialize(e5) {
    this.rawTransaction.serialize(e5), this.feePayerAddress === void 0 ? e5.serializeBool(false) : (e5.serializeBool(true), this.feePayerAddress.serialize(e5));
  }
  static deserialize(e5) {
    let r26 = t16.deserialize(e5), d20 = e5.deserializeBool(), s12;
    return d20 && (s12 = d.deserialize(e5)), new t24(r26, s12);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WV5AD4IE.mjs
function t25(i47, r26) {
  let l19 = r26.bcsToBytes(), a24 = new n10(l19);
  return i47.deserialize(a24);
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-SCHZ67F3.mjs
var s11 = { mainnet: "https://api.mainnet.aptoslabs.com/v1/graphql", testnet: "https://api.testnet.aptoslabs.com/v1/graphql", devnet: "https://api.devnet.aptoslabs.com/v1/graphql", local: "http://127.0.0.1:8090/v1/graphql" };
var o21 = { mainnet: "https://api.mainnet.aptoslabs.com/v1", testnet: "https://api.testnet.aptoslabs.com/v1", devnet: "https://api.devnet.aptoslabs.com/v1", local: "http://127.0.0.1:8080/v1" };
var p9 = { mainnet: "https://faucet.mainnet.aptoslabs.com", testnet: "https://faucet.testnet.aptoslabs.com", devnet: "https://faucet.devnet.aptoslabs.com", local: "http://127.0.0.1:8081" };
var a19 = { mainnet: "https://api.mainnet.aptoslabs.com/keyless/pepper/v0", testnet: "https://api.testnet.aptoslabs.com/keyless/pepper/v0", devnet: "https://api.devnet.aptoslabs.com/keyless/pepper/v0", local: "https://api.devnet.aptoslabs.com/keyless/pepper/v0" };
var n15 = { mainnet: "https://api.mainnet.aptoslabs.com/keyless/prover/v0", testnet: "https://api.testnet.aptoslabs.com/keyless/prover/v0", devnet: "https://api.devnet.aptoslabs.com/keyless/prover/v0", local: "https://api.devnet.aptoslabs.com/keyless/prover/v0" };
var e3 = ((t30) => (t30.MAINNET = "mainnet", t30.TESTNET = "testnet", t30.DEVNET = "devnet", t30.LOCAL = "local", t30.CUSTOM = "custom", t30))(e3 || {});
var r24 = { mainnet: 1, testnet: 2, local: 4 };
var c10 = { mainnet: "mainnet", testnet: "testnet", devnet: "devnet", local: "local", custom: "custom" };

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-XCBLFSY5.mjs
async function vn(n18) {
  if (O(n18)) return yn(n18);
  let { moduleAddress: t30, moduleName: e5, functionName: i47 } = L(n18.function), a24 = await on2({ key: "entry-function", moduleAddress: t30, moduleName: e5, functionName: i47, aptosConfig: n18.aptosConfig, abi: n18.abi, fetch: fn });
  return mn({ ...n18, abi: a24 });
}
function mn(n18) {
  let t30 = n18.abi, { moduleAddress: e5, moduleName: i47, functionName: a24 } = L(n18.function), r26 = sn(n18.typeArguments);
  if (r26.length !== t30.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${t30.typeParameters.length}, received ${r26.length}`);
  let o26 = n18.functionArguments.map((s12, d20) => cn(n18.function, t30, s12, d20, r26));
  if (o26.length !== t30.parameters.length) throw new Error(`Too few arguments for '${e5}::${i47}::${a24}', expected ${t30.parameters.length} but got ${o26.length}`);
  let c14 = l6.build(`${e5}::${i47}`, a24, r26, o26);
  if ("multisigAddress" in n18) {
    let s12 = d.from(n18.multisigAddress);
    return new h6(new f3(s12, new b6(c14)));
  }
  return new z4(c14);
}
async function Kn(n18) {
  let { moduleAddress: t30, moduleName: e5, functionName: i47 } = L(n18.function), a24 = await on2({ key: "view-function", moduleAddress: t30, moduleName: e5, functionName: i47, aptosConfig: n18.aptosConfig, abi: n18.abi, fetch: on });
  return An({ abi: a24, ...n18 });
}
function An(n18) {
  var _a;
  let t30 = n18.abi, { moduleAddress: e5, moduleName: i47, functionName: a24 } = L(n18.function), r26 = sn(n18.typeArguments);
  if (r26.length !== t30.typeParameters.length) throw new Error(`Type argument count mismatch, expected ${t30.typeParameters.length}, received ${r26.length}`);
  let o26 = ((_a = n18 == null ? void 0 : n18.functionArguments) == null ? void 0 : _a.map((c14, s12) => cn(n18.function, t30, c14, s12, r26))) ?? [];
  if (o26.length !== t30.parameters.length) throw new Error(`Too few arguments for '${e5}::${i47}::${a24}', expected ${t30.parameters.length} but got ${o26.length}`);
  return l6.build(`${e5}::${i47}`, a24, r26, o26);
}
function yn(n18) {
  return new A5(new U5(i.fromHexInput(n18.bytecode).toUint8Array(), sn(n18.typeArguments), n18.functionArguments));
}
async function fn2(n18) {
  let { aptosConfig: t30, sender: e5, payload: i47, options: a24, feePayerAddress: r26 } = n18, o26 = async () => r24[t30.network] ? { chainId: r24[t30.network] } : { chainId: (await d7({ aptosConfig: t30 })).chain_id }, c14 = async () => (a24 == null ? void 0 : a24.gasUnitPrice) ? { gasEstimate: a24.gasUnitPrice } : { gasEstimate: (await G3({ aptosConfig: t30 })).gas_estimate }, s12 = async () => {
    let g10 = async () => (a24 == null ? void 0 : a24.accountSequenceNumber) !== void 0 ? a24.accountSequenceNumber : (await R4({ aptosConfig: t30, accountAddress: e5 })).sequence_number;
    if (r26 && d.from(r26).equals(d.ZERO)) try {
      return await g10();
    } catch {
      return 0;
    }
    else return g10();
  }, [{ chainId: d20 }, { gasEstimate: m15 }, w5] = await Promise.all([o26(), c14(), s12()]), { maxGasAmount: sn2, gasUnitPrice: cn2, expireTimestamp: un } = { maxGasAmount: (a24 == null ? void 0 : a24.maxGasAmount) ? BigInt(a24.maxGasAmount) : BigInt(2e5), gasUnitPrice: (a24 == null ? void 0 : a24.gasUnitPrice) ?? BigInt(m15), expireTimestamp: (a24 == null ? void 0 : a24.expireTimestamp) ?? BigInt(Math.floor(Date.now() / 1e3) + 20) };
  return new t16(d.from(e5), BigInt(w5), i47, BigInt(sn2), BigInt(cn2), BigInt(un), new r5(d20));
}
async function On(n18) {
  var _a;
  let { aptosConfig: t30, sender: e5, payload: i47, options: a24, feePayerAddress: r26 } = n18, o26 = await fn2({ aptosConfig: t30, sender: e5, payload: i47, options: a24, feePayerAddress: r26 });
  if ("secondarySignerAddresses" in n18) {
    let c14 = ((_a = n18.secondarySignerAddresses) == null ? void 0 : _a.map((s12) => d.from(s12))) ?? [];
    return new o17(o26, c14, n18.feePayerAddress ? d.from(n18.feePayerAddress) : void 0);
  }
  return new o20(o26, n18.feePayerAddress ? d.from(n18.feePayerAddress) : void 0);
}
function Vn(n18) {
  let { signerPublicKey: t30, transaction: e5, secondarySignersPublicKeys: i47, feePayerPublicKey: a24 } = n18, r26 = h12(t30);
  if (e5.feePayerAddress) {
    let c14 = new p4(e5.rawTransaction, e5.secondarySignerAddresses ?? [], e5.feePayerAddress), s12 = [];
    i47 && (s12 = i47.map((w5) => h12(w5)));
    let d20 = h12(a24), m15 = new l12(r26, e5.secondarySignerAddresses ?? [], s12, { address: e5.feePayerAddress, authenticator: d20 });
    return new n14(c14.raw_txn, m15).bcsToBytes();
  }
  if (e5.secondarySignerAddresses) {
    let c14 = new u5(e5.rawTransaction, e5.secondarySignerAddresses), s12 = [];
    s12 = i47.map((m15) => h12(m15));
    let d20 = new u11(r26, e5.secondarySignerAddresses, s12);
    return new n14(c14.raw_txn, d20).bcsToBytes();
  }
  let o26;
  if (r26 instanceof u9) o26 = new o18(r26.public_key, r26.signature);
  else if (r26 instanceof n12) o26 = new A10(r26);
  else throw new Error("Invalid public key");
  return new n14(e5.rawTransaction, o26).bcsToBytes();
}
function h12(n18) {
  let t30 = new h8(new Uint8Array(64));
  if (m6.isInstance(n18)) return new u9(n18, t30);
  if (f8.isInstance(n18)) return A9.isInstance(n18.publicKey) ? new n12(n18, new l9(D5.getSimulationSignature())) : new n12(n18, new l9(t30));
  if (A9.isInstance(n18) || u7.isInstance(n18)) return console.warn("Expected AccountPublicKey, but got PublicKey. Please wrap your public key with AnyPublicKey."), new n12(new f8(n18), new l9(t30));
  throw new Error("Unsupported public key");
}
function gn(n18) {
  let { transaction: t30, feePayerAuthenticator: e5, additionalSignersAuthenticators: i47 } = n18, a24 = t25(r23, n18.senderAuthenticator), r26;
  if (t30.feePayerAddress) {
    if (!e5) throw new Error("Must provide a feePayerAuthenticator argument to generate a signed fee payer transaction");
    r26 = new l12(a24, t30.secondarySignerAddresses ?? [], i47 ?? [], { address: t30.feePayerAddress, authenticator: e5 });
  } else if (t30.secondarySignerAddresses) {
    if (!i47) throw new Error("Must provide a additionalSignersAuthenticators argument to generate a signed multi agent transaction");
    r26 = new u11(a24, t30.secondarySignerAddresses, i47);
  } else a24 instanceof u9 ? r26 = new o18(a24.public_key, a24.signature) : r26 = new A10(a24);
  return new n14(t30.rawTransaction, r26).bcsToBytes();
}
function rn(n18) {
  let t30 = sha3_256.create();
  for (let e5 of n18) t30.update(e5);
  return t30.digest();
}
var pn = rn(["APTOS::Transaction"]);
function qn(n18) {
  let t30 = gn(n18);
  return new i(rn([pn, new Uint8Array([0]), t30])).toString();
}
async function on2({ key: n18, moduleAddress: t30, moduleName: e5, functionName: i47, aptosConfig: a24, abi: r26, fetch: o26 }) {
  return r26 !== void 0 ? r26 : m9(async () => o26(t30, e5, i47, a24), `${n18}-${a24.network}-${t30}-${e5}-${i47}`, 1e3 * 60 * 5)();
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-XUT73RUR.mjs
var S6 = 1209600;
var i38 = class i39 extends B {
  constructor(e5) {
    super();
    let { privateKey: r26, expiryDateSecs: a24, blinder: n18 } = e5;
    this.privateKey = r26, this.publicKey = new c4(r26.publicKey()), this.expiryDateSecs = a24 || i37(d15() + S6), this.blinder = n18 !== void 0 ? i.fromHexInput(n18).toUint8Array() : v4();
    let t30 = T7(this.publicKey.bcsToBytes(), 93);
    t30.push(BigInt(this.expiryDateSecs)), t30.push(L3(this.blinder));
    let x10 = k3(t30);
    this.nonce = x10.toString();
  }
  getPublicKey() {
    return this.publicKey;
  }
  isExpired() {
    return Math.floor(Date.now() / 1e3) > this.expiryDateSecs;
  }
  serialize(e5) {
    e5.serializeU32AsUleb128(this.publicKey.variant), e5.serializeBytes(this.privateKey.toUint8Array()), e5.serializeU64(this.expiryDateSecs), e5.serializeFixedBytes(this.blinder);
  }
  static deserialize(e5) {
    let r26 = e5.deserializeUleb128AsU32(), a24;
    switch (r26) {
      case 0:
        a24 = U7.deserialize(e5);
        break;
      default:
        throw new Error(`Unknown variant index for EphemeralPublicKey: ${r26}`);
    }
    let n18 = e5.deserializeU64(), t30 = e5.deserializeFixedBytes(31);
    return new i39({ privateKey: a24, expiryDateSecs: Number(n18), blinder: t30 });
  }
  static fromBytes(e5) {
    return i39.deserialize(new n10(e5));
  }
  static generate(e5) {
    let r26;
    switch (e5 == null ? void 0 : e5.scheme) {
      case 0:
      default:
        r26 = U7.generate();
    }
    return new i39({ privateKey: r26, expiryDateSecs: e5 == null ? void 0 : e5.expiryDateSecs });
  }
  sign(e5) {
    if (this.isExpired()) throw new Error("EphemeralKeyPair has expired");
    return new p5(this.privateKey.sign(e5));
  }
};
i38.BLINDER_LENGTH = 31;
var o22 = i38;
function v4() {
  return randomBytes(o22.BLINDER_LENGTH);
}

// node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_index.default;

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WS2XAD7R.mjs
var o23 = class o24 extends B {
  constructor(e5) {
    super();
    let { address: r26, ephemeralKeyPair: t30, uidKey: i47, uidVal: a24, aud: c14, pepper: p13, proof: n18, proofFetchCallback: s12, jwt: l19 } = e5;
    if (this.ephemeralKeyPair = t30, this.publicKey = A9.create(e5), this.accountAddress = r26 ? d.from(r26) : this.publicKey.authKey().derivedAddress(), this.uidKey = i47, this.uidVal = a24, this.aud = c14, this.jwt = l19, this.emitter = new eventemitter3_default(), this.proofOrPromise = n18, n18 instanceof S5) this.proof = n18;
    else {
      if (s12 === void 0) throw new Error("Must provide callback for async proof fetch");
      this.emitter.on("proofFetchFinish", async (u15) => {
        await s12(u15), this.emitter.removeAllListeners();
      }), this.init(n18);
    }
    this.signingScheme = 2;
    let h17 = i.fromHexInput(p13).toUint8Array();
    if (h17.length !== o24.PEPPER_LENGTH) throw new Error(`Pepper length in bytes should be ${o24.PEPPER_LENGTH}`);
    this.pepper = h17;
  }
  async init(e5) {
    try {
      this.proof = await e5, this.emitter.emit("proofFetchFinish", { status: "Success" });
    } catch (r26) {
      r26 instanceof Error ? this.emitter.emit("proofFetchFinish", { status: "Failed", error: r26.toString() }) : this.emitter.emit("proofFetchFinish", { status: "Failed", error: "Unknown" });
    }
  }
  serialize(e5) {
    if (e5.serializeStr(this.jwt), e5.serializeStr(this.uidKey), e5.serializeFixedBytes(this.pepper), this.ephemeralKeyPair.serialize(e5), this.proof === void 0) throw new Error("Connot serialize - proof undefined");
    this.proof.serialize(e5);
  }
  static deserialize(e5) {
    let r26 = e5.deserializeStr(), t30 = e5.deserializeStr(), i47 = e5.deserializeFixedBytes(31), a24 = o22.deserialize(e5), c14 = S5.deserialize(e5);
    return o24.create({ proof: c14, pepper: i47, uidKey: t30, jwt: r26, ephemeralKeyPair: a24 });
  }
  isExpired() {
    return this.ephemeralKeyPair.isExpired();
  }
  signWithAuthenticator(e5) {
    let r26 = new l9(this.sign(e5)), t30 = new f8(this.publicKey);
    return new n12(t30, r26);
  }
  signTransactionWithAuthenticator(e5) {
    let r26 = new l9(this.signTransaction(e5)), t30 = new f8(this.publicKey);
    return new n12(t30, r26);
  }
  async waitForProofFetch() {
    this.proofOrPromise instanceof Promise && await this.proofOrPromise;
  }
  sign(e5) {
    let { expiryDateSecs: r26 } = this.ephemeralKeyPair;
    if (this.isExpired()) throw new Error("EphemeralKeyPair is expired");
    if (this.proof === void 0) throw new Error("Proof not defined");
    let t30 = this.ephemeralKeyPair.getPublicKey(), i47 = this.ephemeralKeyPair.sign(e5);
    return new D5({ jwtHeader: u10(this.jwt.split(".")[0]), ephemeralCertificate: new h10(this.proof, 0), expiryDateSecs: r26, ephemeralPublicKey: t30, ephemeralSignature: i47 });
  }
  signTransaction(e5) {
    if (this.proof === void 0) throw new Error("Proof not found");
    let r26 = d8(e5), i47 = new P4(r26, this.proof.proof).hash();
    return this.sign(i47);
  }
  verifySignature(e5) {
    let { message: r26, signature: t30 } = e5;
    return !(this.isExpired() || !this.ephemeralKeyPair.getPublicKey().verifySignature({ message: r26, signature: t30.ephemeralSignature }));
  }
  static fromBytes(e5) {
    return o24.deserialize(new n10(e5));
  }
  static create(e5) {
    let { address: r26, proof: t30, jwt: i47, ephemeralKeyPair: a24, pepper: c14, uidKey: p13 = "sub", proofFetchCallback: n18 } = e5, s12 = jwtDecode(i47), l19 = s12.iss;
    if (typeof s12.aud != "string") throw new Error("aud was not found or an array of values");
    let h17 = s12.aud, u15 = s12[p13];
    return new o24({ address: r26, proof: t30, ephemeralKeyPair: a24, iss: l19, uidKey: p13, uidVal: u15, aud: h17, pepper: c14, jwt: i47, proofFetchCallback: n18 });
  }
};
o23.PEPPER_LENGTH = 31;
var k4 = o23;
var P4 = class extends B {
  constructor(r26, t30) {
    super();
    this.domainSeparator = "APTOS::TransactionAndProof";
    this.transaction = r26, this.proof = t30;
  }
  serialize(r26) {
    r26.serializeFixedBytes(this.transaction.bcsToBytes()), r26.serializeOption(this.proof);
  }
  hash() {
    return n9(this.bcsToBytes(), this.domainSeparator);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-C3DUPBSO.mjs
var l13 = class a20 {
  constructor(i47) {
    let { multiKey: s12, signers: e5 } = i47;
    this.publicKey = s12, this.signingScheme = 3, this.accountAddress = this.publicKey.authKey().derivedAddress();
    let r26 = [];
    for (let t30 of e5) r26.push(this.publicKey.getIndex(t30.publicKey));
    let n18 = e5.map((t30, c14) => [t30, r26[c14]]);
    n18.sort((t30, c14) => t30[1] - c14[1]), this.signers = n18.map((t30) => t30[0]), this.signerIndicies = n18.map((t30) => t30[1]), this.signaturesBitmap = this.publicKey.createBitmap({ bits: r26 });
  }
  static fromPublicKeysAndSigners(i47) {
    let { publicKeys: s12, signaturesRequired: e5, signers: r26 } = i47, n18 = new f9({ publicKeys: s12, signaturesRequired: e5 });
    return new a20({ multiKey: n18, signers: r26 });
  }
  static isMultiKeySigner(i47) {
    return i47 instanceof a20;
  }
  signWithAuthenticator(i47) {
    return new a16(this.publicKey, this.sign(i47));
  }
  signTransactionWithAuthenticator(i47) {
    return new a16(this.publicKey, this.signTransaction(i47));
  }
  async waitForProofFetch() {
    let s12 = this.signers.filter((e5) => e5 instanceof k4).map(async (e5) => e5.waitForProofFetch());
    await Promise.all(s12);
  }
  sign(i47) {
    let s12 = [];
    for (let e5 of this.signers) s12.push(e5.sign(i47));
    return new p7({ signatures: s12, bitmap: this.signaturesBitmap });
  }
  signTransaction(i47) {
    let s12 = [];
    for (let e5 of this.signers) s12.push(e5.signTransaction(i47));
    return new p7({ signatures: s12, bitmap: this.signaturesBitmap });
  }
  verifySignature(i47) {
    let { message: s12, signature: e5 } = i47;
    if (!this.signerIndicies.every((n18, t30) => t30 === 0 || n18 >= this.signerIndicies[t30 - 1])) return false;
    for (let n18 = 0; n18 < e5.signatures.length; n18 += 1) {
      let t30 = e5.signatures[n18];
      if (!this.publicKey.publicKeys[this.signerIndicies[n18]].verifySignature({ message: s12, signature: t30 })) return false;
    }
    return true;
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-HKMG3LZX.mjs
var c11 = class extends B {
  constructor(e5) {
    super();
    this.accountAddress = d.ONE;
    this.moduleName = new a2("account");
    this.structName = new a2("RotationProofChallenge");
    this.sequenceNumber = new y(e5.sequenceNumber), this.originator = e5.originator, this.currentAuthKey = e5.currentAuthKey, this.newPublicKey = t3.U8(e5.newPublicKey.toUint8Array());
  }
  serialize(e5) {
    e5.serialize(this.accountAddress), e5.serialize(this.moduleName), e5.serialize(this.structName), e5.serialize(this.sequenceNumber), e5.serialize(this.originator), e5.serialize(this.currentAuthKey), e5.serialize(this.newPublicKey);
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GG2DBDJT.mjs
async function h13(t30) {
  let a24 = await D6(t30);
  return G4(t30, a24);
}
async function D6(t30) {
  let { aptosConfig: a24, data: n18 } = t30, e5, o26;
  return "bytecode" in n18 ? o26 = await vn(n18) : "multisigAddress" in n18 ? (e5 = { aptosConfig: a24, multisigAddress: n18.multisigAddress, function: n18.function, functionArguments: n18.functionArguments, typeArguments: n18.typeArguments, abi: n18.abi }, o26 = await vn(e5)) : (e5 = { aptosConfig: a24, function: n18.function, functionArguments: n18.functionArguments, typeArguments: n18.typeArguments, abi: n18.abi }, o26 = await vn(e5)), o26;
}
async function G4(t30, a24) {
  let { aptosConfig: n18, sender: e5, options: o26 } = t30, i47;
  if (K2(t30) && (i47 = d.ZERO.toString()), U11(t30)) {
    let { secondarySignerAddresses: c14 } = t30;
    return On({ aptosConfig: n18, sender: e5, payload: a24, options: o26, secondarySignerAddresses: c14, feePayerAddress: i47 });
  }
  return On({ aptosConfig: n18, sender: e5, payload: a24, options: o26, feePayerAddress: i47 });
}
function K2(t30) {
  return t30.withFeePayer === true;
}
function U11(t30) {
  return "secondarySignerAddresses" in t30;
}
function Y3(t30) {
  let { transaction: a24 } = t30;
  return S4(a24);
}
function _5(t30) {
  let { signer: a24, transaction: n18 } = t30;
  return a24.signTransactionWithAuthenticator(n18);
}
async function $5(t30) {
  var _a, _b, _c;
  let { aptosConfig: a24, transaction: n18, signerPublicKey: e5, secondarySignersPublicKeys: o26, feePayerPublicKey: i47, options: c14 } = t30, u15 = Vn({ transaction: n18, signerPublicKey: e5, secondarySignersPublicKeys: o26, feePayerPublicKey: i47, options: c14 }), { data: m15 } = await q2({ aptosConfig: a24, body: u15, path: "transactions/simulate", params: { estimate_gas_unit_price: ((_a = t30.options) == null ? void 0 : _a.estimateGasUnitPrice) ?? false, estimate_max_gas_amount: ((_b = t30.options) == null ? void 0 : _b.estimateMaxGasAmount) ?? false, estimate_prioritized_gas_unit_price: ((_c = t30.options) == null ? void 0 : _c.estimatePrioritizedGasUnitPrice) ?? false }, originMethod: "simulateTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return m15;
}
async function B6(t30) {
  let { aptosConfig: a24 } = t30, n18 = gn({ ...t30 }), { data: e5 } = await q2({ aptosConfig: a24, body: n18, path: "transactions", originMethod: "submitTransaction", contentType: "application/x.aptos.signed_transaction+bcs" });
  return e5;
}
async function M(t30) {
  let { aptosConfig: a24, signer: n18, transaction: e5 } = t30;
  (n18 instanceof k4 || n18 instanceof l13) && await n18.waitForProofFetch();
  let o26 = _5({ signer: n18, transaction: e5 });
  return B6({ aptosConfig: a24, transaction: e5, senderAuthenticator: o26 });
}
var N3 = { typeParameters: [], parameters: [y2.u8(), new y2(y2.u8())] };
async function nn(t30) {
  let { aptosConfig: a24, account: n18, metadataBytes: e5, moduleBytecode: o26, options: i47 } = t30, c14 = o26.map((u15) => t3.U8(u15));
  return h13({ aptosConfig: a24, sender: d.from(n18), data: { function: "0x1::code::publish_package_txn", functionArguments: [t3.U8(e5), new t3(c14)], abi: N3 }, options: i47 });
}
var F3 = { typeParameters: [], parameters: [new u2(), y2.u8(), new u2(), y2.u8(), y2.u8(), y2.u8()] };
async function tn(t30) {
  let { aptosConfig: a24, fromAccount: n18, toNewPrivateKey: e5 } = t30, o26 = await R4({ aptosConfig: a24, accountAddress: n18.accountAddress }), i47 = o16.fromPrivateKey({ privateKey: e5, legacy: true }), u15 = new c11({ sequenceNumber: BigInt(o26.sequence_number), originator: n18.accountAddress, currentAuthKey: d.from(o26.authentication_key), newPublicKey: i47.publicKey }).bcsToBytes(), m15 = n18.sign(u15), R7 = i47.sign(u15), x10 = await h13({ aptosConfig: a24, sender: n18.accountAddress, data: { function: "0x1::account::rotate_authentication_key", functionArguments: [new U2(n18.signingScheme), t3.U8(n18.publicKey.toUint8Array()), new U2(i47.signingScheme), t3.U8(i47.publicKey.toUint8Array()), t3.U8(m15.toUint8Array()), t3.U8(R7.toUint8Array())], abi: F3 } });
  return M({ aptosConfig: a24, signer: n18, transaction: x10 });
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-T4BJCVCN.mjs
var i40 = class {
  constructor(n18) {
    this.config = n18;
  }
  async simple(n18) {
    return $5({ aptosConfig: this.config, ...n18 });
  }
  async multiAgent(n18) {
    return $5({ aptosConfig: this.config, ...n18 });
  }
};
j([u], i40.prototype, "simple", 1), j([u], i40.prototype, "multiAgent", 1);

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GP4FRPJQ.mjs
var n16 = class {
  constructor(t30) {
    this.config = t30;
  }
  async simple(t30) {
    return B6({ aptosConfig: this.config, ...t30 });
  }
  async multiAgent(t30) {
    return B6({ aptosConfig: this.config, ...t30 });
  }
};
j([o], n16.prototype, "simple", 1), j([o], n16.prototype, "multiAgent", 1);

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-2RO27Y23.mjs
var o25 = class {
  constructor(n18) {
    this.config = n18;
  }
  async simple(n18) {
    return h13({ aptosConfig: this.config, ...n18 });
  }
  async multiAgent(n18) {
    return h13({ aptosConfig: this.config, ...n18 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-IWBYKVXH.mjs
var r25 = class {
  constructor(t30, i47, o26, a24, c14) {
    this.lastUncommintedNumber = null;
    this.currentNumber = null;
    this.lock = false;
    this.aptosConfig = t30, this.account = i47, this.maxWaitTime = o26, this.maximumInFlight = a24, this.sleepTime = c14;
  }
  async nextSequenceNumber() {
    for (; this.lock; ) await c9(this.sleepTime);
    this.lock = true;
    let t30 = BigInt(0);
    try {
      if ((this.lastUncommintedNumber === null || this.currentNumber === null) && await this.initialize(), this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight) {
        await this.update();
        let i47 = d15();
        for (; this.currentNumber - this.lastUncommintedNumber >= this.maximumInFlight; ) await c9(this.sleepTime), d15() - i47 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : await this.update();
      }
      t30 = this.currentNumber, this.currentNumber += BigInt(1);
    } catch (i47) {
      console.error("error in getting next sequence number for this account", i47);
    } finally {
      this.lock = false;
    }
    return t30;
  }
  async initialize() {
    let { sequence_number: t30 } = await R4({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    this.currentNumber = BigInt(t30), this.lastUncommintedNumber = BigInt(t30);
  }
  async update() {
    let { sequence_number: t30 } = await R4({ aptosConfig: this.aptosConfig, accountAddress: this.account.accountAddress });
    return this.lastUncommintedNumber = BigInt(t30), this.lastUncommintedNumber;
  }
  async synchronize() {
    if (this.lastUncommintedNumber !== this.currentNumber) {
      for (; this.lock; ) await c9(this.sleepTime);
      this.lock = true;
      try {
        await this.update();
        let t30 = d15();
        for (; this.lastUncommintedNumber !== this.currentNumber; ) d15() - t30 > this.maxWaitTime ? (console.warn(`Waited over 30 seconds for a transaction to commit, resyncing ${this.account.accountAddress.toString()}`), await this.initialize()) : (await c9(this.sleepTime), await this.update());
      } catch (t30) {
        console.error("error in synchronizing this account sequence number with the one on chain", t30);
      } finally {
        this.lock = false;
      }
    }
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-U6Z4FNB7.mjs
var i41 = class {
  constructor() {
    this.queue = [];
    this.pendingDequeue = [];
    this.cancelled = false;
  }
  enqueue(e5) {
    var _a;
    if (this.cancelled = false, this.pendingDequeue.length > 0) {
      (_a = this.pendingDequeue.shift()) == null ? void 0 : _a.resolve(e5);
      return;
    }
    this.queue.push(e5);
  }
  async dequeue() {
    return this.queue.length > 0 ? Promise.resolve(this.queue.shift()) : new Promise((e5, u15) => {
      this.pendingDequeue.push({ resolve: e5, reject: u15 });
    });
  }
  isEmpty() {
    return this.queue.length === 0;
  }
  cancel() {
    this.cancelled = true, this.pendingDequeue.forEach(async ({ reject: e5 }) => {
      e5(new n17("Task cancelled"));
    }), this.pendingDequeue = [], this.queue.length = 0;
  }
  isCancelled() {
    return this.cancelled;
  }
  pendingDequeueLength() {
    return this.pendingDequeue.length;
  }
};
var n17 = class extends Error {
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-D3M72WFO.mjs
var m11 = "fulfilled";
var f11 = ((n18) => (n18.TransactionSent = "transactionSent", n18.TransactionSendFailed = "transactionSendFailed", n18.TransactionExecuted = "transactionExecuted", n18.TransactionExecutionFailed = "transactionExecutionFailed", n18.ExecutionFinish = "executionFinish", n18))(f11 || {});
var p10 = class extends eventemitter3_default {
  constructor(t30, e5, a24 = 30, n18 = 100, i47 = 10) {
    super();
    this.taskQueue = new i41();
    this.transactionsQueue = new i41();
    this.outstandingTransactions = new i41();
    this.sentTransactions = [];
    this.executedTransactions = [];
    this.aptosConfig = t30, this.account = e5, this.started = false, this.accountSequnceNumber = new r25(t30, e5, a24, n18, i47);
  }
  async submitNextTransaction() {
    try {
      for (; ; ) {
        let t30 = await this.accountSequnceNumber.nextSequenceNumber();
        if (t30 === null) return;
        let e5 = await this.generateNextTransaction(this.account, t30);
        if (!e5) return;
        let a24 = M({ aptosConfig: this.aptosConfig, transaction: e5, signer: this.account });
        await this.outstandingTransactions.enqueue([a24, t30]);
      }
    } catch (t30) {
      if (t30 instanceof n17) return;
      throw new Error(`Submit transaction failed for ${this.account.accountAddress.toString()} with error ${t30}`);
    }
  }
  async processTransactions() {
    try {
      for (; ; ) {
        let t30 = [], e5 = [], [a24, n18] = await this.outstandingTransactions.dequeue();
        for (t30.push(a24), e5.push(n18); !this.outstandingTransactions.isEmpty(); ) [a24, n18] = await this.outstandingTransactions.dequeue(), t30.push(a24), e5.push(n18);
        let i47 = await Promise.allSettled(t30);
        for (let s12 = 0; s12 < i47.length && s12 < e5.length; s12 += 1) {
          let r26 = i47[s12];
          n18 = e5[s12], r26.status === m11 ? (this.sentTransactions.push([r26.value.hash, n18, null]), this.emit("transactionSent", { message: `transaction hash ${r26.value.hash} has been committed to chain`, transactionHash: r26.value.hash }), await this.checkTransaction(r26, n18)) : (this.sentTransactions.push([r26.status, n18, r26.reason]), this.emit("transactionSendFailed", { message: `failed to commit transaction ${this.sentTransactions.length} with error ${r26.reason}`, error: r26.reason }));
        }
        this.emit("executionFinish", { message: `execute ${i47.length} transactions finished` });
      }
    } catch (t30) {
      if (t30 instanceof n17) return;
      throw new Error(`Process execution failed for ${this.account.accountAddress.toString()} with error ${t30}`);
    }
  }
  async checkTransaction(t30, e5) {
    try {
      let a24 = [];
      a24.push(q3({ aptosConfig: this.aptosConfig, transactionHash: t30.value.hash }));
      let n18 = await Promise.allSettled(a24);
      for (let i47 = 0; i47 < n18.length; i47 += 1) {
        let s12 = n18[i47];
        s12.status === m11 ? (this.executedTransactions.push([s12.value.hash, e5, null]), this.emit("transactionExecuted", { message: `transaction hash ${s12.value.hash} has been executed on chain`, transactionHash: t30.value.hash })) : (this.executedTransactions.push([s12.status, e5, s12.reason]), this.emit("transactionExecutionFailed", { message: `failed to execute transaction ${this.executedTransactions.length} with error ${s12.reason}`, error: s12.reason }));
      }
    } catch (a24) {
      throw new Error(`Check transaction failed for ${this.account.accountAddress.toString()} with error ${a24}`);
    }
  }
  async push(t30, e5) {
    this.transactionsQueue.enqueue([t30, e5]);
  }
  async generateNextTransaction(t30, e5) {
    if (this.transactionsQueue.isEmpty()) return;
    let [a24, n18] = await this.transactionsQueue.dequeue();
    return h13({ aptosConfig: this.aptosConfig, sender: t30.accountAddress, data: a24, options: { ...n18, accountSequenceNumber: e5 } });
  }
  async run() {
    try {
      for (; !this.taskQueue.isCancelled(); ) await (await this.taskQueue.dequeue())();
    } catch (t30) {
      throw new Error(`Unable to start transaction batching: ${t30}`);
    }
  }
  start() {
    if (this.started) throw new Error("worker has already started");
    this.started = true, this.taskQueue.enqueue(() => this.submitNextTransaction()), this.taskQueue.enqueue(() => this.processTransactions()), this.run();
  }
  stop() {
    if (this.taskQueue.isCancelled()) throw new Error("worker has already stopped");
    this.started = false, this.taskQueue.cancel();
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-H2QJOKSW.mjs
var i42 = class extends eventemitter3_default {
  constructor(t30) {
    super(), this.config = t30;
  }
  start(t30) {
    let { sender: n18 } = t30;
    this.account = n18, this.transactionWorker = new p10(this.config, n18), this.transactionWorker.start(), this.registerToEvents();
  }
  push(t30) {
    let { data: n18, options: o26 } = t30;
    for (let r26 of n18) this.transactionWorker.push(r26, o26);
  }
  registerToEvents() {
    this.transactionWorker.on("transactionSent", async (t30) => {
      this.emit("transactionSent", t30);
    }), this.transactionWorker.on("transactionSendFailed", async (t30) => {
      this.emit("transactionSendFailed", t30);
    }), this.transactionWorker.on("transactionExecuted", async (t30) => {
      this.emit("transactionExecuted", t30);
    }), this.transactionWorker.on("transactionExecutionFailed", async (t30) => {
      this.emit("transactionExecutionFailed", t30);
    }), this.transactionWorker.on("executionFinish", async (t30) => {
      this.emit("executionFinish", t30);
    });
  }
  forSingleAccount(t30) {
    try {
      let { sender: n18, data: o26, options: r26 } = t30;
      this.start({ sender: n18 }), this.push({ data: o26, options: r26 });
    } catch (n18) {
      throw new Error(`failed to submit transactions with error: ${n18}`);
    }
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-EC3JEZIB.mjs
var h14 = class {
  constructor(n18) {
    this.config = n18, this.build = new o25(this.config), this.simulate = new i40(this.config), this.submit = new n16(this.config), this.batch = new i42(this.config);
  }
  async getTransactions(n18) {
    return H({ aptosConfig: this.config, ...n18 });
  }
  async getTransactionByVersion(n18) {
    return W4({ aptosConfig: this.config, ...n18 });
  }
  async getTransactionByHash(n18) {
    return y9({ aptosConfig: this.config, ...n18 });
  }
  async isPendingTransaction(n18) {
    return O4({ aptosConfig: this.config, ...n18 });
  }
  async waitForTransaction(n18) {
    return q3({ aptosConfig: this.config, ...n18 });
  }
  async getGasPriceEstimation() {
    return G3({ aptosConfig: this.config });
  }
  getSigningMessage(n18) {
    return Y3(n18);
  }
  async publishPackageTransaction(n18) {
    return nn({ aptosConfig: this.config, ...n18 });
  }
  async rotateAuthKey(n18) {
    return tn({ aptosConfig: this.config, ...n18 });
  }
  sign(n18) {
    return _5({ ...n18 });
  }
  signAsFeePayer(n18) {
    let { signer: t30, transaction: o26 } = n18;
    if (!o26.feePayerAddress) throw new Error(`Transaction ${o26} is not a Fee Payer transaction`);
    return o26.feePayerAddress = t30.accountAddress, _5({ signer: t30, transaction: o26 });
  }
  async batchTransactionsForSingleAccount(n18) {
    try {
      let { sender: t30, data: o26, options: P7 } = n18;
      this.batch.forSingleAccount({ sender: t30, data: o26, options: P7 });
    } catch (t30) {
      throw new Error(`failed to submit transactions with error: ${t30}`);
    }
  }
  async signAndSubmitTransaction(n18) {
    let { signer: t30, transaction: o26 } = n18;
    return M({ aptosConfig: this.config, signer: t30, transaction: o26 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GTFAH6VB.mjs
async function x7(a24) {
  let { aptosConfig: t30, accountAddress: i47, amount: p13, options: n18 } = a24, u15 = (n18 == null ? void 0 : n18.timeoutSecs) || 20, { data: d20 } = await m4({ aptosConfig: t30, path: "fund", body: { address: d.from(i47).toString(), amount: p13 }, originMethod: "fundAccount" }), m15 = d20.txn_hashes[0], o26 = await q3({ aptosConfig: t30, transactionHash: m15, options: { timeoutSecs: u15, checkSuccess: n18 == null ? void 0 : n18.checkSuccess } });
  if (o26.type === "user_transaction") return o26;
  throw new Error(`Unexpected transaction received for fund account: ${o26.type}`);
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-GIKRKT5B.mjs
var i43 = class {
  constructor(o26) {
    this.config = o26;
  }
  async fundAccount(o26) {
    var _a, _b;
    let n18 = await x7({ aptosConfig: this.config, ...o26 });
    return (((_a = o26.options) == null ? void 0 : _a.waitForIndexer) === void 0 || ((_b = o26.options) == null ? void 0 : _b.waitForIndexer)) && await z6({ aptosConfig: this.config, minimumLedgerVersion: BigInt(n18.version), processorType: "fungible_asset_processor" }), n18;
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LN2AM5IU.mjs
async function G5(t30) {
  let { aptosConfig: s12, options: e5 } = t30, n18 = { query: h4, variables: { where_condition: e5 == null ? void 0 : e5.where, limit: e5 == null ? void 0 : e5.limit, offset: e5 == null ? void 0 : e5.offset } };
  return (await a5({ aptosConfig: s12, query: n18, originMethod: "getFungibleAssetMetadata" })).fungible_asset_metadata;
}
async function h15(t30) {
  let { aptosConfig: s12, options: e5 } = t30, n18 = { query: f, variables: { where_condition: e5 == null ? void 0 : e5.where, limit: e5 == null ? void 0 : e5.limit, offset: e5 == null ? void 0 : e5.offset } };
  return (await a5({ aptosConfig: s12, query: n18, originMethod: "getFungibleAssetActivities" })).fungible_asset_activities;
}
async function M2(t30) {
  let { aptosConfig: s12, options: e5 } = t30, n18 = { query: b4, variables: { where_condition: e5 == null ? void 0 : e5.where, limit: e5 == null ? void 0 : e5.limit, offset: e5 == null ? void 0 : e5.offset } };
  return (await a5({ aptosConfig: s12, query: n18, originMethod: "getCurrentFungibleAssetBalances" })).current_fungible_asset_balances;
}
var b8 = { typeParameters: [{ constraints: [] }], parameters: [j3("0x1::object::Object"), new S2(), new p2()] };
async function x8(t30) {
  let { aptosConfig: s12, sender: e5, fungibleAssetMetadataAddress: n18, recipient: i47, amount: l19, options: f16 } = t30;
  return h13({ aptosConfig: s12, sender: e5.accountAddress, data: { function: "0x1::primary_fungible_store::transfer", typeArguments: ["0x1::fungible_asset::Metadata"], functionArguments: [n18, i47, l19], abi: b8 }, options: f16 });
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-MRT63YLE.mjs
async function i44(o26) {
  o26.minimumLedgerVersion !== void 0 && await z6({ aptosConfig: o26.config, minimumLedgerVersion: o26.minimumLedgerVersion, processorType: o26.processorType });
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-RXK5BSD6.mjs
var a21 = class {
  constructor(e5) {
    this.config = e5;
  }
  async getFungibleAssetMetadata(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5 == null ? void 0 : e5.minimumLedgerVersion, processorType: "fungible_asset_processor" }), G5({ aptosConfig: this.config, ...e5 });
  }
  async getFungibleAssetMetadataByAssetType(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5 == null ? void 0 : e5.minimumLedgerVersion, processorType: "fungible_asset_processor" }), (await G5({ aptosConfig: this.config, options: { where: { asset_type: { _eq: e5.assetType } } } }))[0];
  }
  async getFungibleAssetMetadataByCreatorAddress(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5 == null ? void 0 : e5.minimumLedgerVersion, processorType: "fungible_asset_processor" }), await G5({ aptosConfig: this.config, options: { where: { creator_address: { _eq: d.from(e5.creatorAddress).toStringLong() } } } });
  }
  async getFungibleAssetActivities(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5 == null ? void 0 : e5.minimumLedgerVersion, processorType: "fungible_asset_processor" }), h15({ aptosConfig: this.config, ...e5 });
  }
  async getCurrentFungibleAssetBalances(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5 == null ? void 0 : e5.minimumLedgerVersion, processorType: "fungible_asset_processor" }), M2({ aptosConfig: this.config, ...e5 });
  }
  async transferFungibleAsset(e5) {
    return x8({ aptosConfig: this.config, ...e5 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-IEGY7WEL.mjs
async function F4(n18) {
  let { aptosConfig: e5, payload: o26, options: t30 } = n18, i47 = await Kn({ ...o26, aptosConfig: e5 }), r26 = new n3();
  i47.serialize(r26);
  let u15 = r26.toUint8Array(), { data: d20 } = await q2({ aptosConfig: e5, path: "view", originMethod: "view", contentType: "application/x.aptos.view_function+bcs", params: { ledger_version: t30 == null ? void 0 : t30.ledgerVersion }, body: u15 });
  return d20;
}
async function M3(n18) {
  let { aptosConfig: e5, payload: o26, options: t30 } = n18, { data: i47 } = await q2({ aptosConfig: e5, originMethod: "viewJson", path: "view", params: { ledger_version: t30 == null ? void 0 : t30.ledgerVersion }, body: { function: o26.function, type_arguments: o26.typeArguments ?? [], arguments: o26.functionArguments ?? [] } });
  return i47;
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-3UV2Z2A4.mjs
var p11 = class {
  constructor(o26) {
    this.config = o26;
  }
  async getLedgerInfo() {
    return d7({ aptosConfig: this.config });
  }
  async getChainId() {
    return (await this.getLedgerInfo()).chain_id;
  }
  async getBlockByVersion(o26) {
    return U10({ aptosConfig: this.config, ...o26 });
  }
  async getBlockByHeight(o26) {
    return X({ aptosConfig: this.config, ...o26 });
  }
  async view(o26) {
    return F4({ aptosConfig: this.config, ...o26 });
  }
  async viewJson(o26) {
    return M3({ aptosConfig: this.config, ...o26 });
  }
  async getChainTopUserTransactions(o26) {
    return C3({ aptosConfig: this.config, ...o26 });
  }
  async queryIndexer(o26) {
    return a5({ aptosConfig: this.config, ...o26 });
  }
  async getIndexerLastSuccessVersion() {
    return h5({ aptosConfig: this.config });
  }
  async getProcessorStatus(o26) {
    return T4({ aptosConfig: this.config, processorType: o26 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-JCPI7D7I.mjs
async function A11(o26) {
  let { aptosConfig: n18, jwt: s12, ephemeralKeyPair: e5, uidKey: r26 = "sub", derivationPath: i47 } = o26, t30 = { jwt_b64: s12, epk: e5.getPublicKey().bcsToHex().toStringWithoutPrefix(), exp_date_secs: e5.expiryDateSecs, epk_blinder: i.fromHexInput(e5.blinder).toStringWithoutPrefix(), uid_key: r26, derivation_path: i47 }, { data: a24 } = await E3({ aptosConfig: n18, path: "fetch", body: t30, originMethod: "getPepper", overrides: { WITH_CREDENTIALS: false } });
  return i.fromHexInput(a24.pepper).toUint8Array();
}
async function E7(o26) {
  let { aptosConfig: n18, jwt: s12, ephemeralKeyPair: e5, pepper: r26 = await A11(o26), uidKey: i47 = "sub" } = o26;
  if (i.fromHexInput(r26).toUint8Array().length !== k4.PEPPER_LENGTH) throw new Error(`Pepper needs to be ${k4.PEPPER_LENGTH} bytes`);
  let { maxExpHorizonSecs: t30 } = await be({ aptosConfig: n18 });
  if (t30 < e5.expiryDateSecs - d15()) throw Error(`The EphemeralKeyPair is too long lived.  It's lifespan must be less than ${t30}`);
  let a24 = { jwt_b64: s12, epk: e5.getPublicKey().bcsToHex().toStringWithoutPrefix(), epk_blinder: i.fromHexInput(e5.blinder).toStringWithoutPrefix(), exp_date_secs: e5.expiryDateSecs, exp_horizon_secs: t30, pepper: i.fromHexInput(r26).toStringWithoutPrefix(), uid_key: i47 }, { data: f16 } = await a4({ aptosConfig: n18, path: "prove", body: a24, originMethod: "getProof", overrides: { WITH_CREDENTIALS: false } }), c14 = f16.proof, u15 = new g8({ a: c14.a, b: c14.b, c: c14.c });
  return new S5({ proof: new f7(u15, 0), trainingWheelsSignature: p5.fromHex(f16.training_wheels_signature), expHorizonSecs: t30 });
}
async function W5(o26) {
  let { aptosConfig: n18, jwt: s12, uidKey: e5, proofFetchCallback: r26, pepper: i47 = await A11(o26) } = o26, t30 = E7({ ...o26, pepper: i47 }), a24 = r26 ? t30 : await t30, f16 = A9.fromJwtAndPepper({ jwt: s12, pepper: i47, uidKey: e5 }), c14 = await L5({ aptosConfig: n18, authenticationKey: f16.authKey().derivedAddress() });
  return k4.create({ ...o26, address: c14, proof: a24, pepper: i47, proofFetchCallback: r26 });
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-OMIBMVDW.mjs
var i45 = class {
  constructor(e5) {
    this.config = e5;
  }
  async getPepper(e5) {
    return A11({ aptosConfig: this.config, ...e5 });
  }
  async getProof(e5) {
    return E7({ aptosConfig: this.config, ...e5 });
  }
  async deriveKeylessAccount(e5) {
    return W5({ aptosConfig: this.config, ...e5 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-AW2ARPK4.mjs
async function d17(e5) {
  let { aptosConfig: o26, options: t30 } = e5, r26 = { query: v2, variables: { where_condition: t30 == null ? void 0 : t30.where, offset: t30 == null ? void 0 : t30.offset, limit: t30 == null ? void 0 : t30.limit, order_by: t30 == null ? void 0 : t30.orderBy } };
  return (await a5({ aptosConfig: o26, query: r26, originMethod: "getObjectData" })).current_objects;
}
async function f12(e5) {
  let { aptosConfig: o26, objectAddress: t30, options: r26 } = e5, c14 = { object_address: { _eq: d.from(t30).toStringLong() } };
  return (await d17({ aptosConfig: o26, options: { ...r26, where: c14 } }))[0];
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-LHJBQVU4.mjs
var t26 = class {
  constructor(e5) {
    this.config = e5;
  }
  async getObjectDataByObjectAddress(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "objects_processor" }), f12({ aptosConfig: this.config, ...e5 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-VWGU7IB6.mjs
async function m12(e5) {
  let { aptosConfig: t30, poolAddress: o26 } = e5, r26 = d.from(o26).toStringLong(), i47 = await a5({ aptosConfig: t30, query: { query: w2, variables: { where_condition: { pool_address: { _eq: r26 } } } } });
  return i47.num_active_delegator_per_pool[0] ? i47.num_active_delegator_per_pool[0].num_active_delegator : 0;
}
async function f13(e5) {
  let { aptosConfig: t30, options: o26 } = e5, r26 = { query: w2, variables: { order_by: o26 == null ? void 0 : o26.orderBy } };
  return (await a5({ aptosConfig: t30, query: r26 })).num_active_delegator_per_pool;
}
async function A12(e5) {
  let { aptosConfig: t30, delegatorAddress: o26, poolAddress: r26 } = e5, a24 = { query: $3, variables: { delegatorAddress: d.from(o26).toStringLong(), poolAddress: d.from(r26).toStringLong() } };
  return (await a5({ aptosConfig: t30, query: a24 })).delegated_staking_activities;
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-CTRLWMAG.mjs
var t27 = class {
  constructor(e5) {
    this.config = e5;
  }
  async getNumberOfDelegators(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5 == null ? void 0 : e5.minimumLedgerVersion, processorType: "stake_processor" }), m12({ aptosConfig: this.config, ...e5 });
  }
  async getNumberOfDelegatorsForAllPools(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5 == null ? void 0 : e5.minimumLedgerVersion, processorType: "stake_processor" }), f13({ aptosConfig: this.config, ...e5 });
  }
  async getDelegatedStakingActivities(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5 == null ? void 0 : e5.minimumLedgerVersion, processorType: "stake_processor" }), A12({ aptosConfig: this.config, ...e5 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-DLLNBXLZ.mjs
var a22 = class {
  constructor(e5) {
    this.config = e5;
  }
  async getTableItem(e5) {
    return b5({ aptosConfig: this.config, ...e5 });
  }
  async getTableItemsData(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "default_processor" }), f2({ aptosConfig: this.config, ...e5 });
  }
  async getTableItemsMetadata(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "default_processor" }), T5({ aptosConfig: this.config, ...e5 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-R5Y36IYW.mjs
var l14 = class {
  constructor(e5) {
    this.config = e5;
  }
  async getAccountInfo(e5) {
    return R4({ aptosConfig: this.config, ...e5 });
  }
  async getAccountModules(e5) {
    return Y({ aptosConfig: this.config, ...e5 });
  }
  async getAccountModule(e5) {
    return Z({ aptosConfig: this.config, ...e5 });
  }
  async getAccountTransactions(e5) {
    return ee({ aptosConfig: this.config, ...e5 });
  }
  async getAccountResources(e5) {
    return oe({ aptosConfig: this.config, ...e5 });
  }
  async getAccountResource(e5) {
    return x6({ aptosConfig: this.config, ...e5 });
  }
  async lookupOriginalAccountAddress(e5) {
    return L5({ aptosConfig: this.config, ...e5 });
  }
  async getAccountTokensCount(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "account_transactions_processor" }), te({ aptosConfig: this.config, ...e5 });
  }
  async getAccountOwnedTokens(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "token_v2_processor" }), ne({ aptosConfig: this.config, ...e5 });
  }
  async getAccountOwnedTokensFromCollectionAddress(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "token_v2_processor" }), re({ aptosConfig: this.config, ...e5 });
  }
  async getAccountCollectionsWithOwnedTokens(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "token_v2_processor" }), se({ aptosConfig: this.config, ...e5 });
  }
  async getAccountTransactionsCount(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "account_transactions_processor" }), ce({ aptosConfig: this.config, ...e5 });
  }
  async getAccountCoinsData(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "fungible_asset_processor" }), B5({ aptosConfig: this.config, ...e5 });
  }
  async getAccountCoinsCount(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "fungible_asset_processor" }), ae({ aptosConfig: this.config, ...e5 });
  }
  async getAccountAPTAmount(e5) {
    return this.getAccountCoinAmount({ coinType: o9, ...e5 });
  }
  async getAccountCoinAmount(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "fungible_asset_processor" }), ie({ aptosConfig: this.config, ...e5 });
  }
  async getAccountOwnedObjects(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "default_processor" }), de({ aptosConfig: this.config, ...e5 });
  }
  async deriveAccountFromPrivateKey(e5) {
    return ue({ aptosConfig: this.config, ...e5 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-3O7OEDTT.mjs
var T9 = ["A name must be between 3 and 63 characters long,", "and can only contain lowercase a-z, 0-9, and hyphens.", "A name may not start or end with a hyphen."].join(" ");
function D7(e5) {
  return !(!e5 || e5.length < 3 || e5.length > 63 || !/^[a-z\d][a-z\d-]{1,61}[a-z\d]$/.test(e5));
}
function c12(e5) {
  let [t30, n18, ...o26] = e5.replace(/\.apt$/, "").split(".");
  if (o26.length > 0) throw new Error(`${e5} is invalid. A name can only have two parts, a domain and a subdomain separated by a "."`);
  if (!D7(t30)) throw new Error(`${t30} is not valid. ${T9}`);
  if (n18 && !D7(n18)) throw new Error(`${n18} is not valid. ${T9}`);
  return { domainName: n18 || t30, subdomainName: n18 ? t30 : void 0 };
}
var I4 = ((n18) => (n18[n18.Independent = 0] = "Independent", n18[n18.FollowsDomain = 1] = "FollowsDomain", n18))(I4 || {});
function E8(e5) {
  if (!e5) return false;
  let t30 = new Date(e5.domain_expiration_timestamp).getTime() < Date.now(), n18 = new Date(e5.expiration_timestamp).getTime() < Date.now();
  return e5.subdomain && t30 ? false : e5.subdomain && e5.subdomain_expiration_policy === 1 ? true : !n18;
}
var O5 = "0x585fc9f0f0c54183b039ffc770ca282ebd87307916c215a3e692f2f8e4305e82";
var v5 = { testnet: "0x5f8fd2347449685cf41d4db97926ec3a096eaf381332be4f1318ad4d16a8497c", mainnet: "0x867ed1f6bf916171b1de3ee92849b8978b7d1b9e0a8cc982a3d19d535dfd9c0c", local: O5, custom: null, devnet: null };
function d18(e5) {
  let t30 = v5[e5.network];
  if (!t30) throw new Error(`The ANS contract is not deployed to ${e5.network}`);
  return t30;
}
var b9 = (e5) => {
  if (e5 && typeof e5 == "object" && "vec" in e5 && Array.isArray(e5.vec)) return e5.vec[0];
};
async function F5(e5) {
  let { aptosConfig: t30, name: n18 } = e5, o26 = d18(t30), { domainName: r26, subdomainName: s12 } = c12(n18), i47 = await F4({ aptosConfig: t30, payload: { function: `${o26}::router::get_owner_addr`, functionArguments: [r26, s12] } }), a24 = b9(i47[0]);
  return a24 ? d.from(a24) : void 0;
}
async function Y4(e5) {
  let { aptosConfig: t30, expiration: n18, name: o26, sender: r26, targetAddress: s12, toAddress: i47, options: a24, transferable: u15 } = e5, p13 = d18(t30), { domainName: y12, subdomainName: N6 } = c12(o26), x10 = n18.policy === "subdomain:independent" || n18.policy === "subdomain:follow-domain";
  if (N6 && !x10) throw new Error("Subdomains must have an expiration policy of either 'subdomain:independent' or 'subdomain:follow-domain'");
  if (x10 && !N6) throw new Error(`Policy is set to ${n18.policy} but no subdomain was provided`);
  if (n18.policy === "domain") {
    let h17 = n18.years ?? 1;
    if (h17 !== 1) throw new Error("For now, names can only be registered for 1 year at a time");
    let G7 = h17 * 31536e3;
    return await h13({ aptosConfig: t30, sender: r26.accountAddress.toString(), data: { function: `${p13}::router::register_domain`, functionArguments: [y12, G7, s12, i47] }, options: a24 });
  }
  if (!N6) throw new Error(`${n18.policy} requires a subdomain to be provided.`);
  let _8 = await P5({ aptosConfig: t30, name: y12 });
  if (!_8) throw new Error("The domain does not exist");
  let S8 = n18.policy === "subdomain:independent" ? n18.expirationDate : _8;
  if (S8 > _8) throw new Error("The subdomain expiration time cannot be greater than the domain expiration time");
  return await h13({ aptosConfig: t30, sender: r26.accountAddress.toString(), data: { function: `${p13}::router::register_subdomain`, functionArguments: [y12, N6, Math.round(S8 / 1e3), n18.policy === "subdomain:follow-domain" ? 1 : 0, !!u15, s12, i47] }, options: a24 });
}
async function P5(e5) {
  let { aptosConfig: t30, name: n18 } = e5, o26 = d18(t30), { domainName: r26, subdomainName: s12 } = c12(n18);
  try {
    let i47 = await F4({ aptosConfig: t30, payload: { function: `${o26}::router::get_expiration`, functionArguments: [r26, s12] } });
    return Number(i47[0]) * 1e3;
  } catch {
    return;
  }
}
async function K3(e5) {
  let { aptosConfig: t30, address: n18 } = e5, o26 = d18(t30), r26 = await F4({ aptosConfig: t30, payload: { function: `${o26}::router::get_primary_name`, functionArguments: [d.from(n18).toString()] } }), s12 = b9(r26[1]), i47 = b9(r26[0]);
  if (s12) return [i47, s12].filter(Boolean).join(".");
}
async function W6(e5) {
  let { aptosConfig: t30, sender: n18, name: o26, options: r26 } = e5, s12 = d18(t30);
  if (!o26) return await h13({ aptosConfig: t30, sender: n18.accountAddress.toString(), data: { function: `${s12}::router::clear_primary_name`, functionArguments: [] }, options: r26 });
  let { domainName: i47, subdomainName: a24 } = c12(o26);
  return await h13({ aptosConfig: t30, sender: n18.accountAddress.toString(), data: { function: `${s12}::router::set_primary_name`, functionArguments: [i47, a24] }, options: r26 });
}
async function H2(e5) {
  let { aptosConfig: t30, name: n18 } = e5, o26 = d18(t30), { domainName: r26, subdomainName: s12 } = c12(n18), i47 = await F4({ aptosConfig: t30, payload: { function: `${o26}::router::get_target_addr`, functionArguments: [r26, s12] } }), a24 = b9(i47[0]);
  return a24 ? d.from(a24) : void 0;
}
async function J(e5) {
  let { aptosConfig: t30, sender: n18, name: o26, address: r26, options: s12 } = e5, i47 = d18(t30), { domainName: a24, subdomainName: u15 } = c12(o26);
  return await h13({ aptosConfig: t30, sender: n18.accountAddress.toString(), data: { function: `${i47}::router::set_target_addr`, functionArguments: [a24, u15, r26] }, options: s12 });
}
async function X2(e5) {
  let { aptosConfig: t30, name: n18 } = e5, { domainName: o26, subdomainName: r26 = "" } = c12(n18), a24 = (await a5({ aptosConfig: t30, query: { query: G2, variables: { where_condition: { domain: { _eq: o26 }, subdomain: { _eq: r26 } }, limit: 1 } }, originMethod: "getName" })).current_aptos_names[0];
  return a24 && (a24 = l15(a24)), E8(a24) ? a24 : void 0;
}
async function Z3(e5) {
  var _a;
  let { aptosConfig: t30, options: n18, accountAddress: o26 } = e5, r26 = await C5({ aptosConfig: t30 });
  return (await a5({ aptosConfig: t30, originMethod: "getAccountNames", query: { query: G2, variables: { limit: n18 == null ? void 0 : n18.limit, offset: n18 == null ? void 0 : n18.offset, order_by: n18 == null ? void 0 : n18.orderBy, where_condition: { ...((_a = e5.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o26.toString() }, expiration_timestamp: { _gte: r26 } } } } })).current_aptos_names.map(l15);
}
async function ee2(e5) {
  var _a;
  let { aptosConfig: t30, options: n18, accountAddress: o26 } = e5, r26 = await C5({ aptosConfig: t30 });
  return (await a5({ aptosConfig: t30, originMethod: "getAccountDomains", query: { query: G2, variables: { limit: n18 == null ? void 0 : n18.limit, offset: n18 == null ? void 0 : n18.offset, order_by: n18 == null ? void 0 : n18.orderBy, where_condition: { ...((_a = e5.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o26.toString() }, expiration_timestamp: { _gte: r26 }, subdomain: { _eq: "" } } } } })).current_aptos_names.map(l15);
}
async function ne2(e5) {
  var _a;
  let { aptosConfig: t30, options: n18, accountAddress: o26 } = e5, r26 = await C5({ aptosConfig: t30 });
  return (await a5({ aptosConfig: t30, originMethod: "getAccountSubdomains", query: { query: G2, variables: { limit: n18 == null ? void 0 : n18.limit, offset: n18 == null ? void 0 : n18.offset, order_by: n18 == null ? void 0 : n18.orderBy, where_condition: { ...((_a = e5.options) == null ? void 0 : _a.where) ?? {}, owner_address: { _eq: o26.toString() }, expiration_timestamp: { _gte: r26 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(l15);
}
async function te2(e5) {
  var _a;
  let { aptosConfig: t30, options: n18, domain: o26 } = e5;
  return (await a5({ aptosConfig: t30, originMethod: "getDomainSubdomains", query: { query: G2, variables: { limit: n18 == null ? void 0 : n18.limit, offset: n18 == null ? void 0 : n18.offset, order_by: n18 == null ? void 0 : n18.orderBy, where_condition: { ...((_a = e5.options) == null ? void 0 : _a.where) ?? {}, domain: { _eq: o26 }, subdomain: { _neq: "" } } } } })).current_aptos_names.map(l15).filter(E8);
}
async function C5(e5) {
  let { aptosConfig: t30 } = e5, n18 = d18(t30), [o26] = await F4({ aptosConfig: t30, payload: { function: `${n18}::config::reregistration_grace_sec`, functionArguments: [] } }), r26 = o26 / 60 / 60 / 24, s12 = () => /* @__PURE__ */ new Date();
  return new Date(s12().setDate(s12().getDate() - r26)).toISOString();
}
async function oe2(e5) {
  let { aptosConfig: t30, sender: n18, name: o26, years: r26 = 1, options: s12 } = e5, i47 = d18(t30), a24 = r26 * 31536e3, { domainName: u15, subdomainName: p13 } = c12(o26);
  if (p13) throw new Error("Subdomains cannot be renewed");
  if (r26 !== 1) throw new Error("Currently, only 1 year renewals are supported");
  return await h13({ aptosConfig: t30, sender: n18.accountAddress.toString(), data: { function: `${i47}::router::renew_domain`, functionArguments: [u15, a24] }, options: s12 });
}
function l15(e5) {
  return { ...e5, expiration_timestamp: new Date(e5.expiration_timestamp).getTime() };
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WYG7CP3N.mjs
var A13 = class {
  constructor(n18) {
    this.config = n18;
  }
  async getOwnerAddress(n18) {
    return F5({ aptosConfig: this.config, ...n18 });
  }
  async getExpiration(n18) {
    return P5({ aptosConfig: this.config, ...n18 });
  }
  async getTargetAddress(n18) {
    return H2({ aptosConfig: this.config, ...n18 });
  }
  async setTargetAddress(n18) {
    return J({ aptosConfig: this.config, ...n18 });
  }
  async getPrimaryName(n18) {
    return K3({ aptosConfig: this.config, ...n18 });
  }
  async setPrimaryName(n18) {
    return W6({ aptosConfig: this.config, ...n18 });
  }
  async registerName(n18) {
    return Y4({ aptosConfig: this.config, ...n18 });
  }
  async renewDomain(n18) {
    return oe2({ aptosConfig: this.config, ...n18 });
  }
  async getName(n18) {
    return X2({ aptosConfig: this.config, ...n18 });
  }
  async getAccountNames(n18) {
    return Z3({ aptosConfig: this.config, ...n18 });
  }
  async getAccountDomains(n18) {
    return ee2({ aptosConfig: this.config, ...n18 });
  }
  async getAccountSubdomains(n18) {
    return ne2({ aptosConfig: this.config, ...n18 });
  }
  async getDomainSubdomains(n18) {
    return te2({ aptosConfig: this.config, ...n18 });
  }
};

// node_modules/axios/lib/helpers/bind.js
function bind(fn3, thisArg) {
  return function wrap() {
    return fn3.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString } = Object.prototype;
var { getPrototypeOf } = Object;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type) => {
  type = type.toLowerCase();
  return (thing) => kindOf(thing) === type;
};
var typeOfTest = (type) => (thing) => typeof thing === type;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(Symbol.toStringTag in val) && !(Symbol.iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn3, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i47;
  let l19;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i47 = 0, l19 = obj.length; i47 < l19; i47++) {
      fn3.call(null, obj[i47], i47, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i47 = 0; i47 < len; i47++) {
      key = keys[i47];
      fn3.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i47 = keys.length;
  let _key;
  while (i47-- > 0) {
    _key = keys[i47];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject(result[targetKey]) && isPlainObject(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i47 = 0, l19 = arguments.length; i47 < l19; i47++) {
    arguments[i47] && forEach(arguments[i47], assignValue);
  }
  return result;
}
var extend = (a24, b11, thisArg, { allOwnKeys } = {}) => {
  forEach(b11, (val, key) => {
    if (thisArg && isFunction(val)) {
      a24[key] = bind(val, thisArg);
    } else {
      a24[key] = val;
    }
  }, { allOwnKeys });
  return a24;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter2, propFilter) => {
  let props;
  let i47;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i47 = props.length;
    while (i47-- > 0) {
      prop = props[i47];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter2 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter2 || filter2(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i47 = thing.length;
  if (!isNumber(i47)) return null;
  const arr = new Array(i47);
  while (i47-- > 0) {
    arr[i47] = thing[i47];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn3) => {
  const generator = obj && obj[Symbol.iterator];
  const iterator = generator.call(obj);
  let result;
  while ((result = iterator.next()) && !result.done) {
    const pair = result.value;
    fn3.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m15, p1, p22) {
      return p1.toUpperCase() + p22;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
var ALPHA = "abcdefghijklmnopqrstuvwxyz";
var DIGIT = "0123456789";
var ALPHABET = {
  DIGIT,
  ALPHA,
  ALPHA_DIGIT: ALPHA + ALPHA.toUpperCase() + DIGIT
};
var generateString = (size = 16, alphabet2 = ALPHABET.ALPHA_DIGIT) => {
  let str = "";
  const { length } = alphabet2;
  while (size--) {
    str += alphabet2[Math.random() * length | 0];
  }
  return str;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[Symbol.toStringTag] === "FormData" && thing[Symbol.iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i47) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i47] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i47 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i47] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb) => {
      callbacks.push(cb);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb) => setTimeout(cb);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString,
  isNumber,
  isBoolean,
  isObject,
  isPlainObject,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  ALPHABET,
  generateString,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  response && (this.response = response);
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.response && this.response.status ? this.response.status : null
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter2(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path, key, dots) {
  if (!path) return key;
  return path.concat(key).map(function each(token, i47) {
    token = removeBrackets(token);
    return !dots && i47 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path) {
    let arr = value;
    if (value && !path && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el, index) {
          !(utils_default.isUndefined(el) || el === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index, dots) : indexes === null ? key : key + "[]",
            convertValue(el)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el, key) {
      const result = !(utils_default.isUndefined(el) || el === null) && visitor.call(
        formData,
        el,
        utils_default.isString(key) ? key.trim() : key,
        path,
        exposedHelpers
      );
      if (result === true) {
        build(el, path ? path.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString2(encoder) {
  const _encode = encoder ? function(value) {
    return encoder.call(this, value, encode);
  } : encode;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode2(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode2;
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id) {
    if (this.handlers[id]) {
      this.handlers[id] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn3) {
    utils_default.forEach(this.handlers, function forEachHandler(h17) {
      if (h17 !== null) {
        fn3(h17);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports3 = {};
__export(utils_exports3, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var hasStandardBrowserEnv = ((product) => {
  return hasBrowserEnv && ["ReactNative", "NativeScript", "NS"].indexOf(product) < 0;
})(typeof navigator !== "undefined" && navigator.product);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports3,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i47;
  const len = keys.length;
  let key;
  for (i47 = 0; i47 < len; i47++) {
    key = keys[i47];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path, value, target, index) {
    let name = path[index++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index >= path.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path, value, target[name], index);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e5) {
      if (e5.name !== "SyntaxError") {
        throw e5;
      }
    }
  }
  return (encoder || JSON.stringify)(rawValue);
}
var defaults = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e5) {
        if (strictJSONParsing) {
          if (e5.name === "SyntaxError") {
            throw AxiosError_default.from(e5, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e5;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults.headers[method] = {};
});
var defaults_default = defaults;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i47;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i47 = line.indexOf(":");
    key = line.substring(0, i47).trim().toLowerCase();
    val = line.substring(i47 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter2, isHeaderNameFilter) {
  if (utils_default.isFunction(filter2)) {
    return filter2.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter2)) {
    return value.indexOf(filter2) !== -1;
  }
  if (utils_default.isRegExp(filter2)) {
    return filter2.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w5, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isHeaders(header)) {
      for (const [key, value] of header.entries()) {
        setHeader(value, key, rewrite);
      }
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i47 = keys.length;
    let deleted = false;
    while (i47--) {
      const key = keys[i47];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform(fn3) {
    data = fn3.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes2 = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes2[head] = chunkLength;
    timestamps[head] = now;
    let i47 = tail;
    let bytesCount = 0;
    while (i47 !== head) {
      bytesCount += bytes2[i47++];
      i47 = i47 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle(fn3, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn3.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e5) => {
    const loaded = e5.loaded;
    const total = e5.lengthComputable ? e5.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange2 = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange2 ? (total - loaded) / rate : void 0,
      event: e5,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn3) => (...args) => utils_default.asap(() => fn3(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs have full support of the APIs needed to test
  // whether the request URL is of the same origin as current location.
  function standardBrowserEnv() {
    const msie = /(msie|trident)/i.test(navigator.userAgent);
    const urlParsingNode = document.createElement("a");
    let originURL;
    function resolveURL(url) {
      let href = url;
      if (msie) {
        urlParsingNode.setAttribute("href", href);
        href = urlParsingNode.href;
      }
      urlParsingNode.setAttribute("href", href);
      return {
        href: urlParsingNode.href,
        protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, "") : "",
        host: urlParsingNode.host,
        search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, "") : "",
        hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, "") : "",
        hostname: urlParsingNode.hostname,
        port: urlParsingNode.port,
        pathname: urlParsingNode.pathname.charAt(0) === "/" ? urlParsingNode.pathname : "/" + urlParsingNode.pathname
      };
    }
    originURL = resolveURL(window.location.href);
    return function isURLSameOrigin(requestURL) {
      const parsed = utils_default.isString(requestURL) ? resolveURL(requestURL) : requestURL;
      return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
    };
  }()
) : (
  // Non standard browser envs (web workers, react-native) lack needed support.
  /* @__PURE__ */ function nonStandardBrowserEnv() {
    return function isURLSameOrigin() {
      return true;
    };
  }()
);

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path) && cookie.push("path=" + path);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL) {
  if (baseURL && !isAbsoluteURL(requestedURL)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a24, b11, caseless) {
    if (!utils_default.isUndefined(b11)) {
      return getMergedValue(a24, b11, caseless);
    } else if (!utils_default.isUndefined(a24)) {
      return getMergedValue(void 0, a24, caseless);
    }
  }
  function valueFromConfig2(a24, b11) {
    if (!utils_default.isUndefined(b11)) {
      return getMergedValue(void 0, b11);
    }
  }
  function defaultToConfig2(a24, b11) {
    if (!utils_default.isUndefined(b11)) {
      return getMergedValue(void 0, b11);
    } else if (!utils_default.isUndefined(a24)) {
      return getMergedValue(void 0, a24);
    }
  }
  function mergeDirectKeys(a24, b11, prop) {
    if (prop in config2) {
      return getMergedValue(a24, b11);
    } else if (prop in config1) {
      return getMergedValue(void 0, a24);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a24, b11) => mergeDeepProperties(headersToObject(a24), headersToObject(b11), true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  let controller = new AbortController();
  let aborted;
  const onabort = function(cancel) {
    if (!aborted) {
      aborted = true;
      unsubscribe();
      const err = cancel instanceof Error ? cancel : this.reason;
      controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
    }
  };
  let timer = timeout && setTimeout(() => {
    onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
  }, timeout);
  const unsubscribe = () => {
    if (signals) {
      timer && clearTimeout(timer);
      timer = null;
      signals.forEach((signal2) => {
        signal2 && (signal2.removeEventListener ? signal2.removeEventListener("abort", onabort) : signal2.unsubscribe(onabort));
      });
      signals = null;
    }
  };
  signals.forEach((signal2) => signal2 && signal2.addEventListener && signal2.addEventListener("abort", onabort));
  const { signal } = controller;
  signal.unsubscribe = unsubscribe;
  return [signal, () => {
    timer && clearTimeout(timer);
    timer = null;
  }];
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize, encode3) {
  for await (const chunk of iterable) {
    yield* streamChunk(ArrayBuffer.isView(chunk) ? chunk : await encode3(String(chunk)), chunkSize);
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish, encode3) => {
  const iterator = readBytes(stream, chunkSize, encode3);
  let bytes2 = 0;
  let done;
  let _onFinish = (e5) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e5);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes2 += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder) => (str) => encoder.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test = (fn3, ...args) => {
  try {
    return !!fn3(...args);
  } catch (e5) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type) => {
    !resolvers[type] && (resolvers[type] = utils_default.isFunction(res[type]) ? (res2) => res2[type]() : (_8, config) => {
      throw new AxiosError_default(`Response type '${type}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    return (await new Request(body).arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length = utils_default.toFiniteNumber(headers.getContentLength());
  return length == null ? getBodyLength(body) : length;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let [composedSignal, stopTimeout] = signal || cancelToken || timeout ? composeSignals_default([signal, cancelToken], timeout) : [];
  let finished, request;
  const onFinish = () => {
    !finished && setTimeout(() => {
      composedSignal && composedSignal.unsubscribe();
    });
    finished = true;
  };
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush, encodeText);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: withCredentials
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          isStreamResponse && onFinish();
        }, encodeText),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && onFinish();
    stopTimeout && stopTimeout();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    onFinish();
    if (err && err.name === "TypeError" && /fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn3, value) => {
  if (fn3) {
    try {
      Object.defineProperty(fn3, "name", { value });
    } catch (e5) {
    }
    Object.defineProperty(fn3, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i47 = 0; i47 < length; i47++) {
      nameOrAdapter = adapters[i47];
      let id;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id || "#" + i47] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id, state]) => `adapter ${id} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s12 = length ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s12,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.7.4";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type, i47) => {
  validators[type] = function validator(thing) {
    return typeof thing === type || "a" + (i47 < 1 ? "n " : " ") + type;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version ? " in " + version : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i47 = keys.length;
  while (i47-- > 0) {
    const opt = keys[i47];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig;
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy;
        Error.captureStackTrace ? Error.captureStackTrace(dummy = {}) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e5) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i47 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain2 = [dispatchRequest.bind(this), void 0];
      chain2.unshift.apply(chain2, requestInterceptorChain);
      chain2.push.apply(chain2, responseInterceptorChain);
      len = chain2.length;
      promise = Promise.resolve(config);
      while (i47 < len) {
        promise = promise.then(chain2[i47++], chain2[i47++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i47 = 0;
    while (i47 < len) {
      const onFulfilled = requestInterceptorChain[i47++];
      const onRejected = requestInterceptorChain[i47++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i47 = 0;
    len = responseInterceptorChain.length;
    while (i47 < len) {
      promise = promise.then(responseInterceptorChain[i47++], responseInterceptorChain[i47++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i47 = token._listeners.length;
      while (i47-- > 0) {
        token._listeners[i47](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index = this._listeners.indexOf(listener);
    if (index !== -1) {
      this._listeners.splice(index, 1);
    }
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c14) {
      cancel = c14;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig) {
  const context = new Axios_default(defaultConfig);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/@aptos-labs/aptos-client/dist/browser/index.browser.mjs
async function aptosClient(options) {
  var _a;
  const { params, method, url, headers, body, overrides } = options;
  const requestConfig = {
    headers,
    method,
    url,
    params,
    data: body,
    withCredentials: (_a = overrides == null ? void 0 : overrides.WITH_CREDENTIALS) != null ? _a : true
  };
  try {
    const response = await axios_default(requestConfig);
    return {
      status: response.status,
      statusText: response.statusText,
      data: response.data,
      headers: response.headers,
      config: response.config
    };
  } catch (error) {
    const axiosError = error;
    if (axiosError.response) {
      return axiosError.response;
    }
    throw error;
  }
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-NMD45OTM.mjs
var l16 = class {
  constructor(e5) {
    this.network = (e5 == null ? void 0 : e5.network) ?? "devnet", this.fullnode = e5 == null ? void 0 : e5.fullnode, this.faucet = e5 == null ? void 0 : e5.faucet, this.pepper = e5 == null ? void 0 : e5.pepper, this.prover = e5 == null ? void 0 : e5.prover, this.indexer = e5 == null ? void 0 : e5.indexer, this.client = (e5 == null ? void 0 : e5.client) ?? { provider: aptosClient }, this.clientConfig = (e5 == null ? void 0 : e5.clientConfig) ?? {}, this.fullnodeConfig = (e5 == null ? void 0 : e5.fullnodeConfig) ?? {}, this.indexerConfig = (e5 == null ? void 0 : e5.indexerConfig) ?? {}, this.faucetConfig = (e5 == null ? void 0 : e5.faucetConfig) ?? {};
  }
  getRequestUrl(e5) {
    switch (e5) {
      case "Fullnode":
        if (this.fullnode !== void 0) return this.fullnode;
        if (this.network === "custom") throw new Error("Please provide a custom full node url");
        return o21[this.network];
      case "Faucet":
        if (this.faucet !== void 0) return this.faucet;
        if (this.network === "custom") throw new Error("Please provide a custom faucet url");
        return p9[this.network];
      case "Indexer":
        if (this.indexer !== void 0) return this.indexer;
        if (this.network === "custom") throw new Error("Please provide a custom indexer url");
        return s11[this.network];
      case "Pepper":
        if (this.pepper !== void 0) return this.pepper;
        if (this.network === "custom") throw new Error("Please provide a custom pepper service url");
        return a19[this.network];
      case "Prover":
        if (this.prover !== void 0) return this.prover;
        if (this.network === "custom") throw new Error("Please provide a custom prover service url");
        return n15[this.network];
      default:
        throw Error(`apiType ${e5} is not supported`);
    }
  }
  isPepperServiceRequest(e5) {
    return a19[this.network] === e5;
  }
  isProverServiceRequest(e5) {
    return n15[this.network] === e5;
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-D7RK6FAB.mjs
var u12 = { typeParameters: [{ constraints: [] }], parameters: [new S2(), new p2()] };
async function y10(e5) {
  let { aptosConfig: i47, sender: s12, recipient: c14, amount: p13, coinType: a24, options: m15 } = e5;
  return h13({ aptosConfig: i47, sender: s12, data: { function: "0x1::aptos_account::transfer_coins", typeArguments: [a24 ?? o9], functionArguments: [c14, p13], abi: u12 }, options: m15 });
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-6MNATRA3.mjs
var t28 = class {
  constructor(n18) {
    this.config = n18;
  }
  async transferCoinTransaction(n18) {
    return y10({ aptosConfig: this.config, ...n18 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZBOD65DP.mjs
var C6 = { BOOLEAN: "bool", U8: "u8", U16: "u16", U32: "u32", U64: "u64", U128: "u128", U256: "u256", ADDRESS: "address", STRING: "0x1::string::String", ARRAY: "vector<u8>" };
var l17 = "0x4::token::Token";
async function It(t30) {
  let { aptosConfig: o26, digitalAssetAddress: n18 } = t30, e5 = { token_data_id: { _eq: d.from(n18).toStringLong() } };
  return (await a5({ aptosConfig: o26, query: { query: D2, variables: { where_condition: e5 } }, originMethod: "getDigitalAssetData" })).current_token_datas_v2[0];
}
async function Pt(t30) {
  let { aptosConfig: o26, digitalAssetAddress: n18 } = t30, e5 = { token_data_id: { _eq: d.from(n18).toStringLong() }, amount: { _gt: 0 } };
  return (await a5({ aptosConfig: o26, query: { query: x3, variables: { where_condition: e5 } }, originMethod: "getCurrentDigitalAssetOwnership" })).current_token_ownerships_v2[0];
}
async function bt(t30) {
  let { aptosConfig: o26, ownerAddress: n18, options: e5 } = t30, r26 = { owner_address: { _eq: d.from(n18).toStringLong() }, amount: { _gt: 0 } }, s12 = { query: x3, variables: { where_condition: r26, offset: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit, order_by: e5 == null ? void 0 : e5.orderBy } };
  return (await a5({ aptosConfig: o26, query: s12, originMethod: "getOwnedDigitalAssets" })).current_token_ownerships_v2;
}
async function St(t30) {
  let { aptosConfig: o26, digitalAssetAddress: n18, options: e5 } = t30, r26 = { token_data_id: { _eq: d.from(n18).toStringLong() } }, s12 = { query: Q, variables: { where_condition: r26, offset: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit, order_by: e5 == null ? void 0 : e5.orderBy } };
  return (await a5({ aptosConfig: o26, query: s12, originMethod: "getDigitalAssetActivity" })).token_activities_v2;
}
var F6 = { typeParameters: [], parameters: [new b3(E2()), new p2(), new b3(E2()), new b3(E2()), new c(), new c(), new c(), new c(), new c(), new c(), new c(), new c(), new c(), new p2(), new p2()] };
async function Dt(t30) {
  let { aptosConfig: o26, options: n18, creator: e5 } = t30;
  return h13({ aptosConfig: o26, sender: e5.accountAddress, data: { function: "0x4::aptos_token::create_collection", functionArguments: [new a2(t30.description), new y(t30.maxSupply ?? _), new a2(t30.name), new a2(t30.uri), new d2(t30.mutableDescription ?? true), new d2(t30.mutableRoyalty ?? true), new d2(t30.mutableURI ?? true), new d2(t30.mutableTokenDescription ?? true), new d2(t30.mutableTokenName ?? true), new d2(t30.mutableTokenProperties ?? true), new d2(t30.mutableTokenURI ?? true), new d2(t30.tokensBurnableByCreator ?? true), new d2(t30.tokensFreezableByCreator ?? true), new y(t30.royaltyNumerator ?? 0), new y(t30.royaltyDenominator ?? 1)], abi: F6 }, options: n18 });
}
async function v6(t30) {
  let { aptosConfig: o26, options: n18 } = t30, e5 = n18 == null ? void 0 : n18.where;
  (n18 == null ? void 0 : n18.tokenStandard) && (e5.token_standard = { _eq: (n18 == null ? void 0 : n18.tokenStandard) ?? "v2" });
  let r26 = { query: T3, variables: { where_condition: e5, offset: n18 == null ? void 0 : n18.offset, limit: n18 == null ? void 0 : n18.limit } };
  return (await a5({ aptosConfig: o26, query: r26, originMethod: "getCollectionData" })).current_collections_v2[0];
}
async function ht(t30) {
  let { aptosConfig: o26, creatorAddress: n18, collectionName: e5, options: r26 } = t30, s12 = d.from(n18), a24 = { collection_name: { _eq: e5 }, creator_address: { _eq: s12.toStringLong() } };
  return (r26 == null ? void 0 : r26.tokenStandard) && (a24.token_standard = { _eq: (r26 == null ? void 0 : r26.tokenStandard) ?? "v2" }), v6({ aptosConfig: o26, options: { ...r26, where: a24 } });
}
async function vt(t30) {
  let { aptosConfig: o26, creatorAddress: n18, options: e5 } = t30, s12 = { creator_address: { _eq: d.from(n18).toStringLong() } };
  return (e5 == null ? void 0 : e5.tokenStandard) && (s12.token_standard = { _eq: (e5 == null ? void 0 : e5.tokenStandard) ?? "v2" }), v6({ aptosConfig: o26, options: { ...e5, where: s12 } });
}
async function xt(t30) {
  let { aptosConfig: o26, collectionId: n18, options: e5 } = t30, s12 = { collection_id: { _eq: d.from(n18).toStringLong() } };
  return (e5 == null ? void 0 : e5.tokenStandard) && (s12.token_standard = { _eq: (e5 == null ? void 0 : e5.tokenStandard) ?? "v2" }), v6({ aptosConfig: o26, options: { ...e5, where: s12 } });
}
async function Gt(t30) {
  let { creatorAddress: o26, collectionName: n18, options: e5, aptosConfig: r26 } = t30, s12 = d.from(o26), a24 = { collection_name: { _eq: n18 }, creator_address: { _eq: s12.toStringLong() } };
  return (e5 == null ? void 0 : e5.tokenStandard) && (a24.token_standard = { _eq: (e5 == null ? void 0 : e5.tokenStandard) ?? "v2" }), (await v6({ aptosConfig: r26, options: { where: a24 } })).collection_id;
}
var N4 = { typeParameters: [], parameters: [new b3(E2()), new b3(E2()), new b3(E2()), new b3(E2()), new y2(new b3(E2())), new y2(new b3(E2())), new y2(y2.u8())] };
async function Bt(t30) {
  let { aptosConfig: o26, options: n18, creator: e5, collection: r26, description: s12, name: a24, uri: m15, propertyKeys: g10, propertyTypes: P7, propertyValues: I6 } = t30, b11 = P7 == null ? void 0 : P7.map((S8) => C6[S8]);
  return h13({ aptosConfig: o26, sender: e5.accountAddress, data: { function: "0x4::aptos_token::mint", functionArguments: [new a2(r26), new a2(s12), new a2(a24), new a2(m15), t3.MoveString(g10 ?? []), t3.MoveString(b11 ?? []), K4(I6 ?? [], b11 ?? [])], abi: N4 }, options: n18 });
}
var Q3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0))), new S2()] };
async function Et(t30) {
  let { aptosConfig: o26, sender: n18, digitalAssetAddress: e5, recipient: r26, digitalAssetType: s12, options: a24 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x1::object::transfer", typeArguments: [s12 ?? l17], functionArguments: [d.from(e5), d.from(r26)], abi: Q3 }, options: a24 });
}
var Y5 = { typeParameters: [], parameters: [new b3(E2()), new b3(E2()), new b3(E2()), new b3(E2()), new y2(new b3(E2())), new y2(new b3(E2())), new y2(y2.u8()), new S2()] };
async function Ot(t30) {
  let { aptosConfig: o26, account: n18, collection: e5, description: r26, name: s12, uri: a24, recipient: m15, propertyKeys: g10, propertyTypes: P7, propertyValues: I6, options: b11 } = t30;
  if ((g10 == null ? void 0 : g10.length) !== (I6 == null ? void 0 : I6.length)) throw new Error("Property keys and property values counts do not match");
  if ((P7 == null ? void 0 : P7.length) !== (I6 == null ? void 0 : I6.length)) throw new Error("Property types and property values counts do not match");
  let S8 = P7 == null ? void 0 : P7.map((U13) => C6[U13]);
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::mint_soul_bound", functionArguments: [e5, r26, s12, a24, t3.MoveString(g10 ?? []), t3.MoveString(S8 ?? []), K4(I6 ?? [], S8 ?? []), m15], abi: Y5 }, options: b11 });
}
var L6 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0)))] };
async function qt(t30) {
  let { aptosConfig: o26, creator: n18, digitalAssetAddress: e5, digitalAssetType: r26, options: s12 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::burn", typeArguments: [r26 ?? l17], functionArguments: [d.from(e5)], abi: L6 }, options: s12 });
}
var z7 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0)))] };
async function Vt(t30) {
  let { aptosConfig: o26, creator: n18, digitalAssetAddress: e5, digitalAssetType: r26, options: s12 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::freeze_transfer", typeArguments: [r26 ?? l17], functionArguments: [e5], abi: z7 }, options: s12 });
}
var j5 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0)))] };
async function Rt(t30) {
  let { aptosConfig: o26, creator: n18, digitalAssetAddress: e5, digitalAssetType: r26, options: s12 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::unfreeze_transfer", typeArguments: [r26 ?? l17], functionArguments: [e5], abi: j5 }, options: s12 });
}
var W7 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0))), new b3(E2())] };
async function Mt(t30) {
  let { aptosConfig: o26, creator: n18, description: e5, digitalAssetAddress: r26, digitalAssetType: s12, options: a24 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::set_description", typeArguments: [s12 ?? l17], functionArguments: [d.from(r26), new a2(e5)], abi: W7 }, options: a24 });
}
var X3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0))), new b3(E2())] };
async function Kt(t30) {
  let { aptosConfig: o26, creator: n18, name: e5, digitalAssetAddress: r26, digitalAssetType: s12, options: a24 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::set_name", typeArguments: [s12 ?? l17], functionArguments: [d.from(r26), new a2(e5)], abi: X3 }, options: a24 });
}
var H3 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0))), new b3(E2())] };
async function Ut(t30) {
  let { aptosConfig: o26, creator: n18, uri: e5, digitalAssetAddress: r26, digitalAssetType: s12, options: a24 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::set_uri", typeArguments: [s12 ?? l17], functionArguments: [d.from(r26), new a2(e5)], abi: H3 }, options: a24 });
}
var J2 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0))), new b3(E2()), new b3(E2()), y2.u8()] };
async function Ft(t30) {
  let { aptosConfig: o26, creator: n18, propertyKey: e5, propertyType: r26, propertyValue: s12, digitalAssetAddress: a24, digitalAssetType: m15, options: g10 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::add_property", typeArguments: [m15 ?? l17], functionArguments: [d.from(a24), new a2(e5), new a2(C6[r26]), t3.U8(B7(s12, C6[r26]))], abi: J2 }, options: g10 });
}
var Z4 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0))), new b3(E2())] };
async function Nt(t30) {
  let { aptosConfig: o26, creator: n18, propertyKey: e5, digitalAssetAddress: r26, digitalAssetType: s12, options: a24 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::remove_property", typeArguments: [s12 ?? l17], functionArguments: [d.from(r26), new a2(e5)], abi: Z4 }, options: a24 });
}
var $6 = { typeParameters: [{ constraints: ["key"] }], parameters: [new b3(j2(new h3(0))), new b3(E2()), new b3(E2()), y2.u8()] };
async function Qt(t30) {
  let { aptosConfig: o26, creator: n18, propertyKey: e5, propertyType: r26, propertyValue: s12, digitalAssetAddress: a24, digitalAssetType: m15, options: g10 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::update_property", typeArguments: [m15 ?? l17], functionArguments: [d.from(a24), new a2(e5), new a2(C6[r26]), B7(s12, C6[r26])], abi: $6 }, options: g10 });
}
var tt = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b3(j2(new h3(0))), new b3(E2()), new h3(1)] };
async function Yt(t30) {
  let { aptosConfig: o26, creator: n18, propertyKey: e5, propertyType: r26, propertyValue: s12, digitalAssetAddress: a24, digitalAssetType: m15, options: g10 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::add_typed_property", typeArguments: [m15 ?? l17, C6[r26]], functionArguments: [d.from(a24), new a2(e5), s12], abi: tt }, options: g10 });
}
var et = { typeParameters: [{ constraints: ["key"] }, { constraints: [] }], parameters: [new b3(j2(new h3(0))), new b3(E2()), new h3(1)] };
async function Lt(t30) {
  let { aptosConfig: o26, creator: n18, propertyKey: e5, propertyType: r26, propertyValue: s12, digitalAssetAddress: a24, digitalAssetType: m15, options: g10 } = t30;
  return h13({ aptosConfig: o26, sender: n18.accountAddress, data: { function: "0x4::aptos_token::update_typed_property", typeArguments: [m15 ?? l17, C6[r26]], functionArguments: [d.from(a24), new a2(e5), s12], abi: et }, options: g10 });
}
function K4(t30, o26) {
  let n18 = new Array();
  return o26.forEach((e5, r26) => {
    n18.push(B7(t30[r26], e5));
  }), n18;
}
function B7(t30, o26) {
  let n18 = j3(o26);
  return U9(t30, n18, 0, []).bcsToBytes();
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-ZDRXYQEE.mjs
var L7 = class {
  constructor(t30) {
    this.config = t30;
  }
  async getCollectionData(t30) {
    await i44({ config: this.config, minimumLedgerVersion: t30.minimumLedgerVersion, processorType: "token_v2_processor" });
    let { creatorAddress: N6, collectionName: _8, options: n18 } = t30, w5 = d.from(N6), r26 = { collection_name: { _eq: _8 }, creator_address: { _eq: w5.toStringLong() } };
    return (n18 == null ? void 0 : n18.tokenStandard) && (r26.token_standard = { _eq: (n18 == null ? void 0 : n18.tokenStandard) ?? "v2" }), v6({ aptosConfig: this.config, options: { where: r26 } });
  }
  async getCollectionDataByCreatorAddressAndCollectionName(t30) {
    return await i44({ config: this.config, minimumLedgerVersion: t30.minimumLedgerVersion, processorType: "token_v2_processor" }), ht({ aptosConfig: this.config, ...t30 });
  }
  async getCollectionDataByCreatorAddress(t30) {
    return await i44({ config: this.config, minimumLedgerVersion: t30.minimumLedgerVersion, processorType: "token_v2_processor" }), vt({ aptosConfig: this.config, ...t30 });
  }
  async getCollectionDataByCollectionId(t30) {
    return await i44({ config: this.config, minimumLedgerVersion: t30.minimumLedgerVersion, processorType: "token_v2_processor" }), xt({ aptosConfig: this.config, ...t30 });
  }
  async getCollectionId(t30) {
    return await i44({ config: this.config, minimumLedgerVersion: t30.minimumLedgerVersion, processorType: "token_v2_processor" }), Gt({ aptosConfig: this.config, ...t30 });
  }
  async getDigitalAssetData(t30) {
    return await i44({ config: this.config, minimumLedgerVersion: t30.minimumLedgerVersion, processorType: "token_v2_processor" }), It({ aptosConfig: this.config, ...t30 });
  }
  async getCurrentDigitalAssetOwnership(t30) {
    return await i44({ config: this.config, minimumLedgerVersion: t30.minimumLedgerVersion, processorType: "token_v2_processor" }), Pt({ aptosConfig: this.config, ...t30 });
  }
  async getOwnedDigitalAssets(t30) {
    return await i44({ config: this.config, minimumLedgerVersion: t30.minimumLedgerVersion, processorType: "token_v2_processor" }), bt({ aptosConfig: this.config, ...t30 });
  }
  async getDigitalAssetActivity(t30) {
    return await i44({ config: this.config, minimumLedgerVersion: t30.minimumLedgerVersion, processorType: "token_v2_processor" }), St({ aptosConfig: this.config, ...t30 });
  }
  async createCollectionTransaction(t30) {
    return Dt({ aptosConfig: this.config, ...t30 });
  }
  async mintDigitalAssetTransaction(t30) {
    return Bt({ aptosConfig: this.config, ...t30 });
  }
  async transferDigitalAssetTransaction(t30) {
    return Et({ aptosConfig: this.config, ...t30 });
  }
  async mintSoulBoundTransaction(t30) {
    return Ot({ aptosConfig: this.config, ...t30 });
  }
  async burnDigitalAssetTransaction(t30) {
    return qt({ aptosConfig: this.config, ...t30 });
  }
  async freezeDigitalAssetTransaferTransaction(t30) {
    return Vt({ aptosConfig: this.config, ...t30 });
  }
  async unfreezeDigitalAssetTransaferTransaction(t30) {
    return Rt({ aptosConfig: this.config, ...t30 });
  }
  async setDigitalAssetDescriptionTransaction(t30) {
    return Mt({ aptosConfig: this.config, ...t30 });
  }
  async setDigitalAssetNameTransaction(t30) {
    return Kt({ aptosConfig: this.config, ...t30 });
  }
  async setDigitalAssetURITransaction(t30) {
    return Ut({ aptosConfig: this.config, ...t30 });
  }
  async addDigitalAssetPropertyTransaction(t30) {
    return Ft({ aptosConfig: this.config, ...t30 });
  }
  async removeDigitalAssetPropertyTransaction(t30) {
    return Nt({ aptosConfig: this.config, ...t30 });
  }
  async updateDigitalAssetPropertyTransaction(t30) {
    return Qt({ aptosConfig: this.config, ...t30 });
  }
  async addDigitalAssetTypedPropertyTransaction(t30) {
    return Yt({ aptosConfig: this.config, ...t30 });
  }
  async updateDigitalAssetTypedPropertyTransaction(t30) {
    return Lt({ aptosConfig: this.config, ...t30 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-VHKT63N7.mjs
var a23 = 300;
var u13 = (t30) => {
  if (t30 && t30.length > a23) throw new Error(`Event type length exceeds the maximum length of ${a23}`);
};
async function m13(t30) {
  let { aptosConfig: o26, eventType: e5, options: n18 } = t30;
  return p12({ aptosConfig: o26, options: { ...n18, where: { account_address: { _eq: "0x0000000000000000000000000000000000000000000000000000000000000000" }, creation_number: { _eq: "0" }, sequence_number: { _eq: "0" }, indexed_type: { _eq: e5 } } } });
}
async function f14(t30) {
  let { accountAddress: o26, aptosConfig: e5, creationNumber: n18, options: s12 } = t30, r26 = { account_address: { _eq: d.from(o26).toStringLong() }, creation_number: { _eq: n18 } };
  return p12({ aptosConfig: e5, options: { ...s12, where: r26 } });
}
async function _6(t30) {
  let { accountAddress: o26, aptosConfig: e5, eventType: n18, options: s12 } = t30, r26 = { account_address: { _eq: d.from(o26).toStringLong() }, indexed_type: { _eq: n18 } };
  return p12({ aptosConfig: e5, options: { ...s12, where: r26 } });
}
async function p12(t30) {
  var _a, _b;
  let { aptosConfig: o26, options: e5 } = t30;
  u13((_b = (_a = e5 == null ? void 0 : e5.where) == null ? void 0 : _a.indexed_type) == null ? void 0 : _b._eq);
  let n18 = { query: k2, variables: { where_condition: e5 == null ? void 0 : e5.where, offset: e5 == null ? void 0 : e5.offset, limit: e5 == null ? void 0 : e5.limit, order_by: e5 == null ? void 0 : e5.orderBy } };
  return (await a5({ aptosConfig: o26, query: n18, originMethod: "getEvents" })).events;
}

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-36KSOGK4.mjs
var i46 = class {
  constructor(e5) {
    this.config = e5;
  }
  async getModuleEventsByEventType(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "events_processor" }), m13({ aptosConfig: this.config, ...e5 });
  }
  async getAccountEventsByCreationNumber(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "events_processor" }), f14({ aptosConfig: this.config, ...e5 });
  }
  async getAccountEventsByEventType(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5.minimumLedgerVersion, processorType: "events_processor" }), _6({ aptosConfig: this.config, ...e5 });
  }
  async getEvents(e5) {
    return await i44({ config: this.config, minimumLedgerVersion: e5 == null ? void 0 : e5.minimumLedgerVersion, processorType: "events_processor" }), p12({ aptosConfig: this.config, ...e5 });
  }
};

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-WGZZQQDK.mjs
var t29 = class {
  constructor(n18) {
    this.config = new l16(n18), this.account = new l14(this.config), this.ans = new A13(this.config), this.coin = new t28(this.config), this.digitalAsset = new L7(this.config), this.event = new i46(this.config), this.faucet = new i43(this.config), this.fungibleAsset = new a21(this.config), this.general = new p11(this.config), this.staking = new t27(this.config), this.transaction = new h14(this.config), this.table = new a22(this.config), this.keyless = new i45(this.config), this.object = new t26(this.config);
  }
};
function e4(b11, n18, w5) {
  Object.getOwnPropertyNames(n18.prototype).forEach((i47) => {
    let o26 = Object.getOwnPropertyDescriptor(n18.prototype, i47);
    o26 && (o26.value = function(...j6) {
      return this[w5][i47](...j6);
    }, Object.defineProperty(b11.prototype, i47, o26));
  });
}
e4(t29, l14, "account");
e4(t29, A13, "ans");
e4(t29, t28, "coin");
e4(t29, L7, "digitalAsset");
e4(t29, i46, "event");
e4(t29, i43, "faucet");
e4(t29, a21, "fungibleAsset");
e4(t29, p11, "general");
e4(t29, t27, "staking");
e4(t29, h14, "transaction");
e4(t29, a22, "table");
e4(t29, i45, "keyless");
e4(t29, t26, "object");

// node_modules/@aptos-labs/ts-sdk/dist/esm/chunk-THRXIXIO.mjs
var g9 = ((e5) => (e5.JSON = "application/json", e5.BCS = "application/x-bcs", e5.BCS_SIGNED_TRANSACTION = "application/x.aptos.signed_transaction+bcs", e5.BCS_VIEW_FUNCTION = "application/x.aptos.view_function+bcs", e5))(g9 || {});
var y11 = ((t30) => (t30[t30.Bool = 0] = "Bool", t30[t30.U8 = 1] = "U8", t30[t30.U64 = 2] = "U64", t30[t30.U128 = 3] = "U128", t30[t30.Address = 4] = "Address", t30[t30.Signer = 5] = "Signer", t30[t30.Vector = 6] = "Vector", t30[t30.Struct = 7] = "Struct", t30[t30.U16 = 8] = "U16", t30[t30.U32 = 9] = "U32", t30[t30.U256 = 10] = "U256", t30[t30.Reference = 254] = "Reference", t30[t30.Generic = 255] = "Generic", t30))(y11 || {});
var u14 = ((o26) => (o26[o26.U8 = 0] = "U8", o26[o26.U64 = 1] = "U64", o26[o26.U128 = 2] = "U128", o26[o26.Address = 3] = "Address", o26[o26.U8Vector = 4] = "U8Vector", o26[o26.Bool = 5] = "Bool", o26[o26.U16 = 6] = "U16", o26[o26.U32 = 7] = "U32", o26[o26.U256 = 8] = "U256", o26))(u14 || {});
var d19 = ((s12) => (s12[s12.Script = 0] = "Script", s12[s12.EntryFunction = 2] = "EntryFunction", s12[s12.Multisig = 3] = "Multisig", s12))(d19 || {});
var c13 = ((i47) => (i47[i47.MultiAgentTransaction = 0] = "MultiAgentTransaction", i47[i47.FeePayerTransaction = 1] = "FeePayerTransaction", i47))(c13 || {});
var l18 = ((r26) => (r26[r26.Ed25519 = 0] = "Ed25519", r26[r26.MultiEd25519 = 1] = "MultiEd25519", r26[r26.MultiAgent = 2] = "MultiAgent", r26[r26.FeePayer = 3] = "FeePayer", r26[r26.SingleSender = 4] = "SingleSender", r26))(l18 || {});
var _7 = ((e5) => (e5[e5.Ed25519 = 0] = "Ed25519", e5[e5.MultiEd25519 = 1] = "MultiEd25519", e5[e5.SingleKey = 2] = "SingleKey", e5[e5.MultiKey = 3] = "MultiKey", e5))(_7 || {});
var x9 = ((s12) => (s12[s12.Ed25519 = 0] = "Ed25519", s12[s12.Secp256k1 = 1] = "Secp256k1", s12[s12.Keyless = 3] = "Keyless", s12))(x9 || {});
var h16 = ((s12) => (s12[s12.Ed25519 = 0] = "Ed25519", s12[s12.Secp256k1 = 1] = "Secp256k1", s12[s12.Keyless = 3] = "Keyless", s12))(h16 || {});
var v7 = ((p13) => (p13[p13.Ed25519 = 0] = "Ed25519", p13))(v7 || {});
var M4 = ((p13) => (p13[p13.Ed25519 = 0] = "Ed25519", p13))(M4 || {});
var m14 = ((p13) => (p13[p13.ZkProof = 0] = "ZkProof", p13))(m14 || {});
var R6 = ((p13) => (p13[p13.Groth16 = 0] = "Groth16", p13))(R6 || {});
var b10 = ((a24) => (a24.Pending = "pending_transaction", a24.User = "user_transaction", a24.Genesis = "genesis_transaction", a24.BlockMetadata = "block_metadata_transaction", a24.StateCheckpoint = "state_checkpoint_transaction", a24.Validator = "validator_transaction", a24.BlockEpilogue = "block_epilogue_transaction", a24))(b10 || {});
function U12(n18) {
  return n18.type === "pending_transaction";
}
function W8(n18) {
  return n18.type === "user_transaction";
}
function F7(n18) {
  return n18.type === "genesis_transaction";
}
function I5(n18) {
  return n18.type === "block_metadata_transaction";
}
function B8(n18) {
  return n18.type === "state_checkpoint_transaction";
}
function A14(n18) {
  return n18.type === "validator_transaction";
}
function P6(n18) {
  return n18.type === "block_epilogue_transaction";
}
function G6(n18) {
  return "signature" in n18 && n18.signature === "ed25519_signature";
}
function O6(n18) {
  return "signature" in n18 && n18.signature === "secp256k1_ecdsa_signature";
}
function D8(n18) {
  return n18.type === "multi_agent_signature";
}
function N5(n18) {
  return n18.type === "fee_payer_signature";
}
function q4(n18) {
  return n18.type === "multi_ed25519_signature";
}
var k5 = ((s12) => (s12.PRIVATE = "private", s12.PUBLIC = "public", s12.FRIEND = "friend", s12))(k5 || {});
var S7 = ((e5) => (e5.STORE = "store", e5.DROP = "drop", e5.KEY = "key", e5.COPY = "copy", e5))(S7 || {});
var f15 = ((i47) => (i47.VALIDATOR = "validator", i47.FULL_NODE = "full_node", i47))(f15 || {});
var C7 = ((e5) => (e5[e5.Ed25519 = 0] = "Ed25519", e5[e5.MultiEd25519 = 1] = "MultiEd25519", e5[e5.SingleKey = 2] = "SingleKey", e5[e5.MultiKey = 3] = "MultiKey", e5))(C7 || {});
var T10 = ((i47) => (i47[i47.Ed25519 = 0] = "Ed25519", i47[i47.Secp256k1Ecdsa = 2] = "Secp256k1Ecdsa", i47))(T10 || {});
var E9 = ((r26) => (r26[r26.DeriveAuid = 251] = "DeriveAuid", r26[r26.DeriveObjectAddressFromObject = 252] = "DeriveObjectAddressFromObject", r26[r26.DeriveObjectAddressFromGuid = 253] = "DeriveObjectAddressFromGuid", r26[r26.DeriveObjectAddressFromSeed = 254] = "DeriveObjectAddressFromSeed", r26[r26.DeriveResourceAccountAddress = 255] = "DeriveResourceAccountAddress", r26))(E9 || {});

export {
  s,
  l,
  i,
  B,
  n3 as n,
  A,
  z,
  g,
  g2,
  d,
  t2 as t,
  d2,
  U2 as U,
  p,
  b,
  y,
  m,
  B2,
  t3 as t2,
  a2 as a,
  z2,
  D,
  l2,
  d3,
  P,
  w,
  G,
  $,
  T,
  E,
  x,
  S,
  B3,
  U3 as U2,
  b2,
  I,
  v,
  h2 as h,
  O,
  R,
  W,
  L,
  r3 as r,
  t5 as t3,
  c,
  u2 as u,
  d4,
  g3,
  p2,
  z3,
  T2,
  S2,
  U4 as U3,
  x2,
  h3 as h2,
  y2,
  b3,
  o4 as o,
  O2,
  E2,
  V,
  j2 as j,
  R2,
  t6 as t4,
  j3 as j2,
  n7 as n2,
  A3 as A2,
  y4 as y3,
  r4 as r2,
  m3 as m2,
  y5 as y4,
  A4 as A3,
  o6 as o2,
  q2 as q,
  C2 as C,
  m4 as m3,
  E3,
  a4 as a2,
  o7 as o3,
  t8 as t5,
  D3 as D2,
  a6 as a3,
  A5 as A4,
  z4,
  h6 as h3,
  l6 as l3,
  U5 as U4,
  f3 as f,
  b6 as b4,
  r5 as r3,
  t16 as t6,
  o8 as o4,
  u5 as u2,
  p4 as p3,
  S3,
  R3,
  t17 as t7,
  n8 as n3,
  o9 as o5,
  T6 as T3,
  A6 as A5,
  E4,
  sha3_256,
  d8 as d5,
  n9 as n4,
  u6 as u3,
  S4,
  t18 as t8,
  a8 as a4,
  o10 as o6,
  d9 as d6,
  m5 as m4,
  y6 as y5,
  g6 as g4,
  D4 as D3,
  E5,
  A7 as A6,
  f4 as f2,
  U6 as U5,
  h7 as h4,
  c3 as c2,
  w3 as w2,
  m6 as m5,
  U7 as U6,
  h8 as h5,
  d11 as d7,
  y7 as y6,
  u7 as u4,
  v3 as v2,
  m7 as m6,
  n10 as n5,
  c4 as c3,
  p5 as p4,
  jwtDecode,
  he,
  F2 as F,
  L4 as L2,
  N2 as N,
  ge2 as ge,
  fe2 as fe,
  Se,
  xe,
  A9 as A7,
  D5 as D4,
  h10 as h6,
  g8 as g5,
  f7 as f3,
  S5,
  z5,
  be,
  f8 as f4,
  l9 as l4,
  f9 as f5,
  p7 as p5,
  r23 as r4,
  u9 as u5,
  l11 as l5,
  n12 as n6,
  a16 as a5,
  c7 as c4,
  h11 as h7,
  o16 as o7,
  d14 as d8,
  f10 as f6,
  a18 as a6,
  sn,
  W3 as W2,
  fn,
  on,
  cn,
  U9 as U7,
  o17 as o8,
  n13 as n7,
  o18 as o9,
  d16 as d9,
  u11 as u6,
  l12 as l6,
  A10 as A8,
  n14 as n8,
  o20 as o10,
  t25 as t9,
  s11 as s2,
  o21 as o11,
  p9 as p6,
  a19 as a7,
  n15 as n9,
  e3 as e,
  r24 as r5,
  c10 as c5,
  vn,
  mn,
  Kn,
  An,
  fn2,
  On,
  Vn,
  h12 as h8,
  gn,
  rn,
  qn,
  o22 as o12,
  k4 as k,
  l13 as l7,
  c11 as c6,
  r25 as r6,
  m11 as m7,
  f11 as f7,
  p10 as p7,
  axios_default,
  AxiosError2 as AxiosError,
  isAxiosError2 as isAxiosError,
  aptosClient,
  l16 as l8,
  t29 as t10,
  g9 as g6,
  y11 as y7,
  u14 as u7,
  d19 as d10,
  c13 as c7,
  l18 as l9,
  _7 as _,
  x9 as x3,
  h16 as h9,
  v7 as v3,
  M4 as M,
  m14 as m8,
  R6 as R4,
  b10 as b5,
  U12 as U8,
  W8 as W3,
  F7 as F2,
  I5 as I2,
  B8 as B4,
  A14 as A9,
  P6 as P2,
  G6 as G2,
  O6 as O3,
  D8 as D5,
  N5 as N2,
  q4 as q2,
  k5 as k2,
  S7 as S6,
  f15 as f8,
  C7 as C2,
  T10 as T4,
  E9 as E6
};
/*! Bundled license information:

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/edwards.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/montgomery.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/ed25519.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=chunk-QK5H62YW.js.map
